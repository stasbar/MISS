// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"g5IB":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"HlZQ":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var define;
/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{"process":"g5IB"}],"v5IM":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var _default = Popper;
exports.default = _default;
},{}],"pe4o":[function(require,module,exports) {
var define;
var global = arguments[3];
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap v4.4.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('jquery'), require('popper.js')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery', 'popper.js'], factory) : (global = global || self, factory(global.bootstrap = {}, global.jQuery, global.Popper));
})(this, function (exports, $, Popper) {
  'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.4.1): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */


  var TRANSITION_END = 'transitionend';
  var MAX_UID = 1000000;
  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: TRANSITION_END,
      delegateType: TRANSITION_END,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    $.fn.emulateTransitionEnd = transitionEndEmulator;
    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        var hrefAttr = element.getAttribute('href');
        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
      }

      try {
        return document.querySelector(selector) ? selector : null;
      } catch (err) {
        return null;
      }
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
      if (!element) {
        return 0;
      } // Get transition-duration of the element


      var transitionDuration = $(element).css('transition-duration');
      var transitionDelay = $(element).css('transition-delay');
      var floatTransitionDuration = parseFloat(transitionDuration);
      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      } // If multiple durations are defined, take the first


      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];
      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(TRANSITION_END);
    },
    // TODO: Remove in v5
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(TRANSITION_END);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    },
    findShadowRoot: function findShadowRoot(element) {
      if (!document.documentElement.attachShadow) {
        return null;
      } // Can find the shadow root otherwise it'll return the document


      if (typeof element.getRootNode === 'function') {
        var root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
      }

      if (element instanceof ShadowRoot) {
        return element;
      } // when we don't find a shadow root


      if (!element.parentNode) {
        return null;
      }

      return Util.findShadowRoot(element.parentNode);
    },
    jQueryDetection: function jQueryDetection() {
      if (typeof $ === 'undefined') {
        throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
      }

      var version = $.fn.jquery.split(' ')[0].split('.');
      var minMajor = 1;
      var ltMajor = 2;
      var minMinor = 9;
      var minPatch = 1;
      var maxMajor = 4;

      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
        throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
      }
    }
  };
  Util.jQueryDetection();
  setTransitionEndSupport();
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME = 'alert';
  var VERSION = '4.4.1';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var Selector = {
    DISMISS: '[data-dismiss="alert"]'
  };
  var Event = {
    CLOSE: "close" + EVENT_KEY,
    CLOSED: "closed" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    SHOW: 'show'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Alert =
  /*#__PURE__*/
  function () {
    function Alert(element) {
      this._element = element;
    } // Getters


    var _proto = Alert.prototype; // Public

    _proto.close = function close(element) {
      var rootElement = this._element;

      if (element) {
        rootElement = this._getRootElement(element);
      }

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private
    ;

    _proto._getRootElement = function _getRootElement(element) {
      var selector = Util.getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = document.querySelector(selector);
      }

      if (!parent) {
        parent = $(element).closest("." + ClassName.ALERT)[0];
      }

      return parent;
    };

    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
      var closeEvent = $.Event(Event.CLOSE);
      $(element).trigger(closeEvent);
      return closeEvent;
    };

    _proto._removeElement = function _removeElement(element) {
      var _this = this;

      $(element).removeClass(ClassName.SHOW);

      if (!$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);

        return;
      }

      var transitionDuration = Util.getTransitionDurationFromElement(element);
      $(element).one(Util.TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(transitionDuration);
    };

    _proto._destroyElement = function _destroyElement(element) {
      $(element).detach().trigger(Event.CLOSED).remove();
    } // Static
    ;

    Alert._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    };

    Alert._handleDismiss = function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    };

    _createClass(Alert, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);

    return Alert;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Alert._jQueryInterface;
  $.fn[NAME].Constructor = Alert;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Alert._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$1 = 'button';
  var VERSION$1 = '4.4.1';
  var DATA_KEY$1 = 'bs.button';
  var EVENT_KEY$1 = "." + DATA_KEY$1;
  var DATA_API_KEY$1 = '.data-api';
  var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
  var ClassName$1 = {
    ACTIVE: 'active',
    BUTTON: 'btn',
    FOCUS: 'focus'
  };
  var Selector$1 = {
    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
    DATA_TOGGLES: '[data-toggle="buttons"]',
    DATA_TOGGLE: '[data-toggle="button"]',
    DATA_TOGGLES_BUTTONS: '[data-toggle="buttons"] .btn',
    INPUT: 'input:not([type="hidden"])',
    ACTIVE: '.active',
    BUTTON: '.btn'
  };
  var Event$1 = {
    CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1),
    LOAD_DATA_API: "load" + EVENT_KEY$1 + DATA_API_KEY$1
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Button =
  /*#__PURE__*/
  function () {
    function Button(element) {
      this._element = element;
    } // Getters


    var _proto = Button.prototype; // Public

    _proto.toggle = function toggle() {
      var triggerChangeEvent = true;
      var addAriaPressed = true;
      var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLES)[0];

      if (rootElement) {
        var input = this._element.querySelector(Selector$1.INPUT);

        if (input) {
          if (input.type === 'radio') {
            if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            } else {
              var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

              if (activeElement) {
                $(activeElement).removeClass(ClassName$1.ACTIVE);
              }
            }
          } else if (input.type === 'checkbox') {
            if (this._element.tagName === 'LABEL' && input.checked === this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            }
          } else {
            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input
            triggerChangeEvent = false;
          }

          if (triggerChangeEvent) {
            input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
            $(input).trigger('change');
          }

          input.focus();
          addAriaPressed = false;
        }
      }

      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {
        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
        }

        if (triggerChangeEvent) {
          $(this._element).toggleClass(ClassName$1.ACTIVE);
        }
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$1);
      this._element = null;
    } // Static
    ;

    Button._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$1);

        if (!data) {
          data = new Button(this);
          $(this).data(DATA_KEY$1, data);
        }

        if (config === 'toggle') {
          data[config]();
        }
      });
    };

    _createClass(Button, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$1;
      }
    }]);

    return Button;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = event.target;

    if (!$(button).hasClass(ClassName$1.BUTTON)) {
      button = $(button).closest(Selector$1.BUTTON)[0];
    }

    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {
      event.preventDefault(); // work around Firefox bug #1540995
    } else {
      var inputBtn = button.querySelector(Selector$1.INPUT);

      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {
        event.preventDefault(); // work around Firefox bug #1540995

        return;
      }

      Button._jQueryInterface.call($(button), 'toggle');
    }
  }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = $(event.target).closest(Selector$1.BUTTON)[0];
    $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
  });
  $(window).on(Event$1.LOAD_DATA_API, function () {
    // ensure correct active class is set to match the controls' actual values/states
    // find all checkboxes/readio buttons inside data-toggle groups
    var buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLES_BUTTONS));

    for (var i = 0, len = buttons.length; i < len; i++) {
      var button = buttons[i];
      var input = button.querySelector(Selector$1.INPUT);

      if (input.checked || input.hasAttribute('checked')) {
        button.classList.add(ClassName$1.ACTIVE);
      } else {
        button.classList.remove(ClassName$1.ACTIVE);
      }
    } // find all button toggles


    buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLE));

    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {
      var _button = buttons[_i];

      if (_button.getAttribute('aria-pressed') === 'true') {
        _button.classList.add(ClassName$1.ACTIVE);
      } else {
        _button.classList.remove(ClassName$1.ACTIVE);
      }
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$1] = Button._jQueryInterface;
  $.fn[NAME$1].Constructor = Button;

  $.fn[NAME$1].noConflict = function () {
    $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
    return Button._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$2 = 'carousel';
  var VERSION$2 = '4.4.1';
  var DATA_KEY$2 = 'bs.carousel';
  var EVENT_KEY$2 = "." + DATA_KEY$2;
  var DATA_API_KEY$2 = '.data-api';
  var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var SWIPE_THRESHOLD = 40;
  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  };
  var Direction = {
    NEXT: 'next',
    PREV: 'prev',
    LEFT: 'left',
    RIGHT: 'right'
  };
  var Event$2 = {
    SLIDE: "slide" + EVENT_KEY$2,
    SLID: "slid" + EVENT_KEY$2,
    KEYDOWN: "keydown" + EVENT_KEY$2,
    MOUSEENTER: "mouseenter" + EVENT_KEY$2,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
    TOUCHSTART: "touchstart" + EVENT_KEY$2,
    TOUCHMOVE: "touchmove" + EVENT_KEY$2,
    TOUCHEND: "touchend" + EVENT_KEY$2,
    POINTERDOWN: "pointerdown" + EVENT_KEY$2,
    POINTERUP: "pointerup" + EVENT_KEY$2,
    DRAG_START: "dragstart" + EVENT_KEY$2,
    LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
    CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
  };
  var ClassName$2 = {
    CAROUSEL: 'carousel',
    ACTIVE: 'active',
    SLIDE: 'slide',
    RIGHT: 'carousel-item-right',
    LEFT: 'carousel-item-left',
    NEXT: 'carousel-item-next',
    PREV: 'carousel-item-prev',
    ITEM: 'carousel-item',
    POINTER_EVENT: 'pointer-event'
  };
  var Selector$2 = {
    ACTIVE: '.active',
    ACTIVE_ITEM: '.active.carousel-item',
    ITEM: '.carousel-item',
    ITEM_IMG: '.carousel-item img',
    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
    INDICATORS: '.carousel-indicators',
    DATA_SLIDE: '[data-slide], [data-slide-to]',
    DATA_RIDE: '[data-ride="carousel"]'
  };
  var PointerType = {
    TOUCH: 'touch',
    PEN: 'pen'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Carousel =
  /*#__PURE__*/
  function () {
    function Carousel(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._element = element;
      this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

      this._addEventListeners();
    } // Getters


    var _proto = Carousel.prototype; // Public

    _proto.next = function next() {
      if (!this._isSliding) {
        this._slide(Direction.NEXT);
      }
    };

    _proto.nextWhenVisible = function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
        this.next();
      }
    };

    _proto.prev = function prev() {
      if (!this._isSliding) {
        this._slide(Direction.PREV);
      }
    };

    _proto.pause = function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (this._element.querySelector(Selector$2.NEXT_PREV)) {
        Util.triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    };

    _proto.cycle = function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    };

    _proto.to = function to(index) {
      var _this = this;

      this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        $(this._element).one(Event$2.SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

      this._slide(direction, this._items[index]);
    };

    _proto.dispose = function dispose() {
      $(this._element).off(EVENT_KEY$2);
      $.removeData(this._element, DATA_KEY$2);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default, {}, config);
      Util.typeCheckConfig(NAME$2, config, DefaultType);
      return config;
    };

    _proto._handleSwipe = function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax / this.touchDeltaX;
      this.touchDeltaX = 0; // swipe left

      if (direction > 0) {
        this.prev();
      } // swipe right


      if (direction < 0) {
        this.next();
      }
    };

    _proto._addEventListeners = function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        $(this._element).on(Event$2.KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        $(this._element).on(Event$2.MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(Event$2.MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });
      }

      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    };

    _proto._addTouchEventListeners = function _addTouchEventListeners() {
      var _this3 = this;

      if (!this._touchSupported) {
        return;
      }

      var start = function start(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchStartX = event.originalEvent.clientX;
        } else if (!_this3._pointerEvent) {
          _this3.touchStartX = event.originalEvent.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
          _this3.touchDeltaX = 0;
        } else {
          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
        }
      };

      var end = function end(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
        }

        _this3._handleSwipe();

        if (_this3._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this3.pause();

          if (_this3.touchTimeout) {
            clearTimeout(_this3.touchTimeout);
          }

          _this3.touchTimeout = setTimeout(function (event) {
            return _this3.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
        }
      };

      $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
        return e.preventDefault();
      });

      if (this._pointerEvent) {
        $(this._element).on(Event$2.POINTERDOWN, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(ClassName$2.POINTER_EVENT);
      } else {
        $(this._element).on(Event$2.TOUCHSTART, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.TOUCHMOVE, function (event) {
          return move(event);
        });
        $(this._element).on(Event$2.TOUCHEND, function (event) {
          return end(event);
        });
      }
    };

    _proto._keydown = function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;
      }
    };

    _proto._getItemIndex = function _getItemIndex(element) {
      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
      return this._items.indexOf(element);
    };

    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === Direction.NEXT;
      var isPrevDirection = direction === Direction.PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === Direction.PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    };

    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

      var slideEvent = $.Event(Event$2.SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      $(this._element).trigger(slideEvent);
      return slideEvent;
    };

    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
        $(indicators).removeClass(ClassName$2.ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          $(nextIndicator).addClass(ClassName$2.ACTIVE);
        }
      }
    };

    _proto._slide = function _slide(direction, element) {
      var _this4 = this;

      var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === Direction.NEXT) {
        directionalClassName = ClassName$2.LEFT;
        orderClassName = ClassName$2.NEXT;
        eventDirectionName = Direction.LEFT;
      } else {
        directionalClassName = ClassName$2.RIGHT;
        orderClassName = ClassName$2.PREV;
        eventDirectionName = Direction.RIGHT;
      }

      if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      var slidEvent = $.Event(Event$2.SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if ($(this._element).hasClass(ClassName$2.SLIDE)) {
        $(nextElement).addClass(orderClassName);
        Util.reflow(nextElement);
        $(activeElement).addClass(directionalClassName);
        $(nextElement).addClass(directionalClassName);
        var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

        if (nextElementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = nextElementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
        $(activeElement).one(Util.TRANSITION_END, function () {
          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
          $(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
          _this4._isSliding = false;
          setTimeout(function () {
            return $(_this4._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        $(activeElement).removeClass(ClassName$2.ACTIVE);
        $(nextElement).addClass(ClassName$2.ACTIVE);
        this._isSliding = false;
        $(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    } // Static
    ;

    Carousel._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$2);

        var _config = _objectSpread2({}, Default, {}, $(this).data());

        if (_typeof(config) === 'object') {
          _config = _objectSpread2({}, _config, {}, config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          $(this).data(DATA_KEY$2, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"" + action + "\"");
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      });
    };

    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
      var selector = Util.getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = $(selector)[0];

      if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
        return;
      }

      var config = _objectSpread2({}, $(target).data(), {}, $(this).data());

      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call($(target), config);

      if (slideIndex) {
        $(target).data(DATA_KEY$2).to(slideIndex);
      }

      event.preventDefault();
    };

    _createClass(Carousel, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$2;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Carousel;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
  $(window).on(Event$2.LOAD_DATA_API, function () {
    var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

    for (var i = 0, len = carousels.length; i < len; i++) {
      var $carousel = $(carousels[i]);

      Carousel._jQueryInterface.call($carousel, $carousel.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$2] = Carousel._jQueryInterface;
  $.fn[NAME$2].Constructor = Carousel;

  $.fn[NAME$2].noConflict = function () {
    $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
    return Carousel._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$3 = 'collapse';
  var VERSION$3 = '4.4.1';
  var DATA_KEY$3 = 'bs.collapse';
  var EVENT_KEY$3 = "." + DATA_KEY$3;
  var DATA_API_KEY$3 = '.data-api';
  var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
  var Default$1 = {
    toggle: true,
    parent: ''
  };
  var DefaultType$1 = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event$3 = {
    SHOW: "show" + EVENT_KEY$3,
    SHOWN: "shown" + EVENT_KEY$3,
    HIDE: "hide" + EVENT_KEY$3,
    HIDDEN: "hidden" + EVENT_KEY$3,
    CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
  };
  var ClassName$3 = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector$3 = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

      for (var i = 0, len = toggleList.length; i < len; i++) {
        var elem = toggleList[i];
        var selector = Util.getSelectorFromElement(elem);
        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
          return foundElem === element;
        });

        if (selector !== null && filterElement.length > 0) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    var _proto = Collapse.prototype; // Public

    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName$3.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(ClassName$3.COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).not(this._selector).data(DATA_KEY$3);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event$3.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY$3, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event$3.SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event$3.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(ClassName$3.SHOW)) {
              $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$3);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$1, {}, config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      Util.typeCheckConfig(NAME$3, config, DefaultType$1);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      var children = [].slice.call(parent.querySelectorAll(selector));
      $(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = $(element).hasClass(ClassName$3.SHOW);

      if (triggerArray.length) {
        $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static
    ;

    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$3);

        var _config = _objectSpread2({}, Default$1, {}, $this.data(), {}, _typeof(config) === 'object' && config ? config : {});

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY$3, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$3;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$1;
      }
    }]);

    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    var selectors = [].slice.call(document.querySelectorAll(selector));
    $(selectors).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY$3);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$3] = Collapse._jQueryInterface;
  $.fn[NAME$3].Constructor = Collapse;

  $.fn[NAME$3].noConflict = function () {
    $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
    return Collapse._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$4 = 'dropdown';
  var VERSION$4 = '4.4.1';
  var DATA_KEY$4 = 'bs.dropdown';
  var EVENT_KEY$4 = "." + DATA_KEY$4;
  var DATA_API_KEY$4 = '.data-api';
  var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
  var Event$4 = {
    HIDE: "hide" + EVENT_KEY$4,
    HIDDEN: "hidden" + EVENT_KEY$4,
    SHOW: "show" + EVENT_KEY$4,
    SHOWN: "shown" + EVENT_KEY$4,
    CLICK: "click" + EVENT_KEY$4,
    CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
  };
  var ClassName$4 = {
    DISABLED: 'disabled',
    SHOW: 'show',
    DROPUP: 'dropup',
    DROPRIGHT: 'dropright',
    DROPLEFT: 'dropleft',
    MENURIGHT: 'dropdown-menu-right',
    MENULEFT: 'dropdown-menu-left',
    POSITION_STATIC: 'position-static'
  };
  var Selector$4 = {
    DATA_TOGGLE: '[data-toggle="dropdown"]',
    FORM_CHILD: '.dropdown form',
    MENU: '.dropdown-menu',
    NAVBAR_NAV: '.navbar-nav',
    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
  };
  var AttachmentMap = {
    TOP: 'top-start',
    TOPEND: 'top-end',
    BOTTOM: 'bottom-start',
    BOTTOMEND: 'bottom-end',
    RIGHT: 'right-start',
    RIGHTEND: 'right-end',
    LEFT: 'left-start',
    LEFTEND: 'left-end'
  };
  var Default$2 = {
    offset: 0,
    flip: true,
    boundary: 'scrollParent',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null
  };
  var DefaultType$2 = {
    offset: '(number|string|function)',
    flip: 'boolean',
    boundary: '(string|element)',
    reference: '(string|element)',
    display: 'string',
    popperConfig: '(null|object)'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Dropdown =
  /*#__PURE__*/
  function () {
    function Dropdown(element, config) {
      this._element = element;
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();

      this._addEventListeners();
    } // Getters


    var _proto = Dropdown.prototype; // Public

    _proto.toggle = function toggle() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      this.show(true);
    };

    _proto.show = function show(usePopper) {
      if (usePopper === void 0) {
        usePopper = false;
      }

      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      } // Disable totally Popper.js for Dropdown in Navbar


      if (!this._inNavbar && usePopper) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (Util.isElement(this._config.reference)) {
          referenceElement = this._config.reference; // Check if it's jQuery element

          if (typeof this._config.reference.jquery !== 'undefined') {
            referenceElement = this._config.reference[0];
          }
        } // If boundary is not `scrollParent`, then set position to `static`
        // to allow the menu to "escape" the scroll parent's boundaries
        // https://github.com/twbs/bootstrap/issues/24251


        if (this._config.boundary !== 'scrollParent') {
          $(parent).addClass(ClassName$4.POSITION_STATIC);
        }

        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
        $(document.body).children().on('mouseover', null, $.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.hide = function hide() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      if (this._popper) {
        this._popper.destroy();
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$4);
      $(this._element).off(EVENT_KEY$4);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();

        this._popper = null;
      }
    };

    _proto.update = function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Private
    ;

    _proto._addEventListeners = function _addEventListeners() {
      var _this = this;

      $(this._element).on(Event$4.CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    };

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, this.constructor.Default, {}, $(this._element).data(), {}, config);
      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getMenuElement = function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        if (parent) {
          this._menu = parent.querySelector(Selector$4.MENU);
        }
      }

      return this._menu;
    };

    _proto._getPlacement = function _getPlacement() {
      var $parentDropdown = $(this._element.parentNode);
      var placement = AttachmentMap.BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
        placement = AttachmentMap.TOP;

        if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
          placement = AttachmentMap.TOPEND;
        }
      } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
        placement = AttachmentMap.RIGHT;
      } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
        placement = AttachmentMap.LEFT;
      } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
        placement = AttachmentMap.BOTTOMEND;
      }

      return placement;
    };

    _proto._detectNavbar = function _detectNavbar() {
      return $(this._element).closest('.navbar').length > 0;
    };

    _proto._getOffset = function _getOffset() {
      var _this2 = this;

      var offset = {};

      if (typeof this._config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread2({}, data.offsets, {}, _this2._config.offset(data.offsets, _this2._element) || {});
          return data;
        };
      } else {
        offset.offset = this._config.offset;
      }

      return offset;
    };

    _proto._getPopperConfig = function _getPopperConfig() {
      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      }; // Disable Popper.js if we have a static display

      if (this._config.display === 'static') {
        popperConfig.modifiers.applyStyle = {
          enabled: false
        };
      }

      return _objectSpread2({}, popperConfig, {}, this._config.popperConfig);
    } // Static
    ;

    Dropdown._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$4);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          $(this).data(DATA_KEY$4, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    Dropdown._clearMenus = function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

      for (var i = 0, len = toggles.length; i < len; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = $(toggles[i]).data(DATA_KEY$4);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (event && event.type === 'click') {
          relatedTarget.clickEvent = event;
        }

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!$(parent).hasClass(ClassName$4.SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().off('mouseover', null, $.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');

        if (context._popper) {
          context._popper.destroy();
        }

        $(dropdownMenu).removeClass(ClassName$4.SHOW);
        $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement(element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = document.querySelector(selector);
      }

      return parent || element.parentNode;
    } // eslint-disable-next-line complexity
    ;

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = $(parent).hasClass(ClassName$4.SHOW);

      if (!isActive && event.which === ESCAPE_KEYCODE) {
        return;
      }

      if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
        if (event.which === ESCAPE_KEYCODE) {
          var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return;
      }

      var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS)).filter(function (item) {
        return $(item).is(':visible');
      });

      if (items.length === 0) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // Up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // Down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    _createClass(Dropdown, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$4;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$2;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$2;
      }
    }]);

    return Dropdown;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
    event.preventDefault();
    event.stopPropagation();

    Dropdown._jQueryInterface.call($(this), 'toggle');
  }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
    e.stopPropagation();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$4] = Dropdown._jQueryInterface;
  $.fn[NAME$4].Constructor = Dropdown;

  $.fn[NAME$4].noConflict = function () {
    $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
    return Dropdown._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$5 = 'modal';
  var VERSION$5 = '4.4.1';
  var DATA_KEY$5 = 'bs.modal';
  var EVENT_KEY$5 = "." + DATA_KEY$5;
  var DATA_API_KEY$5 = '.data-api';
  var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default$3 = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType$3 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event$5 = {
    HIDE: "hide" + EVENT_KEY$5,
    HIDE_PREVENTED: "hidePrevented" + EVENT_KEY$5,
    HIDDEN: "hidden" + EVENT_KEY$5,
    SHOW: "show" + EVENT_KEY$5,
    SHOWN: "shown" + EVENT_KEY$5,
    FOCUSIN: "focusin" + EVENT_KEY$5,
    RESIZE: "resize" + EVENT_KEY$5,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
    CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
  };
  var ClassName$5 = {
    SCROLLABLE: 'modal-dialog-scrollable',
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show',
    STATIC: 'modal-static'
  };
  var Selector$5 = {
    DIALOG: '.modal-dialog',
    MODAL_BODY: '.modal-body',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = element.querySelector(Selector$5.DIALOG);
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollbarWidth = 0;
    } // Getters


    var _proto = Modal.prototype; // Public

    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      if ($(this._element).hasClass(ClassName$5.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event$5.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = $.Event(Event$5.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event$5.FOCUSIN);
      $(this._element).removeClass(ClassName$5.SHOW);
      $(this._element).off(Event$5.CLICK_DISMISS);
      $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return $(htmlElement).off(EVENT_KEY$5);
      });
      /**
       * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `Event.CLICK_DATA_API` event that should remain
       */

      $(document).off(Event$5.FOCUSIN);
      $.removeData(this._element, DATA_KEY$5);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$3, {}, config);
      Util.typeCheckConfig(NAME$5, config, DefaultType$3);
      return config;
    };

    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {
      var _this3 = this;

      if (this._config.backdrop === 'static') {
        var hideEventPrevented = $.Event(Event$5.HIDE_PREVENTED);
        $(this._element).trigger(hideEventPrevented);

        if (hideEventPrevented.defaultPrevented) {
          return;
        }

        this._element.classList.add(ClassName$5.STATIC);

        var modalTransitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function () {
          _this3._element.classList.remove(ClassName$5.STATIC);
        }).emulateTransitionEnd(modalTransitionDuration);

        this._element.focus();
      } else {
        this.hide();
      }
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this4 = this;

      var transition = $(this._element).hasClass(ClassName$5.FADE);
      var modalBody = this._dialog ? this._dialog.querySelector(Selector$5.MODAL_BODY) : null;

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE) && modalBody) {
        modalBody.scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName$5.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event$5.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this4._config.focus) {
          _this4._element.focus();
        }

        _this4._isTransitioning = false;
        $(_this4._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this5 = this;

      $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
      .on(Event$5.FOCUSIN, function (event) {
        if (document !== event.target && _this5._element !== event.target && $(_this5._element).has(event.target).length === 0) {
          _this5._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this6 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE$1) {
            _this6._triggerBackdropTransition();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event$5.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this7 = this;

      if (this._isShown) {
        $(window).on(Event$5.RESIZE, function (event) {
          return _this7.handleUpdate(event);
        });
      } else {
        $(window).off(Event$5.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this8 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName$5.OPEN);

        _this8._resetAdjustments();

        _this8._resetScrollbar();

        $(_this8._element).trigger(Event$5.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this9 = this;

      var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName$5.BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
          if (_this9._ignoreBackdropClick) {
            _this9._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          _this9._triggerBackdropTransition();
        });

        if (animate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName$5.SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName$5.SHOW);

        var callbackRemove = function callbackRemove() {
          _this9._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if ($(this._element).hasClass(ClassName$5.FADE)) {
          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------
    ;

    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this10 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

        $(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $(document.body).css('padding-right');
        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }

      $(document.body).addClass(ClassName$5.OPEN);
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
      $(fixedContent).each(function (index, element) {
        var padding = $(element).data('padding-right');
        $(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
      $(elements).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $(document.body).data('padding-right');
      $(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static
    ;

    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$5);

        var _config = _objectSpread2({}, Default$3, {}, $(this).data(), {}, _typeof(config) === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY$5, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    _createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$5;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$3;
      }
    }]);

    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
    var _this11 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = document.querySelector(selector);
    }

    var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread2({}, $(target).data(), {}, $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event$5.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // Only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event$5.HIDDEN, function () {
        if ($(_this11).is(':visible')) {
          _this11.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$5] = Modal._jQueryInterface;
  $.fn[NAME$5].Constructor = Modal;

  $.fn[NAME$5].noConflict = function () {
    $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
    return Modal._jQueryInterface;
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.4.1): tools/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultWhitelist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function allowedAttribute(attr, allowedAttributeList) {
    var attrName = attr.nodeName.toLowerCase();

    if (allowedAttributeList.indexOf(attrName) !== -1) {
      if (uriAttrs.indexOf(attrName) !== -1) {
        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
      }

      return true;
    }

    var regExp = allowedAttributeList.filter(function (attrRegex) {
      return attrRegex instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, l = regExp.length; i < l; i++) {
      if (attrName.match(regExp[i])) {
        return true;
      }
    }

    return false;
  }

  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
    if (unsafeHtml.length === 0) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    var whitelistKeys = Object.keys(whiteList);
    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

    var _loop = function _loop(i, len) {
      var el = elements[i];
      var elName = el.nodeName.toLowerCase();

      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
        el.parentNode.removeChild(el);
        return "continue";
      }

      var attributeList = [].slice.call(el.attributes);
      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
      attributeList.forEach(function (attr) {
        if (!allowedAttribute(attr, whitelistedAttributes)) {
          el.removeAttribute(attr.nodeName);
        }
      });
    };

    for (var i = 0, len = elements.length; i < len; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    return createdDocument.body.innerHTML;
  }
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$6 = 'tooltip';
  var VERSION$6 = '4.4.1';
  var DATA_KEY$6 = 'bs.tooltip';
  var EVENT_KEY$6 = "." + DATA_KEY$6;
  var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
  var DefaultType$4 = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)',
    boundary: '(string|element)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    whiteList: 'object',
    popperConfig: '(null|object)'
  };
  var AttachmentMap$1 = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default$4 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent',
    sanitize: true,
    sanitizeFn: null,
    whiteList: DefaultWhitelist,
    popperConfig: null
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event$6 = {
    HIDE: "hide" + EVENT_KEY$6,
    HIDDEN: "hidden" + EVENT_KEY$6,
    SHOW: "show" + EVENT_KEY$6,
    SHOWN: "shown" + EVENT_KEY$6,
    INSERTED: "inserted" + EVENT_KEY$6,
    CLICK: "click" + EVENT_KEY$6,
    FOCUSIN: "focusin" + EVENT_KEY$6,
    FOCUSOUT: "focusout" + EVENT_KEY$6,
    MOUSEENTER: "mouseenter" + EVENT_KEY$6,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$6
  };
  var ClassName$6 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$6 = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
      } // private


      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // Protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // Getters


    var _proto = Tooltip.prototype; // Public

    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var shadowRoot = Util.findShadowRoot(this.element);
        var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName$6.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, this._getPopperConfig(attachment));
        $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if ($(this.tip).hasClass(ClassName$6.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $(document.body).children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if ($(this.tip).hasClass(ClassName$6.FADE)) {
        var transitionDuration = Util.getTransitionDurationFromElement(tip);
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected
    ;

    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var tip = this.getTipElement();
      this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
      $(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private
    ;

    _proto._getPopperConfig = function _getPopperConfig(attachment) {
      var _this3 = this;

      var defaultBsConfig = {
        placement: attachment,
        modifiers: {
          offset: this._getOffset(),
          flip: {
            behavior: this.config.fallbackPlacement
          },
          arrow: {
            element: Selector$6.ARROW
          },
          preventOverflow: {
            boundariesElement: this.config.boundary
          }
        },
        onCreate: function onCreate(data) {
          if (data.originalPlacement !== data.placement) {
            _this3._handlePopperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          return _this3._handlePopperPlacementChange(data);
        }
      };
      return _objectSpread2({}, defaultBsConfig, {}, this.config.popperConfig);
    };

    _proto._getOffset = function _getOffset() {
      var _this4 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread2({}, data.offsets, {}, _this4.config.offset(data.offsets, _this4.element) || {});
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    };

    _proto._getContainer = function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (Util.isElement(this.config.container)) {
        return $(this.config.container);
      }

      return $(document).find(this.config.container);
    };

    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap$1[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this5 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {
            return _this5.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
          $(_this5.element).on(eventIn, _this5.config.selector, function (event) {
            return _this5._enter(event);
          }).on(eventOut, _this5.config.selector, function (event) {
            return _this5._leave(event);
          });
        }
      });

      this._hideModalHandler = function () {
        if (_this5.element) {
          _this5.hide();
        }
      };

      $(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);

      if (this.config.selector) {
        this.config = _objectSpread2({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = _typeof(this.element.getAttribute('data-original-title'));

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      var dataAttributes = $(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread2({}, this.constructor.Default, {}, dataAttributes, {}, _typeof(config) === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
      var popperInstance = popperData.instance;
      this.tip = popperInstance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName$6.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static
    ;

    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$6);

        var _config = _typeof(config) === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY$6, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$6;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$4;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$6;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$6;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$6;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$6;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$4;
      }
    }]);

    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$6] = Tooltip._jQueryInterface;
  $.fn[NAME$6].Constructor = Tooltip;

  $.fn[NAME$6].noConflict = function () {
    $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
    return Tooltip._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$7 = 'popover';
  var VERSION$7 = '4.4.1';
  var DATA_KEY$7 = 'bs.popover';
  var EVENT_KEY$7 = "." + DATA_KEY$7;
  var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
  var CLASS_PREFIX$1 = 'bs-popover';
  var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

  var Default$5 = _objectSpread2({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });

  var DefaultType$5 = _objectSpread2({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });

  var ClassName$7 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$7 = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event$7 = {
    HIDE: "hide" + EVENT_KEY$7,
    HIDDEN: "hidden" + EVENT_KEY$7,
    SHOW: "show" + EVENT_KEY$7,
    SHOWN: "shown" + EVENT_KEY$7,
    INSERTED: "inserted" + EVENT_KEY$7,
    CLICK: "click" + EVENT_KEY$7,
    FOCUSIN: "focusin" + EVENT_KEY$7,
    FOCUSOUT: "focusout" + EVENT_KEY$7,
    MOUSEENTER: "mouseenter" + EVENT_KEY$7,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$7
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    _inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype; // Overrides

    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(Selector$7.CONTENT), content);
      $tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
    } // Private
    ;

    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    } // Static
    ;

    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$7);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY$7, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Popover, null, [{
      key: "VERSION",
      // Getters
      get: function get() {
        return VERSION$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$5;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$7;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$7;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$7;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$7;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$5;
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$7] = Popover._jQueryInterface;
  $.fn[NAME$7].Constructor = Popover;

  $.fn[NAME$7].noConflict = function () {
    $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
    return Popover._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$8 = 'scrollspy';
  var VERSION$8 = '4.4.1';
  var DATA_KEY$8 = 'bs.scrollspy';
  var EVENT_KEY$8 = "." + DATA_KEY$8;
  var DATA_API_KEY$6 = '.data-api';
  var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
  var Default$6 = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType$6 = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var Event$8 = {
    ACTIVATE: "activate" + EVENT_KEY$8,
    SCROLL: "scroll" + EVENT_KEY$8,
    LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
  };
  var ClassName$8 = {
    DROPDOWN_ITEM: 'dropdown-item',
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active'
  };
  var Selector$8 = {
    DATA_SPY: '[data-spy="scroll"]',
    ACTIVE: '.active',
    NAV_LIST_GROUP: '.nav, .list-group',
    NAV_LINKS: '.nav-link',
    NAV_ITEMS: '.nav-item',
    LIST_ITEMS: '.list-group-item',
    DROPDOWN: '.dropdown',
    DROPDOWN_ITEMS: '.dropdown-item',
    DROPDOWN_TOGGLE: '.dropdown-toggle'
  };
  var OffsetMethod = {
    OFFSET: 'offset',
    POSITION: 'position'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var ScrollSpy =
  /*#__PURE__*/
  function () {
    function ScrollSpy(element, config) {
      var _this = this;

      this._element = element;
      this._scrollElement = element.tagName === 'BODY' ? window : element;
      this._config = this._getConfig(config);
      this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      $(this._scrollElement).on(Event$8.SCROLL, function (event) {
        return _this._process(event);
      });
      this.refresh();

      this._process();
    } // Getters


    var _proto = ScrollSpy.prototype; // Public

    _proto.refresh = function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = [].slice.call(document.querySelectorAll(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = Util.getSelectorFromElement(element);

        if (targetSelector) {
          target = document.querySelector(targetSelector);
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // TODO (fat): remove sketch reliance on jQuery position/offset
            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$8);
      $(this._scrollElement).off(EVENT_KEY$8);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$6, {}, _typeof(config) === 'object' && config ? config : {});

      if (typeof config.target !== 'string') {
        var id = $(config.target).attr('id');

        if (!id) {
          id = Util.getUID(NAME$8);
          $(config.target).attr('id', id);
        }

        config.target = "#" + id;
      }

      Util.typeCheckConfig(NAME$8, config, DefaultType$6);
      return config;
    };

    _proto._getScrollTop = function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    };

    _proto._getScrollHeight = function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    };

    _proto._getOffsetHeight = function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    };

    _proto._process = function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      var offsetLength = this._offsets.length;

      for (var i = offsetLength; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    };

    _proto._activate = function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(',').map(function (selector) {
        return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
      });

      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

      if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
        $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
        $link.addClass(ClassName$8.ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
      }

      $(this._scrollElement).trigger(Event$8.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
        return node.classList.contains(ClassName$8.ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(ClassName$8.ACTIVE);
      });
    } // Static
    ;

    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$8);

        var _config = _typeof(config) === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $(this).data(DATA_KEY$8, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(ScrollSpy, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$8;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$6;
      }
    }]);

    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(window).on(Event$8.LOAD_DATA_API, function () {
    var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
    var scrollSpysLength = scrollSpys.length;

    for (var i = scrollSpysLength; i--;) {
      var $spy = $(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$8] = ScrollSpy._jQueryInterface;
  $.fn[NAME$8].Constructor = ScrollSpy;

  $.fn[NAME$8].noConflict = function () {
    $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
    return ScrollSpy._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$9 = 'tab';
  var VERSION$9 = '4.4.1';
  var DATA_KEY$9 = 'bs.tab';
  var EVENT_KEY$9 = "." + DATA_KEY$9;
  var DATA_API_KEY$7 = '.data-api';
  var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
  var Event$9 = {
    HIDE: "hide" + EVENT_KEY$9,
    HIDDEN: "hidden" + EVENT_KEY$9,
    SHOW: "show" + EVENT_KEY$9,
    SHOWN: "shown" + EVENT_KEY$9,
    CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
  };
  var ClassName$9 = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$9 = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype; // Public

    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event$9.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event$9.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event$9.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event$9.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$9);
      this._element = null;
    } // Private
    ;

    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = Util.getTransitionDurationFromElement(active);
        $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $(active).removeClass(ClassName$9.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName$9.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName$9.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);

      if (element.classList.contains(ClassName$9.FADE)) {
        element.classList.add(ClassName$9.SHOW);
      }

      if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
          $(dropdownToggleList).addClass(ClassName$9.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static
    ;

    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$9);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY$9, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$9;
      }
    }]);

    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$9] = Tab._jQueryInterface;
  $.fn[NAME$9].Constructor = Tab;

  $.fn[NAME$9].noConflict = function () {
    $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
    return Tab._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$a = 'toast';
  var VERSION$a = '4.4.1';
  var DATA_KEY$a = 'bs.toast';
  var EVENT_KEY$a = "." + DATA_KEY$a;
  var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
  var Event$a = {
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
    HIDE: "hide" + EVENT_KEY$a,
    HIDDEN: "hidden" + EVENT_KEY$a,
    SHOW: "show" + EVENT_KEY$a,
    SHOWN: "shown" + EVENT_KEY$a
  };
  var ClassName$a = {
    FADE: 'fade',
    HIDE: 'hide',
    SHOW: 'show',
    SHOWING: 'showing'
  };
  var DefaultType$7 = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default$7 = {
    animation: true,
    autohide: true,
    delay: 500
  };
  var Selector$a = {
    DATA_DISMISS: '[data-dismiss="toast"]'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Toast =
  /*#__PURE__*/
  function () {
    function Toast(element, config) {
      this._element = element;
      this._config = this._getConfig(config);
      this._timeout = null;

      this._setListeners();
    } // Getters


    var _proto = Toast.prototype; // Public

    _proto.show = function show() {
      var _this = this;

      var showEvent = $.Event(Event$a.SHOW);
      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      if (this._config.animation) {
        this._element.classList.add(ClassName$a.FADE);
      }

      var complete = function complete() {
        _this._element.classList.remove(ClassName$a.SHOWING);

        _this._element.classList.add(ClassName$a.SHOW);

        $(_this._element).trigger(Event$a.SHOWN);

        if (_this._config.autohide) {
          _this._timeout = setTimeout(function () {
            _this.hide();
          }, _this._config.delay);
        }
      };

      this._element.classList.remove(ClassName$a.HIDE);

      Util.reflow(this._element);

      this._element.classList.add(ClassName$a.SHOWING);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto.hide = function hide() {
      if (!this._element.classList.contains(ClassName$a.SHOW)) {
        return;
      }

      var hideEvent = $.Event(Event$a.HIDE);
      $(this._element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      this._close();
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      this._timeout = null;

      if (this._element.classList.contains(ClassName$a.SHOW)) {
        this._element.classList.remove(ClassName$a.SHOW);
      }

      $(this._element).off(Event$a.CLICK_DISMISS);
      $.removeData(this._element, DATA_KEY$a);
      this._element = null;
      this._config = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$7, {}, $(this._element).data(), {}, _typeof(config) === 'object' && config ? config : {});
      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
      return config;
    };

    _proto._setListeners = function _setListeners() {
      var _this2 = this;

      $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
        return _this2.hide();
      });
    };

    _proto._close = function _close() {
      var _this3 = this;

      var complete = function complete() {
        _this3._element.classList.add(ClassName$a.HIDE);

        $(_this3._element).trigger(Event$a.HIDDEN);
      };

      this._element.classList.remove(ClassName$a.SHOW);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    } // Static
    ;

    Toast._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY$a);

        var _config = _typeof(config) === 'object' && config;

        if (!data) {
          data = new Toast(this, _config);
          $element.data(DATA_KEY$a, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](this);
        }
      });
    };

    _createClass(Toast, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$a;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$7;
      }
    }]);

    return Toast;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$a] = Toast._jQueryInterface;
  $.fn[NAME$a].Constructor = Toast;

  $.fn[NAME$a].noConflict = function () {
    $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
    return Toast._jQueryInterface;
  };

  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Util = Util;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
},{"jquery":"HlZQ","popper.js":"v5IM"}],"gsgA":[function(require,module,exports) {

},{}],"Eofe":[function(require,module,exports) {

},{"./../webfonts/fa-brands-400.eot":[["fa-brands-400.c99d5442.eot","YH3g"],"YH3g"],"./../webfonts/fa-brands-400.woff2":[["fa-brands-400.c0d8bb36.woff2","qUWF"],"qUWF"],"./../webfonts/fa-brands-400.woff":[["fa-brands-400.11a44150.woff","d16i"],"d16i"],"./../webfonts/fa-brands-400.ttf":[["fa-brands-400.20cead16.ttf","Lu1x"],"Lu1x"],"./../webfonts/fa-brands-400.svg":[["fa-brands-400.a515b611.svg","GRGc"],"GRGc"],"./../webfonts/fa-regular-400.eot":[["fa-regular-400.369eb765.eot","nv22"],"nv22"],"./../webfonts/fa-regular-400.woff2":[["fa-regular-400.550f7af0.woff2","M504"],"M504"],"./../webfonts/fa-regular-400.woff":[["fa-regular-400.ef6f0018.woff","H1q6"],"H1q6"],"./../webfonts/fa-regular-400.ttf":[["fa-regular-400.17102ce2.ttf","Evul"],"Evul"],"./../webfonts/fa-regular-400.svg":[["fa-regular-400.14dd3750.svg","D7rB"],"D7rB"],"./../webfonts/fa-solid-900.eot":[["fa-solid-900.2c8dfef2.eot","ISQp"],"ISQp"],"./../webfonts/fa-solid-900.woff2":[["fa-solid-900.c1a895b2.woff2","PerI"],"PerI"],"./../webfonts/fa-solid-900.woff":[["fa-solid-900.cf2beb40.woff","nA9q"],"nA9q"],"./../webfonts/fa-solid-900.ttf":[["fa-solid-900.8bff6c41.ttf","FJZt"],"FJZt"],"./../webfonts/fa-solid-900.svg":[["fa-solid-900.6f9dbdf9.svg","lFqB"],"lFqB"]}],"isAo":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Network = RT;
exports.util = exports.network = exports.moment = exports.keycharm = exports.data = exports.Queue = exports.Hammer = exports.DataView = exports.DataSet = exports.DOMutil = exports.default = void 0;

/**
 * vis-network - network
 * http://visjs.org/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 6.4.6
 * @date    2019-11-29T21:09:43Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2018-2019 visjs contributors, https://github.com/visjs
 *
 * @license 
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function e() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}

function i(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var n = function (t) {
  return t && t.Math == Math && t;
},
    o = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof t && t) || Function("return this")(),
    r = function (t) {
  try {
    return !!t();
  } catch (t) {
    return !0;
  }
},
    s = !r(function () {
  return 7 != Object.defineProperty({}, "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    a = {}.propertyIsEnumerable,
    h = Object.getOwnPropertyDescriptor,
    l = {
  f: h && !a.call({
    1: 2
  }, 1) ? function (t) {
    var e = h(this, t);
    return !!e && e.enumerable;
  } : a
},
    d = function (t, e) {
  return {
    enumerable: !(1 & t),
    configurable: !(2 & t),
    writable: !(4 & t),
    value: e
  };
},
    u = {}.toString,
    c = function (t) {
  return u.call(t).slice(8, -1);
},
    f = "".split,
    p = r(function () {
  return !Object("z").propertyIsEnumerable(0);
}) ? function (t) {
  return "String" == c(t) ? f.call(t, "") : Object(t);
} : Object,
    v = function (t) {
  if (null == t) throw TypeError("Can't call method on " + t);
  return t;
},
    y = function (t) {
  return p(v(t));
},
    g = function (t) {
  return "object" == typeof t ? null !== t : "function" == typeof t;
},
    m = function (t, e) {
  if (!g(t)) return t;
  var i, n;
  if (e && "function" == typeof (i = t.toString) && !g(n = i.call(t))) return n;
  if ("function" == typeof (i = t.valueOf) && !g(n = i.call(t))) return n;
  if (!e && "function" == typeof (i = t.toString) && !g(n = i.call(t))) return n;
  throw TypeError("Can't convert object to primitive value");
},
    b = {}.hasOwnProperty,
    w = function (t, e) {
  return b.call(t, e);
},
    _ = o.document,
    k = g(_) && g(_.createElement),
    x = function (t) {
  return k ? _.createElement(t) : {};
},
    O = !s && !r(function () {
  return 7 != Object.defineProperty(x("div"), "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    S = Object.getOwnPropertyDescriptor,
    M = {
  f: s ? S : function (t, e) {
    if (t = y(t), e = m(e, !0), O) try {
      return S(t, e);
    } catch (t) {}
    if (w(t, e)) return d(!l.f.call(t, e), t[e]);
  }
},
    E = /#|\.prototype\./,
    D = function (t, e) {
  var i = C[T(t)];
  return i == A || i != P && ("function" == typeof e ? r(e) : !!e);
},
    T = D.normalize = function (t) {
  return String(t).replace(E, ".").toLowerCase();
},
    C = D.data = {},
    P = D.NATIVE = "N",
    A = D.POLYFILL = "P",
    I = D,
    F = {},
    N = function (t) {
  if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
  return t;
},
    j = function (t, e, i) {
  if (N(t), void 0 === e) return t;

  switch (i) {
    case 0:
      return function () {
        return t.call(e);
      };

    case 1:
      return function (i) {
        return t.call(e, i);
      };

    case 2:
      return function (i, n) {
        return t.call(e, i, n);
      };

    case 3:
      return function (i, n, o) {
        return t.call(e, i, n, o);
      };
  }

  return function () {
    return t.apply(e, arguments);
  };
},
    z = function (t) {
  if (!g(t)) throw TypeError(String(t) + " is not an object");
  return t;
},
    L = Object.defineProperty,
    R = {
  f: s ? L : function (t, e, i) {
    if (z(t), e = m(e, !0), z(i), O) try {
      return L(t, e, i);
    } catch (t) {}
    if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
    return "value" in i && (t[e] = i.value), t;
  }
},
    B = s ? function (t, e, i) {
  return R.f(t, e, d(1, i));
} : function (t, e, i) {
  return t[e] = i, t;
},
    Y = M.f,
    H = function (t) {
  var e = function (e, i, n) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new t();

        case 1:
          return new t(e);

        case 2:
          return new t(e, i);
      }

      return new t(e, i, n);
    }

    return t.apply(this, arguments);
  };

  return e.prototype = t.prototype, e;
},
    W = function (t, e) {
  var i,
      n,
      r,
      s,
      a,
      h,
      l,
      d,
      u = t.target,
      c = t.global,
      f = t.stat,
      p = t.proto,
      v = c ? o : f ? o[u] : (o[u] || {}).prototype,
      y = c ? F : F[u] || (F[u] = {}),
      g = y.prototype;

  for (r in e) i = !I(c ? r : u + (f ? "." : "#") + r, t.forced) && v && w(v, r), a = y[r], i && (h = t.noTargetGet ? (d = Y(v, r)) && d.value : v[r]), s = i && h ? h : e[r], i && typeof a == typeof s || (l = t.bind && i ? j(s, o) : t.wrap && i ? H(s) : p && "function" == typeof s ? j(Function.call, s) : s, (t.sham || s && s.sham || a && a.sham) && B(l, "sham", !0), y[r] = l, p && (w(F, n = u + "Prototype") || B(F, n, {}), F[n][r] = s, t.real && g && !g[r] && B(g, r, s)));
},
    V = [].slice,
    U = {},
    G = function (t, e, i) {
  if (!(e in U)) {
    for (var n = [], o = 0; o < e; o++) n[o] = "a[" + o + "]";

    U[e] = Function("C,a", "return new C(" + n.join(",") + ")");
  }

  return U[e](t, i);
},
    q = Function.bind || function (t) {
  var e = N(this),
      i = V.call(arguments, 1),
      n = function () {
    var o = i.concat(V.call(arguments));
    return this instanceof n ? G(e, o.length, o) : e.apply(t, o);
  };

  return g(e.prototype) && (n.prototype = e.prototype), n;
};

W({
  target: "Function",
  proto: !0
}, {
  bind: q
});

var X = function (t) {
  return F[t + "Prototype"];
},
    Z = X("Function").bind,
    K = Function.prototype,
    $ = function (t) {
  var e = t.bind;
  return t === K || t instanceof Function && e === K.bind ? Z : e;
};

function J(t, e, i, n) {
  t.beginPath(), t.arc(e, i, n, 0, 2 * Math.PI, !1), t.closePath();
}

function Q(t, e, i, n, o, r) {
  var s = Math.PI / 180;
  n - 2 * r < 0 && (r = n / 2), o - 2 * r < 0 && (r = o / 2), t.beginPath(), t.moveTo(e + r, i), t.lineTo(e + n - r, i), t.arc(e + n - r, i + r, r, 270 * s, 360 * s, !1), t.lineTo(e + n, i + o - r), t.arc(e + n - r, i + o - r, r, 0, 90 * s, !1), t.lineTo(e + r, i + o), t.arc(e + r, i + o - r, r, 90 * s, 180 * s, !1), t.lineTo(e, i + r), t.arc(e + r, i + r, r, 180 * s, 270 * s, !1), t.closePath();
}

function tt(t, e, i, n, o) {
  var r = n / 2 * .5522848,
      s = o / 2 * .5522848,
      a = e + n,
      h = i + o,
      l = e + n / 2,
      d = i + o / 2;
  t.beginPath(), t.moveTo(e, d), t.bezierCurveTo(e, d - s, l - r, i, l, i), t.bezierCurveTo(l + r, i, a, d - s, a, d), t.bezierCurveTo(a, d + s, l + r, h, l, h), t.bezierCurveTo(l - r, h, e, d + s, e, d), t.closePath();
}

function et(t, e, i, n, o) {
  var r = o * (1 / 3),
      s = n / 2 * .5522848,
      a = r / 2 * .5522848,
      h = e + n,
      l = i + r,
      d = e + n / 2,
      u = i + r / 2,
      c = i + (o - r / 2),
      f = i + o;
  t.beginPath(), t.moveTo(h, u), t.bezierCurveTo(h, u + a, d + s, l, d, l), t.bezierCurveTo(d - s, l, e, u + a, e, u), t.bezierCurveTo(e, u - a, d - s, i, d, i), t.bezierCurveTo(d + s, i, h, u - a, h, u), t.lineTo(h, c), t.bezierCurveTo(h, c + a, d + s, f, d, f), t.bezierCurveTo(d - s, f, e, c + a, e, c), t.lineTo(e, u);
}

function it(t, e, i, n, o, r) {
  t.beginPath(), t.moveTo(e, i);

  for (var s = r.length, a = n - e, h = o - i, l = h / a, d = Math.sqrt(a * a + h * h), u = 0, c = !0, f = 0, p = +r[0]; d >= .1;) (p = +r[u++ % s]) > d && (p = d), f = Math.sqrt(p * p / (1 + l * l)), e += f = a < 0 ? -f : f, i += l * f, !0 === c ? t.lineTo(e, i) : t.moveTo(e, i), d -= p, c = !c;
}

var nt = {
  circle: J,
  dashedLine: it,
  database: et,
  diamond: function (t, e, i, n) {
    t.beginPath(), t.lineTo(e, i + n), t.lineTo(e + n, i), t.lineTo(e, i - n), t.lineTo(e - n, i), t.closePath();
  },
  ellipse: tt,
  ellipse_vis: tt,
  hexagon: function (t, e, i, n) {
    t.beginPath();
    var o = 2 * Math.PI / 6;
    t.moveTo(e + n, i);

    for (var r = 1; r < 6; r++) t.lineTo(e + n * Math.cos(o * r), i + n * Math.sin(o * r));

    t.closePath();
  },
  roundRect: Q,
  square: function (t, e, i, n) {
    t.beginPath(), t.rect(e - n, i - n, 2 * n, 2 * n), t.closePath();
  },
  star: function (t, e, i, n) {
    t.beginPath(), i += .1 * (n *= .82);

    for (var o = 0; o < 10; o++) {
      var r = o % 2 == 0 ? 1.3 * n : .5 * n;
      t.lineTo(e + r * Math.sin(2 * o * Math.PI / 10), i - r * Math.cos(2 * o * Math.PI / 10));
    }

    t.closePath();
  },
  triangle: function (t, e, i, n) {
    t.beginPath(), i += .275 * (n *= 1.15);
    var o = 2 * n,
        r = o / 2,
        s = Math.sqrt(3) / 6 * o,
        a = Math.sqrt(o * o - r * r);
    t.moveTo(e, i - (a - s)), t.lineTo(e + r, i + s), t.lineTo(e - r, i + s), t.lineTo(e, i - (a - s)), t.closePath();
  },
  triangleDown: function (t, e, i, n) {
    t.beginPath(), i -= .275 * (n *= 1.15);
    var o = 2 * n,
        r = o / 2,
        s = Math.sqrt(3) / 6 * o,
        a = Math.sqrt(o * o - r * r);
    t.moveTo(e, i + (a - s)), t.lineTo(e + r, i - s), t.lineTo(e - r, i - s), t.lineTo(e, i + (a - s)), t.closePath();
  }
};
var ot = i(function (t) {
  function e(t) {
    if (t) return function (t) {
      for (var i in e.prototype) t[i] = e.prototype[i];

      return t;
    }(t);
  }

  t.exports = e, e.prototype.on = e.prototype.addEventListener = function (t, e) {
    return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
  }, e.prototype.once = function (t, e) {
    function i() {
      this.off(t, i), e.apply(this, arguments);
    }

    return i.fn = e, this.on(t, i), this;
  }, e.prototype.off = e.prototype.removeListener = e.prototype.removeAllListeners = e.prototype.removeEventListener = function (t, e) {
    if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
    var i,
        n = this._callbacks["$" + t];
    if (!n) return this;
    if (1 == arguments.length) return delete this._callbacks["$" + t], this;

    for (var o = 0; o < n.length; o++) if ((i = n[o]) === e || i.fn === e) {
      n.splice(o, 1);
      break;
    }

    return 0 === n.length && delete this._callbacks["$" + t], this;
  }, e.prototype.emit = function (t) {
    this._callbacks = this._callbacks || {};

    for (var e = new Array(arguments.length - 1), i = this._callbacks["$" + t], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];

    if (i) {
      n = 0;

      for (var o = (i = i.slice(0)).length; n < o; ++n) i[n].apply(this, e);
    }

    return this;
  }, e.prototype.listeners = function (t) {
    return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
  }, e.prototype.hasListeners = function (t) {
    return !!this.listeners(t).length;
  };
}),
    rt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function st(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var at = function (t) {
  return t && t.Math == Math && t;
},
    ht = at("object" == typeof globalThis && globalThis) || at("object" == typeof window && window) || at("object" == typeof self && self) || at("object" == typeof rt && rt) || Function("return this")(),
    lt = function (t) {
  try {
    return !!t();
  } catch (t) {
    return !0;
  }
},
    dt = !lt(function () {
  return 7 != Object.defineProperty({}, "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    ut = {}.propertyIsEnumerable,
    ct = Object.getOwnPropertyDescriptor,
    ft = {
  f: ct && !ut.call({
    1: 2
  }, 1) ? function (t) {
    var e = ct(this, t);
    return !!e && e.enumerable;
  } : ut
},
    pt = function (t, e) {
  return {
    enumerable: !(1 & t),
    configurable: !(2 & t),
    writable: !(4 & t),
    value: e
  };
},
    vt = {}.toString,
    yt = function (t) {
  return vt.call(t).slice(8, -1);
},
    gt = "".split,
    mt = lt(function () {
  return !Object("z").propertyIsEnumerable(0);
}) ? function (t) {
  return "String" == yt(t) ? gt.call(t, "") : Object(t);
} : Object,
    bt = function (t) {
  if (null == t) throw TypeError("Can't call method on " + t);
  return t;
},
    wt = function (t) {
  return mt(bt(t));
},
    _t = function (t) {
  return "object" == typeof t ? null !== t : "function" == typeof t;
},
    kt = function (t, e) {
  if (!_t(t)) return t;
  var i, n;
  if (e && "function" == typeof (i = t.toString) && !_t(n = i.call(t))) return n;
  if ("function" == typeof (i = t.valueOf) && !_t(n = i.call(t))) return n;
  if (!e && "function" == typeof (i = t.toString) && !_t(n = i.call(t))) return n;
  throw TypeError("Can't convert object to primitive value");
},
    xt = {}.hasOwnProperty,
    Ot = function (t, e) {
  return xt.call(t, e);
},
    St = ht.document,
    Mt = _t(St) && _t(St.createElement),
    Et = function (t) {
  return Mt ? St.createElement(t) : {};
},
    Dt = !dt && !lt(function () {
  return 7 != Object.defineProperty(Et("div"), "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    Tt = Object.getOwnPropertyDescriptor,
    Ct = {
  f: dt ? Tt : function (t, e) {
    if (t = wt(t), e = kt(e, !0), Dt) try {
      return Tt(t, e);
    } catch (t) {}
    if (Ot(t, e)) return pt(!ft.f.call(t, e), t[e]);
  }
},
    Pt = /#|\.prototype\./,
    At = function (t, e) {
  var i = Ft[It(t)];
  return i == jt || i != Nt && ("function" == typeof e ? lt(e) : !!e);
},
    It = At.normalize = function (t) {
  return String(t).replace(Pt, ".").toLowerCase();
},
    Ft = At.data = {},
    Nt = At.NATIVE = "N",
    jt = At.POLYFILL = "P",
    zt = At,
    Lt = {},
    Rt = function (t, e, i) {
  if (function (t) {
    if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
  }(t), void 0 === e) return t;

  switch (i) {
    case 0:
      return function () {
        return t.call(e);
      };

    case 1:
      return function (i) {
        return t.call(e, i);
      };

    case 2:
      return function (i, n) {
        return t.call(e, i, n);
      };

    case 3:
      return function (i, n, o) {
        return t.call(e, i, n, o);
      };
  }

  return function () {
    return t.apply(e, arguments);
  };
},
    Bt = function (t) {
  if (!_t(t)) throw TypeError(String(t) + " is not an object");
  return t;
},
    Yt = Object.defineProperty,
    Ht = {
  f: dt ? Yt : function (t, e, i) {
    if (Bt(t), e = kt(e, !0), Bt(i), Dt) try {
      return Yt(t, e, i);
    } catch (t) {}
    if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
    return "value" in i && (t[e] = i.value), t;
  }
},
    Wt = dt ? function (t, e, i) {
  return Ht.f(t, e, pt(1, i));
} : function (t, e, i) {
  return t[e] = i, t;
},
    Vt = Ct.f,
    Ut = function (t) {
  var e = function (e, i, n) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new t();

        case 1:
          return new t(e);

        case 2:
          return new t(e, i);
      }

      return new t(e, i, n);
    }

    return t.apply(this, arguments);
  };

  return e.prototype = t.prototype, e;
},
    Gt = function (t, e) {
  var i,
      n,
      o,
      r,
      s,
      a,
      h,
      l,
      d = t.target,
      u = t.global,
      c = t.stat,
      f = t.proto,
      p = u ? ht : c ? ht[d] : (ht[d] || {}).prototype,
      v = u ? Lt : Lt[d] || (Lt[d] = {}),
      y = v.prototype;

  for (o in e) i = !zt(u ? o : d + (c ? "." : "#") + o, t.forced) && p && Ot(p, o), s = v[o], i && (a = t.noTargetGet ? (l = Vt(p, o)) && l.value : p[o]), r = i && a ? a : e[o], i && typeof s == typeof r || (h = t.bind && i ? Rt(r, ht) : t.wrap && i ? Ut(r) : f && "function" == typeof r ? Rt(Function.call, r) : r, (t.sham || r && r.sham || s && s.sham) && Wt(h, "sham", !0), v[o] = h, f && (Ot(Lt, n = d + "Prototype") || Wt(Lt, n, {}), Lt[n][o] = r, t.real && y && !y[o] && Wt(y, o, r)));
};

Gt({
  target: "Object",
  stat: !0,
  forced: !dt,
  sham: !dt
}, {
  defineProperty: Ht.f
});

var qt = st(function (t) {
  var e = Lt.Object,
      i = t.exports = function (t, i, n) {
    return e.defineProperty(t, i, n);
  };

  e.defineProperty.sham && (i.sham = !0);
}),
    Xt = qt,
    Zt = Math.ceil,
    Kt = Math.floor,
    $t = function (t) {
  return isNaN(t = +t) ? 0 : (t > 0 ? Kt : Zt)(t);
},
    Jt = Math.min,
    Qt = function (t) {
  return t > 0 ? Jt($t(t), 9007199254740991) : 0;
},
    te = Math.max,
    ee = Math.min,
    ie = function (t, e) {
  var i = $t(t);
  return i < 0 ? te(i + e, 0) : ee(i, e);
},
    ne = function (t) {
  return function (e, i, n) {
    var o,
        r = wt(e),
        s = Qt(r.length),
        a = ie(n, s);

    if (t && i != i) {
      for (; s > a;) if ((o = r[a++]) != o) return !0;
    } else for (; s > a; a++) if ((t || a in r) && r[a] === i) return t || a || 0;

    return !t && -1;
  };
},
    oe = {
  includes: ne(!0),
  indexOf: ne(!1)
},
    re = {},
    se = oe.indexOf,
    ae = function (t, e) {
  var i,
      n = wt(t),
      o = 0,
      r = [];

  for (i in n) !Ot(re, i) && Ot(n, i) && r.push(i);

  for (; e.length > o;) Ot(n, i = e[o++]) && (~se(r, i) || r.push(i));

  return r;
},
    he = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    le = Object.keys || function (t) {
  return ae(t, he);
},
    de = dt ? Object.defineProperties : function (t, e) {
  Bt(t);

  for (var i, n = le(e), o = n.length, r = 0; o > r;) Ht.f(t, i = n[r++], e[i]);

  return t;
};

Gt({
  target: "Object",
  stat: !0,
  forced: !dt,
  sham: !dt
}, {
  defineProperties: de
});

var ue = st(function (t) {
  var e = Lt.Object,
      i = t.exports = function (t, i) {
    return e.defineProperties(t, i);
  };

  e.defineProperties.sham && (i.sham = !0);
}),
    ce = function (t) {
  return "function" == typeof t ? t : void 0;
},
    fe = function (t, e) {
  return arguments.length < 2 ? ce(Lt[t]) || ce(ht[t]) : Lt[t] && Lt[t][e] || ht[t] && ht[t][e];
},
    pe = he.concat("length", "prototype"),
    ve = {
  f: Object.getOwnPropertyNames || function (t) {
    return ae(t, pe);
  }
},
    ye = {
  f: Object.getOwnPropertySymbols
},
    ge = fe("Reflect", "ownKeys") || function (t) {
  var e = ve.f(Bt(t)),
      i = ye.f;
  return i ? e.concat(i(t)) : e;
},
    me = function (t, e, i) {
  var n = kt(e);
  n in t ? Ht.f(t, n, pt(0, i)) : t[n] = i;
};

Gt({
  target: "Object",
  stat: !0,
  sham: !dt
}, {
  getOwnPropertyDescriptors: function (t) {
    for (var e, i, n = wt(t), o = Ct.f, r = ge(n), s = {}, a = 0; r.length > a;) void 0 !== (i = o(n, e = r[a++])) && me(s, e, i);

    return s;
  }
});

var be = Lt.Object.getOwnPropertyDescriptors,
    we = Ct.f,
    _e = lt(function () {
  we(1);
});

Gt({
  target: "Object",
  stat: !0,
  forced: !dt || _e,
  sham: !dt
}, {
  getOwnPropertyDescriptor: function (t, e) {
    return we(wt(t), e);
  }
});

var ke = st(function (t) {
  var e = Lt.Object,
      i = t.exports = function (t, i) {
    return e.getOwnPropertyDescriptor(t, i);
  };

  e.getOwnPropertyDescriptor.sham && (i.sham = !0);
}),
    xe = !!Object.getOwnPropertySymbols && !lt(function () {
  return !String(Symbol());
}),
    Oe = Array.isArray || function (t) {
  return "Array" == yt(t);
},
    Se = function (t) {
  return Object(bt(t));
},
    Me = fe("document", "documentElement"),
    Ee = ht["__core-js_shared__"] || function (t, e) {
  try {
    Wt(ht, t, e);
  } catch (i) {
    ht[t] = e;
  }

  return e;
}("__core-js_shared__", {}),
    De = st(function (t) {
  (t.exports = function (t, e) {
    return Ee[t] || (Ee[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.4.1",
    mode: "pure",
    copyright: " 2019 Denis Pushkarev (zloirock.ru)"
  });
}),
    Te = 0,
    Ce = Math.random(),
    Pe = function (t) {
  return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++Te + Ce).toString(36);
},
    Ae = De("keys"),
    Ie = function (t) {
  return Ae[t] || (Ae[t] = Pe(t));
},
    Fe = Ie("IE_PROTO"),
    Ne = function () {},
    je = function () {
  var t,
      e = Et("iframe"),
      i = he.length;

  for (e.style.display = "none", Me.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), je = t.F; i--;) delete je.prototype[he[i]];

  return je();
},
    ze = Object.create || function (t, e) {
  var i;
  return null !== t ? (Ne.prototype = Bt(t), i = new Ne(), Ne.prototype = null, i[Fe] = t) : i = je(), void 0 === e ? i : de(i, e);
};

re[Fe] = !0;

var Le = ve.f,
    Re = {}.toString,
    Be = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
    Ye = {
  f: function (t) {
    return Be && "[object Window]" == Re.call(t) ? function (t) {
      try {
        return Le(t);
      } catch (t) {
        return Be.slice();
      }
    }(t) : Le(wt(t));
  }
},
    He = function (t, e, i, n) {
  n && n.enumerable ? t[e] = i : Wt(t, e, i);
},
    We = ht.Symbol,
    Ve = De("wks"),
    Ue = function (t) {
  return Ve[t] || (Ve[t] = xe && We[t] || (xe ? We : Pe)("Symbol." + t));
},
    Ge = {
  f: Ue
},
    qe = Ht.f,
    Xe = function (t) {
  var e = Lt.Symbol || (Lt.Symbol = {});
  Ot(e, t) || qe(e, t, {
    value: Ge.f(t)
  });
},
    Ze = Ue("toStringTag"),
    Ke = "Arguments" == yt(function () {
  return arguments;
}()),
    $e = function (t) {
  var e, i, n;
  return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function (t, e) {
    try {
      return t[e];
    } catch (t) {}
  }(e = Object(t), Ze)) ? i : Ke ? yt(e) : "Object" == (n = yt(e)) && "function" == typeof e.callee ? "Arguments" : n;
},
    Je = {};

Je[Ue("toStringTag")] = "z";

var Qe,
    ti,
    ei,
    ii = "[object z]" !== String(Je) ? function () {
  return "[object " + $e(this) + "]";
} : Je.toString,
    ni = Ht.f,
    oi = Ue("toStringTag"),
    ri = ii !== {}.toString,
    si = function (t, e, i, n) {
  if (t) {
    var o = i ? t : t.prototype;
    Ot(o, oi) || ni(o, oi, {
      configurable: !0,
      value: e
    }), n && ri && Wt(o, "toString", ii);
  }
},
    ai = De("native-function-to-string", Function.toString),
    hi = ht.WeakMap,
    li = "function" == typeof hi && /native code/.test(ai.call(hi)),
    di = ht.WeakMap;

if (li) {
  var ui = new di(),
      ci = ui.get,
      fi = ui.has,
      pi = ui.set;
  Qe = function (t, e) {
    return pi.call(ui, t, e), e;
  }, ti = function (t) {
    return ci.call(ui, t) || {};
  }, ei = function (t) {
    return fi.call(ui, t);
  };
} else {
  var vi = Ie("state");
  re[vi] = !0, Qe = function (t, e) {
    return Wt(t, vi, e), e;
  }, ti = function (t) {
    return Ot(t, vi) ? t[vi] : {};
  }, ei = function (t) {
    return Ot(t, vi);
  };
}

var yi = {
  set: Qe,
  get: ti,
  has: ei,
  enforce: function (t) {
    return ei(t) ? ti(t) : Qe(t, {});
  },
  getterFor: function (t) {
    return function (e) {
      var i;
      if (!_t(e) || (i = ti(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
      return i;
    };
  }
},
    gi = Ue("species"),
    mi = function (t, e) {
  var i;
  return Oe(t) && ("function" != typeof (i = t.constructor) || i !== Array && !Oe(i.prototype) ? _t(i) && null === (i = i[gi]) && (i = void 0) : i = void 0), new (void 0 === i ? Array : i)(0 === e ? 0 : e);
},
    bi = [].push,
    wi = function (t) {
  var e = 1 == t,
      i = 2 == t,
      n = 3 == t,
      o = 4 == t,
      r = 6 == t,
      s = 5 == t || r;
  return function (a, h, l, d) {
    for (var u, c, f = Se(a), p = mt(f), v = Rt(h, l, 3), y = Qt(p.length), g = 0, m = d || mi, b = e ? m(a, y) : i ? m(a, 0) : void 0; y > g; g++) if ((s || g in p) && (c = v(u = p[g], g, f), t)) if (e) b[g] = c;else if (c) switch (t) {
      case 3:
        return !0;

      case 5:
        return u;

      case 6:
        return g;

      case 2:
        bi.call(b, u);
    } else if (o) return !1;

    return r ? -1 : n || o ? o : b;
  };
},
    _i = {
  forEach: wi(0),
  map: wi(1),
  filter: wi(2),
  some: wi(3),
  every: wi(4),
  find: wi(5),
  findIndex: wi(6)
},
    ki = _i.forEach,
    xi = Ie("hidden"),
    Oi = Ue("toPrimitive"),
    Si = yi.set,
    Mi = yi.getterFor("Symbol"),
    Ei = Object.prototype,
    Di = ht.Symbol,
    Ti = fe("JSON", "stringify"),
    Ci = Ct.f,
    Pi = Ht.f,
    Ai = Ye.f,
    Ii = ft.f,
    Fi = De("symbols"),
    Ni = De("op-symbols"),
    ji = De("string-to-symbol-registry"),
    zi = De("symbol-to-string-registry"),
    Li = De("wks"),
    Ri = ht.QObject,
    Bi = !Ri || !Ri.prototype || !Ri.prototype.findChild,
    Yi = dt && lt(function () {
  return 7 != ze(Pi({}, "a", {
    get: function () {
      return Pi(this, "a", {
        value: 7
      }).a;
    }
  })).a;
}) ? function (t, e, i) {
  var n = Ci(Ei, e);
  n && delete Ei[e], Pi(t, e, i), n && t !== Ei && Pi(Ei, e, n);
} : Pi,
    Hi = function (t, e) {
  var i = Fi[t] = ze(Di.prototype);
  return Si(i, {
    type: "Symbol",
    tag: t,
    description: e
  }), dt || (i.description = e), i;
},
    Wi = xe && "symbol" == typeof Di.iterator ? function (t) {
  return "symbol" == typeof t;
} : function (t) {
  return Object(t) instanceof Di;
},
    Vi = function (t, e, i) {
  t === Ei && Vi(Ni, e, i), Bt(t);
  var n = kt(e, !0);
  return Bt(i), Ot(Fi, n) ? (i.enumerable ? (Ot(t, xi) && t[xi][n] && (t[xi][n] = !1), i = ze(i, {
    enumerable: pt(0, !1)
  })) : (Ot(t, xi) || Pi(t, xi, pt(1, {})), t[xi][n] = !0), Yi(t, n, i)) : Pi(t, n, i);
},
    Ui = function (t, e) {
  Bt(t);
  var i = wt(e),
      n = le(i).concat(Zi(i));
  return ki(n, function (e) {
    dt && !Gi.call(i, e) || Vi(t, e, i[e]);
  }), t;
},
    Gi = function (t) {
  var e = kt(t, !0),
      i = Ii.call(this, e);
  return !(this === Ei && Ot(Fi, e) && !Ot(Ni, e)) && (!(i || !Ot(this, e) || !Ot(Fi, e) || Ot(this, xi) && this[xi][e]) || i);
},
    qi = function (t, e) {
  var i = wt(t),
      n = kt(e, !0);

  if (i !== Ei || !Ot(Fi, n) || Ot(Ni, n)) {
    var o = Ci(i, n);
    return !o || !Ot(Fi, n) || Ot(i, xi) && i[xi][n] || (o.enumerable = !0), o;
  }
},
    Xi = function (t) {
  var e = Ai(wt(t)),
      i = [];
  return ki(e, function (t) {
    Ot(Fi, t) || Ot(re, t) || i.push(t);
  }), i;
},
    Zi = function (t) {
  var e = t === Ei,
      i = Ai(e ? Ni : wt(t)),
      n = [];
  return ki(i, function (t) {
    !Ot(Fi, t) || e && !Ot(Ei, t) || n.push(Fi[t]);
  }), n;
};

if (xe || (He((Di = function () {
  if (this instanceof Di) throw TypeError("Symbol is not a constructor");

  var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
      e = Pe(t),
      i = function (t) {
    this === Ei && i.call(Ni, t), Ot(this, xi) && Ot(this[xi], e) && (this[xi][e] = !1), Yi(this, e, pt(1, t));
  };

  return dt && Bi && Yi(Ei, e, {
    configurable: !0,
    set: i
  }), Hi(e, t);
}).prototype, "toString", function () {
  return Mi(this).tag;
}), ft.f = Gi, Ht.f = Vi, Ct.f = qi, ve.f = Ye.f = Xi, ye.f = Zi, dt && Pi(Di.prototype, "description", {
  configurable: !0,
  get: function () {
    return Mi(this).description;
  }
}), Ge.f = function (t) {
  return Hi(Ue(t), t);
}), Gt({
  global: !0,
  wrap: !0,
  forced: !xe,
  sham: !xe
}, {
  Symbol: Di
}), ki(le(Li), function (t) {
  Xe(t);
}), Gt({
  target: "Symbol",
  stat: !0,
  forced: !xe
}, {
  for: function (t) {
    var e = String(t);
    if (Ot(ji, e)) return ji[e];
    var i = Di(e);
    return ji[e] = i, zi[i] = e, i;
  },
  keyFor: function (t) {
    if (!Wi(t)) throw TypeError(t + " is not a symbol");
    if (Ot(zi, t)) return zi[t];
  },
  useSetter: function () {
    Bi = !0;
  },
  useSimple: function () {
    Bi = !1;
  }
}), Gt({
  target: "Object",
  stat: !0,
  forced: !xe,
  sham: !dt
}, {
  create: function (t, e) {
    return void 0 === e ? ze(t) : Ui(ze(t), e);
  },
  defineProperty: Vi,
  defineProperties: Ui,
  getOwnPropertyDescriptor: qi
}), Gt({
  target: "Object",
  stat: !0,
  forced: !xe
}, {
  getOwnPropertyNames: Xi,
  getOwnPropertySymbols: Zi
}), Gt({
  target: "Object",
  stat: !0,
  forced: lt(function () {
    ye.f(1);
  })
}, {
  getOwnPropertySymbols: function (t) {
    return ye.f(Se(t));
  }
}), Ti) {
  var Ki = !xe || lt(function () {
    var t = Di();
    return "[null]" != Ti([t]) || "{}" != Ti({
      a: t
    }) || "{}" != Ti(Object(t));
  });
  Gt({
    target: "JSON",
    stat: !0,
    forced: Ki
  }, {
    stringify: function (t, e, i) {
      for (var n, o = [t], r = 1; arguments.length > r;) o.push(arguments[r++]);

      if (n = e, (_t(e) || void 0 !== t) && !Wi(t)) return Oe(e) || (e = function (t, e) {
        if ("function" == typeof n && (e = n.call(this, t, e)), !Wi(e)) return e;
      }), o[1] = e, Ti.apply(null, o);
    }
  });
}

Di.prototype[Oi] || Wt(Di.prototype, Oi, Di.prototype.valueOf), si(Di, "Symbol"), re[xi] = !0;
var $i,
    Ji,
    Qi,
    tn = Lt.Object.getOwnPropertySymbols,
    en = {},
    nn = !lt(function () {
  function t() {}

  return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
}),
    on = Ie("IE_PROTO"),
    rn = Object.prototype,
    sn = nn ? Object.getPrototypeOf : function (t) {
  return t = Se(t), Ot(t, on) ? t[on] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? rn : null;
},
    an = (Ue("iterator"), !1);
[].keys && ("next" in (Qi = [].keys()) ? (Ji = sn(sn(Qi))) !== Object.prototype && ($i = Ji) : an = !0), null == $i && ($i = {});

var hn = {
  IteratorPrototype: $i,
  BUGGY_SAFARI_ITERATORS: an
},
    ln = hn.IteratorPrototype,
    dn = function () {
  return this;
},
    un = (Object.setPrototypeOf || "__proto__" in {} && function () {
  var t,
      e = !1,
      i = {};

  try {
    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i, []), e = i instanceof Array;
  } catch (t) {}
}(), hn.IteratorPrototype),
    cn = hn.BUGGY_SAFARI_ITERATORS,
    fn = Ue("iterator"),
    pn = function () {
  return this;
},
    vn = function (t, e, i, n, o, r, s) {
  !function (t, e, i) {
    var n = e + " Iterator";
    t.prototype = ze(ln, {
      next: pt(1, i)
    }), si(t, n, !1, !0), en[n] = dn;
  }(i, e, n);

  var a,
      h,
      l,
      d = function (t) {
    if (t === o && v) return v;
    if (!cn && t in f) return f[t];

    switch (t) {
      case "keys":
      case "values":
      case "entries":
        return function () {
          return new i(this, t);
        };
    }

    return function () {
      return new i(this);
    };
  },
      u = e + " Iterator",
      c = !1,
      f = t.prototype,
      p = f[fn] || f["@@iterator"] || o && f[o],
      v = !cn && p || d(o),
      y = "Array" == e && f.entries || p;

  if (y && (a = sn(y.call(new t())), un !== Object.prototype && a.next && (si(a, u, !0, !0), en[u] = pn)), "values" == o && p && "values" !== p.name && (c = !0, v = function () {
    return p.call(this);
  }), s && f[fn] !== v && Wt(f, fn, v), en[e] = v, o) if (h = {
    values: d("values"),
    keys: r ? v : d("keys"),
    entries: d("entries")
  }, s) for (l in h) !cn && !c && l in f || He(f, l, h[l]);else Gt({
    target: e,
    proto: !0,
    forced: cn || c
  }, h);
  return h;
},
    yn = yi.set,
    gn = yi.getterFor("Array Iterator");

vn(Array, "Array", function (t, e) {
  yn(this, {
    type: "Array Iterator",
    target: wt(t),
    index: 0,
    kind: e
  });
}, function () {
  var t = gn(this),
      e = t.target,
      i = t.kind,
      n = t.index++;
  return !e || n >= e.length ? (t.target = void 0, {
    value: void 0,
    done: !0
  }) : "keys" == i ? {
    value: n,
    done: !1
  } : "values" == i ? {
    value: e[n],
    done: !1
  } : {
    value: [n, e[n]],
    done: !1
  };
}, "values");
en.Arguments = en.Array;
var mn = Ue("toStringTag");

for (var bn in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var wn = ht[bn],
      _n = wn && wn.prototype;

  _n && !_n[mn] && Wt(_n, mn, bn), en[bn] = en.Array;
}

var kn = function (t) {
  return function (e, i) {
    var n,
        o,
        r = String(bt(e)),
        s = $t(i),
        a = r.length;
    return s < 0 || s >= a ? t ? "" : void 0 : (n = r.charCodeAt(s)) < 55296 || n > 56319 || s + 1 === a || (o = r.charCodeAt(s + 1)) < 56320 || o > 57343 ? t ? r.charAt(s) : n : t ? r.slice(s, s + 2) : o - 56320 + (n - 55296 << 10) + 65536;
  };
},
    xn = {
  codeAt: kn(!1),
  charAt: kn(!0)
}.charAt,
    On = yi.set,
    Sn = yi.getterFor("String Iterator");

vn(String, "String", function (t) {
  On(this, {
    type: "String Iterator",
    string: String(t),
    index: 0
  });
}, function () {
  var t,
      e = Sn(this),
      i = e.string,
      n = e.index;
  return n >= i.length ? {
    value: void 0,
    done: !0
  } : (t = xn(i, n), e.index += t.length, {
    value: t,
    done: !1
  });
});

var Mn = Ue("iterator"),
    En = function (t) {
  if (null != t) return t[Mn] || t["@@iterator"] || en[$e(t)];
},
    Dn = function (t) {
  var e = En(t);
  if ("function" != typeof e) throw TypeError(String(t) + " is not iterable");
  return Bt(e.call(t));
};

Gt({
  target: "Object",
  stat: !0,
  sham: !dt
}, {
  create: ze
});

var Tn = Lt.Object,
    Cn = function (t, e) {
  return Tn.create(t, e);
},
    Pn = qt;

var An = function (t, e, i) {
  return e in t ? Pn(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
},
    In = lt(function () {
  le(1);
});

Gt({
  target: "Object",
  stat: !0,
  forced: In
}, {
  keys: function (t) {
    return le(Se(t));
  }
});

var Fn,
    Nn = Lt.Object.keys,
    jn = "\t\n\v\f\r \u2028\u2029\ufeff",
    zn = "[" + jn + "]",
    Ln = RegExp("^" + zn + zn + "*"),
    Rn = RegExp(zn + zn + "*$"),
    Bn = function (t) {
  return function (e) {
    var i = String(bt(e));
    return 1 & t && (i = i.replace(Ln, "")), 2 & t && (i = i.replace(Rn, "")), i;
  };
},
    Yn = {
  start: Bn(1),
  end: Bn(2),
  trim: Bn(3)
},
    Hn = Yn.trim;

Gt({
  target: "String",
  proto: !0,
  forced: (Fn = "trim", lt(function () {
    return !!jn[Fn]() || "" != ""[Fn]() || jn[Fn].name !== Fn;
  }))
}, {
  trim: function () {
    return Hn(this);
  }
});

var Wn = function (t) {
  return Lt[t + "Prototype"];
},
    Vn = Wn("String").trim,
    Un = String.prototype,
    Gn = function (t) {
  var e = t.trim;
  return "string" == typeof t || t === Un || t instanceof String && e === Un.trim ? Vn : e;
},
    qn = function (t, e) {
  var i = [][t];
  return !i || !lt(function () {
    i.call(null, e || function () {
      throw 1;
    }, 1);
  });
},
    Xn = _i.forEach,
    Zn = qn("forEach") ? function (t) {
  return Xn(this, t, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;

Gt({
  target: "Array",
  proto: !0,
  forced: [].forEach != Zn
}, {
  forEach: Zn
});

var Kn,
    $n,
    Jn = Wn("Array").forEach,
    Qn = Array.prototype,
    to = {
  DOMTokenList: !0,
  NodeList: !0
},
    eo = function (t) {
  var e = t.forEach;
  return t === Qn || t instanceof Array && e === Qn.forEach || to.hasOwnProperty($e(t)) ? Jn : e;
},
    io = fe("navigator", "userAgent") || "",
    no = ht.process,
    oo = no && no.versions,
    ro = oo && oo.v8;

ro ? $n = (Kn = ro.split("."))[0] + Kn[1] : io && (!(Kn = io.match(/Edge\/(\d+)/)) || Kn[1] >= 74) && (Kn = io.match(/Chrome\/(\d+)/)) && ($n = Kn[1]);

var so = $n && +$n,
    ao = Ue("species"),
    ho = function (t) {
  return so >= 51 || !lt(function () {
    var e = [];
    return (e.constructor = {})[ao] = function () {
      return {
        foo: 1
      };
    }, 1 !== e[t](Boolean).foo;
  });
},
    lo = _i.map;

Gt({
  target: "Array",
  proto: !0,
  forced: !ho("map")
}, {
  map: function (t) {
    return lo(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var uo = Wn("Array").map,
    co = Array.prototype,
    fo = function (t) {
  var e = t.map;
  return t === co || t instanceof Array && e === co.map ? uo : e;
},
    po = Yn.trim,
    vo = ht.parseInt,
    yo = /^[+-]?0[Xx]/,
    go = 8 !== vo(jn + "08") || 22 !== vo(jn + "0x16") ? function (t, e) {
  var i = po(String(t));
  return vo(i, e >>> 0 || (yo.test(i) ? 16 : 10));
} : vo;

Gt({
  global: !0,
  forced: parseInt != go
}, {
  parseInt: go
});

var mo = Lt.parseInt,
    bo = ft.f,
    wo = function (t) {
  return function (e) {
    for (var i, n = wt(e), o = le(n), r = o.length, s = 0, a = []; r > s;) i = o[s++], dt && !bo.call(n, i) || a.push(t ? [i, n[i]] : n[i]);

    return a;
  };
},
    _o = {
  entries: wo(!0),
  values: wo(!1)
}.values;

Gt({
  target: "Object",
  stat: !0
}, {
  values: function (t) {
    return _o(t);
  }
});
var ko = Lt.Object.values,
    xo = _i.filter;
Gt({
  target: "Array",
  proto: !0,
  forced: !ho("filter")
}, {
  filter: function (t) {
    return xo(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Oo = Wn("Array").filter,
    So = Array.prototype,
    Mo = function (t) {
  var e = t.filter;
  return t === So || t instanceof Array && e === So.filter ? Oo : e;
},
    Eo = Ue("isConcatSpreadable"),
    Do = so >= 51 || !lt(function () {
  var t = [];
  return t[Eo] = !1, t.concat()[0] !== t;
}),
    To = ho("concat"),
    Co = function (t) {
  if (!_t(t)) return !1;
  var e = t[Eo];
  return void 0 !== e ? !!e : Oe(t);
};

Gt({
  target: "Array",
  proto: !0,
  forced: !Do || !To
}, {
  concat: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = Se(this),
        a = mi(s, 0),
        h = 0;

    for (e = -1, n = arguments.length; e < n; e++) if (r = -1 === e ? s : arguments[e], Co(r)) {
      if (h + (o = Qt(r.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");

      for (i = 0; i < o; i++, h++) i in r && me(a, h, r[i]);
    } else {
      if (h >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
      me(a, h++, r);
    }

    return a.length = h, a;
  }
});

var Po = Wn("Array").concat,
    Ao = Array.prototype,
    Io = function (t) {
  var e = t.concat;
  return t === Ao || t instanceof Array && e === Ao.concat ? Po : e;
};

Gt({
  target: "Array",
  stat: !0
}, {
  isArray: Oe
});
var Fo = Lt.Array.isArray,
    No = Fo;

var jo = function (t) {
  if (No(t)) {
    for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];

    return i;
  }
},
    zo = function (t, e, i, n) {
  try {
    return n ? e(Bt(i)[0], i[1]) : e(i);
  } catch (e) {
    var o = t.return;
    throw void 0 !== o && Bt(o.call(t)), e;
  }
},
    Lo = Ue("iterator"),
    Ro = Array.prototype,
    Bo = function (t) {
  return void 0 !== t && (en.Array === t || Ro[Lo] === t);
},
    Yo = Ue("iterator"),
    Ho = !1;

try {
  var Wo = 0,
      Vo = {
    next: function () {
      return {
        done: !!Wo++
      };
    },
    return: function () {
      Ho = !0;
    }
  };
  Vo[Yo] = function () {
    return this;
  }, Array.from(Vo, function () {
    throw 2;
  });
} catch (t) {}

var Uo = !function (t, e) {
  if (!e && !Ho) return !1;
  var i = !1;

  try {
    var n = {};
    n[Yo] = function () {
      return {
        next: function () {
          return {
            done: i = !0
          };
        }
      };
    }, t(n);
  } catch (t) {}

  return i;
}(function (t) {
  Array.from(t);
});
Gt({
  target: "Array",
  stat: !0,
  forced: Uo
}, {
  from: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = Se(t),
        a = "function" == typeof this ? this : Array,
        h = arguments.length,
        l = h > 1 ? arguments[1] : void 0,
        d = void 0 !== l,
        u = 0,
        c = En(s);
    if (d && (l = Rt(l, h > 2 ? arguments[2] : void 0, 2)), null == c || a == Array && Bo(c)) for (i = new a(e = Qt(s.length)); e > u; u++) me(i, u, d ? l(s[u], u) : s[u]);else for (r = (o = c.call(s)).next, i = new a(); !(n = r.call(o)).done; u++) me(i, u, d ? zo(o, l, [n.value, u], !0) : n.value);
    return i.length = u, i;
  }
});

var Go = Lt.Array.from,
    qo = Ue("iterator"),
    Xo = function (t) {
  var e = Object(t);
  return void 0 !== e[qo] || "@@iterator" in e || en.hasOwnProperty($e(e));
};

var Zo = function (t) {
  if (Xo(Object(t)) || "[object Arguments]" === Object.prototype.toString.call(t)) return Go(t);
};

var Ko = function () {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
};

var $o = function (t) {
  return jo(t) || Zo(t) || Ko();
},
    Jo = Ue("species"),
    Qo = [].slice,
    tr = Math.max;

Gt({
  target: "Array",
  proto: !0,
  forced: !ho("slice")
}, {
  slice: function (t, e) {
    var i,
        n,
        o,
        r = wt(this),
        s = Qt(r.length),
        a = ie(t, s),
        h = ie(void 0 === e ? s : e, s);
    if (Oe(r) && ("function" != typeof (i = r.constructor) || i !== Array && !Oe(i.prototype) ? _t(i) && null === (i = i[Jo]) && (i = void 0) : i = void 0, i === Array || void 0 === i)) return Qo.call(r, a, h);

    for (n = new (void 0 === i ? Array : i)(tr(h - a, 0)), o = 0; a < h; a++, o++) a in r && me(n, o, r[a]);

    return n.length = o, n;
  }
});

var er = Wn("Array").slice,
    ir = Array.prototype,
    nr = function (t) {
  var e = t.slice;
  return t === ir || t instanceof Array && e === ir.slice ? er : e;
},
    or = lt(function () {
  sn(1);
});

Gt({
  target: "Object",
  stat: !0,
  forced: or,
  sham: !nn
}, {
  getPrototypeOf: function (t) {
    return sn(Se(t));
  }
});
var rr = Lt.Object.getPrototypeOf,
    sr = oe.indexOf,
    ar = [].indexOf,
    hr = !!ar && 1 / [1].indexOf(1, -0) < 0,
    lr = qn("indexOf");
Gt({
  target: "Array",
  proto: !0,
  forced: hr || lr
}, {
  indexOf: function (t) {
    return hr ? ar.apply(this, arguments) || 0 : sr(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var dr = Wn("Array").indexOf,
    ur = Array.prototype,
    cr = function (t) {
  var e = t.indexOf;
  return t === ur || t instanceof Array && e === ur.indexOf ? dr : e;
},
    fr = Fo,
    pr = Object.assign,
    vr = !pr || lt(function () {
  var t = {},
      e = {},
      i = Symbol();
  return t[i] = 7, "abcdefghijklmnopqrst".split("").forEach(function (t) {
    e[t] = t;
  }), 7 != pr({}, t)[i] || "abcdefghijklmnopqrst" != le(pr({}, e)).join("");
}) ? function (t, e) {
  for (var i = Se(t), n = arguments.length, o = 1, r = ye.f, s = ft.f; n > o;) for (var a, h = mt(arguments[o++]), l = r ? le(h).concat(r(h)) : le(h), d = l.length, u = 0; d > u;) a = l[u++], dt && !s.call(h, a) || (i[a] = h[a]);

  return i;
} : pr;

Gt({
  target: "Object",
  stat: !0,
  forced: Object.assign !== vr
}, {
  assign: vr
});
var yr = Lt.Object.assign;
Xe("iterator");
var gr = Ge.f("iterator");
Xe("asyncIterator"), Xe("hasInstance"), Xe("isConcatSpreadable"), Xe("match"), Xe("matchAll"), Xe("replace"), Xe("search"), Xe("species"), Xe("split"), Xe("toPrimitive"), Xe("toStringTag"), Xe("unscopables"), si(Math, "Math", !0), si(ht.JSON, "JSON", !0);
var mr = Lt.Symbol;
Xe("asyncDispose"), Xe("dispose"), Xe("observable"), Xe("patternMatch"), Xe("replaceAll");

for (var br = mr, wr = st(function (t) {
  function e(t) {
    return (e = "function" == typeof br && "symbol" == typeof gr ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof br && t.constructor === br && t !== br.prototype ? "symbol" : typeof t;
    })(t);
  }

  function i(n) {
    return "function" == typeof br && "symbol" === e(gr) ? t.exports = i = function (t) {
      return e(t);
    } : t.exports = i = function (t) {
      return t && "function" == typeof br && t.constructor === br && t !== br.prototype ? "symbol" : e(t);
    }, i(n);
  }

  t.exports = i;
}), _r = [], kr = 0; kr < 256; kr++) _r[kr] = (kr + 256).toString(16).substr(1);

for (var xr = function () {
  if ("undefined" != typeof crypto && crypto.getRandomValues) {
    var t = new Uint8Array(16);
    return function () {
      return crypto.getRandomValues(t), t;
    };
  }

  var e = new Array(16);
  return function () {
    for (var t, i = 0; i < 16; i++) 0 == (3 & i) && (t = 4294967296 * Math.random()), e[i] = t >>> ((3 & i) << 3) & 255;

    return e;
  };
}(), Or = [], Sr = 0; Sr < 256; Sr++) Or[Sr] = (Sr + 256).toString(16).substr(1);

var Mr = xr();
Mr[0], Mr[1], Mr[2], Mr[3], Mr[4], Mr[5], Mr[6], Mr[7];

function Er() {
  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      e = arguments.length > 1 ? arguments[1] : void 0,
      i = arguments.length > 2 ? arguments[2] : void 0,
      n = e && i || 0;
  "string" == typeof t && (e = "binary" === t ? new Array(16) : void 0, t = {});
  var o = t.random || (t.rng || xr)();
  if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) for (var r = 0; r < 16; r++) e[n + r] = o[r];
  return e || function (t, e) {
    var i = e || 0,
        n = _r;
    return n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]];
  }(o);
}

function Dr(t, e) {
  var i = Nn(t);

  if (tn) {
    var n = tn(t);
    e && (n = Mo(n).call(n, function (e) {
      return ke(t, e).enumerable;
    })), i.push.apply(i, n);
  }

  return i;
}

var Tr = /^\/?Date\((-?\d+)/i,
    Cr = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    Pr = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    Ar = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i,
    Ir = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;

function Fr(t) {
  return t instanceof Number || "number" == typeof t;
}

function Nr(t) {
  if (t) for (; !0 === t.hasChildNodes();) {
    var e = t.firstChild;
    e && (Nr(e), t.removeChild(e));
  }
}

function jr(t) {
  return t instanceof String || "string" == typeof t;
}

function zr(t) {
  return "object" === wr(t) && null !== t;
}

function Lr(t) {
  if (t instanceof Date) return !0;

  if (jr(t)) {
    if (Tr.exec(t)) return !0;
    if (!isNaN(Date.parse(t))) return !0;
  }

  return !1;
}

function Rr(t, e, i, n) {
  var o = !1;
  !0 === n && (o = null === e[i] && void 0 !== t[i]), o ? delete t[i] : t[i] = e[i];
}

function Br(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];

  for (var n in t) if (void 0 !== e[n]) if (null === e[n] || "object" !== wr(e[n])) Rr(t, e, n, i);else {
    var o = t[n],
        r = e[n];
    zr(o) && zr(r) && Br(o, r, i);
  }
}

var Yr = yr;

function Hr(t, e) {
  if (!fr(t)) throw new Error("Array with property names expected as first argument");

  for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++) n[o - 2] = arguments[o];

  for (var r = 0, s = n; r < s.length; r++) for (var a = s[r], h = 0; h < t.length; h++) {
    var l = t[h];
    a && Object.prototype.hasOwnProperty.call(a, l) && (e[l] = a[l]);
  }

  return e;
}

function Wr(t, e, i) {
  var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  if (fr(i)) throw new TypeError("Arrays are not supported by deepExtend");

  for (var o = 0; o < t.length; o++) {
    var r = t[o];
    if (Object.prototype.hasOwnProperty.call(i, r)) if (i[r] && i[r].constructor === Object) void 0 === e[r] && (e[r] = {}), e[r].constructor === Object ? Ur(e[r], i[r], !1, n) : Rr(e, i, r, n);else {
      if (fr(i[r])) throw new TypeError("Arrays are not supported by deepExtend");
      Rr(e, i, r, n);
    }
  }

  return e;
}

function Vr(t, e, i) {
  var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  if (fr(i)) throw new TypeError("Arrays are not supported by deepExtend");

  for (var o in i) if (Object.prototype.hasOwnProperty.call(i, o) && -1 === cr(t).call(t, o)) if (i[o] && i[o].constructor === Object) void 0 === e[o] && (e[o] = {}), e[o].constructor === Object ? Ur(e[o], i[o]) : Rr(e, i, o, n);else if (fr(i[o])) {
    e[o] = [];

    for (var r = 0; r < i[o].length; r++) e[o].push(i[o][r]);
  } else Rr(e, i, o, n);

  return e;
}

function Ur(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
      n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];

  for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o) || !0 === i) if ("object" === wr(e[o]) && null !== e[o] && rr(e[o]) === Object.prototype) void 0 === t[o] ? t[o] = Ur({}, e[o], i) : "object" === wr(t[o]) && null !== t[o] && rr(t[o]) === Object.prototype ? Ur(t[o], e[o], i) : Rr(t, e, o, n);else if (fr(e[o])) {
    var r;
    t[o] = nr(r = e[o]).call(r);
  } else Rr(t, e, o, n);

  return t;
}

function Gr(t, e) {
  if (t.length !== e.length) return !1;

  for (var i = 0, n = t.length; i < n; i++) if (t[i] != e[i]) return !1;

  return !0;
}

function qr(t) {
  var e = wr(t);
  return "object" === e ? null === t ? "null" : t instanceof Boolean ? "Boolean" : t instanceof Number ? "Number" : t instanceof String ? "String" : fr(t) ? "Array" : t instanceof Date ? "Date" : "Object" : "number" === e ? "Number" : "boolean" === e ? "Boolean" : "string" === e ? "String" : void 0 === e ? "undefined" : e;
}

function Xr(t, e) {
  var i;
  return Io(i = []).call(i, $o(t), [e]);
}

function Zr(t) {
  return nr(t).call(t);
}

function Kr(t) {
  return t.getBoundingClientRect().left;
}

function $r(t) {
  return t.getBoundingClientRect().right;
}

function Jr(t) {
  return t.getBoundingClientRect().top;
}

function Qr(t, e) {
  var i = t.className.split(" "),
      n = e.split(" ");
  i = Io(i).call(i, Mo(n).call(n, function (t) {
    return cr(i).call(i, t) < 0;
  })), t.className = i.join(" ");
}

function ts(t, e) {
  var i = t.className.split(" "),
      n = e.split(" ");
  i = Mo(i).call(i, function (t) {
    return cr(n).call(n, t) < 0;
  }), t.className = i.join(" ");
}

function es(t, e) {
  if (fr(t)) for (var i = t.length, n = 0; n < i; n++) e(t[n], n, t);else for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && e(t[o], o, t);
}

var is = ko;

function ns(t, e, i) {
  return t[e] !== i && (t[e] = i, !0);
}

function os(t) {
  var e = !1;
  return function () {
    e || (e = !0, requestAnimationFrame(function () {
      e = !1, t();
    }));
  };
}

function rs(t, e, i, n) {
  var o;
  t.addEventListener ? (void 0 === n && (n = !1), "mousewheel" === e && cr(o = navigator.userAgent).call(o, "Firefox") >= 0 && (e = "DOMMouseScroll"), t.addEventListener(e, i, n)) : t.attachEvent("on" + e, i);
}

function ss(t, e, i, n) {
  var o;
  t.removeEventListener ? (void 0 === n && (n = !1), "mousewheel" === e && cr(o = navigator.userAgent).call(o, "Firefox") >= 0 && (e = "DOMMouseScroll"), t.removeEventListener(e, i, n)) : t.detachEvent("on" + e, i);
}

function as(t) {
  t || (t = window.event), t && (t.preventDefault ? t.preventDefault() : t.returnValue = !1);
}

function hs() {
  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.event,
      e = null;
  return t && (t.target ? e = t.target : t.srcElement && (e = t.srcElement)), e instanceof Element && (null == e.nodeType || 3 != e.nodeType || (e = e.parentNode) instanceof Element) ? e : null;
}

function ls(t, e) {
  for (var i = t; i;) {
    if (i === e) return !0;
    if (!i.parentNode) return !1;
    i = i.parentNode;
  }

  return !1;
}

var ds = {
  asBoolean: function (t, e) {
    return "function" == typeof t && (t = t()), null != t ? 0 != t : e || null;
  },
  asNumber: function (t, e) {
    return "function" == typeof t && (t = t()), null != t ? Number(t) || e || null : e || null;
  },
  asString: function (t, e) {
    return "function" == typeof t && (t = t()), null != t ? String(t) : e || null;
  },
  asSize: function (t, e) {
    return "function" == typeof t && (t = t()), jr(t) ? t : Fr(t) ? t + "px" : e || null;
  },
  asElement: function (t, e) {
    return "function" == typeof t && (t = t()), t || e || null;
  }
};

function us(t) {
  var e;

  switch (t.length) {
    case 3:
    case 4:
      return (e = Pr.exec(t)) ? {
        r: mo(e[1] + e[1], 16),
        g: mo(e[2] + e[2], 16),
        b: mo(e[3] + e[3], 16)
      } : null;

    case 6:
    case 7:
      return (e = Cr.exec(t)) ? {
        r: mo(e[1], 16),
        g: mo(e[2], 16),
        b: mo(e[3], 16)
      } : null;

    default:
      return null;
  }
}

function cs(t, e) {
  if (-1 !== cr(t).call(t, "rgba")) return t;

  if (-1 !== cr(t).call(t, "rgb")) {
    var i = t.substr(cr(t).call(t, "(") + 1).replace(")", "").split(",");
    return "rgba(" + i[0] + "," + i[1] + "," + i[2] + "," + e + ")";
  }

  var n = us(t);
  return null == n ? t : "rgba(" + n.r + "," + n.g + "," + n.b + "," + e + ")";
}

function fs(t, e, i) {
  var n;
  return "#" + nr(n = ((1 << 24) + (t << 16) + (e << 8) + i).toString(16)).call(n, 1);
}

function ps(t, e) {
  if (jr(t)) {
    var i = t;

    if (xs(i)) {
      var n,
          o = fo(n = i.substr(4).substr(0, i.length - 5).split(",")).call(n, function (t) {
        return mo(t);
      });
      i = fs(o[0], o[1], o[2]);
    }

    if (!0 === ks(i)) {
      var r = _s(i),
          s = {
        h: r.h,
        s: .8 * r.s,
        v: Math.min(1, 1.02 * r.v)
      },
          a = {
        h: r.h,
        s: Math.min(1, 1.25 * r.s),
        v: .8 * r.v
      },
          h = ws(a.h, a.s, a.v),
          l = ws(s.h, s.s, s.v);

      return {
        background: i,
        border: h,
        highlight: {
          background: l,
          border: h
        },
        hover: {
          background: l,
          border: h
        }
      };
    }

    return {
      background: i,
      border: i,
      highlight: {
        background: i,
        border: i
      },
      hover: {
        background: i,
        border: i
      }
    };
  }

  return e ? {
    background: t.background || e.background,
    border: t.border || e.border,
    highlight: jr(t.highlight) ? {
      border: t.highlight,
      background: t.highlight
    } : {
      background: t.highlight && t.highlight.background || e.highlight.background,
      border: t.highlight && t.highlight.border || e.highlight.border
    },
    hover: jr(t.hover) ? {
      border: t.hover,
      background: t.hover
    } : {
      border: t.hover && t.hover.border || e.hover.border,
      background: t.hover && t.hover.background || e.hover.background
    }
  } : {
    background: t.background || void 0,
    border: t.border || void 0,
    highlight: jr(t.highlight) ? {
      border: t.highlight,
      background: t.highlight
    } : {
      background: t.highlight && t.highlight.background || void 0,
      border: t.highlight && t.highlight.border || void 0
    },
    hover: jr(t.hover) ? {
      border: t.hover,
      background: t.hover
    } : {
      border: t.hover && t.hover.border || void 0,
      background: t.hover && t.hover.background || void 0
    }
  };
}

function vs(t, e, i) {
  t /= 255, e /= 255, i /= 255;
  var n = Math.min(t, Math.min(e, i)),
      o = Math.max(t, Math.max(e, i));
  return n === o ? {
    h: 0,
    s: 0,
    v: n
  } : {
    h: 60 * ((t === n ? 3 : i === n ? 1 : 5) - (t === n ? e - i : i === n ? t - e : i - t) / (o - n)) / 360,
    s: (o - n) / o,
    v: o
  };
}

var ys = {
  split: function (t) {
    var e,
        i = {};
    return eo(e = t.split(";")).call(e, function (t) {
      if ("" != Gn(t).call(t)) {
        var e,
            n,
            o = t.split(":"),
            r = Gn(e = o[0]).call(e),
            s = Gn(n = o[1]).call(n);
        i[r] = s;
      }
    }), i;
  },
  join: function (t) {
    var e;
    return fo(e = Nn(t)).call(e, function (e) {
      return e + ": " + t[e];
    }).join("; ");
  }
};

function gs(t, e) {
  var i = function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var i,
          n = null != arguments[e] ? arguments[e] : {};
      if (e % 2) eo(i = Dr(n, !0)).call(i, function (e) {
        An(t, e, n[e]);
      });else if (be) ue(t, be(n));else {
        var o;
        eo(o = Dr(n)).call(o, function (e) {
          Xt(t, e, ke(n, e));
        });
      }
    }

    return t;
  }({}, ys.split(t.style.cssText), {}, ys.split(e));

  t.style.cssText = ys.join(i);
}

function ms(t, e) {
  var i = ys.split(t.style.cssText),
      n = ys.split(e);

  for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && delete i[o];

  t.style.cssText = ys.join(i);
}

function bs(t, e, i) {
  var n,
      o,
      r,
      s = Math.floor(6 * t),
      a = 6 * t - s,
      h = i * (1 - e),
      l = i * (1 - a * e),
      d = i * (1 - (1 - a) * e);

  switch (s % 6) {
    case 0:
      n = i, o = d, r = h;
      break;

    case 1:
      n = l, o = i, r = h;
      break;

    case 2:
      n = h, o = i, r = d;
      break;

    case 3:
      n = h, o = l, r = i;
      break;

    case 4:
      n = d, o = h, r = i;
      break;

    case 5:
      n = i, o = h, r = l;
  }

  return {
    r: Math.floor(255 * n),
    g: Math.floor(255 * o),
    b: Math.floor(255 * r)
  };
}

function ws(t, e, i) {
  var n = bs(t, e, i);
  return fs(n.r, n.g, n.b);
}

function _s(t) {
  var e = us(t);
  if (!e) throw new TypeError("'".concat(t, "' is not a valid color."));
  return vs(e.r, e.g, e.b);
}

function ks(t) {
  return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t);
}

function xs(t) {
  return Ar.test(t);
}

function Os(t) {
  return Ir.test(t);
}

function Ss(t, e) {
  if (null !== e && "object" === wr(e)) {
    for (var i = Cn(e), n = 0; n < t.length; n++) Object.prototype.hasOwnProperty.call(e, t[n]) && "object" == wr(e[t[n]]) && (i[t[n]] = Ms(e[t[n]]));

    return i;
  }

  return null;
}

function Ms(t) {
  if (null === t || "object" !== wr(t)) return null;
  if (t instanceof Element) return t;
  var e = Cn(t);

  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && "object" == wr(t[i]) && (e[i] = Ms(t[i]));

  return e;
}

function Es(t, e) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i],
        o = void 0;

    for (o = i; o > 0 && e(n, t[o - 1]) < 0; o--) t[o] = t[o - 1];

    t[o] = n;
  }

  return t;
}

function Ds(t, e, i) {
  var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
      o = function (t) {
    return null != t;
  },
      r = function (t) {
    return null !== t && "object" === wr(t);
  };

  if (!r(t)) throw new Error("Parameter mergeTarget must be an object");
  if (!r(e)) throw new Error("Parameter options must be an object");
  if (!o(i)) throw new Error("Parameter option must have a value");
  if (!r(n)) throw new Error("Parameter globalOptions must be an object");
  var s = e[i],
      a = r(n) && !function (t) {
    for (var e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;

    return !0;
  }(n) ? n[i] : void 0,
      h = a ? a.enabled : void 0;

  if (void 0 !== s) {
    if ("boolean" == typeof s) return r(t[i]) || (t[i] = {}), void (t[i].enabled = s);

    if (null === s && !r(t[i])) {
      if (!o(a)) return;
      t[i] = Cn(a);
    }

    if (r(s)) {
      var l = !0;
      void 0 !== s.enabled ? l = s.enabled : void 0 !== h && (l = a.enabled), function (t, e, i) {
        r(t[i]) || (t[i] = {});
        var n = e[i],
            o = t[i];

        for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (o[s] = n[s]);
      }(t, e, i), t[i].enabled = l;
    }
  }
}

function Ts(t, e, i, n) {
  for (var o = 0, r = 0, s = t.length - 1; r <= s && o < 1e4;) {
    var a = Math.floor((r + s) / 2),
        h = t[a],
        l = e(void 0 === n ? h[i] : h[i][n]);
    if (0 == l) return a;
    -1 == l ? r = a + 1 : s = a - 1, o++;
  }

  return -1;
}

function Cs(t, e, i, n, o) {
  var r,
      s,
      a,
      h,
      l = 0,
      d = 0,
      u = t.length - 1;

  for (o = null != o ? o : function (t, e) {
    return t == e ? 0 : t < e ? -1 : 1;
  }; d <= u && l < 1e4;) {
    if (h = Math.floor(.5 * (u + d)), r = t[Math.max(0, h - 1)][i], s = t[h][i], a = t[Math.min(t.length - 1, h + 1)][i], 0 == o(s, e)) return h;
    if (o(r, e) < 0 && o(s, e) > 0) return "before" == n ? Math.max(0, h - 1) : h;
    if (o(s, e) < 0 && o(a, e) > 0) return "before" == n ? h : Math.min(t.length - 1, h + 1);
    o(s, e) < 0 ? d = h + 1 : u = h - 1, l++;
  }

  return -1;
}

var Ps = {
  linear: function (t) {
    return t;
  },
  easeInQuad: function (t) {
    return t * t;
  },
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1;
  },
  easeInCubic: function (t) {
    return t * t * t;
  },
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

function As() {
  var t = document.createElement("p");
  t.style.width = "100%", t.style.height = "200px";
  var e = document.createElement("div");
  e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.visibility = "hidden", e.style.width = "200px", e.style.height = "150px", e.style.overflow = "hidden", e.appendChild(t), document.body.appendChild(e);
  var i = t.offsetWidth;
  e.style.overflow = "scroll";
  var n = t.offsetWidth;
  return i == n && (n = e.clientWidth), document.body.removeChild(e), i - n;
}

function Is(t, e) {
  var i;
  fr(e) || (e = [e]);
  var n = !0,
      o = !1,
      r = void 0;

  try {
    for (var s, a = Dn(t); !(n = (s = a.next()).done); n = !0) {
      var h = s.value;

      if (h) {
        i = h[e[0]];

        for (var l = 1; l < e.length; l++) i && (i = i[e[l]]);

        if (void 0 !== i) break;
      }
    }
  } catch (t) {
    o = !0, r = t;
  } finally {
    try {
      n || null == a.return || a.return();
    } finally {
      if (o) throw r;
    }
  }

  return i;
}

var Fs,
    Ns,
    js,
    zs = Object.freeze({
  __proto__: null,
  isNumber: Fr,
  recursiveDOMDelete: Nr,
  isString: jr,
  isObject: zr,
  isDate: Lr,
  fillIfDefined: Br,
  extend: Yr,
  selectiveExtend: Hr,
  selectiveDeepExtend: Wr,
  selectiveNotDeepExtend: Vr,
  deepExtend: Ur,
  equalArray: Gr,
  getType: qr,
  copyAndExtendArray: Xr,
  copyArray: Zr,
  getAbsoluteLeft: Kr,
  getAbsoluteRight: $r,
  getAbsoluteTop: Jr,
  addClassName: Qr,
  removeClassName: ts,
  forEach: es,
  toArray: is,
  updateProperty: ns,
  throttle: os,
  addEventListener: rs,
  removeEventListener: ss,
  preventDefault: as,
  getTarget: hs,
  hasParent: ls,
  option: ds,
  hexToRGB: us,
  overrideOpacity: cs,
  RGBToHex: fs,
  parseColor: ps,
  RGBToHSV: vs,
  addCssText: gs,
  removeCssText: ms,
  HSVToRGB: bs,
  HSVToHex: ws,
  hexToHSV: _s,
  isValidHex: ks,
  isValidRGB: xs,
  isValidRGBA: Os,
  selectiveBridgeObject: Ss,
  bridgeObject: Ms,
  insertSort: Es,
  mergeOptions: Ds,
  binarySearchCustom: Ts,
  binarySearchValue: Cs,
  easingFunctions: Ps,
  getScrollBarWidth: As,
  topMost: Is,
  randomUUID: Er
}),
    Ls = Object.freeze({
  __proto__: null,
  default: zs,
  HSVToHex: ws,
  HSVToRGB: bs,
  RGBToHSV: vs,
  RGBToHex: fs,
  addClassName: Qr,
  addCssText: gs,
  addEventListener: rs,
  binarySearchCustom: Ts,
  binarySearchValue: Cs,
  bridgeObject: Ms,
  copyAndExtendArray: Xr,
  copyArray: Zr,
  deepExtend: Ur,
  easingFunctions: Ps,
  equalArray: Gr,
  extend: Yr,
  fillIfDefined: Br,
  forEach: es,
  getAbsoluteLeft: Kr,
  getAbsoluteRight: $r,
  getAbsoluteTop: Jr,
  getScrollBarWidth: As,
  getTarget: hs,
  getType: qr,
  hasParent: ls,
  hexToHSV: _s,
  hexToRGB: us,
  insertSort: Es,
  isDate: Lr,
  isNumber: Fr,
  isObject: zr,
  isString: jr,
  isValidHex: ks,
  isValidRGB: xs,
  isValidRGBA: Os,
  mergeOptions: Ds,
  option: ds,
  overrideOpacity: cs,
  parseColor: ps,
  preventDefault: as,
  randomUUID: Er,
  recursiveDOMDelete: Nr,
  removeClassName: ts,
  removeCssText: ms,
  removeEventListener: ss,
  selectiveBridgeObject: Ss,
  selectiveDeepExtend: Wr,
  selectiveExtend: Hr,
  selectiveNotDeepExtend: Vr,
  throttle: os,
  toArray: is,
  topMost: Is,
  updateProperty: ns
}),
    Rs = {},
    Bs = o["__core-js_shared__"] || function (t, e) {
  try {
    B(o, t, e);
  } catch (i) {
    o[t] = e;
  }

  return e;
}("__core-js_shared__", {}),
    Ys = i(function (t) {
  (t.exports = function (t, e) {
    return Bs[t] || (Bs[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.4.1",
    mode: "pure",
    copyright: " 2019 Denis Pushkarev (zloirock.ru)"
  });
}),
    Hs = Ys("native-function-to-string", Function.toString),
    Ws = o.WeakMap,
    Vs = "function" == typeof Ws && /native code/.test(Hs.call(Ws)),
    Us = 0,
    Gs = Math.random(),
    qs = function (t) {
  return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++Us + Gs).toString(36);
},
    Xs = Ys("keys"),
    Zs = function (t) {
  return Xs[t] || (Xs[t] = qs(t));
},
    Ks = {},
    $s = o.WeakMap;

exports.util = Ls;

if (Vs) {
  var Js = new $s(),
      Qs = Js.get,
      ta = Js.has,
      ea = Js.set;
  Fs = function (t, e) {
    return ea.call(Js, t, e), e;
  }, Ns = function (t) {
    return Qs.call(Js, t) || {};
  }, js = function (t) {
    return ta.call(Js, t);
  };
} else {
  var ia = Zs("state");
  Ks[ia] = !0, Fs = function (t, e) {
    return B(t, ia, e), e;
  }, Ns = function (t) {
    return w(t, ia) ? t[ia] : {};
  }, js = function (t) {
    return w(t, ia);
  };
}

var na,
    oa,
    ra,
    sa = {
  set: Fs,
  get: Ns,
  has: js,
  enforce: function (t) {
    return js(t) ? Ns(t) : Fs(t, {});
  },
  getterFor: function (t) {
    return function (e) {
      var i;
      if (!g(e) || (i = Ns(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
      return i;
    };
  }
},
    aa = function (t) {
  return Object(v(t));
},
    ha = !r(function () {
  function t() {}

  return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
}),
    la = Zs("IE_PROTO"),
    da = Object.prototype,
    ua = ha ? Object.getPrototypeOf : function (t) {
  return t = aa(t), w(t, la) ? t[la] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? da : null;
},
    ca = !!Object.getOwnPropertySymbols && !r(function () {
  return !String(Symbol());
}),
    fa = o.Symbol,
    pa = Ys("wks"),
    va = function (t) {
  return pa[t] || (pa[t] = ca && fa[t] || (ca ? fa : qs)("Symbol." + t));
},
    ya = (va("iterator"), !1);

[].keys && ("next" in (ra = [].keys()) ? (oa = ua(ua(ra))) !== Object.prototype && (na = oa) : ya = !0), null == na && (na = {});

var ga = {
  IteratorPrototype: na,
  BUGGY_SAFARI_ITERATORS: ya
},
    ma = Math.ceil,
    ba = Math.floor,
    wa = function (t) {
  return isNaN(t = +t) ? 0 : (t > 0 ? ba : ma)(t);
},
    _a = Math.min,
    ka = function (t) {
  return t > 0 ? _a(wa(t), 9007199254740991) : 0;
},
    xa = Math.max,
    Oa = Math.min,
    Sa = function (t, e) {
  var i = wa(t);
  return i < 0 ? xa(i + e, 0) : Oa(i, e);
},
    Ma = function (t) {
  return function (e, i, n) {
    var o,
        r = y(e),
        s = ka(r.length),
        a = Sa(n, s);

    if (t && i != i) {
      for (; s > a;) if ((o = r[a++]) != o) return !0;
    } else for (; s > a; a++) if ((t || a in r) && r[a] === i) return t || a || 0;

    return !t && -1;
  };
},
    Ea = {
  includes: Ma(!0),
  indexOf: Ma(!1)
},
    Da = Ea.indexOf,
    Ta = function (t, e) {
  var i,
      n = y(t),
      o = 0,
      r = [];

  for (i in n) !w(Ks, i) && w(n, i) && r.push(i);

  for (; e.length > o;) w(n, i = e[o++]) && (~Da(r, i) || r.push(i));

  return r;
},
    Ca = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    Pa = Object.keys || function (t) {
  return Ta(t, Ca);
},
    Aa = s ? Object.defineProperties : function (t, e) {
  z(t);

  for (var i, n = Pa(e), o = n.length, r = 0; o > r;) R.f(t, i = n[r++], e[i]);

  return t;
},
    Ia = function (t) {
  return "function" == typeof t ? t : void 0;
},
    Fa = function (t, e) {
  return arguments.length < 2 ? Ia(F[t]) || Ia(o[t]) : F[t] && F[t][e] || o[t] && o[t][e];
},
    Na = Fa("document", "documentElement"),
    ja = Zs("IE_PROTO"),
    za = function () {},
    La = function () {
  var t,
      e = x("iframe"),
      i = Ca.length;

  for (e.style.display = "none", Na.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), La = t.F; i--;) delete La.prototype[Ca[i]];

  return La();
},
    Ra = Object.create || function (t, e) {
  var i;
  return null !== t ? (za.prototype = z(t), i = new za(), za.prototype = null, i[ja] = t) : i = La(), void 0 === e ? i : Aa(i, e);
};

Ks[ja] = !0;

var Ba = va("toStringTag"),
    Ya = "Arguments" == c(function () {
  return arguments;
}()),
    Ha = function (t) {
  var e, i, n;
  return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function (t, e) {
    try {
      return t[e];
    } catch (t) {}
  }(e = Object(t), Ba)) ? i : Ya ? c(e) : "Object" == (n = c(e)) && "function" == typeof e.callee ? "Arguments" : n;
},
    Wa = {};

Wa[va("toStringTag")] = "z";

var Va = "[object z]" !== String(Wa) ? function () {
  return "[object " + Ha(this) + "]";
} : Wa.toString,
    Ua = R.f,
    Ga = va("toStringTag"),
    qa = Va !== {}.toString,
    Xa = function (t, e, i, n) {
  if (t) {
    var o = i ? t : t.prototype;
    w(o, Ga) || Ua(o, Ga, {
      configurable: !0,
      value: e
    }), n && qa && B(o, "toString", Va);
  }
},
    Za = ga.IteratorPrototype,
    Ka = function () {
  return this;
},
    $a = Object.setPrototypeOf || ("__proto__" in {} ? function () {
  var t,
      e = !1,
      i = {};

  try {
    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i, []), e = i instanceof Array;
  } catch (t) {}

  return function (i, n) {
    return z(i), function (t) {
      if (!g(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
    }(n), e ? t.call(i, n) : i.__proto__ = n, i;
  };
}() : void 0),
    Ja = function (t, e, i, n) {
  n && n.enumerable ? t[e] = i : B(t, e, i);
},
    Qa = ga.IteratorPrototype,
    th = ga.BUGGY_SAFARI_ITERATORS,
    eh = va("iterator"),
    ih = function () {
  return this;
},
    nh = function (t, e, i, n, o, r, s) {
  !function (t, e, i) {
    var n = e + " Iterator";
    t.prototype = Ra(Za, {
      next: d(1, i)
    }), Xa(t, n, !1, !0), Rs[n] = Ka;
  }(i, e, n);

  var a,
      h,
      l,
      u = function (t) {
    if (t === o && y) return y;
    if (!th && t in p) return p[t];

    switch (t) {
      case "keys":
      case "values":
      case "entries":
        return function () {
          return new i(this, t);
        };
    }

    return function () {
      return new i(this);
    };
  },
      c = e + " Iterator",
      f = !1,
      p = t.prototype,
      v = p[eh] || p["@@iterator"] || o && p[o],
      y = !th && v || u(o),
      g = "Array" == e && p.entries || v;

  if (g && (a = ua(g.call(new t())), Qa !== Object.prototype && a.next && (Xa(a, c, !0, !0), Rs[c] = ih)), "values" == o && v && "values" !== v.name && (f = !0, y = function () {
    return v.call(this);
  }), s && p[eh] !== y && B(p, eh, y), Rs[e] = y, o) if (h = {
    values: u("values"),
    keys: r ? y : u("keys"),
    entries: u("entries")
  }, s) for (l in h) !th && !f && l in p || Ja(p, l, h[l]);else W({
    target: e,
    proto: !0,
    forced: th || f
  }, h);
  return h;
},
    oh = sa.set,
    rh = sa.getterFor("Array Iterator");

nh(Array, "Array", function (t, e) {
  oh(this, {
    type: "Array Iterator",
    target: y(t),
    index: 0,
    kind: e
  });
}, function () {
  var t = rh(this),
      e = t.target,
      i = t.kind,
      n = t.index++;
  return !e || n >= e.length ? (t.target = void 0, {
    value: void 0,
    done: !0
  }) : "keys" == i ? {
    value: n,
    done: !1
  } : "values" == i ? {
    value: e[n],
    done: !1
  } : {
    value: [n, e[n]],
    done: !1
  };
}, "values");
Rs.Arguments = Rs.Array;
var sh = va("toStringTag");

for (var ah in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var hh = o[ah],
      lh = hh && hh.prototype;
  lh && !lh[sh] && B(lh, sh, ah), Rs[ah] = Rs.Array;
}

var dh = Array.isArray || function (t) {
  return "Array" == c(t);
},
    uh = va("species"),
    ch = function (t, e) {
  var i;
  return dh(t) && ("function" != typeof (i = t.constructor) || i !== Array && !dh(i.prototype) ? g(i) && null === (i = i[uh]) && (i = void 0) : i = void 0), new (void 0 === i ? Array : i)(0 === e ? 0 : e);
},
    fh = [].push,
    ph = function (t) {
  var e = 1 == t,
      i = 2 == t,
      n = 3 == t,
      o = 4 == t,
      r = 6 == t,
      s = 5 == t || r;
  return function (a, h, l, d) {
    for (var u, c, f = aa(a), v = p(f), y = j(h, l, 3), g = ka(v.length), m = 0, b = d || ch, w = e ? b(a, g) : i ? b(a, 0) : void 0; g > m; m++) if ((s || m in v) && (c = y(u = v[m], m, f), t)) if (e) w[m] = c;else if (c) switch (t) {
      case 3:
        return !0;

      case 5:
        return u;

      case 6:
        return m;

      case 2:
        fh.call(w, u);
    } else if (o) return !1;

    return r ? -1 : n || o ? o : w;
  };
},
    vh = {
  forEach: ph(0),
  map: ph(1),
  filter: ph(2),
  some: ph(3),
  every: ph(4),
  find: ph(5),
  findIndex: ph(6)
},
    yh = function (t, e) {
  var i = [][t];
  return !i || !r(function () {
    i.call(null, e || function () {
      throw 1;
    }, 1);
  });
},
    gh = vh.forEach,
    mh = yh("forEach") ? function (t) {
  return gh(this, t, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;

W({
  target: "Array",
  proto: !0,
  forced: [].forEach != mh
}, {
  forEach: mh
});

var bh = X("Array").forEach,
    wh = Array.prototype,
    _h = {
  DOMTokenList: !0,
  NodeList: !0
},
    kh = function (t) {
  var e = t.forEach;
  return t === wh || t instanceof Array && e === wh.forEach || _h.hasOwnProperty(Ha(t)) ? bh : e;
};

W({
  target: "Array",
  stat: !0
}, {
  isArray: dh
});

var xh,
    Oh,
    Sh = F.Array.isArray,
    Mh = Sh,
    Eh = function (t, e, i) {
  var n = m(e);
  n in t ? R.f(t, n, d(0, i)) : t[n] = i;
},
    Dh = Fa("navigator", "userAgent") || "",
    Th = o.process,
    Ch = Th && Th.versions,
    Ph = Ch && Ch.v8;

Ph ? Oh = (xh = Ph.split("."))[0] + xh[1] : Dh && (!(xh = Dh.match(/Edge\/(\d+)/)) || xh[1] >= 74) && (xh = Dh.match(/Chrome\/(\d+)/)) && (Oh = xh[1]);

var Ah = Oh && +Oh,
    Ih = va("species"),
    Fh = function (t) {
  return Ah >= 51 || !r(function () {
    var e = [];
    return (e.constructor = {})[Ih] = function () {
      return {
        foo: 1
      };
    }, 1 !== e[t](Boolean).foo;
  });
},
    Nh = Math.max,
    jh = Math.min;

W({
  target: "Array",
  proto: !0,
  forced: !Fh("splice")
}, {
  splice: function (t, e) {
    var i,
        n,
        o,
        r,
        s,
        a,
        h = aa(this),
        l = ka(h.length),
        d = Sa(t, l),
        u = arguments.length;
    if (0 === u ? i = n = 0 : 1 === u ? (i = 0, n = l - d) : (i = u - 2, n = jh(Nh(wa(e), 0), l - d)), l + i - n > 9007199254740991) throw TypeError("Maximum allowed length exceeded");

    for (o = ch(h, n), r = 0; r < n; r++) (s = d + r) in h && Eh(o, r, h[s]);

    if (o.length = n, i < n) {
      for (r = d; r < l - n; r++) a = r + i, (s = r + n) in h ? h[a] = h[s] : delete h[a];

      for (r = l; r > l - n + i; r--) delete h[r - 1];
    } else if (i > n) for (r = l - n; r > d; r--) a = r + i - 1, (s = r + n - 1) in h ? h[a] = h[s] : delete h[a];

    for (r = 0; r < i; r++) h[r + d] = arguments[r + 2];

    return h.length = l - n + i, o;
  }
});

var zh = X("Array").splice,
    Lh = Array.prototype,
    Rh = function (t) {
  var e = t.splice;
  return t === Lh || t instanceof Array && e === Lh.splice ? zh : e;
},
    Bh = Ea.includes;

W({
  target: "Array",
  proto: !0
}, {
  includes: function (t) {
    return Bh(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Yh = X("Array").includes,
    Hh = va("match"),
    Wh = function (t) {
  if (function (t) {
    var e;
    return g(t) && (void 0 !== (e = t[Hh]) ? !!e : "RegExp" == c(t));
  }(t)) throw TypeError("The method doesn't accept regular expressions");
  return t;
},
    Vh = va("match");

W({
  target: "String",
  proto: !0,
  forced: !function (t) {
    var e = /./;

    try {
      "/./"[t](e);
    } catch (i) {
      try {
        return e[Vh] = !1, "/./"[t](e);
      } catch (t) {}
    }

    return !1;
  }("includes")
}, {
  includes: function (t) {
    return !!~String(v(this)).indexOf(Wh(t), arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Uh = X("String").includes,
    Gh = Array.prototype,
    qh = String.prototype,
    Xh = function (t) {
  var e = t.includes;
  return t === Gh || t instanceof Array && e === Gh.includes ? Yh : "string" == typeof t || t === qh || t instanceof String && e === qh.includes ? Uh : e;
},
    Zh = Ea.indexOf,
    Kh = [].indexOf,
    $h = !!Kh && 1 / [1].indexOf(1, -0) < 0,
    Jh = yh("indexOf");

W({
  target: "Array",
  proto: !0,
  forced: $h || Jh
}, {
  indexOf: function (t) {
    return $h ? Kh.apply(this, arguments) || 0 : Zh(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Qh = X("Array").indexOf,
    tl = Array.prototype,
    el = function (t) {
  var e = t.indexOf;
  return t === tl || t instanceof Array && e === tl.indexOf ? Qh : e;
};

W({
  target: "Object",
  stat: !0,
  sham: !s
}, {
  create: Ra
});

var il = F.Object,
    nl = function (t, e) {
  return il.create(t, e);
},
    ol = nl;

function rl(t) {
  return dl = t, function () {
    var t = {};
    ul = 0, void (cl = dl.charAt(0)), Ol(), "strict" === fl && (t.strict = !0, Ol());
    "graph" !== fl && "digraph" !== fl || (t.type = fl, Ol());
    pl === hl.IDENTIFIER && (t.id = fl, Ol());
    if ("{" != fl) throw Cl("Angle bracket { expected");
    if (Ol(), Sl(t), "}" != fl) throw Cl("Angle bracket } expected");
    if (Ol(), "" !== fl) throw Cl("End of file expected");
    return Ol(), delete t.node, delete t.edge, delete t.graph, t;
  }();
}

var sl = {
  fontsize: "font.size",
  fontcolor: "font.color",
  labelfontcolor: "font.color",
  fontname: "font.face",
  color: ["color.border", "color.background"],
  fillcolor: "color.background",
  tooltip: "title",
  labeltooltip: "title"
},
    al = ol(sl);
al.color = "color.color", al.style = "dashes";
var hl = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3
},
    ll = {
  "{": !0,
  "}": !0,
  "[": !0,
  "]": !0,
  ";": !0,
  "=": !0,
  ",": !0,
  "->": !0,
  "--": !0
},
    dl = "",
    ul = 0,
    cl = "",
    fl = "",
    pl = hl.NULL;

function vl() {
  ul++, cl = dl.charAt(ul);
}

function yl() {
  return dl.charAt(ul + 1);
}

var gl = /[a-zA-Z_0-9.:#]/;

function ml(t) {
  return gl.test(t);
}

function bl(t, e) {
  if (t || (t = {}), e) for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
  return t;
}

function wl(t, e, i) {
  for (var n = e.split("."), o = t; n.length;) {
    var r = n.shift();
    n.length ? (o[r] || (o[r] = {}), o = o[r]) : o[r] = i;
  }
}

function _l(t, e) {
  for (var i, n, o = null, r = [t], s = t; s.parent;) r.push(s.parent), s = s.parent;

  if (s.nodes) for (i = 0, n = s.nodes.length; i < n; i++) if (e.id === s.nodes[i].id) {
    o = s.nodes[i];
    break;
  }

  for (o || (o = {
    id: e.id
  }, t.node && (o.attr = bl(o.attr, t.node))), i = r.length - 1; i >= 0; i--) {
    var a,
        h = r[i];
    h.nodes || (h.nodes = []), -1 === el(a = h.nodes).call(a, o) && h.nodes.push(o);
  }

  e.attr && (o.attr = bl(o.attr, e.attr));
}

function kl(t, e) {
  if (t.edges || (t.edges = []), t.edges.push(e), t.edge) {
    var i = bl({}, t.edge);
    e.attr = bl(i, e.attr);
  }
}

function xl(t, e, i, n, o) {
  var r = {
    from: e,
    to: i,
    type: n
  };
  return t.edge && (r.attr = bl({}, t.edge)), r.attr = bl(r.attr || {}, o), null != o && o.hasOwnProperty("arrows") && null != o.arrows && (r.arrows = {
    to: {
      enabled: !0,
      type: o.arrows.type
    }
  }, o.arrows = null), r;
}

function Ol() {
  for (pl = hl.NULL, fl = ""; " " === cl || "\t" === cl || "\n" === cl || "\r" === cl;) vl();

  do {
    var t = !1;

    if ("#" === cl) {
      for (var e = ul - 1; " " === dl.charAt(e) || "\t" === dl.charAt(e);) e--;

      if ("\n" === dl.charAt(e) || "" === dl.charAt(e)) {
        for (; "" != cl && "\n" != cl;) vl();

        t = !0;
      }
    }

    if ("/" === cl && "/" === yl()) {
      for (; "" != cl && "\n" != cl;) vl();

      t = !0;
    }

    if ("/" === cl && "*" === yl()) {
      for (; "" != cl;) {
        if ("*" === cl && "/" === yl()) {
          vl(), vl();
          break;
        }

        vl();
      }

      t = !0;
    }

    for (; " " === cl || "\t" === cl || "\n" === cl || "\r" === cl;) vl();
  } while (t);

  if ("" !== cl) {
    var i = cl + yl();
    if (ll[i]) return pl = hl.DELIMITER, fl = i, vl(), void vl();
    if (ll[cl]) return pl = hl.DELIMITER, fl = cl, void vl();

    if (ml(cl) || "-" === cl) {
      for (fl += cl, vl(); ml(cl);) fl += cl, vl();

      return "false" === fl ? fl = !1 : "true" === fl ? fl = !0 : isNaN(Number(fl)) || (fl = Number(fl)), void (pl = hl.IDENTIFIER);
    }

    if ('"' === cl) {
      for (vl(); "" != cl && ('"' != cl || '"' === cl && '"' === yl());) '"' === cl ? (fl += cl, vl()) : "\\" === cl && "n" === yl() ? (fl += "\n", vl()) : fl += cl, vl();

      if ('"' != cl) throw Cl('End of string " expected');
      return vl(), void (pl = hl.IDENTIFIER);
    }

    for (pl = hl.UNKNOWN; "" != cl;) fl += cl, vl();

    throw new SyntaxError('Syntax error in part "' + Pl(fl, 30) + '"');
  }

  pl = hl.DELIMITER;
}

function Sl(t) {
  for (; "" !== fl && "}" != fl;) Ml(t), ";" === fl && Ol();
}

function Ml(t) {
  var e = El(t);
  if (e) Dl(t, e);else if (!function (t) {
    if ("node" === fl) return Ol(), t.node = Tl(), "node";
    if ("edge" === fl) return Ol(), t.edge = Tl(), "edge";
    if ("graph" === fl) return Ol(), t.graph = Tl(), "graph";
    return null;
  }(t)) {
    if (pl != hl.IDENTIFIER) throw Cl("Identifier expected");
    var i = fl;

    if (Ol(), "=" === fl) {
      if (Ol(), pl != hl.IDENTIFIER) throw Cl("Identifier expected");
      t[i] = fl, Ol();
    } else !function (t, e) {
      var i = {
        id: e
      },
          n = Tl();
      n && (i.attr = n);
      _l(t, i), Dl(t, e);
    }(t, i);
  }
}

function El(t) {
  var e = null;

  if ("subgraph" === fl && ((e = {}).type = "subgraph", Ol(), pl === hl.IDENTIFIER && (e.id = fl, Ol())), "{" === fl) {
    if (Ol(), e || (e = {}), e.parent = t, e.node = t.node, e.edge = t.edge, e.graph = t.graph, Sl(e), "}" != fl) throw Cl("Angle bracket } expected");
    Ol(), delete e.node, delete e.edge, delete e.graph, delete e.parent, t.subgraphs || (t.subgraphs = []), t.subgraphs.push(e);
  }

  return e;
}

function Dl(t, e) {
  for (; "->" === fl || "--" === fl;) {
    var i,
        n = fl;
    Ol();
    var o = El(t);
    if (o) i = o;else {
      if (pl != hl.IDENTIFIER) throw Cl("Identifier or subgraph expected");
      _l(t, {
        id: i = fl
      }), Ol();
    }
    kl(t, xl(t, e, i, n, Tl())), e = i;
  }
}

function Tl() {
  for (var t, e, i = null, n = {
    dashed: !0,
    solid: !1,
    dotted: [1, 5]
  }, o = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  }, r = new Array(), s = new Array(); "[" === fl;) {
    for (Ol(), i = {}; "" !== fl && "]" != fl;) {
      if (pl != hl.IDENTIFIER) throw Cl("Attribute name expected");
      var a = fl;
      if (Ol(), "=" != fl) throw Cl("Equal sign = expected");
      if (Ol(), pl != hl.IDENTIFIER) throw Cl("Attribute value expected");
      var h = fl;
      "style" === a && (h = n[h]), "arrowhead" === a && (a = "arrows", h = {
        to: {
          enabled: !0,
          type: o[h]
        }
      }), "arrowtail" === a && (a = "arrows", h = {
        from: {
          enabled: !0,
          type: o[h]
        }
      }), r.push({
        attr: i,
        name: a,
        value: h
      }), s.push(a), Ol(), "," == fl && Ol();
    }

    if ("]" != fl) throw Cl("Bracket ] expected");
    Ol();
  }

  if (Xh(s).call(s, "dir")) {
    var l = {
      arrows: {}
    };

    for (t = 0; t < r.length; t++) if ("arrows" === r[t].name) {
      if (null != r[t].value.to) l.arrows.to = t;else {
        if (null == r[t].value.from) throw Cl("Invalid value of arrows");
        l.arrows.from = t;
      }
    } else "dir" === r[t].name && (l.dir = t);

    var d,
        u,
        c = r[l.dir].value;
    if (!Xh(s).call(s, "arrows")) if ("both" === c) r.push({
      attr: r[l.dir].attr,
      name: "arrows",
      value: {
        to: {
          enabled: !0
        }
      }
    }), l.arrows.to = r.length - 1, r.push({
      attr: r[l.dir].attr,
      name: "arrows",
      value: {
        from: {
          enabled: !0
        }
      }
    }), l.arrows.from = r.length - 1;else if ("forward" === c) r.push({
      attr: r[l.dir].attr,
      name: "arrows",
      value: {
        to: {
          enabled: !0
        }
      }
    }), l.arrows.to = r.length - 1;else if ("back" === c) r.push({
      attr: r[l.dir].attr,
      name: "arrows",
      value: {
        from: {
          enabled: !0
        }
      }
    }), l.arrows.from = r.length - 1;else {
      if ("none" !== c) throw Cl('Invalid dir type "' + c + '"');
      r.push({
        attr: r[l.dir].attr,
        name: "arrows",
        value: ""
      }), l.arrows.to = r.length - 1;
    }
    if ("both" === c) l.arrows.to && l.arrows.from ? (u = r[l.arrows.to].value.to.type, d = r[l.arrows.from].value.from.type, r[l.arrows.to] = {
      attr: r[l.arrows.to].attr,
      name: r[l.arrows.to].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    }, Rh(r).call(r, l.arrows.from, 1)) : l.arrows.to ? (u = r[l.arrows.to].value.to.type, d = "arrow", r[l.arrows.to] = {
      attr: r[l.arrows.to].attr,
      name: r[l.arrows.to].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    }) : l.arrows.from && (u = "arrow", d = r[l.arrows.from].value.from.type, r[l.arrows.from] = {
      attr: r[l.arrows.from].attr,
      name: r[l.arrows.from].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    });else if ("back" === c) l.arrows.to && l.arrows.from ? (u = "", d = r[l.arrows.from].value.from.type, r[l.arrows.from] = {
      attr: r[l.arrows.from].attr,
      name: r[l.arrows.from].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    }) : l.arrows.to ? (u = "", d = "arrow", l.arrows.from = l.arrows.to, r[l.arrows.from] = {
      attr: r[l.arrows.from].attr,
      name: r[l.arrows.from].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    }) : l.arrows.from && (u = "", d = r[l.arrows.from].value.from.type, r[l.arrows.to] = {
      attr: r[l.arrows.from].attr,
      name: r[l.arrows.from].name,
      value: {
        to: {
          enabled: !0,
          type: u
        },
        from: {
          enabled: !0,
          type: d
        }
      }
    }), r[l.arrows.from] = {
      attr: r[l.arrows.from].attr,
      name: r[l.arrows.from].name,
      value: {
        from: {
          enabled: !0,
          type: r[l.arrows.from].value.from.type
        }
      }
    };else if ("none" === c) {
      var f;
      r[f = l.arrows.to ? l.arrows.to : l.arrows.from] = {
        attr: r[f].attr,
        name: r[f].name,
        value: ""
      };
    } else {
      if ("forward" !== c) throw Cl('Invalid dir type "' + c + '"');
      l.arrows.to && l.arrows.from ? (u = r[l.arrows.to].value.to.type, d = "", r[l.arrows.to] = {
        attr: r[l.arrows.to].attr,
        name: r[l.arrows.to].name,
        value: {
          to: {
            enabled: !0,
            type: u
          },
          from: {
            enabled: !0,
            type: d
          }
        }
      }) : l.arrows.to ? (u = r[l.arrows.to].value.to.type, d = "", r[l.arrows.to] = {
        attr: r[l.arrows.to].attr,
        name: r[l.arrows.to].name,
        value: {
          to: {
            enabled: !0,
            type: u
          },
          from: {
            enabled: !0,
            type: d
          }
        }
      }) : l.arrows.from && (u = "arrow", d = "", l.arrows.to = l.arrows.from, r[l.arrows.to] = {
        attr: r[l.arrows.to].attr,
        name: r[l.arrows.to].name,
        value: {
          to: {
            enabled: !0,
            type: u
          },
          from: {
            enabled: !0,
            type: d
          }
        }
      }), r[l.arrows.to] = {
        attr: r[l.arrows.to].attr,
        name: r[l.arrows.to].name,
        value: {
          to: {
            enabled: !0,
            type: r[l.arrows.to].value.to.type
          }
        }
      };
    }
    Rh(r).call(r, l.dir, 1);
  }

  if (Xh(s).call(s, "penwidth")) {
    var p = [];

    for (e = r.length, t = 0; t < e; t++) "width" !== r[t].name && ("penwidth" === r[t].name && (r[t].name = "width"), p.push(r[t]));

    r = p;
  }

  for (e = r.length, t = 0; t < e; t++) wl(r[t].attr, r[t].name, r[t].value);

  return i;
}

function Cl(t) {
  return new SyntaxError(t + ', got "' + Pl(fl, 30) + '" (char ' + ul + ")");
}

function Pl(t, e) {
  return t.length <= e ? t : t.substr(0, 27) + "...";
}

function Al(t, e, i) {
  for (var n = e.split("."), o = n.pop(), r = t, s = 0; s < n.length; s++) {
    var a = n[s];
    a in r || (r[a] = {}), r = r[a];
  }

  return r[o] = i, t;
}

function Il(t, e) {
  var i = {};

  for (var n in t) if (t.hasOwnProperty(n)) {
    var o = e[n];
    Mh(o) ? kh(o).call(o, function (e) {
      Al(i, e, t[n]);
    }) : Al(i, "string" == typeof o ? o : n, t[n]);
  }

  return i;
}

var Fl = rl,
    Nl = function (t) {
  var e,
      i = rl(t),
      n = {
    nodes: [],
    edges: [],
    options: {}
  };

  if (i.nodes && kh(e = i.nodes).call(e, function (t) {
    var e = {
      id: t.id,
      label: String(t.label || t.id)
    };
    bl(e, Il(t.attr, sl)), e.image && (e.shape = "image"), n.nodes.push(e);
  }), i.edges) {
    var o,
        r = function (t) {
      var e = {
        from: t.from,
        to: t.to
      };
      return bl(e, Il(t.attr, al)), null == e.arrows && "->" === t.type && (e.arrows = "to"), e;
    };

    kh(o = i.edges).call(o, function (t) {
      var e, i, o, s, a, h, l;
      (e = t.from instanceof Object ? t.from.nodes : {
        id: t.from
      }, i = t.to instanceof Object ? t.to.nodes : {
        id: t.to
      }, t.from instanceof Object && t.from.edges) && kh(o = t.from.edges).call(o, function (t) {
        var e = r(t);
        n.edges.push(e);
      });
      (a = i, h = function (e, i) {
        var o = xl(n, e.id, i.id, t.type, t.attr),
            s = r(o);
        n.edges.push(s);
      }, Mh(s = e) ? kh(s).call(s, function (t) {
        Mh(a) ? kh(a).call(a, function (e) {
          h(t, e);
        }) : h(t, a);
      }) : Mh(a) ? kh(a).call(a, function (t) {
        h(s, t);
      }) : h(s, a), t.to instanceof Object && t.to.edges) && kh(l = t.to.edges).call(l, function (t) {
        var e = r(t);
        n.edges.push(e);
      });
    });
  }

  return i.attr && (n.options = i.attr), n;
},
    jl = {
  parseDOT: Fl,
  DOTToGraph: Nl
},
    zl = Object.freeze({
  __proto__: null,
  default: jl,
  __moduleExports: jl,
  parseDOT: Fl,
  DOTToGraph: Nl
}),
    Ll = vh.map;

W({
  target: "Array",
  proto: !0,
  forced: !Fh("map")
}, {
  map: function (t) {
    return Ll(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Rl = X("Array").map,
    Bl = Array.prototype,
    Yl = function (t) {
  var e = t.map;
  return t === Bl || t instanceof Array && e === Bl.map ? Rl : e;
};

function Hl(t, e) {
  var i,
      n = {
    edges: {
      inheritColor: !1
    },
    nodes: {
      fixed: !1,
      parseColor: !1
    }
  };
  null != e && (null != e.fixed && (n.nodes.fixed = e.fixed), null != e.parseColor && (n.nodes.parseColor = e.parseColor), null != e.inheritColor && (n.edges.inheritColor = e.inheritColor));
  var o = t.edges,
      r = Yl(o).call(o, function (t) {
    var e = {
      from: t.source,
      id: t.id,
      to: t.target
    };
    return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), "Directed" === t.type && (e.arrows = "to"), t.color && !1 === n.edges.inheritColor && (e.color = t.color), e;
  });
  return {
    nodes: Yl(i = t.nodes).call(i, function (t) {
      var e = {
        id: t.id,
        fixed: n.nodes.fixed && null != t.x && null != t.y
      };
      return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.size && (e.size = t.size), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), null != t.title && (e.title = t.title), null != t.x && (e.x = t.x), null != t.y && (e.y = t.y), null != t.color && (!0 === n.nodes.parseColor ? e.color = t.color : e.color = {
        background: t.color,
        border: t.color,
        highlight: {
          background: t.color,
          border: t.color
        },
        hover: {
          background: t.color,
          border: t.color
        }
      }), e;
    }),
    edges: r
  };
}

var Wl = Object.freeze({
  __proto__: null,
  parseGephi: Hl
}),
    Vl = Object.freeze({
  __proto__: null,
  default: void 0
}),
    Ul = i(function (t, e) {
  t.exports = function (t) {
    var e,
        i = t && t.preventDefault || !1,
        n = t && t.container || window,
        o = {},
        r = {
      keydown: {},
      keyup: {}
    },
        s = {};

    for (e = 97; e <= 122; e++) s[String.fromCharCode(e)] = {
      code: e - 97 + 65,
      shift: !1
    };

    for (e = 65; e <= 90; e++) s[String.fromCharCode(e)] = {
      code: e,
      shift: !0
    };

    for (e = 0; e <= 9; e++) s["" + e] = {
      code: 48 + e,
      shift: !1
    };

    for (e = 1; e <= 12; e++) s["F" + e] = {
      code: 111 + e,
      shift: !1
    };

    for (e = 0; e <= 9; e++) s["num" + e] = {
      code: 96 + e,
      shift: !1
    };

    s["num*"] = {
      code: 106,
      shift: !1
    }, s["num+"] = {
      code: 107,
      shift: !1
    }, s["num-"] = {
      code: 109,
      shift: !1
    }, s["num/"] = {
      code: 111,
      shift: !1
    }, s["num."] = {
      code: 110,
      shift: !1
    }, s.left = {
      code: 37,
      shift: !1
    }, s.up = {
      code: 38,
      shift: !1
    }, s.right = {
      code: 39,
      shift: !1
    }, s.down = {
      code: 40,
      shift: !1
    }, s.space = {
      code: 32,
      shift: !1
    }, s.enter = {
      code: 13,
      shift: !1
    }, s.shift = {
      code: 16,
      shift: void 0
    }, s.esc = {
      code: 27,
      shift: !1
    }, s.backspace = {
      code: 8,
      shift: !1
    }, s.tab = {
      code: 9,
      shift: !1
    }, s.ctrl = {
      code: 17,
      shift: !1
    }, s.alt = {
      code: 18,
      shift: !1
    }, s.delete = {
      code: 46,
      shift: !1
    }, s.pageup = {
      code: 33,
      shift: !1
    }, s.pagedown = {
      code: 34,
      shift: !1
    }, s["="] = {
      code: 187,
      shift: !1
    }, s["-"] = {
      code: 189,
      shift: !1
    }, s["]"] = {
      code: 221,
      shift: !1
    }, s["["] = {
      code: 219,
      shift: !1
    };

    var a = function (t) {
      l(t, "keydown");
    },
        h = function (t) {
      l(t, "keyup");
    },
        l = function (t, e) {
      if (void 0 !== r[e][t.keyCode]) {
        for (var n = r[e][t.keyCode], o = 0; o < n.length; o++) void 0 === n[o].shift ? n[o].fn(t) : 1 == n[o].shift && 1 == t.shiftKey ? n[o].fn(t) : 0 == n[o].shift && 0 == t.shiftKey && n[o].fn(t);

        1 == i && t.preventDefault();
      }
    };

    return o.bind = function (t, e, i) {
      if (void 0 === i && (i = "keydown"), void 0 === s[t]) throw new Error("unsupported key: " + t);
      void 0 === r[i][s[t].code] && (r[i][s[t].code] = []), r[i][s[t].code].push({
        fn: e,
        shift: s[t].shift
      });
    }, o.bindAll = function (t, e) {
      for (var i in void 0 === e && (e = "keydown"), s) s.hasOwnProperty(i) && o.bind(i, t, e);
    }, o.getKey = function (t) {
      for (var e in s) if (s.hasOwnProperty(e)) {
        if (1 == t.shiftKey && 1 == s[e].shift && t.keyCode == s[e].code) return e;
        if (0 == t.shiftKey && 0 == s[e].shift && t.keyCode == s[e].code) return e;
        if (t.keyCode == s[e].code && "shift" == e) return e;
      }

      return "unknown key, currently not supported";
    }, o.unbind = function (t, e, i) {
      if (void 0 === i && (i = "keydown"), void 0 === s[t]) throw new Error("unsupported key: " + t);

      if (void 0 !== e) {
        var n = [],
            o = r[i][s[t].code];
        if (void 0 !== o) for (var a = 0; a < o.length; a++) o[a].fn == e && o[a].shift == s[t].shift || n.push(r[i][s[t].code][a]);
        r[i][s[t].code] = n;
      } else r[i][s[t].code] = [];
    }, o.reset = function () {
      r = {
        keydown: {},
        keyup: {}
      };
    }, o.destroy = function () {
      r = {
        keydown: {},
        keyup: {}
      }, n.removeEventListener("keydown", a, !0), n.removeEventListener("keyup", h, !0);
    }, n.addEventListener("keydown", a, !0), n.addEventListener("keyup", h, !0), o;
  };
}),
    Gl = Object.freeze({
  __proto__: null,
  default: Ul,
  __moduleExports: Ul
});
exports.keycharm = Gl;

function ql() {
  return (ql = Object.assign || function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];

      for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
    }

    return t;
  }).apply(this, arguments);
}

function Xl(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}

function Zl(t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}

var Kl,
    $l = "function" != typeof Object.assign ? function (t) {
  if (null == t) throw new TypeError("Cannot convert undefined or null to object");

  for (var e = Object(t), i = 1; i < arguments.length; i++) {
    var n = arguments[i];
    if (null != n) for (var o in n) n.hasOwnProperty(o) && (e[o] = n[o]);
  }

  return e;
} : Object.assign,
    Jl = ["", "webkit", "Moz", "MS", "ms", "o"],
    Ql = "undefined" == typeof document ? {
  style: {}
} : document.createElement("div"),
    td = "function",
    ed = Math.round,
    id = Math.abs,
    nd = Date.now;

function od(t, e) {
  for (var i, n, o = e[0].toUpperCase() + e.slice(1), r = 0; r < Jl.length;) {
    if ((n = (i = Jl[r]) ? i + o : e) in t) return n;
    r++;
  }
}

Kl = "undefined" == typeof window ? {} : window;
var rd = od(Ql.style, "touchAction"),
    sd = void 0 !== rd;

var ad = "auto",
    hd = "manipulation",
    ld = "none",
    dd = "pan-x",
    ud = "pan-y",
    cd = function () {
  if (!sd) return !1;
  var t = {},
      e = Kl.CSS && Kl.CSS.supports;
  return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (i) {
    return t[i] = !e || Kl.CSS.supports("touch-action", i);
  }), t;
}(),
    fd = "ontouchstart" in Kl,
    pd = void 0 !== od(Kl, "PointerEvent"),
    vd = fd && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),
    yd = "touch",
    gd = "mouse",
    md = 25,
    bd = 1,
    wd = 2,
    _d = 4,
    kd = 8,
    xd = 1,
    Od = 2,
    Sd = 4,
    Md = 8,
    Ed = 16,
    Dd = Od | Sd,
    Td = Md | Ed,
    Cd = Dd | Td,
    Pd = ["x", "y"],
    Ad = ["clientX", "clientY"];

function Id(t, e, i) {
  var n;
  if (t) if (t.forEach) t.forEach(e, i);else if (void 0 !== t.length) for (n = 0; n < t.length;) e.call(i, t[n], n, t), n++;else for (n in t) t.hasOwnProperty(n) && e.call(i, t[n], n, t);
}

function Fd(t, e) {
  return typeof t === td ? t.apply(e && e[0] || void 0, e) : t;
}

function Nd(t, e) {
  return t.indexOf(e) > -1;
}

var jd = function () {
  function t(t, e) {
    this.manager = t, this.set(e);
  }

  var e = t.prototype;
  return e.set = function (t) {
    "compute" === t && (t = this.compute()), sd && this.manager.element.style && cd[t] && (this.manager.element.style[rd] = t), this.actions = t.toLowerCase().trim();
  }, e.update = function () {
    this.set(this.manager.options.touchAction);
  }, e.compute = function () {
    var t = [];
    return Id(this.manager.recognizers, function (e) {
      Fd(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()));
    }), function (t) {
      if (Nd(t, ld)) return ld;
      var e = Nd(t, dd),
          i = Nd(t, ud);
      return e && i ? ld : e || i ? e ? dd : ud : Nd(t, hd) ? hd : ad;
    }(t.join(" "));
  }, e.preventDefaults = function (t) {
    var e = t.srcEvent,
        i = t.offsetDirection;
    if (this.manager.session.prevented) e.preventDefault();else {
      var n = this.actions,
          o = Nd(n, ld) && !cd[ld],
          r = Nd(n, ud) && !cd[ud],
          s = Nd(n, dd) && !cd[dd];

      if (o) {
        var a = 1 === t.pointers.length,
            h = t.distance < 2,
            l = t.deltaTime < 250;
        if (a && h && l) return;
      }

      if (!s || !r) return o || r && i & Dd || s && i & Td ? this.preventSrc(e) : void 0;
    }
  }, e.preventSrc = function (t) {
    this.manager.session.prevented = !0, t.preventDefault();
  }, t;
}();

function zd(t, e) {
  for (; t;) {
    if (t === e) return !0;
    t = t.parentNode;
  }

  return !1;
}

function Ld(t) {
  var e = t.length;
  if (1 === e) return {
    x: ed(t[0].clientX),
    y: ed(t[0].clientY)
  };

  for (var i = 0, n = 0, o = 0; o < e;) i += t[o].clientX, n += t[o].clientY, o++;

  return {
    x: ed(i / e),
    y: ed(n / e)
  };
}

function Rd(t) {
  for (var e = [], i = 0; i < t.pointers.length;) e[i] = {
    clientX: ed(t.pointers[i].clientX),
    clientY: ed(t.pointers[i].clientY)
  }, i++;

  return {
    timeStamp: nd(),
    pointers: e,
    center: Ld(e),
    deltaX: t.deltaX,
    deltaY: t.deltaY
  };
}

function Bd(t, e, i) {
  i || (i = Pd);
  var n = e[i[0]] - t[i[0]],
      o = e[i[1]] - t[i[1]];
  return Math.sqrt(n * n + o * o);
}

function Yd(t, e, i) {
  i || (i = Pd);
  var n = e[i[0]] - t[i[0]],
      o = e[i[1]] - t[i[1]];
  return 180 * Math.atan2(o, n) / Math.PI;
}

function Hd(t, e) {
  return t === e ? xd : id(t) >= id(e) ? t < 0 ? Od : Sd : e < 0 ? Md : Ed;
}

function Wd(t, e, i) {
  return {
    x: e / t || 0,
    y: i / t || 0
  };
}

function Vd(t, e) {
  var i = t.session,
      n = e.pointers,
      o = n.length;
  i.firstInput || (i.firstInput = Rd(e)), o > 1 && !i.firstMultiple ? i.firstMultiple = Rd(e) : 1 === o && (i.firstMultiple = !1);
  var r = i.firstInput,
      s = i.firstMultiple,
      a = s ? s.center : r.center,
      h = e.center = Ld(n);
  e.timeStamp = nd(), e.deltaTime = e.timeStamp - r.timeStamp, e.angle = Yd(a, h), e.distance = Bd(a, h), function (t, e) {
    var i = e.center,
        n = t.offsetDelta || {},
        o = t.prevDelta || {},
        r = t.prevInput || {};
    e.eventType !== bd && r.eventType !== _d || (o = t.prevDelta = {
      x: r.deltaX || 0,
      y: r.deltaY || 0
    }, n = t.offsetDelta = {
      x: i.x,
      y: i.y
    }), e.deltaX = o.x + (i.x - n.x), e.deltaY = o.y + (i.y - n.y);
  }(i, e), e.offsetDirection = Hd(e.deltaX, e.deltaY);
  var l,
      d,
      u = Wd(e.deltaTime, e.deltaX, e.deltaY);
  e.overallVelocityX = u.x, e.overallVelocityY = u.y, e.overallVelocity = id(u.x) > id(u.y) ? u.x : u.y, e.scale = s ? (l = s.pointers, Bd((d = n)[0], d[1], Ad) / Bd(l[0], l[1], Ad)) : 1, e.rotation = s ? function (t, e) {
    return Yd(e[1], e[0], Ad) + Yd(t[1], t[0], Ad);
  }(s.pointers, n) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, function (t, e) {
    var i,
        n,
        o,
        r,
        s = t.lastInterval || e,
        a = e.timeStamp - s.timeStamp;

    if (e.eventType !== kd && (a > md || void 0 === s.velocity)) {
      var h = e.deltaX - s.deltaX,
          l = e.deltaY - s.deltaY,
          d = Wd(a, h, l);
      n = d.x, o = d.y, i = id(d.x) > id(d.y) ? d.x : d.y, r = Hd(h, l), t.lastInterval = e;
    } else i = s.velocity, n = s.velocityX, o = s.velocityY, r = s.direction;

    e.velocity = i, e.velocityX = n, e.velocityY = o, e.direction = r;
  }(i, e);
  var c,
      f = t.element,
      p = e.srcEvent;
  zd(c = p.composedPath ? p.composedPath()[0] : p.path ? p.path[0] : f, f) && (f = c), e.target = f;
}

function Ud(t, e, i) {
  var n = i.pointers.length,
      o = i.changedPointers.length,
      r = e & bd && n - o == 0,
      s = e & (_d | kd) && n - o == 0;
  i.isFirst = !!r, i.isFinal = !!s, r && (t.session = {}), i.eventType = e, Vd(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i;
}

function Gd(t) {
  return t.trim().split(/\s+/g);
}

function qd(t, e, i) {
  Id(Gd(e), function (e) {
    t.addEventListener(e, i, !1);
  });
}

function Xd(t, e, i) {
  Id(Gd(e), function (e) {
    t.removeEventListener(e, i, !1);
  });
}

function Zd(t) {
  var e = t.ownerDocument || t;
  return e.defaultView || e.parentWindow || window;
}

var Kd = function () {
  function t(t, e) {
    var i = this;
    this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) {
      Fd(t.options.enable, [t]) && i.handler(e);
    }, this.init();
  }

  var e = t.prototype;
  return e.handler = function () {}, e.init = function () {
    this.evEl && qd(this.element, this.evEl, this.domHandler), this.evTarget && qd(this.target, this.evTarget, this.domHandler), this.evWin && qd(Zd(this.element), this.evWin, this.domHandler);
  }, e.destroy = function () {
    this.evEl && Xd(this.element, this.evEl, this.domHandler), this.evTarget && Xd(this.target, this.evTarget, this.domHandler), this.evWin && Xd(Zd(this.element), this.evWin, this.domHandler);
  }, t;
}();

function $d(t, e, i) {
  if (t.indexOf && !i) return t.indexOf(e);

  for (var n = 0; n < t.length;) {
    if (i && t[n][i] == e || !i && t[n] === e) return n;
    n++;
  }

  return -1;
}

var Jd = {
  pointerdown: bd,
  pointermove: wd,
  pointerup: _d,
  pointercancel: kd,
  pointerout: kd
},
    Qd = {
  2: yd,
  3: "pen",
  4: gd,
  5: "kinect"
},
    tu = "pointerdown",
    eu = "pointermove pointerup pointercancel";
Kl.MSPointerEvent && !Kl.PointerEvent && (tu = "MSPointerDown", eu = "MSPointerMove MSPointerUp MSPointerCancel");

var iu = function (t) {
  function e() {
    var i,
        n = e.prototype;
    return n.evEl = tu, n.evWin = eu, (i = t.apply(this, arguments) || this).store = i.manager.session.pointerEvents = [], i;
  }

  return Xl(e, t), e.prototype.handler = function (t) {
    var e = this.store,
        i = !1,
        n = t.type.toLowerCase().replace("ms", ""),
        o = Jd[n],
        r = Qd[t.pointerType] || t.pointerType,
        s = r === yd,
        a = $d(e, t.pointerId, "pointerId");
    o & bd && (0 === t.button || s) ? a < 0 && (e.push(t), a = e.length - 1) : o & (_d | kd) && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, o, {
      pointers: e,
      changedPointers: [t],
      pointerType: r,
      srcEvent: t
    }), i && e.splice(a, 1));
  }, e;
}(Kd);

function nu(t) {
  return Array.prototype.slice.call(t, 0);
}

function ou(t, e, i) {
  for (var n = [], o = [], r = 0; r < t.length;) {
    var s = e ? t[r][e] : t[r];
    $d(o, s) < 0 && n.push(t[r]), o[r] = s, r++;
  }

  return i && (n = e ? n.sort(function (t, i) {
    return t[e] > i[e];
  }) : n.sort()), n;
}

var ru = {
  touchstart: bd,
  touchmove: wd,
  touchend: _d,
  touchcancel: kd
},
    su = "touchstart touchmove touchend touchcancel",
    au = function (t) {
  function e() {
    var i;
    return e.prototype.evTarget = su, (i = t.apply(this, arguments) || this).targetIds = {}, i;
  }

  return Xl(e, t), e.prototype.handler = function (t) {
    var e = ru[t.type],
        i = hu.call(this, t, e);
    i && this.callback(this.manager, e, {
      pointers: i[0],
      changedPointers: i[1],
      pointerType: yd,
      srcEvent: t
    });
  }, e;
}(Kd);

function hu(t, e) {
  var i,
      n,
      o = nu(t.touches),
      r = this.targetIds;
  if (e & (bd | wd) && 1 === o.length) return r[o[0].identifier] = !0, [o, o];
  var s = nu(t.changedTouches),
      a = [],
      h = this.target;
  if (n = o.filter(function (t) {
    return zd(t.target, h);
  }), e === bd) for (i = 0; i < n.length;) r[n[i].identifier] = !0, i++;

  for (i = 0; i < s.length;) r[s[i].identifier] && a.push(s[i]), e & (_d | kd) && delete r[s[i].identifier], i++;

  return a.length ? [ou(n.concat(a), "identifier", !0), a] : void 0;
}

var lu = {
  mousedown: bd,
  mousemove: wd,
  mouseup: _d
},
    du = "mousedown",
    uu = "mousemove mouseup",
    cu = function (t) {
  function e() {
    var i,
        n = e.prototype;
    return n.evEl = du, n.evWin = uu, (i = t.apply(this, arguments) || this).pressed = !1, i;
  }

  return Xl(e, t), e.prototype.handler = function (t) {
    var e = lu[t.type];
    e & bd && 0 === t.button && (this.pressed = !0), e & wd && 1 !== t.which && (e = _d), this.pressed && (e & _d && (this.pressed = !1), this.callback(this.manager, e, {
      pointers: [t],
      changedPointers: [t],
      pointerType: gd,
      srcEvent: t
    }));
  }, e;
}(Kd),
    fu = 2500,
    pu = 25;

function vu(t) {
  var e = t.changedPointers[0];

  if (e.identifier === this.primaryTouch) {
    var i = {
      x: e.clientX,
      y: e.clientY
    },
        n = this.lastTouches;
    this.lastTouches.push(i);
    setTimeout(function () {
      var t = n.indexOf(i);
      t > -1 && n.splice(t, 1);
    }, fu);
  }
}

function yu(t, e) {
  t & bd ? (this.primaryTouch = e.changedPointers[0].identifier, vu.call(this, e)) : t & (_d | kd) && vu.call(this, e);
}

function gu(t) {
  for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
    var o = this.lastTouches[n],
        r = Math.abs(e - o.x),
        s = Math.abs(i - o.y);
    if (r <= pu && s <= pu) return !0;
  }

  return !1;
}

var mu = function () {
  return function (t) {
    function e(e, i) {
      var n;
      return (n = t.call(this, e, i) || this).handler = function (t, e, i) {
        var o = i.pointerType === yd,
            r = i.pointerType === gd;

        if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
          if (o) yu.call(Zl(Zl(n)), e, i);else if (r && gu.call(Zl(Zl(n)), i)) return;
          n.callback(t, e, i);
        }
      }, n.touch = new au(n.manager, n.handler), n.mouse = new cu(n.manager, n.handler), n.primaryTouch = null, n.lastTouches = [], n;
    }

    return Xl(e, t), e.prototype.destroy = function () {
      this.touch.destroy(), this.mouse.destroy();
    }, e;
  }(Kd);
}();

function bu(t, e, i) {
  return !!Array.isArray(t) && (Id(t, i[e], i), !0);
}

var wu = 1,
    _u = 2,
    ku = 4,
    xu = 8,
    Ou = xu,
    Su = 16,
    Mu = 1;

function Eu(t, e) {
  var i = e.manager;
  return i ? i.get(t) : t;
}

function Du(t) {
  return t & Su ? "cancel" : t & xu ? "end" : t & ku ? "move" : t & _u ? "start" : "";
}

var Tu = function () {
  function t(t) {
    void 0 === t && (t = {}), this.options = ql({
      enable: !0
    }, t), this.id = Mu++, this.manager = null, this.state = wu, this.simultaneous = {}, this.requireFail = [];
  }

  var e = t.prototype;
  return e.set = function (t) {
    return $l(this.options, t), this.manager && this.manager.touchAction.update(), this;
  }, e.recognizeWith = function (t) {
    if (bu(t, "recognizeWith", this)) return this;
    var e = this.simultaneous;
    return e[(t = Eu(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this;
  }, e.dropRecognizeWith = function (t) {
    return bu(t, "dropRecognizeWith", this) ? this : (t = Eu(t, this), delete this.simultaneous[t.id], this);
  }, e.requireFailure = function (t) {
    if (bu(t, "requireFailure", this)) return this;
    var e = this.requireFail;
    return -1 === $d(e, t = Eu(t, this)) && (e.push(t), t.requireFailure(this)), this;
  }, e.dropRequireFailure = function (t) {
    if (bu(t, "dropRequireFailure", this)) return this;
    t = Eu(t, this);
    var e = $d(this.requireFail, t);
    return e > -1 && this.requireFail.splice(e, 1), this;
  }, e.hasRequireFailures = function () {
    return this.requireFail.length > 0;
  }, e.canRecognizeWith = function (t) {
    return !!this.simultaneous[t.id];
  }, e.emit = function (t) {
    var e = this,
        i = this.state;

    function n(i) {
      e.manager.emit(i, t);
    }

    i < xu && n(e.options.event + Du(i)), n(e.options.event), t.additionalEvent && n(t.additionalEvent), i >= xu && n(e.options.event + Du(i));
  }, e.tryEmit = function (t) {
    if (this.canEmit()) return this.emit(t);
    this.state = 32;
  }, e.canEmit = function () {
    for (var t = 0; t < this.requireFail.length;) {
      if (!(this.requireFail[t].state & (32 | wu))) return !1;
      t++;
    }

    return !0;
  }, e.recognize = function (t) {
    var e = $l({}, t);
    if (!Fd(this.options.enable, [this, e])) return this.reset(), void (this.state = 32);
    this.state & (Ou | Su | 32) && (this.state = wu), this.state = this.process(e), this.state & (_u | ku | xu | Su) && this.tryEmit(e);
  }, e.process = function (t) {}, e.getTouchAction = function () {}, e.reset = function () {}, t;
}(),
    Cu = {
  domEvents: !1,
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  inputClass: null,
  preset: [],
  cssProps: {
    userSelect: "none",
    touchSelect: "none",
    touchCallout: "none",
    contentZooming: "none",
    userDrag: "none",
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};

function Pu(t, e) {
  var i,
      n = t.element;
  n.style && (Id(t.options.cssProps, function (o, r) {
    i = od(n.style, r), e ? (t.oldCssProps[i] = n.style[i], n.style[i] = o) : n.style[i] = t.oldCssProps[i] || "";
  }), e || (t.oldCssProps = {}));
}

var Au = function () {
  function t(t, e) {
    var i,
        n = this;
    this.options = $l({}, Cu, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((i = this).options.inputClass || (pd ? iu : vd ? au : fd ? mu : cu))(i, Ud), this.touchAction = new jd(this, this.options.touchAction), Pu(this, !0), Id(this.options.recognizers, function (t) {
      var e = n.add(new t[0](t[1]));
      t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]);
    }, this);
  }

  var e = t.prototype;
  return e.set = function (t) {
    return $l(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this;
  }, e.stop = function (t) {
    this.session.stopped = t ? 2 : 1;
  }, e.recognize = function (t) {
    var e = this.session;

    if (!e.stopped) {
      var i;
      this.touchAction.preventDefaults(t);
      var n = this.recognizers,
          o = e.curRecognizer;
      (!o || o && o.state & Ou) && (e.curRecognizer = null, o = null);

      for (var r = 0; r < n.length;) i = n[r], 2 === e.stopped || o && i !== o && !i.canRecognizeWith(o) ? i.reset() : i.recognize(t), !o && i.state & (_u | ku | xu) && (e.curRecognizer = i, o = i), r++;
    }
  }, e.get = function (t) {
    if (t instanceof Tu) return t;

    for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event === t) return e[i];

    return null;
  }, e.add = function (t) {
    if (bu(t, "add", this)) return this;
    var e = this.get(t.options.event);
    return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t;
  }, e.remove = function (t) {
    if (bu(t, "remove", this)) return this;
    var e = this.get(t);

    if (t) {
      var i = this.recognizers,
          n = $d(i, e);
      -1 !== n && (i.splice(n, 1), this.touchAction.update());
    }

    return this;
  }, e.on = function (t, e) {
    if (void 0 === t || void 0 === e) return this;
    var i = this.handlers;
    return Id(Gd(t), function (t) {
      i[t] = i[t] || [], i[t].push(e);
    }), this;
  }, e.off = function (t, e) {
    if (void 0 === t) return this;
    var i = this.handlers;
    return Id(Gd(t), function (t) {
      e ? i[t] && i[t].splice($d(i[t], e), 1) : delete i[t];
    }), this;
  }, e.emit = function (t, e) {
    this.options.domEvents && function (t, e) {
      var i = document.createEvent("Event");
      i.initEvent(t, !0, !0), i.gesture = e, e.target.dispatchEvent(i);
    }(t, e);
    var i = this.handlers[t] && this.handlers[t].slice();

    if (i && i.length) {
      e.type = t, e.preventDefault = function () {
        e.srcEvent.preventDefault();
      };

      for (var n = 0; n < i.length;) i[n](e), n++;
    }
  }, e.destroy = function () {
    this.element && Pu(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }, t;
}(),
    Iu = {
  touchstart: bd,
  touchmove: wd,
  touchend: _d,
  touchcancel: kd
},
    Fu = "touchstart",
    Nu = "touchstart touchmove touchend touchcancel",
    ju = function (t) {
  function e() {
    var i,
        n = e.prototype;
    return n.evTarget = Fu, n.evWin = Nu, (i = t.apply(this, arguments) || this).started = !1, i;
  }

  return Xl(e, t), e.prototype.handler = function (t) {
    var e = Iu[t.type];

    if (e === bd && (this.started = !0), this.started) {
      var i = zu.call(this, t, e);
      e & (_d | kd) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
        pointers: i[0],
        changedPointers: i[1],
        pointerType: yd,
        srcEvent: t
      });
    }
  }, e;
}(Kd);

function zu(t, e) {
  var i = nu(t.touches),
      n = nu(t.changedTouches);
  return e & (_d | kd) && (i = ou(i.concat(n), "identifier", !0)), [i, n];
}

var Lu = function (t) {
  function e(e) {
    return void 0 === e && (e = {}), t.call(this, ql({
      pointers: 1
    }, e)) || this;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.attrTest = function (t) {
    var e = this.options.pointers;
    return 0 === e || t.pointers.length === e;
  }, i.process = function (t) {
    var e = this.state,
        i = t.eventType,
        n = e & (_u | ku),
        o = this.attrTest(t);
    return n && (i & kd || !o) ? e | Su : n || o ? i & _d ? e | xu : e & _u ? e | ku : _u : 32;
  }, e;
}(Tu),
    Ru = function (t) {
  function e(e) {
    var i;
    return void 0 === e && (e = {}), (i = t.call(this, ql({
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10
    }, e)) || this).pTime = !1, i.pCenter = !1, i._timer = null, i._input = null, i.count = 0, i;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    return [hd];
  }, i.process = function (t) {
    var e = this,
        i = this.options,
        n = t.pointers.length === i.pointers,
        o = t.distance < i.threshold,
        r = t.deltaTime < i.time;
    if (this.reset(), t.eventType & bd && 0 === this.count) return this.failTimeout();

    if (o && r && n) {
      if (t.eventType !== _d) return this.failTimeout();
      var s = !this.pTime || t.timeStamp - this.pTime < i.interval,
          a = !this.pCenter || Bd(this.pCenter, t.center) < i.posThreshold;
      if (this.pTime = t.timeStamp, this.pCenter = t.center, a && s ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % i.taps) return this.hasRequireFailures() ? (this._timer = setTimeout(function () {
        e.state = Ou, e.tryEmit();
      }, i.interval), _u) : Ou;
    }

    return 32;
  }, i.failTimeout = function () {
    var t = this;
    return this._timer = setTimeout(function () {
      t.state = 32;
    }, this.options.interval), 32;
  }, i.reset = function () {
    clearTimeout(this._timer);
  }, i.emit = function () {
    this.state === Ou && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
  }, e;
}(Tu);

function Bu(t) {
  return t === Ed ? "down" : t === Md ? "up" : t === Od ? "left" : t === Sd ? "right" : "";
}

var Yu = function (t) {
  function e(e) {
    var i;
    return void 0 === e && (e = {}), (i = t.call(this, ql({
      event: "pan",
      threshold: 10,
      pointers: 1,
      direction: Cd
    }, e)) || this).pX = null, i.pY = null, i;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    var t = this.options.direction,
        e = [];
    return t & Dd && e.push(ud), t & Td && e.push(dd), e;
  }, i.directionTest = function (t) {
    var e = this.options,
        i = !0,
        n = t.distance,
        o = t.direction,
        r = t.deltaX,
        s = t.deltaY;
    return o & e.direction || (e.direction & Dd ? (o = 0 === r ? xd : r < 0 ? Od : Sd, i = r !== this.pX, n = Math.abs(t.deltaX)) : (o = 0 === s ? xd : s < 0 ? Md : Ed, i = s !== this.pY, n = Math.abs(t.deltaY))), t.direction = o, i && n > e.threshold && o & e.direction;
  }, i.attrTest = function (t) {
    return Lu.prototype.attrTest.call(this, t) && (this.state & _u || !(this.state & _u) && this.directionTest(t));
  }, i.emit = function (e) {
    this.pX = e.deltaX, this.pY = e.deltaY;
    var i = Bu(e.direction);
    i && (e.additionalEvent = this.options.event + i), t.prototype.emit.call(this, e);
  }, e;
}(Lu),
    Hu = function (t) {
  function e(e) {
    return void 0 === e && (e = {}), t.call(this, ql({
      event: "swipe",
      threshold: 10,
      velocity: .3,
      direction: Dd | Td,
      pointers: 1
    }, e)) || this;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    return Yu.prototype.getTouchAction.call(this);
  }, i.attrTest = function (e) {
    var i,
        n = this.options.direction;
    return n & (Dd | Td) ? i = e.overallVelocity : n & Dd ? i = e.overallVelocityX : n & Td && (i = e.overallVelocityY), t.prototype.attrTest.call(this, e) && n & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers === this.options.pointers && id(i) > this.options.velocity && e.eventType & _d;
  }, i.emit = function (t) {
    var e = Bu(t.offsetDirection);
    e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t);
  }, e;
}(Lu),
    Wu = function (t) {
  function e(e) {
    return void 0 === e && (e = {}), t.call(this, ql({
      event: "pinch",
      threshold: 0,
      pointers: 2
    }, e)) || this;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    return [ld];
  }, i.attrTest = function (e) {
    return t.prototype.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & _u);
  }, i.emit = function (e) {
    if (1 !== e.scale) {
      var i = e.scale < 1 ? "in" : "out";
      e.additionalEvent = this.options.event + i;
    }

    t.prototype.emit.call(this, e);
  }, e;
}(Lu),
    Vu = function (t) {
  function e(e) {
    return void 0 === e && (e = {}), t.call(this, ql({
      event: "rotate",
      threshold: 0,
      pointers: 2
    }, e)) || this;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    return [ld];
  }, i.attrTest = function (e) {
    return t.prototype.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & _u);
  }, e;
}(Lu),
    Uu = function (t) {
  function e(e) {
    var i;
    return void 0 === e && (e = {}), (i = t.call(this, ql({
      event: "press",
      pointers: 1,
      time: 251,
      threshold: 9
    }, e)) || this)._timer = null, i._input = null, i;
  }

  Xl(e, t);
  var i = e.prototype;
  return i.getTouchAction = function () {
    return [ad];
  }, i.process = function (t) {
    var e = this,
        i = this.options,
        n = t.pointers.length === i.pointers,
        o = t.distance < i.threshold,
        r = t.deltaTime > i.time;
    if (this._input = t, !o || !n || t.eventType & (_d | kd) && !r) this.reset();else if (t.eventType & bd) this.reset(), this._timer = setTimeout(function () {
      e.state = Ou, e.tryEmit();
    }, i.time);else if (t.eventType & _d) return Ou;
    return 32;
  }, i.reset = function () {
    clearTimeout(this._timer);
  }, i.emit = function (t) {
    this.state === Ou && (t && t.eventType & _d ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = nd(), this.manager.emit(this.options.event, this._input)));
  }, e;
}(Tu);

function Gu(t, e, i) {
  var n = "DEPRECATED METHOD: " + e + "\n" + i + " AT \n";
  return function () {
    var e = new Error("get-stack-trace"),
        i = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
        o = window.console && (window.console.warn || window.console.log);
    return o && o.call(window.console, n, i), t.apply(this, arguments);
  };
}

var qu = Gu(function (t, e, i) {
  for (var n = Object.keys(e), o = 0; o < n.length;) (!i || i && void 0 === t[n[o]]) && (t[n[o]] = e[n[o]]), o++;

  return t;
}, "extend", "Use `assign`."),
    Xu = Gu(function (t, e) {
  return qu(t, e, !0);
}, "merge", "Use `assign`.");

function Zu(t, e, i) {
  var n,
      o = e.prototype;
  (n = t.prototype = Object.create(o)).constructor = t, n._super = o, i && $l(n, i);
}

function Ku(t, e) {
  return function () {
    return t.apply(e, arguments);
  };
}

var $u,
    Ju = function () {
  var t = function (t, e) {
    return void 0 === e && (e = {}), new Au(t, ql({
      recognizers: [[Vu, {
        enable: !1
      }], [Wu, {
        enable: !1
      }, ["rotate"]], [Hu, {
        direction: Dd
      }], [Yu, {
        direction: Dd
      }, ["swipe"]], [Ru], [Ru, {
        event: "doubletap",
        taps: 2
      }, ["tap"]], [Uu]]
    }, e));
  };

  return t.VERSION = "2.0.16", t.DIRECTION_ALL = Cd, t.DIRECTION_DOWN = Ed, t.DIRECTION_LEFT = Od, t.DIRECTION_RIGHT = Sd, t.DIRECTION_UP = Md, t.DIRECTION_HORIZONTAL = Dd, t.DIRECTION_VERTICAL = Td, t.DIRECTION_NONE = xd, t.DIRECTION_DOWN = Ed, t.INPUT_START = bd, t.INPUT_MOVE = wd, t.INPUT_END = _d, t.INPUT_CANCEL = kd, t.STATE_POSSIBLE = wu, t.STATE_BEGAN = _u, t.STATE_CHANGED = ku, t.STATE_ENDED = xu, t.STATE_RECOGNIZED = Ou, t.STATE_CANCELLED = Su, t.STATE_FAILED = 32, t.Manager = Au, t.Input = Kd, t.TouchAction = jd, t.TouchInput = au, t.MouseInput = cu, t.PointerEventInput = iu, t.TouchMouseInput = mu, t.SingleTouchInput = ju, t.Recognizer = Tu, t.AttrRecognizer = Lu, t.Tap = Ru, t.Pan = Yu, t.Swipe = Hu, t.Pinch = Wu, t.Rotate = Vu, t.Press = Uu, t.on = qd, t.off = Xd, t.each = Id, t.merge = Xu, t.extend = qu, t.bindFn = Ku, t.assign = $l, t.inherit = Zu, t.bindFn = Ku, t.prefixed = od, t.toArray = nu, t.inArray = $d, t.uniqueArray = ou, t.splitStr = Gd, t.boolOrFn = Fd, t.hasParent = zd, t.addEventListeners = qd, t.removeEventListeners = Xd, t.defaults = Cu, t;
}(),
    Qu = i(function (t) {
  if ("undefined" != typeof window) {
    var e = window.Hammer || Ju;
    t.exports = e;
  } else t.exports = function () {
    return {
      on: t = function () {},
      off: t,
      destroy: t,
      emit: t,
      get: function (e) {
        return {
          set: t
        };
      }
    };
    var t;
  };
}),
    tc = Object.freeze({
  __proto__: null,
  default: Qu,
  __moduleExports: Qu
});

exports.Hammer = tc;

function ec(t) {
  var e,
      i,
      n = this;
  this.active = !1, this.dom = {
    container: t
  }, this.dom.overlay = document.createElement("div"), this.dom.overlay.className = "vis-overlay", this.dom.container.appendChild(this.dom.overlay), this.hammer = Qu(this.dom.overlay), this.hammer.on("tap", $(e = this._onTapOverlay).call(e, this));
  var o = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
  kh(o).call(o, function (t) {
    n.hammer.on(t, function (t) {
      t.srcEvent.stopPropagation();
    });
  }), document && document.body && (this.onClick = function (e) {
    (function (t, e) {
      for (; t;) {
        if (t === e) return !0;
        t = t.parentNode;
      }

      return !1;
    })(e.target, t) || n.deactivate();
  }, document.body.addEventListener("click", this.onClick)), void 0 !== this.keycharm && this.keycharm.destroy(), this.keycharm = Ul(), this.escListener = $(i = this.deactivate).call(i, this);
}

($u = Vl) && $u.default, ot(ec.prototype), ec.current = null, ec.prototype.destroy = function () {
  this.deactivate(), this.dom.overlay.parentNode.removeChild(this.dom.overlay), this.onClick && document.body.removeEventListener("click", this.onClick), void 0 !== this.keycharm && this.keycharm.destroy(), this.keycharm = null, this.hammer.destroy(), this.hammer = null;
}, ec.prototype.activate = function () {
  var t;
  ec.current && ec.current.deactivate(), ec.current = this, this.active = !0, this.dom.overlay.style.display = "none", zs.addClassName(this.dom.container, "vis-active"), this.emit("change"), this.emit("activate"), $(t = this.keycharm).call(t, "esc", this.escListener);
}, ec.prototype.deactivate = function () {
  this.active = !1, this.dom.overlay.style.display = "block", zs.removeClassName(this.dom.container, "vis-active"), this.keycharm.unbind("esc", this.escListener), this.emit("change"), this.emit("deactivate");
}, ec.prototype._onTapOverlay = function (t) {
  this.activate(), t.srcEvent.stopPropagation();
};
var ic = ec,
    nc = i(function (t, e) {
  e.en = {
    edit: "Edit",
    del: "Delete selected",
    back: "Back",
    addNode: "Add Node",
    addEdge: "Add Edge",
    editNode: "Edit Node",
    editEdge: "Edit Edge",
    addDescription: "Click in an empty space to place a new node.",
    edgeDescription: "Click on a node and drag the edge to another node to connect them.",
    editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
    createEdgeError: "Cannot link edges to a cluster.",
    deleteClusterError: "Clusters cannot be deleted.",
    editClusterError: "Clusters cannot be edited."
  }, e.en_EN = e.en, e.en_US = e.en, e.de = {
    edit: "Editieren",
    del: "Lsche Auswahl",
    back: "Zurck",
    addNode: "Knoten hinzufgen",
    addEdge: "Kante hinzufgen",
    editNode: "Knoten editieren",
    editEdge: "Kante editieren",
    addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
    edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
    editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
    createEdgeError: "Es ist nicht mglich, Kanten mit Clustern zu verbinden.",
    deleteClusterError: "Cluster knnen nicht gelscht werden.",
    editClusterError: "Cluster knnen nicht editiert werden."
  }, e.de_DE = e.de, e.es = {
    edit: "Editar",
    del: "Eliminar seleccin",
    back: "Atrs",
    addNode: "Aadir nodo",
    addEdge: "Aadir arista",
    editNode: "Editar nodo",
    editEdge: "Editar arista",
    addDescription: "Haga clic en un lugar vaco para colocar un nuevo nodo.",
    edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
    editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
    createEdgeError: "No se puede conectar una arista a un grupo.",
    deleteClusterError: "No es posible eliminar grupos.",
    editClusterError: "No es posible editar grupos."
  }, e.es_ES = e.es, e.it = {
    edit: "Modifica",
    del: "Cancella la selezione",
    back: "Indietro",
    addNode: "Aggiungi un nodo",
    addEdge: "Aggiungi un vertice",
    editNode: "Modifica il nodo",
    editEdge: "Modifica il vertice",
    addDescription: "Clicca per aggiungere un nuovo nodo",
    edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
    editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
    createEdgeError: "Non si possono collegare vertici ad un cluster",
    deleteClusterError: "I cluster non possono essere cancellati",
    editClusterError: "I clusters non possono essere modificati."
  }, e.it_IT = e.it, e.nl = {
    edit: "Wijzigen",
    del: "Selectie verwijderen",
    back: "Terug",
    addNode: "Node toevoegen",
    addEdge: "Link toevoegen",
    editNode: "Node wijzigen",
    editEdge: "Link wijzigen",
    addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
    edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
    editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
    createEdgeError: "Kan geen link maken naar een cluster.",
    deleteClusterError: "Clusters kunnen niet worden verwijderd.",
    editClusterError: "Clusters kunnen niet worden aangepast."
  }, e.nl_NL = e.nl, e.nl_BE = e.nl, e["pt-br"] = {
    edit: "Editar",
    del: "Remover selecionado",
    back: "Voltar",
    addNode: "Adicionar n",
    addEdge: "Adicionar aresta",
    editNode: "Editar n",
    editEdge: "Editar aresta",
    addDescription: "Clique em um espao em branco para adicionar um novo n",
    edgeDescription: "Clique em um n e arraste a aresta at outro n para conect-los",
    editEdgeDescription: "Clique nos pontos de controle e os arraste para um n para conect-los",
    createEdgeError: "No foi possvel linkar arestas a um cluster.",
    deleteClusterError: "Clusters no puderam ser removidos.",
    editClusterError: "Clusters no puderam ser editados."
  }, e["pt-BR"] = e["pt-br"], e.pt_BR = e["pt-br"], e.pt_br = e["pt-br"], e.ru = {
    edit: "",
    del: " ",
    back: "",
    addNode: " ",
    addEdge: " ",
    editNode: " ",
    editEdge: " ",
    addDescription: "   ,    .",
    edgeDescription: "        ,   .",
    editEdgeDescription: "        ,    .",
    createEdgeError: "    .",
    deleteClusterError: "    ",
    editClusterError: "   ."
  }, e.ru_RU = e.ru, e.cn = {
    edit: "",
    del: "",
    back: "",
    addNode: "",
    addEdge: "",
    editNode: "",
    editEdge: "",
    addDescription: "",
    edgeDescription: "",
    editEdgeDescription: "",
    createEdgeError: "",
    deleteClusterError: "",
    editClusterError: ""
  }, e.zh_CN = e.cn, e.uk = {
    edit: "",
    del: " ",
    back: "",
    addNode: " ",
    addEdge: " ",
    editNode: " ",
    editEdge: " ",
    addDescription: "K   ,    .",
    edgeDescription: "        ,   '.",
    editEdgeDescription: "        ,    .",
    createEdgeError: "  '   .",
    deleteClusterError: "    .",
    editClusterError: "   ."
  }, e.uk_UA = e.uk, e.fr = {
    edit: "Editer",
    del: "Effacer la selection",
    back: "Retour",
    addNode: "Ajouter un noeud",
    addEdge: "Ajouter un lien",
    editNode: "Editer le noeud",
    editEdge: "Editer le lien",
    addDescription: "Cliquez dans un endroit vide pour placer un noeud.",
    edgeDescription: "Cliquez sur un noeud et glissez le lien vers un autre noeud pour les connecter.",
    editEdgeDescription: "Cliquez sur les points de contrle et glissez-les pour connecter un noeud.",
    createEdgeError: "Impossible de crer un lien vers un cluster.",
    deleteClusterError: "Les clusters ne peuvent pas tre ffacs.",
    editClusterError: "Les clusters ne peuvent pas tre dites."
  }, e.fr_FR = e.fr, e.cs = {
    edit: "Upravit",
    del: "Smazat vbr",
    back: "Zpt",
    addNode: "Pidat vrchol",
    addEdge: "Pidat hranu",
    editNode: "Upravit vrchol",
    editEdge: "Upravit hranu",
    addDescription: "Kluknutm do przdnho prostoru mete pidat nov vrchol.",
    edgeDescription: "Petaenm z jednoho vrcholu do druhho mete spojit tyto vrcholy novou hranou.",
    editEdgeDescription: "Petaenm kontrolnho vrcholu hrany ji mete pipojit k jinmu vrcholu.",
    createEdgeError: "Nelze pipojit hranu ke shluku.",
    deleteClusterError: "Nelze mazat shluky.",
    editClusterError: "Nelze upravovat shluky."
  }, e.cs_CZ = e.cs;
});

var oc = function (t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
};

W({
  target: "Object",
  stat: !0,
  forced: !s,
  sham: !s
}, {
  defineProperty: R.f
});
var rc = i(function (t) {
  var e = F.Object,
      i = t.exports = function (t, i, n) {
    return e.defineProperty(t, i, n);
  };

  e.defineProperty.sham && (i.sham = !0);
}),
    sc = rc;

function ac(t, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), sc(t, n.key, n);
  }
}

var hc = function (t, e, i) {
  return e && ac(t.prototype, e), i && ac(t, i), t;
},
    lc = function () {
  function t() {
    oc(this, t), this.NUM_ITERATIONS = 4, this.image = new Image(), this.canvas = document.createElement("canvas");
  }

  return hc(t, [{
    key: "init",
    value: function () {
      if (!this.initialized()) {
        this.src = this.image.src;
        var t = this.image.width,
            e = this.image.height;
        this.width = t, this.height = e;
        var i = Math.floor(e / 2),
            n = Math.floor(e / 4),
            o = Math.floor(e / 8),
            r = Math.floor(e / 16),
            s = Math.floor(t / 2),
            a = Math.floor(t / 4),
            h = Math.floor(t / 8),
            l = Math.floor(t / 16);
        this.canvas.width = 3 * a, this.canvas.height = i, this.coordinates = [[0, 0, s, i], [s, 0, a, n], [s, n, h, o], [5 * h, n, l, r]], this._fillMipMap();
      }
    }
  }, {
    key: "initialized",
    value: function () {
      return void 0 !== this.coordinates;
    }
  }, {
    key: "_fillMipMap",
    value: function () {
      var t = this.canvas.getContext("2d"),
          e = this.coordinates[0];
      t.drawImage(this.image, e[0], e[1], e[2], e[3]);

      for (var i = 1; i < this.NUM_ITERATIONS; i++) {
        var n = this.coordinates[i - 1],
            o = this.coordinates[i];
        t.drawImage(this.canvas, n[0], n[1], n[2], n[3], o[0], o[1], o[2], o[3]);
      }
    }
  }, {
    key: "drawImageAtPosition",
    value: function (t, e, i, n, o, r) {
      if (this.initialized()) if (e > 2) {
        e *= .5;

        for (var s = 0; e > 2 && s < this.NUM_ITERATIONS;) e *= .5, s += 1;

        s >= this.NUM_ITERATIONS && (s = this.NUM_ITERATIONS - 1);
        var a = this.coordinates[s];
        t.drawImage(this.canvas, a[0], a[1], a[2], a[3], i, n, o, r);
      } else t.drawImage(this.image, i, n, o, r);
    }
  }]), t;
}(),
    dc = function () {
  function t(e) {
    oc(this, t), this.images = {}, this.imageBroken = {}, this.callback = e;
  }

  return hc(t, [{
    key: "_tryloadBrokenUrl",
    value: function (t, e, i) {
      void 0 !== t && void 0 !== i && (void 0 !== e ? (i.image.onerror = function () {
        console.error("Could not load brokenImage:", e);
      }, i.image.src = e) : console.warn("No broken url image defined"));
    }
  }, {
    key: "_redrawWithImage",
    value: function (t) {
      this.callback && this.callback(t);
    }
  }, {
    key: "load",
    value: function (t, e) {
      var i = this,
          n = this.images[t];
      if (n) return n;
      var o = new lc();
      return this.images[t] = o, o.image.onload = function () {
        i._fixImageCoordinates(o.image), o.init(), i._redrawWithImage(o);
      }, o.image.onerror = function () {
        console.error("Could not load image:", t), i._tryloadBrokenUrl(t, e, o);
      }, o.image.src = t, o;
    }
  }, {
    key: "_fixImageCoordinates",
    value: function (t) {
      0 === t.width && (document.body.appendChild(t), t.width = t.offsetWidth, t.height = t.offsetHeight, document.body.removeChild(t));
    }
  }]), t;
}(),
    uc = function () {
  function t() {
    oc(this, t), this.clear(), this.defaultIndex = 0, this.groupsArray = [], this.groupIndex = 0, this.defaultGroups = [{
      border: "#2B7CE9",
      background: "#97C2FC",
      highlight: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      },
      hover: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      }
    }, {
      border: "#FFA500",
      background: "#FFFF00",
      highlight: {
        border: "#FFA500",
        background: "#FFFFA3"
      },
      hover: {
        border: "#FFA500",
        background: "#FFFFA3"
      }
    }, {
      border: "#FA0A10",
      background: "#FB7E81",
      highlight: {
        border: "#FA0A10",
        background: "#FFAFB1"
      },
      hover: {
        border: "#FA0A10",
        background: "#FFAFB1"
      }
    }, {
      border: "#41A906",
      background: "#7BE141",
      highlight: {
        border: "#41A906",
        background: "#A1EC76"
      },
      hover: {
        border: "#41A906",
        background: "#A1EC76"
      }
    }, {
      border: "#E129F0",
      background: "#EB7DF4",
      highlight: {
        border: "#E129F0",
        background: "#F0B3F5"
      },
      hover: {
        border: "#E129F0",
        background: "#F0B3F5"
      }
    }, {
      border: "#7C29F0",
      background: "#AD85E4",
      highlight: {
        border: "#7C29F0",
        background: "#D3BDF0"
      },
      hover: {
        border: "#7C29F0",
        background: "#D3BDF0"
      }
    }, {
      border: "#C37F00",
      background: "#FFA807",
      highlight: {
        border: "#C37F00",
        background: "#FFCA66"
      },
      hover: {
        border: "#C37F00",
        background: "#FFCA66"
      }
    }, {
      border: "#4220FB",
      background: "#6E6EFD",
      highlight: {
        border: "#4220FB",
        background: "#9B9BFD"
      },
      hover: {
        border: "#4220FB",
        background: "#9B9BFD"
      }
    }, {
      border: "#FD5A77",
      background: "#FFC0CB",
      highlight: {
        border: "#FD5A77",
        background: "#FFD1D9"
      },
      hover: {
        border: "#FD5A77",
        background: "#FFD1D9"
      }
    }, {
      border: "#4AD63A",
      background: "#C2FABC",
      highlight: {
        border: "#4AD63A",
        background: "#E6FFE3"
      },
      hover: {
        border: "#4AD63A",
        background: "#E6FFE3"
      }
    }, {
      border: "#990000",
      background: "#EE0000",
      highlight: {
        border: "#BB0000",
        background: "#FF3333"
      },
      hover: {
        border: "#BB0000",
        background: "#FF3333"
      }
    }, {
      border: "#FF6000",
      background: "#FF6000",
      highlight: {
        border: "#FF6000",
        background: "#FF6000"
      },
      hover: {
        border: "#FF6000",
        background: "#FF6000"
      }
    }, {
      border: "#97C2FC",
      background: "#2B7CE9",
      highlight: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      },
      hover: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      }
    }, {
      border: "#399605",
      background: "#255C03",
      highlight: {
        border: "#399605",
        background: "#255C03"
      },
      hover: {
        border: "#399605",
        background: "#255C03"
      }
    }, {
      border: "#B70054",
      background: "#FF007E",
      highlight: {
        border: "#B70054",
        background: "#FF007E"
      },
      hover: {
        border: "#B70054",
        background: "#FF007E"
      }
    }, {
      border: "#AD85E4",
      background: "#7C29F0",
      highlight: {
        border: "#D3BDF0",
        background: "#7C29F0"
      },
      hover: {
        border: "#D3BDF0",
        background: "#7C29F0"
      }
    }, {
      border: "#4557FA",
      background: "#000EA1",
      highlight: {
        border: "#6E6EFD",
        background: "#000EA1"
      },
      hover: {
        border: "#6E6EFD",
        background: "#000EA1"
      }
    }, {
      border: "#FFC0CB",
      background: "#FD5A77",
      highlight: {
        border: "#FFD1D9",
        background: "#FD5A77"
      },
      hover: {
        border: "#FFD1D9",
        background: "#FD5A77"
      }
    }, {
      border: "#C2FABC",
      background: "#74D66A",
      highlight: {
        border: "#E6FFE3",
        background: "#74D66A"
      },
      hover: {
        border: "#E6FFE3",
        background: "#74D66A"
      }
    }, {
      border: "#EE0000",
      background: "#990000",
      highlight: {
        border: "#FF3333",
        background: "#BB0000"
      },
      hover: {
        border: "#FF3333",
        background: "#BB0000"
      }
    }], this.options = {}, this.defaultOptions = {
      useDefaultGroups: !0
    }, Yr(this.options, this.defaultOptions);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      var e = ["useDefaultGroups"];
      if (void 0 !== t) for (var i in t) if (t.hasOwnProperty(i) && -1 === el(e).call(e, i)) {
        var n = t[i];
        this.add(i, n);
      }
    }
  }, {
    key: "clear",
    value: function () {
      this.groups = {}, this.groupsArray = [];
    }
  }, {
    key: "get",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = this.groups[t];
      if (void 0 === i && e) if (!1 === this.options.useDefaultGroups && this.groupsArray.length > 0) {
        var n = this.groupIndex % this.groupsArray.length;
        this.groupIndex++, (i = {}).color = this.groups[this.groupsArray[n]], this.groups[t] = i;
      } else {
        var o = this.defaultIndex % this.defaultGroups.length;
        this.defaultIndex++, (i = {}).color = this.defaultGroups[o], this.groups[t] = i;
      }
      return i;
    }
  }, {
    key: "add",
    value: function (t, e) {
      return this.groups[t] = e, this.groupsArray.push(t), e;
    }
  }]), t;
}(),
    cc = [].slice,
    fc = /MSIE .\./.test(Dh),
    pc = function (t) {
  return function (e, i) {
    var n = arguments.length > 2,
        o = n ? cc.call(arguments, 2) : void 0;
    return t(n ? function () {
      ("function" == typeof e ? e : Function(e)).apply(this, o);
    } : e, i);
  };
};

W({
  global: !0,
  bind: !0,
  forced: fc
}, {
  setTimeout: pc(o.setTimeout),
  setInterval: pc(o.setInterval)
});

var vc = F.setTimeout,
    yc = function (t) {
  return function (e, i) {
    var n,
        o,
        r = String(v(e)),
        s = wa(i),
        a = r.length;
    return s < 0 || s >= a ? t ? "" : void 0 : (n = r.charCodeAt(s)) < 55296 || n > 56319 || s + 1 === a || (o = r.charCodeAt(s + 1)) < 56320 || o > 57343 ? t ? r.charAt(s) : n : t ? r.slice(s, s + 2) : o - 56320 + (n - 55296 << 10) + 65536;
  };
},
    gc = {
  codeAt: yc(!1),
  charAt: yc(!0)
}.charAt,
    mc = sa.set,
    bc = sa.getterFor("String Iterator");

nh(String, "String", function (t) {
  mc(this, {
    type: "String Iterator",
    string: String(t),
    index: 0
  });
}, function () {
  var t,
      e = bc(this),
      i = e.string,
      n = e.index;
  return n >= i.length ? {
    value: void 0,
    done: !0
  } : (t = gc(i, n), e.index += t.length, {
    value: t,
    done: !1
  });
});

var wc = va("iterator"),
    _c = function (t) {
  if (null != t) return t[wc] || t["@@iterator"] || Rs[Ha(t)];
},
    kc = function (t) {
  var e = _c(t);

  if ("function" != typeof e) throw TypeError(String(t) + " is not iterable");
  return z(e.call(t));
},
    xc = vh.some;

W({
  target: "Array",
  proto: !0,
  forced: yh("some")
}, {
  some: function (t) {
    return xc(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Oc = X("Array").some,
    Sc = Array.prototype,
    Mc = function (t) {
  var e = t.some;
  return t === Sc || t instanceof Array && e === Sc.some ? Oc : e;
},
    Ec = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function Dc(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var Tc = function (t) {
  return t && t.Math == Math && t;
},
    Cc = Tc("object" == typeof globalThis && globalThis) || Tc("object" == typeof window && window) || Tc("object" == typeof self && self) || Tc("object" == typeof Ec && Ec) || Function("return this")(),
    Pc = function (t) {
  try {
    return !!t();
  } catch (t) {
    return !0;
  }
},
    Ac = !Pc(function () {
  return 7 != Object.defineProperty({}, "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    Ic = {}.propertyIsEnumerable,
    Fc = Object.getOwnPropertyDescriptor,
    Nc = {
  f: Fc && !Ic.call({
    1: 2
  }, 1) ? function (t) {
    var e = Fc(this, t);
    return !!e && e.enumerable;
  } : Ic
},
    jc = function (t, e) {
  return {
    enumerable: !(1 & t),
    configurable: !(2 & t),
    writable: !(4 & t),
    value: e
  };
},
    zc = {}.toString,
    Lc = function (t) {
  return zc.call(t).slice(8, -1);
},
    Rc = "".split,
    Bc = Pc(function () {
  return !Object("z").propertyIsEnumerable(0);
}) ? function (t) {
  return "String" == Lc(t) ? Rc.call(t, "") : Object(t);
} : Object,
    Yc = function (t) {
  if (null == t) throw TypeError("Can't call method on " + t);
  return t;
},
    Hc = function (t) {
  return Bc(Yc(t));
},
    Wc = function (t) {
  return "object" == typeof t ? null !== t : "function" == typeof t;
},
    Vc = function (t, e) {
  if (!Wc(t)) return t;
  var i, n;
  if (e && "function" == typeof (i = t.toString) && !Wc(n = i.call(t))) return n;
  if ("function" == typeof (i = t.valueOf) && !Wc(n = i.call(t))) return n;
  if (!e && "function" == typeof (i = t.toString) && !Wc(n = i.call(t))) return n;
  throw TypeError("Can't convert object to primitive value");
},
    Uc = {}.hasOwnProperty,
    Gc = function (t, e) {
  return Uc.call(t, e);
},
    qc = Cc.document,
    Xc = Wc(qc) && Wc(qc.createElement),
    Zc = function (t) {
  return Xc ? qc.createElement(t) : {};
},
    Kc = !Ac && !Pc(function () {
  return 7 != Object.defineProperty(Zc("div"), "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    $c = Object.getOwnPropertyDescriptor,
    Jc = {
  f: Ac ? $c : function (t, e) {
    if (t = Hc(t), e = Vc(e, !0), Kc) try {
      return $c(t, e);
    } catch (t) {}
    if (Gc(t, e)) return jc(!Nc.f.call(t, e), t[e]);
  }
},
    Qc = /#|\.prototype\./,
    tf = function (t, e) {
  var i = nf[ef(t)];
  return i == rf || i != of && ("function" == typeof e ? Pc(e) : !!e);
},
    ef = tf.normalize = function (t) {
  return String(t).replace(Qc, ".").toLowerCase();
},
    nf = tf.data = {},
    of = tf.NATIVE = "N",
    rf = tf.POLYFILL = "P",
    sf = tf,
    af = {},
    hf = function (t) {
  if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
  return t;
},
    lf = function (t, e, i) {
  if (hf(t), void 0 === e) return t;

  switch (i) {
    case 0:
      return function () {
        return t.call(e);
      };

    case 1:
      return function (i) {
        return t.call(e, i);
      };

    case 2:
      return function (i, n) {
        return t.call(e, i, n);
      };

    case 3:
      return function (i, n, o) {
        return t.call(e, i, n, o);
      };
  }

  return function () {
    return t.apply(e, arguments);
  };
},
    df = function (t) {
  if (!Wc(t)) throw TypeError(String(t) + " is not an object");
  return t;
},
    uf = Object.defineProperty,
    cf = {
  f: Ac ? uf : function (t, e, i) {
    if (df(t), e = Vc(e, !0), df(i), Kc) try {
      return uf(t, e, i);
    } catch (t) {}
    if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
    return "value" in i && (t[e] = i.value), t;
  }
},
    ff = Ac ? function (t, e, i) {
  return cf.f(t, e, jc(1, i));
} : function (t, e, i) {
  return t[e] = i, t;
},
    pf = Jc.f,
    vf = function (t) {
  var e = function (e, i, n) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new t();

        case 1:
          return new t(e);

        case 2:
          return new t(e, i);
      }

      return new t(e, i, n);
    }

    return t.apply(this, arguments);
  };

  return e.prototype = t.prototype, e;
},
    yf = function (t, e) {
  var i,
      n,
      o,
      r,
      s,
      a,
      h,
      l,
      d = t.target,
      u = t.global,
      c = t.stat,
      f = t.proto,
      p = u ? Cc : c ? Cc[d] : (Cc[d] || {}).prototype,
      v = u ? af : af[d] || (af[d] = {}),
      y = v.prototype;

  for (o in e) i = !sf(u ? o : d + (c ? "." : "#") + o, t.forced) && p && Gc(p, o), s = v[o], i && (a = t.noTargetGet ? (l = pf(p, o)) && l.value : p[o]), r = i && a ? a : e[o], i && typeof s == typeof r || (h = t.bind && i ? lf(r, Cc) : t.wrap && i ? vf(r) : f && "function" == typeof r ? lf(Function.call, r) : r, (t.sham || r && r.sham || s && s.sham) && ff(h, "sham", !0), v[o] = h, f && (Gc(af, n = d + "Prototype") || ff(af, n, {}), af[n][o] = r, t.real && y && !y[o] && ff(y, o, r)));
};

yf({
  target: "Object",
  stat: !0,
  forced: !Ac,
  sham: !Ac
}, {
  defineProperty: cf.f
});

var gf = Dc(function (t) {
  var e = af.Object,
      i = t.exports = function (t, i, n) {
    return e.defineProperty(t, i, n);
  };

  e.defineProperty.sham && (i.sham = !0);
}),
    mf = gf,
    bf = Math.ceil,
    wf = Math.floor,
    _f = function (t) {
  return isNaN(t = +t) ? 0 : (t > 0 ? wf : bf)(t);
},
    kf = Math.min,
    xf = function (t) {
  return t > 0 ? kf(_f(t), 9007199254740991) : 0;
},
    Of = Math.max,
    Sf = Math.min,
    Mf = function (t, e) {
  var i = _f(t);

  return i < 0 ? Of(i + e, 0) : Sf(i, e);
},
    Ef = function (t) {
  return function (e, i, n) {
    var o,
        r = Hc(e),
        s = xf(r.length),
        a = Mf(n, s);

    if (t && i != i) {
      for (; s > a;) if ((o = r[a++]) != o) return !0;
    } else for (; s > a; a++) if ((t || a in r) && r[a] === i) return t || a || 0;

    return !t && -1;
  };
},
    Df = {
  includes: Ef(!0),
  indexOf: Ef(!1)
},
    Tf = {},
    Cf = Df.indexOf,
    Pf = function (t, e) {
  var i,
      n = Hc(t),
      o = 0,
      r = [];

  for (i in n) !Gc(Tf, i) && Gc(n, i) && r.push(i);

  for (; e.length > o;) Gc(n, i = e[o++]) && (~Cf(r, i) || r.push(i));

  return r;
},
    Af = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    If = Object.keys || function (t) {
  return Pf(t, Af);
},
    Ff = Ac ? Object.defineProperties : function (t, e) {
  df(t);

  for (var i, n = If(e), o = n.length, r = 0; o > r;) cf.f(t, i = n[r++], e[i]);

  return t;
};

yf({
  target: "Object",
  stat: !0,
  forced: !Ac,
  sham: !Ac
}, {
  defineProperties: Ff
});

var Nf = Dc(function (t) {
  var e = af.Object,
      i = t.exports = function (t, i) {
    return e.defineProperties(t, i);
  };

  e.defineProperties.sham && (i.sham = !0);
}),
    jf = function (t) {
  return "function" == typeof t ? t : void 0;
},
    zf = function (t, e) {
  return arguments.length < 2 ? jf(af[t]) || jf(Cc[t]) : af[t] && af[t][e] || Cc[t] && Cc[t][e];
},
    Lf = Af.concat("length", "prototype"),
    Rf = {
  f: Object.getOwnPropertyNames || function (t) {
    return Pf(t, Lf);
  }
},
    Bf = {
  f: Object.getOwnPropertySymbols
},
    Yf = zf("Reflect", "ownKeys") || function (t) {
  var e = Rf.f(df(t)),
      i = Bf.f;
  return i ? e.concat(i(t)) : e;
},
    Hf = function (t, e, i) {
  var n = Vc(e);
  n in t ? cf.f(t, n, jc(0, i)) : t[n] = i;
};

yf({
  target: "Object",
  stat: !0,
  sham: !Ac
}, {
  getOwnPropertyDescriptors: function (t) {
    for (var e, i, n = Hc(t), o = Jc.f, r = Yf(n), s = {}, a = 0; r.length > a;) void 0 !== (i = o(n, e = r[a++])) && Hf(s, e, i);

    return s;
  }
});

var Wf,
    Vf,
    Uf,
    Gf = af.Object.getOwnPropertyDescriptors,
    qf = {},
    Xf = Cc["__core-js_shared__"] || function (t, e) {
  try {
    ff(Cc, t, e);
  } catch (i) {
    Cc[t] = e;
  }

  return e;
}("__core-js_shared__", {}),
    Zf = Dc(function (t) {
  (t.exports = function (t, e) {
    return Xf[t] || (Xf[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.4.0",
    mode: "pure",
    copyright: " 2019 Denis Pushkarev (zloirock.ru)"
  });
}),
    Kf = Zf("native-function-to-string", Function.toString),
    $f = Cc.WeakMap,
    Jf = "function" == typeof $f && /native code/.test(Kf.call($f)),
    Qf = 0,
    tp = Math.random(),
    ep = function (t) {
  return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++Qf + tp).toString(36);
},
    ip = Zf("keys"),
    np = function (t) {
  return ip[t] || (ip[t] = ep(t));
},
    op = Cc.WeakMap;

if (Jf) {
  var rp = new op(),
      sp = rp.get,
      ap = rp.has,
      hp = rp.set;
  Wf = function (t, e) {
    return hp.call(rp, t, e), e;
  }, Vf = function (t) {
    return sp.call(rp, t) || {};
  }, Uf = function (t) {
    return ap.call(rp, t);
  };
} else {
  var lp = np("state");
  Tf[lp] = !0, Wf = function (t, e) {
    return ff(t, lp, e), e;
  }, Vf = function (t) {
    return Gc(t, lp) ? t[lp] : {};
  }, Uf = function (t) {
    return Gc(t, lp);
  };
}

var dp,
    up,
    cp,
    fp = {
  set: Wf,
  get: Vf,
  has: Uf,
  enforce: function (t) {
    return Uf(t) ? Vf(t) : Wf(t, {});
  },
  getterFor: function (t) {
    return function (e) {
      var i;
      if (!Wc(e) || (i = Vf(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
      return i;
    };
  }
},
    pp = function (t) {
  return Object(Yc(t));
},
    vp = !Pc(function () {
  function t() {}

  return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
}),
    yp = np("IE_PROTO"),
    gp = Object.prototype,
    mp = vp ? Object.getPrototypeOf : function (t) {
  return t = pp(t), Gc(t, yp) ? t[yp] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? gp : null;
},
    bp = !!Object.getOwnPropertySymbols && !Pc(function () {
  return !String(Symbol());
}),
    wp = Cc.Symbol,
    _p = Zf("wks"),
    kp = function (t) {
  return _p[t] || (_p[t] = bp && wp[t] || (bp ? wp : ep)("Symbol." + t));
},
    xp = (kp("iterator"), !1);

[].keys && ("next" in (cp = [].keys()) ? (up = mp(mp(cp))) !== Object.prototype && (dp = up) : xp = !0), null == dp && (dp = {});

var Op = {
  IteratorPrototype: dp,
  BUGGY_SAFARI_ITERATORS: xp
},
    Sp = zf("document", "documentElement"),
    Mp = np("IE_PROTO"),
    Ep = function () {},
    Dp = function () {
  var t,
      e = Zc("iframe"),
      i = Af.length;

  for (e.style.display = "none", Sp.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), Dp = t.F; i--;) delete Dp.prototype[Af[i]];

  return Dp();
},
    Tp = Object.create || function (t, e) {
  var i;
  return null !== t ? (Ep.prototype = df(t), i = new Ep(), Ep.prototype = null, i[Mp] = t) : i = Dp(), void 0 === e ? i : Ff(i, e);
};

Tf[Mp] = !0;

var Cp = kp("toStringTag"),
    Pp = "Arguments" == Lc(function () {
  return arguments;
}()),
    Ap = function (t) {
  var e, i, n;
  return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function (t, e) {
    try {
      return t[e];
    } catch (t) {}
  }(e = Object(t), Cp)) ? i : Pp ? Lc(e) : "Object" == (n = Lc(e)) && "function" == typeof e.callee ? "Arguments" : n;
},
    Ip = {};

Ip[kp("toStringTag")] = "z";

var Fp = "[object z]" !== String(Ip) ? function () {
  return "[object " + Ap(this) + "]";
} : Ip.toString,
    Np = cf.f,
    jp = kp("toStringTag"),
    zp = Fp !== {}.toString,
    Lp = function (t, e, i, n) {
  if (t) {
    var o = i ? t : t.prototype;
    Gc(o, jp) || Np(o, jp, {
      configurable: !0,
      value: e
    }), n && zp && ff(o, "toString", Fp);
  }
},
    Rp = Op.IteratorPrototype,
    Bp = function () {
  return this;
},
    Yp = Object.setPrototypeOf || ("__proto__" in {} ? function () {
  var t,
      e = !1,
      i = {};

  try {
    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i, []), e = i instanceof Array;
  } catch (t) {}

  return function (i, n) {
    return df(i), function (t) {
      if (!Wc(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
    }(n), e ? t.call(i, n) : i.__proto__ = n, i;
  };
}() : void 0),
    Hp = function (t, e, i, n) {
  n && n.enumerable ? t[e] = i : ff(t, e, i);
},
    Wp = Op.IteratorPrototype,
    Vp = Op.BUGGY_SAFARI_ITERATORS,
    Up = kp("iterator"),
    Gp = function () {
  return this;
},
    qp = function (t, e, i, n, o, r, s) {
  !function (t, e, i) {
    var n = e + " Iterator";
    t.prototype = Tp(Rp, {
      next: jc(1, i)
    }), Lp(t, n, !1, !0), qf[n] = Bp;
  }(i, e, n);

  var a,
      h,
      l,
      d = function (t) {
    if (t === o && v) return v;
    if (!Vp && t in f) return f[t];

    switch (t) {
      case "keys":
      case "values":
      case "entries":
        return function () {
          return new i(this, t);
        };
    }

    return function () {
      return new i(this);
    };
  },
      u = e + " Iterator",
      c = !1,
      f = t.prototype,
      p = f[Up] || f["@@iterator"] || o && f[o],
      v = !Vp && p || d(o),
      y = "Array" == e && f.entries || p;

  if (y && (a = mp(y.call(new t())), Wp !== Object.prototype && a.next && (Lp(a, u, !0, !0), qf[u] = Gp)), "values" == o && p && "values" !== p.name && (c = !0, v = function () {
    return p.call(this);
  }), s && f[Up] !== v && ff(f, Up, v), qf[e] = v, o) if (h = {
    values: d("values"),
    keys: r ? v : d("keys"),
    entries: d("entries")
  }, s) for (l in h) !Vp && !c && l in f || Hp(f, l, h[l]);else yf({
    target: e,
    proto: !0,
    forced: Vp || c
  }, h);
  return h;
},
    Xp = fp.set,
    Zp = fp.getterFor("Array Iterator");

qp(Array, "Array", function (t, e) {
  Xp(this, {
    type: "Array Iterator",
    target: Hc(t),
    index: 0,
    kind: e
  });
}, function () {
  var t = Zp(this),
      e = t.target,
      i = t.kind,
      n = t.index++;
  return !e || n >= e.length ? (t.target = void 0, {
    value: void 0,
    done: !0
  }) : "keys" == i ? {
    value: n,
    done: !1
  } : "values" == i ? {
    value: e[n],
    done: !1
  } : {
    value: [n, e[n]],
    done: !1
  };
}, "values");
qf.Arguments = qf.Array;
var Kp = kp("toStringTag");

for (var $p in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var Jp = Cc[$p],
      Qp = Jp && Jp.prototype;
  Qp && !Qp[Kp] && ff(Qp, Kp, $p), qf[$p] = qf.Array;
}

var tv = Array.isArray || function (t) {
  return "Array" == Lc(t);
},
    ev = kp("species"),
    iv = function (t, e) {
  var i;
  return tv(t) && ("function" != typeof (i = t.constructor) || i !== Array && !tv(i.prototype) ? Wc(i) && null === (i = i[ev]) && (i = void 0) : i = void 0), new (void 0 === i ? Array : i)(0 === e ? 0 : e);
},
    nv = [].push,
    ov = function (t) {
  var e = 1 == t,
      i = 2 == t,
      n = 3 == t,
      o = 4 == t,
      r = 6 == t,
      s = 5 == t || r;
  return function (a, h, l, d) {
    for (var u, c, f = pp(a), p = Bc(f), v = lf(h, l, 3), y = xf(p.length), g = 0, m = d || iv, b = e ? m(a, y) : i ? m(a, 0) : void 0; y > g; g++) if ((s || g in p) && (c = v(u = p[g], g, f), t)) if (e) b[g] = c;else if (c) switch (t) {
      case 3:
        return !0;

      case 5:
        return u;

      case 6:
        return g;

      case 2:
        nv.call(b, u);
    } else if (o) return !1;

    return r ? -1 : n || o ? o : b;
  };
},
    rv = {
  forEach: ov(0),
  map: ov(1),
  filter: ov(2),
  some: ov(3),
  every: ov(4),
  find: ov(5),
  findIndex: ov(6)
},
    sv = function (t, e) {
  var i = [][t];
  return !i || !Pc(function () {
    i.call(null, e || function () {
      throw 1;
    }, 1);
  });
},
    av = rv.forEach,
    hv = sv("forEach") ? function (t) {
  return av(this, t, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;

yf({
  target: "Array",
  proto: !0,
  forced: [].forEach != hv
}, {
  forEach: hv
});

var lv = function (t) {
  return af[t + "Prototype"];
},
    dv = lv("Array").forEach,
    uv = Array.prototype,
    cv = {
  DOMTokenList: !0,
  NodeList: !0
},
    fv = function (t) {
  var e = t.forEach;
  return t === uv || t instanceof Array && e === uv.forEach || cv.hasOwnProperty(Ap(t)) ? dv : e;
},
    pv = Jc.f,
    vv = Pc(function () {
  pv(1);
});

yf({
  target: "Object",
  stat: !0,
  forced: !Ac || vv,
  sham: !Ac
}, {
  getOwnPropertyDescriptor: function (t, e) {
    return pv(Hc(t), e);
  }
});

var yv = Dc(function (t) {
  var e = af.Object,
      i = t.exports = function (t, i) {
    return e.getOwnPropertyDescriptor(t, i);
  };

  e.getOwnPropertyDescriptor.sham && (i.sham = !0);
}),
    gv = Rf.f,
    mv = {}.toString,
    bv = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
    wv = {
  f: function (t) {
    return bv && "[object Window]" == mv.call(t) ? function (t) {
      try {
        return gv(t);
      } catch (t) {
        return bv.slice();
      }
    }(t) : gv(Hc(t));
  }
},
    _v = {
  f: kp
},
    kv = cf.f,
    xv = function (t) {
  var e = af.Symbol || (af.Symbol = {});
  Gc(e, t) || kv(e, t, {
    value: _v.f(t)
  });
},
    Ov = rv.forEach,
    Sv = np("hidden"),
    Mv = kp("toPrimitive"),
    Ev = fp.set,
    Dv = fp.getterFor("Symbol"),
    Tv = Object.prototype,
    Cv = Cc.Symbol,
    Pv = zf("JSON", "stringify"),
    Av = Jc.f,
    Iv = cf.f,
    Fv = wv.f,
    Nv = Nc.f,
    jv = Zf("symbols"),
    zv = Zf("op-symbols"),
    Lv = Zf("string-to-symbol-registry"),
    Rv = Zf("symbol-to-string-registry"),
    Bv = Zf("wks"),
    Yv = Cc.QObject,
    Hv = !Yv || !Yv.prototype || !Yv.prototype.findChild,
    Wv = Ac && Pc(function () {
  return 7 != Tp(Iv({}, "a", {
    get: function () {
      return Iv(this, "a", {
        value: 7
      }).a;
    }
  })).a;
}) ? function (t, e, i) {
  var n = Av(Tv, e);
  n && delete Tv[e], Iv(t, e, i), n && t !== Tv && Iv(Tv, e, n);
} : Iv,
    Vv = function (t, e) {
  var i = jv[t] = Tp(Cv.prototype);
  return Ev(i, {
    type: "Symbol",
    tag: t,
    description: e
  }), Ac || (i.description = e), i;
},
    Uv = bp && "symbol" == typeof Cv.iterator ? function (t) {
  return "symbol" == typeof t;
} : function (t) {
  return Object(t) instanceof Cv;
},
    Gv = function (t, e, i) {
  t === Tv && Gv(zv, e, i), df(t);
  var n = Vc(e, !0);
  return df(i), Gc(jv, n) ? (i.enumerable ? (Gc(t, Sv) && t[Sv][n] && (t[Sv][n] = !1), i = Tp(i, {
    enumerable: jc(0, !1)
  })) : (Gc(t, Sv) || Iv(t, Sv, jc(1, {})), t[Sv][n] = !0), Wv(t, n, i)) : Iv(t, n, i);
},
    qv = function (t, e) {
  df(t);
  var i = Hc(e),
      n = If(i).concat($v(i));
  return Ov(n, function (e) {
    Ac && !Xv.call(i, e) || Gv(t, e, i[e]);
  }), t;
},
    Xv = function (t) {
  var e = Vc(t, !0),
      i = Nv.call(this, e);
  return !(this === Tv && Gc(jv, e) && !Gc(zv, e)) && (!(i || !Gc(this, e) || !Gc(jv, e) || Gc(this, Sv) && this[Sv][e]) || i);
},
    Zv = function (t, e) {
  var i = Hc(t),
      n = Vc(e, !0);

  if (i !== Tv || !Gc(jv, n) || Gc(zv, n)) {
    var o = Av(i, n);
    return !o || !Gc(jv, n) || Gc(i, Sv) && i[Sv][n] || (o.enumerable = !0), o;
  }
},
    Kv = function (t) {
  var e = Fv(Hc(t)),
      i = [];
  return Ov(e, function (t) {
    Gc(jv, t) || Gc(Tf, t) || i.push(t);
  }), i;
},
    $v = function (t) {
  var e = t === Tv,
      i = Fv(e ? zv : Hc(t)),
      n = [];
  return Ov(i, function (t) {
    !Gc(jv, t) || e && !Gc(Tv, t) || n.push(jv[t]);
  }), n;
};

if (bp || (Hp((Cv = function () {
  if (this instanceof Cv) throw TypeError("Symbol is not a constructor");

  var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
      e = ep(t),
      i = function (t) {
    this === Tv && i.call(zv, t), Gc(this, Sv) && Gc(this[Sv], e) && (this[Sv][e] = !1), Wv(this, e, jc(1, t));
  };

  return Ac && Hv && Wv(Tv, e, {
    configurable: !0,
    set: i
  }), Vv(e, t);
}).prototype, "toString", function () {
  return Dv(this).tag;
}), Nc.f = Xv, cf.f = Gv, Jc.f = Zv, Rf.f = wv.f = Kv, Bf.f = $v, Ac && Iv(Cv.prototype, "description", {
  configurable: !0,
  get: function () {
    return Dv(this).description;
  }
}), _v.f = function (t) {
  return Vv(kp(t), t);
}), yf({
  global: !0,
  wrap: !0,
  forced: !bp,
  sham: !bp
}, {
  Symbol: Cv
}), Ov(If(Bv), function (t) {
  xv(t);
}), yf({
  target: "Symbol",
  stat: !0,
  forced: !bp
}, {
  for: function (t) {
    var e = String(t);
    if (Gc(Lv, e)) return Lv[e];
    var i = Cv(e);
    return Lv[e] = i, Rv[i] = e, i;
  },
  keyFor: function (t) {
    if (!Uv(t)) throw TypeError(t + " is not a symbol");
    if (Gc(Rv, t)) return Rv[t];
  },
  useSetter: function () {
    Hv = !0;
  },
  useSimple: function () {
    Hv = !1;
  }
}), yf({
  target: "Object",
  stat: !0,
  forced: !bp,
  sham: !Ac
}, {
  create: function (t, e) {
    return void 0 === e ? Tp(t) : qv(Tp(t), e);
  },
  defineProperty: Gv,
  defineProperties: qv,
  getOwnPropertyDescriptor: Zv
}), yf({
  target: "Object",
  stat: !0,
  forced: !bp
}, {
  getOwnPropertyNames: Kv,
  getOwnPropertySymbols: $v
}), yf({
  target: "Object",
  stat: !0,
  forced: Pc(function () {
    Bf.f(1);
  })
}, {
  getOwnPropertySymbols: function (t) {
    return Bf.f(pp(t));
  }
}), Pv) {
  var Jv = !bp || Pc(function () {
    var t = Cv();
    return "[null]" != Pv([t]) || "{}" != Pv({
      a: t
    }) || "{}" != Pv(Object(t));
  });
  yf({
    target: "JSON",
    stat: !0,
    forced: Jv
  }, {
    stringify: function (t, e, i) {
      for (var n, o = [t], r = 1; arguments.length > r;) o.push(arguments[r++]);

      if (n = e, (Wc(e) || void 0 !== t) && !Uv(t)) return tv(e) || (e = function (t, e) {
        if ("function" == typeof n && (e = n.call(this, t, e)), !Uv(e)) return e;
      }), o[1] = e, Pv.apply(null, o);
    }
  });
}

Cv.prototype[Mv] || ff(Cv.prototype, Mv, Cv.prototype.valueOf), Lp(Cv, "Symbol"), Tf[Sv] = !0;

var Qv = af.Object.getOwnPropertySymbols,
    ty = lv("Array").entries,
    ey = Array.prototype,
    iy = {
  DOMTokenList: !0,
  NodeList: !0
},
    ny = function (t) {
  var e = t.entries;
  return t === ey || t instanceof Array && e === ey.entries || iy.hasOwnProperty(Ap(t)) ? ty : e;
},
    oy = [].slice,
    ry = {},
    sy = function (t, e, i) {
  if (!(e in ry)) {
    for (var n = [], o = 0; o < e; o++) n[o] = "a[" + o + "]";

    ry[e] = Function("C,a", "return new C(" + n.join(",") + ")");
  }

  return ry[e](t, i);
},
    ay = Function.bind || function (t) {
  var e = hf(this),
      i = oy.call(arguments, 1),
      n = function () {
    var o = i.concat(oy.call(arguments));
    return this instanceof n ? sy(e, o.length, o) : e.apply(t, o);
  };

  return Wc(e.prototype) && (n.prototype = e.prototype), n;
};

yf({
  target: "Function",
  proto: !0
}, {
  bind: ay
});

var hy = lv("Function").bind,
    ly = Function.prototype,
    dy = function (t) {
  var e = t.bind;
  return t === ly || t instanceof Function && e === ly.bind ? hy : e;
},
    uy = Dc(function (t) {
  var e = function (t) {
    var e,
        i = Object.prototype,
        n = i.hasOwnProperty,
        o = "function" == typeof Symbol ? Symbol : {},
        r = o.iterator || "@@iterator",
        s = o.asyncIterator || "@@asyncIterator",
        a = o.toStringTag || "@@toStringTag";

    function h(t, e, i, n) {
      var o = e && e.prototype instanceof v ? e : v,
          r = Object.create(o.prototype),
          s = new E(n || []);
      return r._invoke = function (t, e, i) {
        var n = d;
        return function (o, r) {
          if (n === c) throw new Error("Generator is already running");

          if (n === f) {
            if ("throw" === o) throw r;
            return T();
          }

          for (i.method = o, i.arg = r;;) {
            var s = i.delegate;

            if (s) {
              var a = O(s, i);

              if (a) {
                if (a === p) continue;
                return a;
              }
            }

            if ("next" === i.method) i.sent = i._sent = i.arg;else if ("throw" === i.method) {
              if (n === d) throw n = f, i.arg;
              i.dispatchException(i.arg);
            } else "return" === i.method && i.abrupt("return", i.arg);
            n = c;
            var h = l(t, e, i);

            if ("normal" === h.type) {
              if (n = i.done ? f : u, h.arg === p) continue;
              return {
                value: h.arg,
                done: i.done
              };
            }

            "throw" === h.type && (n = f, i.method = "throw", i.arg = h.arg);
          }
        };
      }(t, i, s), r;
    }

    function l(t, e, i) {
      try {
        return {
          type: "normal",
          arg: t.call(e, i)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }

    t.wrap = h;
    var d = "suspendedStart",
        u = "suspendedYield",
        c = "executing",
        f = "completed",
        p = {};

    function v() {}

    function y() {}

    function g() {}

    var m = {};

    m[r] = function () {
      return this;
    };

    var b = Object.getPrototypeOf,
        w = b && b(b(D([])));
    w && w !== i && n.call(w, r) && (m = w);

    var _ = g.prototype = v.prototype = Object.create(m);

    function k(t) {
      ["next", "throw", "return"].forEach(function (e) {
        t[e] = function (t) {
          return this._invoke(e, t);
        };
      });
    }

    function x(t) {
      var e;

      this._invoke = function (i, o) {
        function r() {
          return new Promise(function (e, r) {
            !function e(i, o, r, s) {
              var a = l(t[i], t, o);

              if ("throw" !== a.type) {
                var h = a.arg,
                    d = h.value;
                return d && "object" == typeof d && n.call(d, "__await") ? Promise.resolve(d.__await).then(function (t) {
                  e("next", t, r, s);
                }, function (t) {
                  e("throw", t, r, s);
                }) : Promise.resolve(d).then(function (t) {
                  h.value = t, r(h);
                }, function (t) {
                  return e("throw", t, r, s);
                });
              }

              s(a.arg);
            }(i, o, e, r);
          });
        }

        return e = e ? e.then(r, r) : r();
      };
    }

    function O(t, i) {
      var n = t.iterator[i.method];

      if (n === e) {
        if (i.delegate = null, "throw" === i.method) {
          if (t.iterator.return && (i.method = "return", i.arg = e, O(t, i), "throw" === i.method)) return p;
          i.method = "throw", i.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return p;
      }

      var o = l(n, t.iterator, i.arg);
      if ("throw" === o.type) return i.method = "throw", i.arg = o.arg, i.delegate = null, p;
      var r = o.arg;
      return r ? r.done ? (i[t.resultName] = r.value, i.next = t.nextLoc, "return" !== i.method && (i.method = "next", i.arg = e), i.delegate = null, p) : r : (i.method = "throw", i.arg = new TypeError("iterator result is not an object"), i.delegate = null, p);
    }

    function S(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }

    function M(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }

    function E(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(S, this), this.reset(!0);
    }

    function D(t) {
      if (t) {
        var i = t[r];
        if (i) return i.call(t);
        if ("function" == typeof t.next) return t;

        if (!isNaN(t.length)) {
          var o = -1,
              s = function i() {
            for (; ++o < t.length;) if (n.call(t, o)) return i.value = t[o], i.done = !1, i;

            return i.value = e, i.done = !0, i;
          };

          return s.next = s;
        }
      }

      return {
        next: T
      };
    }

    function T() {
      return {
        value: e,
        done: !0
      };
    }

    return y.prototype = _.constructor = g, g.constructor = y, g[a] = y.displayName = "GeneratorFunction", t.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === y || "GeneratorFunction" === (e.displayName || e.name));
    }, t.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, g) : (t.__proto__ = g, a in t || (t[a] = "GeneratorFunction")), t.prototype = Object.create(_), t;
    }, t.awrap = function (t) {
      return {
        __await: t
      };
    }, k(x.prototype), x.prototype[s] = function () {
      return this;
    }, t.AsyncIterator = x, t.async = function (e, i, n, o) {
      var r = new x(h(e, i, n, o));
      return t.isGeneratorFunction(i) ? r : r.next().then(function (t) {
        return t.done ? t.value : r.next();
      });
    }, k(_), _[a] = "Generator", _[r] = function () {
      return this;
    }, _.toString = function () {
      return "[object Generator]";
    }, t.keys = function (t) {
      var e = [];

      for (var i in t) e.push(i);

      return e.reverse(), function i() {
        for (; e.length;) {
          var n = e.pop();
          if (n in t) return i.value = n, i.done = !1, i;
        }

        return i.done = !0, i;
      };
    }, t.values = D, E.prototype = {
      constructor: E,
      reset: function (t) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(M), !t) for (var i in this) "t" === i.charAt(0) && n.call(this, i) && !isNaN(+i.slice(1)) && (this[i] = e);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (t) {
        if (this.done) throw t;
        var i = this;

        function o(n, o) {
          return a.type = "throw", a.arg = t, i.next = n, o && (i.method = "next", i.arg = e), !!o;
        }

        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var s = this.tryEntries[r],
              a = s.completion;
          if ("root" === s.tryLoc) return o("end");

          if (s.tryLoc <= this.prev) {
            var h = n.call(s, "catchLoc"),
                l = n.call(s, "finallyLoc");

            if (h && l) {
              if (this.prev < s.catchLoc) return o(s.catchLoc, !0);
              if (this.prev < s.finallyLoc) return o(s.finallyLoc);
            } else if (h) {
              if (this.prev < s.catchLoc) return o(s.catchLoc, !0);
            } else {
              if (!l) throw new Error("try statement without catch or finally");
              if (this.prev < s.finallyLoc) return o(s.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var o = this.tryEntries[i];

          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var r = o;
            break;
          }
        }

        r && ("break" === t || "continue" === t) && r.tryLoc <= e && e <= r.finallyLoc && (r = null);
        var s = r ? r.completion : {};
        return s.type = t, s.arg = e, r ? (this.method = "next", this.next = r.finallyLoc, p) : this.complete(s);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), p;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var i = this.tryEntries[e];
          if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), M(i), p;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var i = this.tryEntries[e];

          if (i.tryLoc === t) {
            var n = i.completion;

            if ("throw" === n.type) {
              var o = n.arg;
              M(i);
            }

            return o;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (t, i, n) {
        return this.delegate = {
          iterator: D(t),
          resultName: i,
          nextLoc: n
        }, "next" === this.method && (this.arg = e), p;
      }
    }, t;
  }(t.exports);

  try {
    regeneratorRuntime = e;
  } catch (t) {
    Function("r", "regeneratorRuntime = r")(e);
  }
});

xv("iterator");

var cy = function (t) {
  return function (e, i) {
    var n,
        o,
        r = String(Yc(e)),
        s = _f(i),
        a = r.length;

    return s < 0 || s >= a ? t ? "" : void 0 : (n = r.charCodeAt(s)) < 55296 || n > 56319 || s + 1 === a || (o = r.charCodeAt(s + 1)) < 56320 || o > 57343 ? t ? r.charAt(s) : n : t ? r.slice(s, s + 2) : o - 56320 + (n - 55296 << 10) + 65536;
  };
},
    fy = {
  codeAt: cy(!1),
  charAt: cy(!0)
}.charAt,
    py = fp.set,
    vy = fp.getterFor("String Iterator");

qp(String, "String", function (t) {
  py(this, {
    type: "String Iterator",
    string: String(t),
    index: 0
  });
}, function () {
  var t,
      e = vy(this),
      i = e.string,
      n = e.index;
  return n >= i.length ? {
    value: void 0,
    done: !0
  } : (t = fy(i, n), e.index += t.length, {
    value: t,
    done: !1
  });
});

var yy = _v.f("iterator"),
    gy = yy,
    my = zf("JSON", "stringify"),
    by = /[\uD800-\uDFFF]/g,
    wy = /^[\uD800-\uDBFF]$/,
    _y = /^[\uDC00-\uDFFF]$/,
    ky = function (t, e, i) {
  var n = i.charAt(e - 1),
      o = i.charAt(e + 1);
  return wy.test(t) && !_y.test(o) || _y.test(t) && !wy.test(n) ? "\\u" + t.charCodeAt(0).toString(16) : t;
},
    xy = Pc(function () {
  return '"\\udf06\\ud834"' !== my("\udf06\ud834") || '"\\udead"' !== my("\udead");
});

my && yf({
  target: "JSON",
  stat: !0,
  forced: xy
}, {
  stringify: function (t, e, i) {
    var n = my.apply(null, arguments);
    return "string" == typeof n ? n.replace(by, ky) : n;
  }
}), af.JSON || (af.JSON = {
  stringify: JSON.stringify
});

var Oy = function (t, e, i) {
  return af.JSON.stringify.apply(null, arguments);
},
    Sy = gf;

var My = function (t, e, i) {
  return e in t ? Sy(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
},
    Ey = lv("Array").values,
    Dy = Array.prototype,
    Ty = {
  DOMTokenList: !0,
  NodeList: !0
},
    Cy = function (t) {
  var e = t.values;
  return t === Dy || t instanceof Array && e === Dy.values || Ty.hasOwnProperty(Ap(t)) ? Ey : e;
},
    Py = kp("iterator"),
    Ay = function (t) {
  if (null != t) return t[Py] || t["@@iterator"] || qf[Ap(t)];
},
    Iy = function (t) {
  var e = Ay(t);
  if ("function" != typeof e) throw TypeError(String(t) + " is not iterable");
  return df(e.call(t));
},
    Fy = [].sort,
    Ny = [1, 2, 3],
    jy = Pc(function () {
  Ny.sort(void 0);
}),
    zy = Pc(function () {
  Ny.sort(null);
}),
    Ly = sv("sort");

yf({
  target: "Array",
  proto: !0,
  forced: jy || !zy || Ly
}, {
  sort: function (t) {
    return void 0 === t ? Fy.call(pp(this)) : Fy.call(pp(this), hf(t));
  }
});

var Ry = lv("Array").sort,
    By = Array.prototype,
    Yy = function (t) {
  var e = t.sort;
  return t === By || t instanceof Array && e === By.sort ? Ry : e;
},
    Hy = function (t) {
  return function (e, i, n, o) {
    hf(i);
    var r = pp(e),
        s = Bc(r),
        a = xf(r.length),
        h = t ? a - 1 : 0,
        l = t ? -1 : 1;
    if (n < 2) for (;;) {
      if (h in s) {
        o = s[h], h += l;
        break;
      }

      if (h += l, t ? h < 0 : a <= h) throw TypeError("Reduce of empty array with no initial value");
    }

    for (; t ? h >= 0 : a > h; h += l) h in s && (o = i(o, s[h], h, r));

    return o;
  };
},
    Wy = {
  left: Hy(!1),
  right: Hy(!0)
}.left;

yf({
  target: "Array",
  proto: !0,
  forced: sv("reduce")
}, {
  reduce: function (t) {
    return Wy(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Vy = lv("Array").reduce,
    Uy = Array.prototype,
    Gy = function (t) {
  var e = t.reduce;
  return t === Uy || t instanceof Array && e === Uy.reduce ? Vy : e;
},
    qy = lv("Array").keys,
    Xy = Array.prototype,
    Zy = {
  DOMTokenList: !0,
  NodeList: !0
},
    Ky = function (t) {
  var e = t.keys;
  return t === Xy || t instanceof Array && e === Xy.keys || Zy.hasOwnProperty(Ap(t)) ? qy : e;
};

yf({
  target: "Array",
  stat: !0
}, {
  isArray: tv
});
var $y = af.Array.isArray,
    Jy = $y;

var Qy = function (t) {
  if (Jy(t)) {
    for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];

    return i;
  }
},
    tg = function (t, e, i, n) {
  try {
    return n ? e(df(i)[0], i[1]) : e(i);
  } catch (e) {
    var o = t.return;
    throw void 0 !== o && df(o.call(t)), e;
  }
},
    eg = kp("iterator"),
    ig = Array.prototype,
    ng = function (t) {
  return void 0 !== t && (qf.Array === t || ig[eg] === t);
},
    og = kp("iterator"),
    rg = !1;

try {
  var sg = 0,
      ag = {
    next: function () {
      return {
        done: !!sg++
      };
    },
    return: function () {
      rg = !0;
    }
  };
  ag[og] = function () {
    return this;
  }, Array.from(ag, function () {
    throw 2;
  });
} catch (t) {}

var hg = !function (t, e) {
  if (!e && !rg) return !1;
  var i = !1;

  try {
    var n = {};
    n[og] = function () {
      return {
        next: function () {
          return {
            done: i = !0
          };
        }
      };
    }, t(n);
  } catch (t) {}

  return i;
}(function (t) {
  Array.from(t);
});
yf({
  target: "Array",
  stat: !0,
  forced: hg
}, {
  from: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = pp(t),
        a = "function" == typeof this ? this : Array,
        h = arguments.length,
        l = h > 1 ? arguments[1] : void 0,
        d = void 0 !== l,
        u = 0,
        c = Ay(s);
    if (d && (l = lf(l, h > 2 ? arguments[2] : void 0, 2)), null == c || a == Array && ng(c)) for (i = new a(e = xf(s.length)); e > u; u++) Hf(i, u, d ? l(s[u], u) : s[u]);else for (r = (o = c.call(s)).next, i = new a(); !(n = r.call(o)).done; u++) Hf(i, u, d ? tg(o, l, [n.value, u], !0) : n.value);
    return i.length = u, i;
  }
});

var lg = af.Array.from,
    dg = kp("iterator"),
    ug = function (t) {
  var e = Object(t);
  return void 0 !== e[dg] || "@@iterator" in e || qf.hasOwnProperty(Ap(e));
};

var cg = function (t) {
  if (ug(Object(t)) || "[object Arguments]" === Object.prototype.toString.call(t)) return lg(t);
};

var fg = function () {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
};

var pg,
    vg,
    yg = function (t) {
  return Qy(t) || cg(t) || fg();
},
    gg = zf("navigator", "userAgent") || "",
    mg = Cc.process,
    bg = mg && mg.versions,
    wg = bg && bg.v8;

wg ? vg = (pg = wg.split("."))[0] + pg[1] : gg && (!(pg = gg.match(/Edge\/(\d+)/)) || pg[1] >= 74) && (pg = gg.match(/Chrome\/(\d+)/)) && (vg = pg[1]);

var _g = vg && +vg,
    kg = kp("species"),
    xg = function (t) {
  return _g >= 51 || !Pc(function () {
    var e = [];
    return (e.constructor = {})[kg] = function () {
      return {
        foo: 1
      };
    }, 1 !== e[t](Boolean).foo;
  });
},
    Og = rv.filter;

yf({
  target: "Array",
  proto: !0,
  forced: !xg("filter")
}, {
  filter: function (t) {
    return Og(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Sg = lv("Array").filter,
    Mg = Array.prototype,
    Eg = function (t) {
  var e = t.filter;
  return t === Mg || t instanceof Array && e === Mg.filter ? Sg : e;
},
    Dg = kp("isConcatSpreadable"),
    Tg = _g >= 51 || !Pc(function () {
  var t = [];
  return t[Dg] = !1, t.concat()[0] !== t;
}),
    Cg = xg("concat"),
    Pg = function (t) {
  if (!Wc(t)) return !1;
  var e = t[Dg];
  return void 0 !== e ? !!e : tv(t);
};

yf({
  target: "Array",
  proto: !0,
  forced: !Tg || !Cg
}, {
  concat: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = pp(this),
        a = iv(s, 0),
        h = 0;

    for (e = -1, n = arguments.length; e < n; e++) if (r = -1 === e ? s : arguments[e], Pg(r)) {
      if (h + (o = xf(r.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");

      for (i = 0; i < o; i++, h++) i in r && Hf(a, h, r[i]);
    } else {
      if (h >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
      Hf(a, h++, r);
    }

    return a.length = h, a;
  }
});

var Ag = lv("Array").concat,
    Ig = Array.prototype,
    Fg = function (t) {
  var e = t.concat;
  return t === Ig || t instanceof Array && e === Ig.concat ? Ag : e;
},
    Ng = Object.assign,
    jg = !Ng || Pc(function () {
  var t = {},
      e = {},
      i = Symbol();
  return t[i] = 7, "abcdefghijklmnopqrst".split("").forEach(function (t) {
    e[t] = t;
  }), 7 != Ng({}, t)[i] || "abcdefghijklmnopqrst" != If(Ng({}, e)).join("");
}) ? function (t, e) {
  for (var i = pp(t), n = arguments.length, o = 1, r = Bf.f, s = Nc.f; n > o;) for (var a, h = Bc(arguments[o++]), l = r ? If(h).concat(r(h)) : If(h), d = l.length, u = 0; d > u;) a = l[u++], Ac && !s.call(h, a) || (i[a] = h[a]);

  return i;
} : Ng;

yf({
  target: "Object",
  stat: !0,
  forced: Object.assign !== jg
}, {
  assign: jg
});
var zg = af.Object.assign,
    Lg = rv.some;
yf({
  target: "Array",
  proto: !0,
  forced: sv("some")
}, {
  some: function (t) {
    return Lg(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Rg = lv("Array").some,
    Bg = Array.prototype,
    Yg = function (t) {
  var e = t.some;
  return t === Bg || t instanceof Array && e === Bg.some ? Rg : e;
},
    Hg = rv.map;

yf({
  target: "Array",
  proto: !0,
  forced: !xg("map")
}, {
  map: function (t) {
    return Hg(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Wg = lv("Array").map,
    Vg = Array.prototype,
    Ug = function (t) {
  var e = t.map;
  return t === Vg || t instanceof Array && e === Vg.map ? Wg : e;
},
    Gg = yy;

xv("asyncIterator"), xv("hasInstance"), xv("isConcatSpreadable"), xv("match"), xv("matchAll"), xv("replace"), xv("search"), xv("species"), xv("split"), xv("toPrimitive"), xv("toStringTag"), xv("unscopables"), Lp(Math, "Math", !0), Lp(Cc.JSON, "JSON", !0);
var qg = af.Symbol;
xv("asyncDispose"), xv("dispose"), xv("observable"), xv("patternMatch"), xv("replaceAll");
var Xg = qg,
    Zg = Dc(function (t) {
  function e(t) {
    return (e = "function" == typeof Xg && "symbol" == typeof Gg ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof Xg && t.constructor === Xg && t !== Xg.prototype ? "symbol" : typeof t;
    })(t);
  }

  function i(n) {
    return "function" == typeof Xg && "symbol" === e(Gg) ? t.exports = i = function (t) {
      return e(t);
    } : t.exports = i = function (t) {
      return t && "function" == typeof Xg && t.constructor === Xg && t !== Xg.prototype ? "symbol" : e(t);
    }, i(n);
  }

  t.exports = i;
}),
    Kg = Pc(function () {
  If(1);
});
yf({
  target: "Object",
  stat: !0,
  forced: Kg
}, {
  keys: function (t) {
    return If(pp(t));
  }
});

var $g = af.Object.keys,
    Jg = !Pc(function () {
  return Object.isExtensible(Object.preventExtensions({}));
}),
    Qg = Dc(function (t) {
  var e = cf.f,
      i = ep("meta"),
      n = 0,
      o = Object.isExtensible || function () {
    return !0;
  },
      r = function (t) {
    e(t, i, {
      value: {
        objectID: "O" + ++n,
        weakData: {}
      }
    });
  },
      s = t.exports = {
    REQUIRED: !1,
    fastKey: function (t, e) {
      if (!Wc(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;

      if (!Gc(t, i)) {
        if (!o(t)) return "F";
        if (!e) return "E";
        r(t);
      }

      return t[i].objectID;
    },
    getWeakData: function (t, e) {
      if (!Gc(t, i)) {
        if (!o(t)) return !0;
        if (!e) return !1;
        r(t);
      }

      return t[i].weakData;
    },
    onFreeze: function (t) {
      return Jg && s.REQUIRED && o(t) && !Gc(t, i) && r(t), t;
    }
  };

  Tf[i] = !0;
}),
    tm = (Qg.REQUIRED, Qg.fastKey, Qg.getWeakData, Qg.onFreeze, Dc(function (t) {
  var e = function (t, e) {
    this.stopped = t, this.result = e;
  };

  (t.exports = function (t, i, n, o, r) {
    var s,
        a,
        h,
        l,
        d,
        u,
        c,
        f = lf(i, n, o ? 2 : 1);
    if (r) s = t;else {
      if ("function" != typeof (a = Ay(t))) throw TypeError("Target is not iterable");

      if (ng(a)) {
        for (h = 0, l = xf(t.length); l > h; h++) if ((d = o ? f(df(c = t[h])[0], c[1]) : f(t[h])) && d instanceof e) return d;

        return new e(!1);
      }

      s = a.call(t);
    }

    for (u = s.next; !(c = u.call(s)).done;) if ("object" == typeof (d = tg(s, f, c.value, o)) && d && d instanceof e) return d;

    return new e(!1);
  }).stop = function (t) {
    return new e(!0, t);
  };
})),
    em = function (t, e, i) {
  if (!(t instanceof e)) throw TypeError("Incorrect " + (i ? i + " " : "") + "invocation");
  return t;
},
    im = cf.f,
    nm = rv.forEach,
    om = fp.set,
    rm = fp.getterFor,
    sm = function (t, e, i, n, o) {
  var r,
      s = Cc[t],
      a = s && s.prototype,
      h = n ? "set" : "add",
      l = {};

  if (Ac && "function" == typeof s && (o || a.forEach && !Pc(function () {
    new s().entries().next();
  }))) {
    r = e(function (e, i) {
      om(em(e, r, t), {
        type: t,
        collection: new s()
      }), null != i && tm(i, e[h], e, n);
    });
    var d = rm(t);
    nm(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function (t) {
      var e = "add" == t || "set" == t;
      t in a && (!o || "clear" != t) && ff(r.prototype, t, function (i, n) {
        var r = d(this).collection;
        if (!e && o && !Wc(i)) return "get" == t && void 0;
        var s = r[t](0 === i ? 0 : i, n);
        return e ? this : s;
      });
    }), o || im(r.prototype, "size", {
      get: function () {
        return d(this).collection.size;
      }
    });
  } else r = i.getConstructor(e, t, n, h), Qg.REQUIRED = !0;

  return Lp(r, t, !1, !0), l[t] = r, yf({
    global: !0,
    forced: !0
  }, l), o || i.setStrong(r, t, n), r;
},
    am = function (t, e, i) {
  for (var n in e) i && i.unsafe && t[n] ? t[n] = e[n] : Hp(t, n, e[n], i);

  return t;
},
    hm = kp("species"),
    lm = cf.f,
    dm = Qg.fastKey,
    um = fp.set,
    cm = fp.getterFor,
    fm = {
  getConstructor: function (t, e, i, n) {
    var o = t(function (t, r) {
      em(t, o, e), um(t, {
        type: e,
        index: Tp(null),
        first: void 0,
        last: void 0,
        size: 0
      }), Ac || (t.size = 0), null != r && tm(r, t[n], t, i);
    }),
        r = cm(e),
        s = function (t, e, i) {
      var n,
          o,
          s = r(t),
          h = a(t, e);
      return h ? h.value = i : (s.last = h = {
        index: o = dm(e, !0),
        key: e,
        value: i,
        previous: n = s.last,
        next: void 0,
        removed: !1
      }, s.first || (s.first = h), n && (n.next = h), Ac ? s.size++ : t.size++, "F" !== o && (s.index[o] = h)), t;
    },
        a = function (t, e) {
      var i,
          n = r(t),
          o = dm(e);
      if ("F" !== o) return n.index[o];

      for (i = n.first; i; i = i.next) if (i.key == e) return i;
    };

    return am(o.prototype, {
      clear: function () {
        for (var t = r(this), e = t.index, i = t.first; i;) i.removed = !0, i.previous && (i.previous = i.previous.next = void 0), delete e[i.index], i = i.next;

        t.first = t.last = void 0, Ac ? t.size = 0 : this.size = 0;
      },
      delete: function (t) {
        var e = r(this),
            i = a(this, t);

        if (i) {
          var n = i.next,
              o = i.previous;
          delete e.index[i.index], i.removed = !0, o && (o.next = n), n && (n.previous = o), e.first == i && (e.first = n), e.last == i && (e.last = o), Ac ? e.size-- : this.size--;
        }

        return !!i;
      },
      forEach: function (t) {
        for (var e, i = r(this), n = lf(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : i.first;) for (n(e.value, e.key, this); e && e.removed;) e = e.previous;
      },
      has: function (t) {
        return !!a(this, t);
      }
    }), am(o.prototype, i ? {
      get: function (t) {
        var e = a(this, t);
        return e && e.value;
      },
      set: function (t, e) {
        return s(this, 0 === t ? 0 : t, e);
      }
    } : {
      add: function (t) {
        return s(this, t = 0 === t ? 0 : t, t);
      }
    }), Ac && lm(o.prototype, "size", {
      get: function () {
        return r(this).size;
      }
    }), o;
  },
  setStrong: function (t, e, i) {
    var n = e + " Iterator",
        o = cm(e),
        r = cm(n);
    qp(t, e, function (t, e) {
      um(this, {
        type: n,
        target: t,
        state: o(t),
        kind: e,
        last: void 0
      });
    }, function () {
      for (var t = r(this), e = t.kind, i = t.last; i && i.removed;) i = i.previous;

      return t.target && (t.last = i = i ? i.next : t.state.first) ? "keys" == e ? {
        value: i.key,
        done: !1
      } : "values" == e ? {
        value: i.value,
        done: !1
      } : {
        value: [i.key, i.value],
        done: !1
      } : (t.target = void 0, {
        value: void 0,
        done: !0
      });
    }, i ? "entries" : "values", !i, !0), function (t) {
      var e = zf(t),
          i = cf.f;
      Ac && e && !e[hm] && i(e, hm, {
        configurable: !0,
        get: function () {
          return this;
        }
      });
    }(e);
  }
},
    pm = (sm("Map", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0);
  };
}, fm, !0), af.Map),
    vm = $y;

var ym = function (t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
};

function gm(t, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Sy(t, n.key, n);
  }
}

var mm = function (t, e, i) {
  return e && gm(t.prototype, e), i && gm(t, i), t;
};

var bm = function (t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
};

var wm = function (t, e) {
  return !e || "object" !== Zg(e) && "function" != typeof e ? bm(t) : e;
},
    _m = Pc(function () {
  mp(1);
});

yf({
  target: "Object",
  stat: !0,
  forced: _m,
  sham: !vp
}, {
  getPrototypeOf: function (t) {
    return mp(pp(t));
  }
});
var km = af.Object.getPrototypeOf;
yf({
  target: "Object",
  stat: !0
}, {
  setPrototypeOf: Yp
});
var xm = af.Object.setPrototypeOf,
    Om = Dc(function (t) {
  function e(i) {
    return t.exports = e = xm ? km : function (t) {
      return t.__proto__ || km(t);
    }, e(i);
  }

  t.exports = e;
});
yf({
  target: "Object",
  stat: !0,
  sham: !Ac
}, {
  create: Tp
});

var Sm = af.Object,
    Mm = function (t, e) {
  return Sm.create(t, e);
},
    Em = Mm,
    Dm = Dc(function (t) {
  function e(i, n) {
    return t.exports = e = xm || function (t, e) {
      return t.__proto__ = e, t;
    }, e(i, n);
  }

  t.exports = e;
});

for (var Tm = function (t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Em(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), e && Dm(t, e);
}, Cm = [], Pm = 0; Pm < 256; Pm++) Cm[Pm] = (Pm + 256).toString(16).substr(1);

for (var Am = function () {
  if ("undefined" != typeof crypto && crypto.getRandomValues) {
    var t = new Uint8Array(16);
    return function () {
      return crypto.getRandomValues(t), t;
    };
  }

  var e = new Array(16);
  return function () {
    for (var t, i = 0; i < 16; i++) 0 == (3 & i) && (t = 4294967296 * Math.random()), e[i] = t >>> ((3 & i) << 3) & 255;

    return e;
  };
}(), Im = [], Fm = 0; Fm < 256; Fm++) Im[Fm] = (Fm + 256).toString(16).substr(1);

var Nm = Am();
Nm[0], Nm[1], Nm[2], Nm[3], Nm[4], Nm[5], Nm[6], Nm[7];

function jm() {
  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      e = arguments.length > 1 ? arguments[1] : void 0,
      i = arguments.length > 2 ? arguments[2] : void 0,
      n = e && i || 0;
  "string" == typeof t && (e = "binary" === t ? new Array(16) : void 0, t = {});
  var o = t.random || (t.rng || Am)();
  if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) for (var r = 0; r < 16; r++) e[n + r] = o[r];
  return e || function (t, e) {
    var i = e || 0,
        n = Cm;
    return n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + "-" + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]] + n[t[i++]];
  }(o);
}

var zm = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function Lm() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}

function Rm(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var Bm = function (t) {
  return t && t.Math == Math && t;
},
    Ym = Bm("object" == typeof globalThis && globalThis) || Bm("object" == typeof window && window) || Bm("object" == typeof self && self) || Bm("object" == typeof zm && zm) || Function("return this")(),
    Hm = function (t) {
  try {
    return !!t();
  } catch (t) {
    return !0;
  }
},
    Wm = !Hm(function () {
  return 7 != Object.defineProperty({}, "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    Vm = {}.propertyIsEnumerable,
    Um = Object.getOwnPropertyDescriptor,
    Gm = {
  f: Um && !Vm.call({
    1: 2
  }, 1) ? function (t) {
    var e = Um(this, t);
    return !!e && e.enumerable;
  } : Vm
},
    qm = function (t, e) {
  return {
    enumerable: !(1 & t),
    configurable: !(2 & t),
    writable: !(4 & t),
    value: e
  };
},
    Xm = {}.toString,
    Zm = function (t) {
  return Xm.call(t).slice(8, -1);
},
    Km = "".split,
    $m = Hm(function () {
  return !Object("z").propertyIsEnumerable(0);
}) ? function (t) {
  return "String" == Zm(t) ? Km.call(t, "") : Object(t);
} : Object,
    Jm = function (t) {
  if (null == t) throw TypeError("Can't call method on " + t);
  return t;
},
    Qm = function (t) {
  return $m(Jm(t));
},
    tb = function (t) {
  return "object" == typeof t ? null !== t : "function" == typeof t;
},
    eb = function (t, e) {
  if (!tb(t)) return t;
  var i, n;
  if (e && "function" == typeof (i = t.toString) && !tb(n = i.call(t))) return n;
  if ("function" == typeof (i = t.valueOf) && !tb(n = i.call(t))) return n;
  if (!e && "function" == typeof (i = t.toString) && !tb(n = i.call(t))) return n;
  throw TypeError("Can't convert object to primitive value");
},
    ib = {}.hasOwnProperty,
    nb = function (t, e) {
  return ib.call(t, e);
},
    ob = Ym.document,
    rb = tb(ob) && tb(ob.createElement),
    sb = function (t) {
  return rb ? ob.createElement(t) : {};
},
    ab = !Wm && !Hm(function () {
  return 7 != Object.defineProperty(sb("div"), "a", {
    get: function () {
      return 7;
    }
  }).a;
}),
    hb = Object.getOwnPropertyDescriptor,
    lb = {
  f: Wm ? hb : function (t, e) {
    if (t = Qm(t), e = eb(e, !0), ab) try {
      return hb(t, e);
    } catch (t) {}
    if (nb(t, e)) return qm(!Gm.f.call(t, e), t[e]);
  }
},
    db = /#|\.prototype\./,
    ub = function (t, e) {
  var i = fb[cb(t)];
  return i == vb || i != pb && ("function" == typeof e ? Hm(e) : !!e);
},
    cb = ub.normalize = function (t) {
  return String(t).replace(db, ".").toLowerCase();
},
    fb = ub.data = {},
    pb = ub.NATIVE = "N",
    vb = ub.POLYFILL = "P",
    yb = ub,
    gb = {},
    mb = function (t) {
  if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
  return t;
},
    bb = function (t, e, i) {
  if (mb(t), void 0 === e) return t;

  switch (i) {
    case 0:
      return function () {
        return t.call(e);
      };

    case 1:
      return function (i) {
        return t.call(e, i);
      };

    case 2:
      return function (i, n) {
        return t.call(e, i, n);
      };

    case 3:
      return function (i, n, o) {
        return t.call(e, i, n, o);
      };
  }

  return function () {
    return t.apply(e, arguments);
  };
},
    wb = function (t) {
  if (!tb(t)) throw TypeError(String(t) + " is not an object");
  return t;
},
    _b = Object.defineProperty,
    kb = {
  f: Wm ? _b : function (t, e, i) {
    if (wb(t), e = eb(e, !0), wb(i), ab) try {
      return _b(t, e, i);
    } catch (t) {}
    if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
    return "value" in i && (t[e] = i.value), t;
  }
},
    xb = Wm ? function (t, e, i) {
  return kb.f(t, e, qm(1, i));
} : function (t, e, i) {
  return t[e] = i, t;
},
    Ob = lb.f,
    Sb = function (t) {
  var e = function (e, i, n) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new t();

        case 1:
          return new t(e);

        case 2:
          return new t(e, i);
      }

      return new t(e, i, n);
    }

    return t.apply(this, arguments);
  };

  return e.prototype = t.prototype, e;
},
    Mb = function (t, e) {
  var i,
      n,
      o,
      r,
      s,
      a,
      h,
      l,
      d = t.target,
      u = t.global,
      c = t.stat,
      f = t.proto,
      p = u ? Ym : c ? Ym[d] : (Ym[d] || {}).prototype,
      v = u ? gb : gb[d] || (gb[d] = {}),
      y = v.prototype;

  for (o in e) i = !yb(u ? o : d + (c ? "." : "#") + o, t.forced) && p && nb(p, o), s = v[o], i && (a = t.noTargetGet ? (l = Ob(p, o)) && l.value : p[o]), r = i && a ? a : e[o], i && typeof s == typeof r || (h = t.bind && i ? bb(r, Ym) : t.wrap && i ? Sb(r) : f && "function" == typeof r ? bb(Function.call, r) : r, (t.sham || r && r.sham || s && s.sham) && xb(h, "sham", !0), v[o] = h, f && (nb(gb, n = d + "Prototype") || xb(gb, n, {}), gb[n][o] = r, t.real && y && !y[o] && xb(y, o, r)));
};

Mb({
  target: "Object",
  stat: !0,
  forced: !Wm,
  sham: !Wm
}, {
  defineProperty: kb.f
});
Rm(function (t) {
  var e = gb.Object,
      i = t.exports = function (t, i, n) {
    return e.defineProperty(t, i, n);
  };

  e.defineProperty.sham && (i.sham = !0);
});

var Eb = Math.ceil,
    Db = Math.floor,
    Tb = function (t) {
  return isNaN(t = +t) ? 0 : (t > 0 ? Db : Eb)(t);
},
    Cb = Math.min,
    Pb = function (t) {
  return t > 0 ? Cb(Tb(t), 9007199254740991) : 0;
},
    Ab = Math.max,
    Ib = Math.min,
    Fb = function (t, e) {
  var i = Tb(t);
  return i < 0 ? Ab(i + e, 0) : Ib(i, e);
},
    Nb = function (t) {
  return function (e, i, n) {
    var o,
        r = Qm(e),
        s = Pb(r.length),
        a = Fb(n, s);

    if (t && i != i) {
      for (; s > a;) if ((o = r[a++]) != o) return !0;
    } else for (; s > a; a++) if ((t || a in r) && r[a] === i) return t || a || 0;

    return !t && -1;
  };
},
    jb = {
  includes: Nb(!0),
  indexOf: Nb(!1)
},
    zb = {},
    Lb = jb.indexOf,
    Rb = function (t, e) {
  var i,
      n = Qm(t),
      o = 0,
      r = [];

  for (i in n) !nb(zb, i) && nb(n, i) && r.push(i);

  for (; e.length > o;) nb(n, i = e[o++]) && (~Lb(r, i) || r.push(i));

  return r;
},
    Bb = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    Yb = Object.keys || function (t) {
  return Rb(t, Bb);
},
    Hb = Wm ? Object.defineProperties : function (t, e) {
  wb(t);

  for (var i, n = Yb(e), o = n.length, r = 0; o > r;) kb.f(t, i = n[r++], e[i]);

  return t;
};

Mb({
  target: "Object",
  stat: !0,
  forced: !Wm,
  sham: !Wm
}, {
  defineProperties: Hb
});
Rm(function (t) {
  var e = gb.Object,
      i = t.exports = function (t, i) {
    return e.defineProperties(t, i);
  };

  e.defineProperties.sham && (i.sham = !0);
});

var Wb = function (t) {
  return "function" == typeof t ? t : void 0;
},
    Vb = function (t, e) {
  return arguments.length < 2 ? Wb(gb[t]) || Wb(Ym[t]) : gb[t] && gb[t][e] || Ym[t] && Ym[t][e];
},
    Ub = Bb.concat("length", "prototype"),
    Gb = {
  f: Object.getOwnPropertyNames || function (t) {
    return Rb(t, Ub);
  }
},
    qb = {
  f: Object.getOwnPropertySymbols
},
    Xb = Vb("Reflect", "ownKeys") || function (t) {
  var e = Gb.f(wb(t)),
      i = qb.f;
  return i ? e.concat(i(t)) : e;
},
    Zb = function (t, e, i) {
  var n = eb(e);
  n in t ? kb.f(t, n, qm(0, i)) : t[n] = i;
};

Mb({
  target: "Object",
  stat: !0,
  sham: !Wm
}, {
  getOwnPropertyDescriptors: function (t) {
    for (var e, i, n = Qm(t), o = lb.f, r = Xb(n), s = {}, a = 0; r.length > a;) void 0 !== (i = o(n, e = r[a++])) && Zb(s, e, i);

    return s;
  }
});
gb.Object.getOwnPropertyDescriptors;
var Kb = lb.f,
    $b = Hm(function () {
  Kb(1);
});
Mb({
  target: "Object",
  stat: !0,
  forced: !Wm || $b,
  sham: !Wm
}, {
  getOwnPropertyDescriptor: function (t, e) {
    return Kb(Qm(t), e);
  }
});
Rm(function (t) {
  var e = gb.Object,
      i = t.exports = function (t, i) {
    return e.getOwnPropertyDescriptor(t, i);
  };

  e.getOwnPropertyDescriptor.sham && (i.sham = !0);
});

var Jb = !!Object.getOwnPropertySymbols && !Hm(function () {
  return !String(Symbol());
}),
    Qb = Array.isArray || function (t) {
  return "Array" == Zm(t);
},
    tw = function (t) {
  return Object(Jm(t));
},
    ew = Vb("document", "documentElement"),
    iw = Ym["__core-js_shared__"] || function (t, e) {
  try {
    xb(Ym, t, e);
  } catch (i) {
    Ym[t] = e;
  }

  return e;
}("__core-js_shared__", {}),
    nw = Rm(function (t) {
  (t.exports = function (t, e) {
    return iw[t] || (iw[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.4.1",
    mode: "pure",
    copyright: " 2019 Denis Pushkarev (zloirock.ru)"
  });
}),
    ow = 0,
    rw = Math.random(),
    sw = function (t) {
  return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++ow + rw).toString(36);
},
    aw = nw("keys"),
    hw = function (t) {
  return aw[t] || (aw[t] = sw(t));
},
    lw = hw("IE_PROTO"),
    dw = function () {},
    uw = function () {
  var t,
      e = sb("iframe"),
      i = Bb.length;

  for (e.style.display = "none", ew.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), uw = t.F; i--;) delete uw.prototype[Bb[i]];

  return uw();
},
    cw = Object.create || function (t, e) {
  var i;
  return null !== t ? (dw.prototype = wb(t), i = new dw(), dw.prototype = null, i[lw] = t) : i = uw(), void 0 === e ? i : Hb(i, e);
};

zb[lw] = !0;

var fw = Gb.f,
    pw = {}.toString,
    vw = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
    yw = {
  f: function (t) {
    return vw && "[object Window]" == pw.call(t) ? function (t) {
      try {
        return fw(t);
      } catch (t) {
        return vw.slice();
      }
    }(t) : fw(Qm(t));
  }
},
    gw = function (t, e, i, n) {
  n && n.enumerable ? t[e] = i : xb(t, e, i);
},
    mw = Ym.Symbol,
    bw = nw("wks"),
    ww = function (t) {
  return bw[t] || (bw[t] = Jb && mw[t] || (Jb ? mw : sw)("Symbol." + t));
},
    _w = {
  f: ww
},
    kw = kb.f,
    xw = function (t) {
  var e = gb.Symbol || (gb.Symbol = {});
  nb(e, t) || kw(e, t, {
    value: _w.f(t)
  });
},
    Ow = ww("toStringTag"),
    Sw = "Arguments" == Zm(function () {
  return arguments;
}()),
    Mw = function (t) {
  var e, i, n;
  return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function (t, e) {
    try {
      return t[e];
    } catch (t) {}
  }(e = Object(t), Ow)) ? i : Sw ? Zm(e) : "Object" == (n = Zm(e)) && "function" == typeof e.callee ? "Arguments" : n;
},
    Ew = {};

Ew[ww("toStringTag")] = "z";

var Dw,
    Tw,
    Cw,
    Pw = "[object z]" !== String(Ew) ? function () {
  return "[object " + Mw(this) + "]";
} : Ew.toString,
    Aw = kb.f,
    Iw = ww("toStringTag"),
    Fw = Pw !== {}.toString,
    Nw = function (t, e, i, n) {
  if (t) {
    var o = i ? t : t.prototype;
    nb(o, Iw) || Aw(o, Iw, {
      configurable: !0,
      value: e
    }), n && Fw && xb(o, "toString", Pw);
  }
},
    jw = nw("native-function-to-string", Function.toString),
    zw = Ym.WeakMap,
    Lw = "function" == typeof zw && /native code/.test(jw.call(zw)),
    Rw = Ym.WeakMap;

if (Lw) {
  var Bw = new Rw(),
      Yw = Bw.get,
      Hw = Bw.has,
      Ww = Bw.set;
  Dw = function (t, e) {
    return Ww.call(Bw, t, e), e;
  }, Tw = function (t) {
    return Yw.call(Bw, t) || {};
  }, Cw = function (t) {
    return Hw.call(Bw, t);
  };
} else {
  var Vw = hw("state");
  zb[Vw] = !0, Dw = function (t, e) {
    return xb(t, Vw, e), e;
  }, Tw = function (t) {
    return nb(t, Vw) ? t[Vw] : {};
  }, Cw = function (t) {
    return nb(t, Vw);
  };
}

var Uw = {
  set: Dw,
  get: Tw,
  has: Cw,
  enforce: function (t) {
    return Cw(t) ? Tw(t) : Dw(t, {});
  },
  getterFor: function (t) {
    return function (e) {
      var i;
      if (!tb(e) || (i = Tw(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
      return i;
    };
  }
},
    Gw = ww("species"),
    qw = function (t, e) {
  var i;
  return Qb(t) && ("function" != typeof (i = t.constructor) || i !== Array && !Qb(i.prototype) ? tb(i) && null === (i = i[Gw]) && (i = void 0) : i = void 0), new (void 0 === i ? Array : i)(0 === e ? 0 : e);
},
    Xw = [].push,
    Zw = function (t) {
  var e = 1 == t,
      i = 2 == t,
      n = 3 == t,
      o = 4 == t,
      r = 6 == t,
      s = 5 == t || r;
  return function (a, h, l, d) {
    for (var u, c, f = tw(a), p = $m(f), v = bb(h, l, 3), y = Pb(p.length), g = 0, m = d || qw, b = e ? m(a, y) : i ? m(a, 0) : void 0; y > g; g++) if ((s || g in p) && (c = v(u = p[g], g, f), t)) if (e) b[g] = c;else if (c) switch (t) {
      case 3:
        return !0;

      case 5:
        return u;

      case 6:
        return g;

      case 2:
        Xw.call(b, u);
    } else if (o) return !1;

    return r ? -1 : n || o ? o : b;
  };
},
    Kw = {
  forEach: Zw(0),
  map: Zw(1),
  filter: Zw(2),
  some: Zw(3),
  every: Zw(4),
  find: Zw(5),
  findIndex: Zw(6)
},
    $w = Kw.forEach,
    Jw = hw("hidden"),
    Qw = ww("toPrimitive"),
    t_ = Uw.set,
    e_ = Uw.getterFor("Symbol"),
    i_ = Object.prototype,
    n_ = Ym.Symbol,
    o_ = Vb("JSON", "stringify"),
    r_ = lb.f,
    s_ = kb.f,
    a_ = yw.f,
    h_ = Gm.f,
    l_ = nw("symbols"),
    d_ = nw("op-symbols"),
    u_ = nw("string-to-symbol-registry"),
    c_ = nw("symbol-to-string-registry"),
    f_ = nw("wks"),
    p_ = Ym.QObject,
    v_ = !p_ || !p_.prototype || !p_.prototype.findChild,
    y_ = Wm && Hm(function () {
  return 7 != cw(s_({}, "a", {
    get: function () {
      return s_(this, "a", {
        value: 7
      }).a;
    }
  })).a;
}) ? function (t, e, i) {
  var n = r_(i_, e);
  n && delete i_[e], s_(t, e, i), n && t !== i_ && s_(i_, e, n);
} : s_,
    g_ = function (t, e) {
  var i = l_[t] = cw(n_.prototype);
  return t_(i, {
    type: "Symbol",
    tag: t,
    description: e
  }), Wm || (i.description = e), i;
},
    m_ = Jb && "symbol" == typeof n_.iterator ? function (t) {
  return "symbol" == typeof t;
} : function (t) {
  return Object(t) instanceof n_;
},
    b_ = function (t, e, i) {
  t === i_ && b_(d_, e, i), wb(t);
  var n = eb(e, !0);
  return wb(i), nb(l_, n) ? (i.enumerable ? (nb(t, Jw) && t[Jw][n] && (t[Jw][n] = !1), i = cw(i, {
    enumerable: qm(0, !1)
  })) : (nb(t, Jw) || s_(t, Jw, qm(1, {})), t[Jw][n] = !0), y_(t, n, i)) : s_(t, n, i);
},
    w_ = function (t, e) {
  wb(t);
  var i = Qm(e),
      n = Yb(i).concat(O_(i));
  return $w(n, function (e) {
    Wm && !__.call(i, e) || b_(t, e, i[e]);
  }), t;
},
    __ = function (t) {
  var e = eb(t, !0),
      i = h_.call(this, e);
  return !(this === i_ && nb(l_, e) && !nb(d_, e)) && (!(i || !nb(this, e) || !nb(l_, e) || nb(this, Jw) && this[Jw][e]) || i);
},
    k_ = function (t, e) {
  var i = Qm(t),
      n = eb(e, !0);

  if (i !== i_ || !nb(l_, n) || nb(d_, n)) {
    var o = r_(i, n);
    return !o || !nb(l_, n) || nb(i, Jw) && i[Jw][n] || (o.enumerable = !0), o;
  }
},
    x_ = function (t) {
  var e = a_(Qm(t)),
      i = [];
  return $w(e, function (t) {
    nb(l_, t) || nb(zb, t) || i.push(t);
  }), i;
},
    O_ = function (t) {
  var e = t === i_,
      i = a_(e ? d_ : Qm(t)),
      n = [];
  return $w(i, function (t) {
    !nb(l_, t) || e && !nb(i_, t) || n.push(l_[t]);
  }), n;
};

if (Jb || (gw((n_ = function () {
  if (this instanceof n_) throw TypeError("Symbol is not a constructor");

  var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
      e = sw(t),
      i = function (t) {
    this === i_ && i.call(d_, t), nb(this, Jw) && nb(this[Jw], e) && (this[Jw][e] = !1), y_(this, e, qm(1, t));
  };

  return Wm && v_ && y_(i_, e, {
    configurable: !0,
    set: i
  }), g_(e, t);
}).prototype, "toString", function () {
  return e_(this).tag;
}), Gm.f = __, kb.f = b_, lb.f = k_, Gb.f = yw.f = x_, qb.f = O_, Wm && s_(n_.prototype, "description", {
  configurable: !0,
  get: function () {
    return e_(this).description;
  }
}), _w.f = function (t) {
  return g_(ww(t), t);
}), Mb({
  global: !0,
  wrap: !0,
  forced: !Jb,
  sham: !Jb
}, {
  Symbol: n_
}), $w(Yb(f_), function (t) {
  xw(t);
}), Mb({
  target: "Symbol",
  stat: !0,
  forced: !Jb
}, {
  for: function (t) {
    var e = String(t);
    if (nb(u_, e)) return u_[e];
    var i = n_(e);
    return u_[e] = i, c_[i] = e, i;
  },
  keyFor: function (t) {
    if (!m_(t)) throw TypeError(t + " is not a symbol");
    if (nb(c_, t)) return c_[t];
  },
  useSetter: function () {
    v_ = !0;
  },
  useSimple: function () {
    v_ = !1;
  }
}), Mb({
  target: "Object",
  stat: !0,
  forced: !Jb,
  sham: !Wm
}, {
  create: function (t, e) {
    return void 0 === e ? cw(t) : w_(cw(t), e);
  },
  defineProperty: b_,
  defineProperties: w_,
  getOwnPropertyDescriptor: k_
}), Mb({
  target: "Object",
  stat: !0,
  forced: !Jb
}, {
  getOwnPropertyNames: x_,
  getOwnPropertySymbols: O_
}), Mb({
  target: "Object",
  stat: !0,
  forced: Hm(function () {
    qb.f(1);
  })
}, {
  getOwnPropertySymbols: function (t) {
    return qb.f(tw(t));
  }
}), o_) {
  var S_ = !Jb || Hm(function () {
    var t = n_();
    return "[null]" != o_([t]) || "{}" != o_({
      a: t
    }) || "{}" != o_(Object(t));
  });
  Mb({
    target: "JSON",
    stat: !0,
    forced: S_
  }, {
    stringify: function (t, e, i) {
      for (var n, o = [t], r = 1; arguments.length > r;) o.push(arguments[r++]);

      if (n = e, (tb(e) || void 0 !== t) && !m_(t)) return Qb(e) || (e = function (t, e) {
        if ("function" == typeof n && (e = n.call(this, t, e)), !m_(e)) return e;
      }), o[1] = e, o_.apply(null, o);
    }
  });
}

n_.prototype[Qw] || xb(n_.prototype, Qw, n_.prototype.valueOf), Nw(n_, "Symbol"), zb[Jw] = !0;
gb.Object.getOwnPropertySymbols;
var M_,
    E_,
    D_,
    T_ = {},
    C_ = !Hm(function () {
  function t() {}

  return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
}),
    P_ = hw("IE_PROTO"),
    A_ = Object.prototype,
    I_ = C_ ? Object.getPrototypeOf : function (t) {
  return t = tw(t), nb(t, P_) ? t[P_] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? A_ : null;
},
    F_ = (ww("iterator"), !1);
[].keys && ("next" in (D_ = [].keys()) ? (E_ = I_(I_(D_))) !== Object.prototype && (M_ = E_) : F_ = !0), null == M_ && (M_ = {});

var N_ = {
  IteratorPrototype: M_,
  BUGGY_SAFARI_ITERATORS: F_
},
    j_ = N_.IteratorPrototype,
    z_ = function () {
  return this;
},
    L_ = (Object.setPrototypeOf || "__proto__" in {} && function () {
  var t,
      e = !1,
      i = {};

  try {
    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i, []), e = i instanceof Array;
  } catch (t) {}
}(), N_.IteratorPrototype),
    R_ = N_.BUGGY_SAFARI_ITERATORS,
    B_ = ww("iterator"),
    Y_ = function () {
  return this;
},
    H_ = function (t, e, i, n, o, r, s) {
  !function (t, e, i) {
    var n = e + " Iterator";
    t.prototype = cw(j_, {
      next: qm(1, i)
    }), Nw(t, n, !1, !0), T_[n] = z_;
  }(i, e, n);

  var a,
      h,
      l,
      d = function (t) {
    if (t === o && v) return v;
    if (!R_ && t in f) return f[t];

    switch (t) {
      case "keys":
      case "values":
      case "entries":
        return function () {
          return new i(this, t);
        };
    }

    return function () {
      return new i(this);
    };
  },
      u = e + " Iterator",
      c = !1,
      f = t.prototype,
      p = f[B_] || f["@@iterator"] || o && f[o],
      v = !R_ && p || d(o),
      y = "Array" == e && f.entries || p;

  if (y && (a = I_(y.call(new t())), L_ !== Object.prototype && a.next && (Nw(a, u, !0, !0), T_[u] = Y_)), "values" == o && p && "values" !== p.name && (c = !0, v = function () {
    return p.call(this);
  }), s && f[B_] !== v && xb(f, B_, v), T_[e] = v, o) if (h = {
    values: d("values"),
    keys: r ? v : d("keys"),
    entries: d("entries")
  }, s) for (l in h) !R_ && !c && l in f || gw(f, l, h[l]);else Mb({
    target: e,
    proto: !0,
    forced: R_ || c
  }, h);
  return h;
},
    W_ = Uw.set,
    V_ = Uw.getterFor("Array Iterator");

H_(Array, "Array", function (t, e) {
  W_(this, {
    type: "Array Iterator",
    target: Qm(t),
    index: 0,
    kind: e
  });
}, function () {
  var t = V_(this),
      e = t.target,
      i = t.kind,
      n = t.index++;
  return !e || n >= e.length ? (t.target = void 0, {
    value: void 0,
    done: !0
  }) : "keys" == i ? {
    value: n,
    done: !1
  } : "values" == i ? {
    value: e[n],
    done: !1
  } : {
    value: [n, e[n]],
    done: !1
  };
}, "values");
T_.Arguments = T_.Array;
var U_ = ww("toStringTag");

for (var G_ in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var q_ = Ym[G_],
      X_ = q_ && q_.prototype;
  X_ && !X_[U_] && xb(X_, U_, G_), T_[G_] = T_.Array;
}

var Z_ = function (t) {
  return function (e, i) {
    var n,
        o,
        r = String(Jm(e)),
        s = Tb(i),
        a = r.length;
    return s < 0 || s >= a ? t ? "" : void 0 : (n = r.charCodeAt(s)) < 55296 || n > 56319 || s + 1 === a || (o = r.charCodeAt(s + 1)) < 56320 || o > 57343 ? t ? r.charAt(s) : n : t ? r.slice(s, s + 2) : o - 56320 + (n - 55296 << 10) + 65536;
  };
},
    K_ = {
  codeAt: Z_(!1),
  charAt: Z_(!0)
}.charAt,
    $_ = Uw.set,
    J_ = Uw.getterFor("String Iterator");

H_(String, "String", function (t) {
  $_(this, {
    type: "String Iterator",
    string: String(t),
    index: 0
  });
}, function () {
  var t,
      e = J_(this),
      i = e.string,
      n = e.index;
  return n >= i.length ? {
    value: void 0,
    done: !0
  } : (t = K_(i, n), e.index += t.length, {
    value: t,
    done: !1
  });
});

var Q_ = ww("iterator"),
    tk = function (t) {
  if (null != t) return t[Q_] || t["@@iterator"] || T_[Mw(t)];
};

Mb({
  target: "Object",
  stat: !0,
  sham: !Wm
}, {
  create: cw
});
var ek = Hm(function () {
  Yb(1);
});
Mb({
  target: "Object",
  stat: !0,
  forced: ek
}, {
  keys: function (t) {
    return Yb(tw(t));
  }
});

var ik = gb.Object.keys,
    nk = "\t\n\v\f\r \u2028\u2029\ufeff",
    ok = "[" + nk + "]",
    rk = RegExp("^" + ok + ok + "*"),
    sk = RegExp(ok + ok + "*$"),
    ak = function (t) {
  return function (e) {
    var i = String(Jm(e));
    return 1 & t && (i = i.replace(rk, "")), 2 & t && (i = i.replace(sk, "")), i;
  };
},
    hk = {
  start: ak(1),
  end: ak(2),
  trim: ak(3)
},
    lk = hk.trim;

Mb({
  target: "String",
  proto: !0,
  forced: function (t) {
    return Hm(function () {
      return !!nk[t]() || "" != ""[t]() || nk[t].name !== t;
    });
  }("trim")
}, {
  trim: function () {
    return lk(this);
  }
});

var dk = function (t) {
  return gb[t + "Prototype"];
},
    uk = (dk("String").trim, function (t, e) {
  var i = [][t];
  return !i || !Hm(function () {
    i.call(null, e || function () {
      throw 1;
    }, 1);
  });
}),
    ck = Kw.forEach,
    fk = uk("forEach") ? function (t) {
  return ck(this, t, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;

Mb({
  target: "Array",
  proto: !0,
  forced: [].forEach != fk
}, {
  forEach: fk
});

var pk,
    vk,
    yk = dk("Array").forEach,
    gk = Array.prototype,
    mk = {
  DOMTokenList: !0,
  NodeList: !0
},
    bk = function (t) {
  var e = t.forEach;
  return t === gk || t instanceof Array && e === gk.forEach || mk.hasOwnProperty(Mw(t)) ? yk : e;
},
    wk = Vb("navigator", "userAgent") || "",
    _k = Ym.process,
    kk = _k && _k.versions,
    xk = kk && kk.v8;

xk ? vk = (pk = xk.split("."))[0] + pk[1] : wk && (!(pk = wk.match(/Edge\/(\d+)/)) || pk[1] >= 74) && (pk = wk.match(/Chrome\/(\d+)/)) && (vk = pk[1]);

var Ok = vk && +vk,
    Sk = ww("species"),
    Mk = function (t) {
  return Ok >= 51 || !Hm(function () {
    var e = [];
    return (e.constructor = {})[Sk] = function () {
      return {
        foo: 1
      };
    }, 1 !== e[t](Boolean).foo;
  });
},
    Ek = Kw.map;

Mb({
  target: "Array",
  proto: !0,
  forced: !Mk("map")
}, {
  map: function (t) {
    return Ek(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
dk("Array").map;
var Dk = hk.trim,
    Tk = Ym.parseInt,
    Ck = /^[+-]?0[Xx]/,
    Pk = 8 !== Tk(nk + "08") || 22 !== Tk(nk + "0x16") ? function (t, e) {
  var i = Dk(String(t));
  return Tk(i, e >>> 0 || (Ck.test(i) ? 16 : 10));
} : Tk;
Mb({
  global: !0,
  forced: parseInt != Pk
}, {
  parseInt: Pk
});

var Ak = gb.parseInt,
    Ik = Gm.f,
    Fk = function (t) {
  return function (e) {
    for (var i, n = Qm(e), o = Yb(n), r = o.length, s = 0, a = []; r > s;) i = o[s++], Wm && !Ik.call(n, i) || a.push(t ? [i, n[i]] : n[i]);

    return a;
  };
},
    Nk = {
  entries: Fk(!0),
  values: Fk(!1)
}.values;

Mb({
  target: "Object",
  stat: !0
}, {
  values: function (t) {
    return Nk(t);
  }
});
gb.Object.values;
var jk = Kw.filter;
Mb({
  target: "Array",
  proto: !0,
  forced: !Mk("filter")
}, {
  filter: function (t) {
    return jk(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
dk("Array").filter;

var zk = ww("isConcatSpreadable"),
    Lk = Ok >= 51 || !Hm(function () {
  var t = [];
  return t[zk] = !1, t.concat()[0] !== t;
}),
    Rk = Mk("concat"),
    Bk = function (t) {
  if (!tb(t)) return !1;
  var e = t[zk];
  return void 0 !== e ? !!e : Qb(t);
};

Mb({
  target: "Array",
  proto: !0,
  forced: !Lk || !Rk
}, {
  concat: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = tw(this),
        a = qw(s, 0),
        h = 0;

    for (e = -1, n = arguments.length; e < n; e++) if (r = -1 === e ? s : arguments[e], Bk(r)) {
      if (h + (o = Pb(r.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");

      for (i = 0; i < o; i++, h++) i in r && Zb(a, h, r[i]);
    } else {
      if (h >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
      Zb(a, h++, r);
    }

    return a.length = h, a;
  }
});

var Yk = dk("Array").concat,
    Hk = Array.prototype,
    Wk = function (t) {
  var e = t.concat;
  return t === Hk || t instanceof Array && e === Hk.concat ? Yk : e;
};

Mb({
  target: "Array",
  stat: !0
}, {
  isArray: Qb
});

var Vk = gb.Array.isArray,
    Uk = function (t, e, i, n) {
  try {
    return n ? e(wb(i)[0], i[1]) : e(i);
  } catch (e) {
    var o = t.return;
    throw void 0 !== o && wb(o.call(t)), e;
  }
},
    Gk = ww("iterator"),
    qk = Array.prototype,
    Xk = function (t) {
  return void 0 !== t && (T_.Array === t || qk[Gk] === t);
},
    Zk = ww("iterator"),
    Kk = !1;

try {
  var $k = 0,
      Jk = {
    next: function () {
      return {
        done: !!$k++
      };
    },
    return: function () {
      Kk = !0;
    }
  };
  Jk[Zk] = function () {
    return this;
  }, Array.from(Jk, function () {
    throw 2;
  });
} catch (t) {}

var Qk = !function (t, e) {
  if (!e && !Kk) return !1;
  var i = !1;

  try {
    var n = {};
    n[Zk] = function () {
      return {
        next: function () {
          return {
            done: i = !0
          };
        }
      };
    }, t(n);
  } catch (t) {}

  return i;
}(function (t) {
  Array.from(t);
});
Mb({
  target: "Array",
  stat: !0,
  forced: Qk
}, {
  from: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = tw(t),
        a = "function" == typeof this ? this : Array,
        h = arguments.length,
        l = h > 1 ? arguments[1] : void 0,
        d = void 0 !== l,
        u = 0,
        c = tk(s);
    if (d && (l = bb(l, h > 2 ? arguments[2] : void 0, 2)), null == c || a == Array && Xk(c)) for (i = new a(e = Pb(s.length)); e > u; u++) Zb(i, u, d ? l(s[u], u) : s[u]);else for (r = (o = c.call(s)).next, i = new a(); !(n = r.call(o)).done; u++) Zb(i, u, d ? Uk(o, l, [n.value, u], !0) : n.value);
    return i.length = u, i;
  }
});
gb.Array.from, ww("iterator");
var tx = ww("species"),
    ex = [].slice,
    ix = Math.max;
Mb({
  target: "Array",
  proto: !0,
  forced: !Mk("slice")
}, {
  slice: function (t, e) {
    var i,
        n,
        o,
        r = Qm(this),
        s = Pb(r.length),
        a = Fb(t, s),
        h = Fb(void 0 === e ? s : e, s);
    if (Qb(r) && ("function" != typeof (i = r.constructor) || i !== Array && !Qb(i.prototype) ? tb(i) && null === (i = i[tx]) && (i = void 0) : i = void 0, i === Array || void 0 === i)) return ex.call(r, a, h);

    for (n = new (void 0 === i ? Array : i)(ix(h - a, 0)), o = 0; a < h; a++, o++) a in r && Zb(n, o, r[a]);

    return n.length = o, n;
  }
});

var nx = dk("Array").slice,
    ox = Array.prototype,
    rx = function (t) {
  var e = t.slice;
  return t === ox || t instanceof Array && e === ox.slice ? nx : e;
},
    sx = Hm(function () {
  I_(1);
});

Mb({
  target: "Object",
  stat: !0,
  forced: sx,
  sham: !C_
}, {
  getPrototypeOf: function (t) {
    return I_(tw(t));
  }
});
var ax = gb.Object.getPrototypeOf,
    hx = jb.indexOf,
    lx = [].indexOf,
    dx = !!lx && 1 / [1].indexOf(1, -0) < 0,
    ux = uk("indexOf");
Mb({
  target: "Array",
  proto: !0,
  forced: dx || ux
}, {
  indexOf: function (t) {
    return dx ? lx.apply(this, arguments) || 0 : hx(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var cx = dk("Array").indexOf,
    fx = Array.prototype,
    px = function (t) {
  var e = t.indexOf;
  return t === fx || t instanceof Array && e === fx.indexOf ? cx : e;
},
    vx = Vk,
    yx = Object.assign,
    gx = !yx || Hm(function () {
  var t = {},
      e = {},
      i = Symbol();
  return t[i] = 7, "abcdefghijklmnopqrst".split("").forEach(function (t) {
    e[t] = t;
  }), 7 != yx({}, t)[i] || "abcdefghijklmnopqrst" != Yb(yx({}, e)).join("");
}) ? function (t, e) {
  for (var i = tw(t), n = arguments.length, o = 1, r = qb.f, s = Gm.f; n > o;) for (var a, h = $m(arguments[o++]), l = r ? Yb(h).concat(r(h)) : Yb(h), d = l.length, u = 0; d > u;) a = l[u++], Wm && !s.call(h, a) || (i[a] = h[a]);

  return i;
} : yx;

Mb({
  target: "Object",
  stat: !0,
  forced: Object.assign !== gx
}, {
  assign: gx
});
gb.Object.assign;
xw("iterator");

var mx = _w.f("iterator");

xw("asyncIterator"), xw("hasInstance"), xw("isConcatSpreadable"), xw("match"), xw("matchAll"), xw("replace"), xw("search"), xw("species"), xw("split"), xw("toPrimitive"), xw("toStringTag"), xw("unscopables"), Nw(Math, "Math", !0), Nw(Ym.JSON, "JSON", !0);
var bx = gb.Symbol;
xw("asyncDispose"), xw("dispose"), xw("observable"), xw("patternMatch"), xw("replaceAll");

var wx = bx,
    _x = Rm(function (t) {
  function e(t) {
    return (e = "function" == typeof wx && "symbol" == typeof mx ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof wx && t.constructor === wx && t !== wx.prototype ? "symbol" : typeof t;
    })(t);
  }

  function i(n) {
    return "function" == typeof wx && "symbol" === e(mx) ? t.exports = i = function (t) {
      return e(t);
    } : t.exports = i = function (t) {
      return t && "function" == typeof wx && t.constructor === wx && t !== wx.prototype ? "symbol" : e(t);
    }, i(n);
  }

  t.exports = i;
}),
    kx = hk.trim,
    xx = Ym.parseFloat,
    Ox = 1 / xx(nk + "-0") != -1 / 0 ? function (t) {
  var e = kx(String(t)),
      i = xx(e);
  return 0 === i && "-" == e.charAt(0) ? -0 : i;
} : xx;

Mb({
  global: !0,
  forced: parseFloat != Ox
}, {
  parseFloat: Ox
});
var Sx = gb.parseFloat;
Mb({
  target: "Date",
  stat: !0
}, {
  now: function () {
    return new Date().getTime();
  }
});
var Mx = gb.Date.now,
    Ex = [],
    Dx = Ex.sort,
    Tx = Hm(function () {
  Ex.sort(void 0);
}),
    Cx = Hm(function () {
  Ex.sort(null);
}),
    Px = uk("sort");
Mb({
  target: "Array",
  proto: !0,
  forced: Tx || !Cx || Px
}, {
  sort: function (t) {
    return void 0 === t ? Dx.call(tw(this)) : Dx.call(tw(this), mb(t));
  }
});

var Ax = dk("Array").sort,
    Ix = Array.prototype,
    Fx = function (t) {
  var e = t.sort;
  return t === Ix || t instanceof Array && e === Ix.sort ? Ax : e;
},
    Nx = Object.isFrozen,
    jx = Hm(function () {
  Nx(1);
});

Mb({
  target: "Object",
  stat: !0,
  forced: jx
}, {
  isFrozen: function (t) {
    return !tb(t) || !!Nx && Nx(t);
  }
});
var zx = gb.Object.isFrozen,
    Lx = Kw.some;
Mb({
  target: "Array",
  proto: !0,
  forced: uk("some")
}, {
  some: function (t) {
    return Lx(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var Rx = dk("Array").some,
    Bx = Array.prototype,
    Yx = function (t) {
  var e = t.some;
  return t === Bx || t instanceof Array && e === Bx.some ? Rx : e;
},
    Hx = yw.f,
    Wx = Hm(function () {
  return !Object.getOwnPropertyNames(1);
});

Mb({
  target: "Object",
  stat: !0,
  forced: Wx
}, {
  getOwnPropertyNames: Hx
});

for (var Vx = gb.Object, Ux = function (t) {
  return Vx.getOwnPropertyNames(t);
}, Gx = Rm(function (t, e) {
  t.exports = function () {
    var e, i;

    function n() {
      return e.apply(null, arguments);
    }

    function o(t) {
      return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t);
    }

    function r(t) {
      return null != t && "[object Object]" === Object.prototype.toString.call(t);
    }

    function s(t) {
      return void 0 === t;
    }

    function a(t) {
      return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t);
    }

    function h(t) {
      return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t);
    }

    function l(t, e) {
      var i,
          n = [];

      for (i = 0; i < t.length; ++i) n.push(e(t[i], i));

      return n;
    }

    function d(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }

    function u(t, e) {
      for (var i in e) d(e, i) && (t[i] = e[i]);

      return d(e, "toString") && (t.toString = e.toString), d(e, "valueOf") && (t.valueOf = e.valueOf), t;
    }

    function c(t, e, i, n) {
      return Ae(t, e, i, n, !0).utc();
    }

    function f(t) {
      return null == t._pf && (t._pf = {
        empty: !1,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: !1,
        invalidMonth: null,
        invalidFormat: !1,
        userInvalidated: !1,
        iso: !1,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: !1,
        weekdayMismatch: !1
      }), t._pf;
    }

    function p(t) {
      if (null == t._isValid) {
        var e = f(t),
            n = i.call(e.parsedDateParts, function (t) {
          return null != t;
        }),
            o = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && n);
        if (t._strict && (o = o && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != zx && zx(t)) return o;
        t._isValid = o;
      }

      return t._isValid;
    }

    function v(t) {
      var e = c(NaN);
      return null != t ? u(f(e), t) : f(e).userInvalidated = !0, e;
    }

    i = Yx(Array.prototype) ? Yx(Array.prototype) : function (t) {
      for (var e = Object(this), i = e.length >>> 0, n = 0; n < i; n++) if ((n in e) && t.call(this, e[n], n, e)) return !0;

      return !1;
    };
    var y = n.momentProperties = [];

    function g(t, e) {
      var i, n, o;
      if (s(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), s(e._i) || (t._i = e._i), s(e._f) || (t._f = e._f), s(e._l) || (t._l = e._l), s(e._strict) || (t._strict = e._strict), s(e._tzm) || (t._tzm = e._tzm), s(e._isUTC) || (t._isUTC = e._isUTC), s(e._offset) || (t._offset = e._offset), s(e._pf) || (t._pf = f(e)), s(e._locale) || (t._locale = e._locale), y.length > 0) for (i = 0; i < y.length; i++) s(o = e[n = y[i]]) || (t[n] = o);
      return t;
    }

    var m = !1;

    function b(t) {
      g(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === m && (m = !0, n.updateOffset(this), m = !1);
    }

    function w(t) {
      return t instanceof b || null != t && null != t._isAMomentObject;
    }

    function _(t) {
      return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
    }

    function k(t) {
      var e = +t,
          i = 0;
      return 0 !== e && isFinite(e) && (i = _(e)), i;
    }

    function x(t, e, i) {
      var n,
          o = Math.min(t.length, e.length),
          r = Math.abs(t.length - e.length),
          s = 0;

      for (n = 0; n < o; n++) (i && t[n] !== e[n] || !i && k(t[n]) !== k(e[n])) && s++;

      return s + r;
    }

    function O(t) {
      !1 === n.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t);
    }

    function S(t, e) {
      var i = !0;
      return u(function () {
        if (null != n.deprecationHandler && n.deprecationHandler(null, t), i) {
          for (var o, r = [], s = 0; s < arguments.length; s++) {
            if (o = "", "object" === _x(arguments[s])) {
              for (var a in o += "\n[" + s + "] ", arguments[0]) o += a + ": " + arguments[0][a] + ", ";

              o = rx(o).call(o, 0, -2);
            } else o = arguments[s];

            r.push(o);
          }

          O(t + "\nArguments: " + rx(Array.prototype).call(r).join("") + "\n" + new Error().stack), i = !1;
        }

        return e.apply(this, arguments);
      }, e);
    }

    var M,
        E = {};

    function D(t, e) {
      null != n.deprecationHandler && n.deprecationHandler(t, e), E[t] || (O(e), E[t] = !0);
    }

    function T(t) {
      return t instanceof Function || "[object Function]" === Object.prototype.toString.call(t);
    }

    function C(t, e) {
      var i,
          n = u({}, t);

      for (i in e) d(e, i) && (r(t[i]) && r(e[i]) ? (n[i] = {}, u(n[i], t[i]), u(n[i], e[i])) : null != e[i] ? n[i] = e[i] : delete n[i]);

      for (i in t) d(t, i) && !d(e, i) && r(t[i]) && (n[i] = u({}, n[i]));

      return n;
    }

    function P(t) {
      null != t && this.set(t);
    }

    n.suppressDeprecationWarnings = !1, n.deprecationHandler = null, M = ik || function (t) {
      var e,
          i = [];

      for (e in t) d(t, e) && i.push(e);

      return i;
    };
    var A = {};

    function I(t, e) {
      var i = t.toLowerCase();
      A[i] = A[i + "s"] = A[e] = t;
    }

    function F(t) {
      return "string" == typeof t ? A[t] || A[t.toLowerCase()] : void 0;
    }

    function N(t) {
      var e,
          i,
          n = {};

      for (i in t) d(t, i) && (e = F(i)) && (n[e] = t[i]);

      return n;
    }

    var j = {};

    function z(t, e) {
      j[t] = e;
    }

    function L(t, e, i) {
      var n = "" + Math.abs(t),
          o = e - n.length;
      return (t >= 0 ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, o)).toString().substr(1) + n;
    }

    var R = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        B = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        Y = {},
        H = {};

    function W(t, e, i, n) {
      var o = n;
      "string" == typeof n && (o = function () {
        return this[n]();
      }), t && (H[t] = o), e && (H[e[0]] = function () {
        return L(o.apply(this, arguments), e[1], e[2]);
      }), i && (H[i] = function () {
        return this.localeData().ordinal(o.apply(this, arguments), t);
      });
    }

    function V(t, e) {
      return t.isValid() ? (e = U(e, t.localeData()), Y[e] = Y[e] || function (t) {
        var e,
            i,
            n,
            o = t.match(R);

        for (e = 0, i = o.length; e < i; e++) H[o[e]] ? o[e] = H[o[e]] : o[e] = (n = o[e]).match(/\[[\s\S]/) ? n.replace(/^\[|\]$/g, "") : n.replace(/\\/g, "");

        return function (e) {
          var n,
              r = "";

          for (n = 0; n < i; n++) r += T(o[n]) ? o[n].call(e, t) : o[n];

          return r;
        };
      }(e), Y[e](t)) : t.localeData().invalidDate();
    }

    function U(t, e) {
      var i = 5;

      function n(t) {
        return e.longDateFormat(t) || t;
      }

      for (B.lastIndex = 0; i >= 0 && B.test(t);) t = t.replace(B, n), B.lastIndex = 0, i -= 1;

      return t;
    }

    var G = /\d/,
        q = /\d\d/,
        X = /\d{3}/,
        Z = /\d{4}/,
        K = /[+-]?\d{6}/,
        $ = /\d\d?/,
        J = /\d\d\d\d?/,
        Q = /\d\d\d\d\d\d?/,
        tt = /\d{1,3}/,
        et = /\d{1,4}/,
        it = /[+-]?\d{1,6}/,
        nt = /\d+/,
        ot = /[+-]?\d+/,
        rt = /Z|[+-]\d\d:?\d\d/gi,
        st = /Z|[+-]\d\d(?::?\d\d)?/gi,
        at = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        ht = {};

    function lt(t, e, i) {
      ht[t] = T(e) ? e : function (t, n) {
        return t && i ? i : e;
      };
    }

    function dt(t, e) {
      return d(ht, t) ? ht[t](e._strict, e._locale) : new RegExp(ut(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, o) {
        return e || i || n || o;
      })));
    }

    function ut(t) {
      return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }

    var ct = {};

    function ft(t, e) {
      var i,
          n = e;

      for ("string" == typeof t && (t = [t]), a(e) && (n = function (t, i) {
        i[e] = k(t);
      }), i = 0; i < t.length; i++) ct[t[i]] = n;
    }

    function pt(t, e) {
      ft(t, function (t, i, n, o) {
        n._w = n._w || {}, e(t, n._w, n, o);
      });
    }

    function vt(t, e, i) {
      null != e && d(ct, t) && ct[t](e, i._a, i, t);
    }

    var yt = 0,
        gt = 1,
        mt = 2,
        bt = 3,
        wt = 4,
        _t = 5,
        kt = 6,
        xt = 7,
        Ot = 8;

    function St(t) {
      return Mt(t) ? 366 : 365;
    }

    function Mt(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    }

    W("Y", 0, 0, function () {
      var t = this.year();
      return t <= 9999 ? "" + t : "+" + t;
    }), W(0, ["YY", 2], 0, function () {
      return this.year() % 100;
    }), W(0, ["YYYY", 4], 0, "year"), W(0, ["YYYYY", 5], 0, "year"), W(0, ["YYYYYY", 6, !0], 0, "year"), I("year", "y"), z("year", 1), lt("Y", ot), lt("YY", $, q), lt("YYYY", et, Z), lt("YYYYY", it, K), lt("YYYYYY", it, K), ft(["YYYYY", "YYYYYY"], yt), ft("YYYY", function (t, e) {
      e[yt] = 2 === t.length ? n.parseTwoDigitYear(t) : k(t);
    }), ft("YY", function (t, e) {
      e[yt] = n.parseTwoDigitYear(t);
    }), ft("Y", function (t, e) {
      e[yt] = Ak(t, 10);
    }), n.parseTwoDigitYear = function (t) {
      return k(t) + (k(t) > 68 ? 1900 : 2e3);
    };
    var Et,
        Dt = Tt("FullYear", !0);

    function Tt(t, e) {
      return function (i) {
        return null != i ? (Pt(this, t, i), n.updateOffset(this, e), this) : Ct(this, t);
      };
    }

    function Ct(t, e) {
      return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN;
    }

    function Pt(t, e, i) {
      t.isValid() && !isNaN(i) && ("FullYear" === e && Mt(t.year()) && 1 === t.month() && 29 === t.date() ? t._d["set" + (t._isUTC ? "UTC" : "") + e](i, t.month(), At(i, t.month())) : t._d["set" + (t._isUTC ? "UTC" : "") + e](i));
    }

    function At(t, e) {
      if (isNaN(t) || isNaN(e)) return NaN;

      var i = function (t, e) {
        return (t % e + e) % e;
      }(e, 12);

      return t += (e - i) / 12, 1 === i ? Mt(t) ? 29 : 28 : 31 - i % 7 % 2;
    }

    Et = px(Array.prototype) ? px(Array.prototype) : function (t) {
      var e;

      for (e = 0; e < this.length; ++e) if (this[e] === t) return e;

      return -1;
    }, W("M", ["MM", 2], "Mo", function () {
      return this.month() + 1;
    }), W("MMM", 0, 0, function (t) {
      return this.localeData().monthsShort(this, t);
    }), W("MMMM", 0, 0, function (t) {
      return this.localeData().months(this, t);
    }), I("month", "M"), z("month", 8), lt("M", $), lt("MM", $, q), lt("MMM", function (t, e) {
      return e.monthsShortRegex(t);
    }), lt("MMMM", function (t, e) {
      return e.monthsRegex(t);
    }), ft(["M", "MM"], function (t, e) {
      e[gt] = k(t) - 1;
    }), ft(["MMM", "MMMM"], function (t, e, i, n) {
      var o = i._locale.monthsParse(t, n, i._strict);

      null != o ? e[gt] = o : f(i).invalidMonth = t;
    });
    var It = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        Ft = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        Nt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

    function jt(t, e, i) {
      var n,
          o,
          r,
          s = t.toLocaleLowerCase();
      if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n) r = c([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[n] = this.months(r, "").toLocaleLowerCase();
      return i ? "MMM" === e ? -1 !== (o = Et.call(this._shortMonthsParse, s)) ? o : null : -1 !== (o = Et.call(this._longMonthsParse, s)) ? o : null : "MMM" === e ? -1 !== (o = Et.call(this._shortMonthsParse, s)) ? o : -1 !== (o = Et.call(this._longMonthsParse, s)) ? o : null : -1 !== (o = Et.call(this._longMonthsParse, s)) ? o : -1 !== (o = Et.call(this._shortMonthsParse, s)) ? o : null;
    }

    function zt(t, e) {
      var i;
      if (!t.isValid()) return t;
      if ("string" == typeof e) if (/^\d+$/.test(e)) e = k(e);else if (!a(e = t.localeData().monthsParse(e))) return t;
      return i = Math.min(t.date(), At(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i), t;
    }

    function Lt(t) {
      return null != t ? (zt(this, t), n.updateOffset(this, !0), this) : Ct(this, "Month");
    }

    var Rt = at,
        Bt = at;

    function Yt() {
      function t(t, e) {
        return e.length - t.length;
      }

      var e,
          i,
          n = [],
          o = [],
          r = [];

      for (e = 0; e < 12; e++) i = c([2e3, e]), n.push(this.monthsShort(i, "")), o.push(this.months(i, "")), r.push(this.months(i, "")), r.push(this.monthsShort(i, ""));

      for (Fx(n).call(n, t), Fx(o).call(o, t), Fx(r).call(r, t), e = 0; e < 12; e++) n[e] = ut(n[e]), o[e] = ut(o[e]);

      for (e = 0; e < 24; e++) r[e] = ut(r[e]);

      this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i");
    }

    function Ht(t, e, i, n, o, r, s) {
      var a;
      return t < 100 && t >= 0 ? (a = new Date(t + 400, e, i, n, o, r, s), isFinite(a.getFullYear()) && a.setFullYear(t)) : a = new Date(t, e, i, n, o, r, s), a;
    }

    function Wt(t) {
      var e;

      if (t < 100 && t >= 0) {
        var i = rx(Array.prototype).call(arguments);
        i[0] = t + 400, e = new Date(Date.UTC.apply(null, i)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t);
      } else e = new Date(Date.UTC.apply(null, arguments));

      return e;
    }

    function Vt(t, e, i) {
      var n = 7 + e - i;
      return -(7 + Wt(t, 0, n).getUTCDay() - e) % 7 + n - 1;
    }

    function Ut(t, e, i, n, o) {
      var r,
          s,
          a = 1 + 7 * (e - 1) + (7 + i - n) % 7 + Vt(t, n, o);
      return a <= 0 ? s = St(r = t - 1) + a : a > St(t) ? (r = t + 1, s = a - St(t)) : (r = t, s = a), {
        year: r,
        dayOfYear: s
      };
    }

    function Gt(t, e, i) {
      var n,
          o,
          r = Vt(t.year(), e, i),
          s = Math.floor((t.dayOfYear() - r - 1) / 7) + 1;
      return s < 1 ? n = s + qt(o = t.year() - 1, e, i) : s > qt(t.year(), e, i) ? (n = s - qt(t.year(), e, i), o = t.year() + 1) : (o = t.year(), n = s), {
        week: n,
        year: o
      };
    }

    function qt(t, e, i) {
      var n = Vt(t, e, i),
          o = Vt(t + 1, e, i);
      return (St(t) - n + o) / 7;
    }

    function Xt(t, e) {
      var i;
      return Wk(i = rx(t).call(t, e, 7)).call(i, rx(t).call(t, 0, e));
    }

    W("w", ["ww", 2], "wo", "week"), W("W", ["WW", 2], "Wo", "isoWeek"), I("week", "w"), I("isoWeek", "W"), z("week", 5), z("isoWeek", 5), lt("w", $), lt("ww", $, q), lt("W", $), lt("WW", $, q), pt(["w", "ww", "W", "WW"], function (t, e, i, n) {
      e[n.substr(0, 1)] = k(t);
    }), W("d", 0, "do", "day"), W("dd", 0, 0, function (t) {
      return this.localeData().weekdaysMin(this, t);
    }), W("ddd", 0, 0, function (t) {
      return this.localeData().weekdaysShort(this, t);
    }), W("dddd", 0, 0, function (t) {
      return this.localeData().weekdays(this, t);
    }), W("e", 0, 0, "weekday"), W("E", 0, 0, "isoWeekday"), I("day", "d"), I("weekday", "e"), I("isoWeekday", "E"), z("day", 11), z("weekday", 11), z("isoWeekday", 11), lt("d", $), lt("e", $), lt("E", $), lt("dd", function (t, e) {
      return e.weekdaysMinRegex(t);
    }), lt("ddd", function (t, e) {
      return e.weekdaysShortRegex(t);
    }), lt("dddd", function (t, e) {
      return e.weekdaysRegex(t);
    }), pt(["dd", "ddd", "dddd"], function (t, e, i, n) {
      var o = i._locale.weekdaysParse(t, n, i._strict);

      null != o ? e.d = o : f(i).invalidWeekday = t;
    }), pt(["d", "e", "E"], function (t, e, i, n) {
      e[n] = k(t);
    });
    var Zt = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        Kt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        $t = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

    function Jt(t, e, i) {
      var n,
          o,
          r,
          s = t.toLocaleLowerCase();
      if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n) r = c([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(r, "").toLocaleLowerCase();
      return i ? "dddd" === e ? -1 !== (o = Et.call(this._weekdaysParse, s)) ? o : null : "ddd" === e ? -1 !== (o = Et.call(this._shortWeekdaysParse, s)) ? o : null : -1 !== (o = Et.call(this._minWeekdaysParse, s)) ? o : null : "dddd" === e ? -1 !== (o = Et.call(this._weekdaysParse, s)) ? o : -1 !== (o = Et.call(this._shortWeekdaysParse, s)) ? o : -1 !== (o = Et.call(this._minWeekdaysParse, s)) ? o : null : "ddd" === e ? -1 !== (o = Et.call(this._shortWeekdaysParse, s)) ? o : -1 !== (o = Et.call(this._weekdaysParse, s)) ? o : -1 !== (o = Et.call(this._minWeekdaysParse, s)) ? o : null : -1 !== (o = Et.call(this._minWeekdaysParse, s)) ? o : -1 !== (o = Et.call(this._weekdaysParse, s)) ? o : -1 !== (o = Et.call(this._shortWeekdaysParse, s)) ? o : null;
    }

    var Qt = at,
        te = at,
        ee = at;

    function ie() {
      function t(t, e) {
        return e.length - t.length;
      }

      var e,
          i,
          n,
          o,
          r,
          s = [],
          a = [],
          h = [],
          l = [];

      for (e = 0; e < 7; e++) i = c([2e3, 1]).day(e), n = this.weekdaysMin(i, ""), o = this.weekdaysShort(i, ""), r = this.weekdays(i, ""), s.push(n), a.push(o), h.push(r), l.push(n), l.push(o), l.push(r);

      for (Fx(s).call(s, t), Fx(a).call(a, t), Fx(h).call(h, t), Fx(l).call(l, t), e = 0; e < 7; e++) a[e] = ut(a[e]), h[e] = ut(h[e]), l[e] = ut(l[e]);

      this._weekdaysRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + s.join("|") + ")", "i");
    }

    function ne() {
      return this.hours() % 12 || 12;
    }

    function oe(t, e) {
      W(t, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), e);
      });
    }

    function re(t, e) {
      return e._meridiemParse;
    }

    W("H", ["HH", 2], 0, "hour"), W("h", ["hh", 2], 0, ne), W("k", ["kk", 2], 0, function () {
      return this.hours() || 24;
    }), W("hmm", 0, 0, function () {
      return "" + ne.apply(this) + L(this.minutes(), 2);
    }), W("hmmss", 0, 0, function () {
      return "" + ne.apply(this) + L(this.minutes(), 2) + L(this.seconds(), 2);
    }), W("Hmm", 0, 0, function () {
      return "" + this.hours() + L(this.minutes(), 2);
    }), W("Hmmss", 0, 0, function () {
      return "" + this.hours() + L(this.minutes(), 2) + L(this.seconds(), 2);
    }), oe("a", !0), oe("A", !1), I("hour", "h"), z("hour", 13), lt("a", re), lt("A", re), lt("H", $), lt("h", $), lt("k", $), lt("HH", $, q), lt("hh", $, q), lt("kk", $, q), lt("hmm", J), lt("hmmss", Q), lt("Hmm", J), lt("Hmmss", Q), ft(["H", "HH"], bt), ft(["k", "kk"], function (t, e, i) {
      var n = k(t);
      e[bt] = 24 === n ? 0 : n;
    }), ft(["a", "A"], function (t, e, i) {
      i._isPm = i._locale.isPM(t), i._meridiem = t;
    }), ft(["h", "hh"], function (t, e, i) {
      e[bt] = k(t), f(i).bigHour = !0;
    }), ft("hmm", function (t, e, i) {
      var n = t.length - 2;
      e[bt] = k(t.substr(0, n)), e[wt] = k(t.substr(n)), f(i).bigHour = !0;
    }), ft("hmmss", function (t, e, i) {
      var n = t.length - 4,
          o = t.length - 2;
      e[bt] = k(t.substr(0, n)), e[wt] = k(t.substr(n, 2)), e[_t] = k(t.substr(o)), f(i).bigHour = !0;
    }), ft("Hmm", function (t, e, i) {
      var n = t.length - 2;
      e[bt] = k(t.substr(0, n)), e[wt] = k(t.substr(n));
    }), ft("Hmmss", function (t, e, i) {
      var n = t.length - 4,
          o = t.length - 2;
      e[bt] = k(t.substr(0, n)), e[wt] = k(t.substr(n, 2)), e[_t] = k(t.substr(o));
    });
    var se,
        ae = Tt("Hours", !0),
        he = {
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      longDateFormat: {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      invalidDate: "Invalid date",
      ordinal: "%d",
      dayOfMonthOrdinalParse: /\d{1,2}/,
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      months: Ft,
      monthsShort: Nt,
      week: {
        dow: 0,
        doy: 6
      },
      weekdays: Zt,
      weekdaysMin: $t,
      weekdaysShort: Kt,
      meridiemParse: /[ap]\.?m?\.?/i
    },
        le = {},
        de = {};

    function ue(t) {
      return t ? t.toLowerCase().replace("_", "-") : t;
    }

    function ce(e) {
      var i = null;
      if (!le[e] && t && t.exports) try {
        i = se._abbr, Lm(), fe(i);
      } catch (t) {}
      return le[e];
    }

    function fe(t, e) {
      var i;
      return t && ((i = s(e) ? ve(t) : pe(t, e)) ? se = i : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), se._abbr;
    }

    function pe(t, e) {
      if (null !== e) {
        var i,
            n,
            o = he;
        if (e.abbr = t, null != le[t]) D("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), o = le[t]._config;else if (null != e.parentLocale) if (null != le[e.parentLocale]) o = le[e.parentLocale]._config;else {
          if (null == (i = ce(e.parentLocale))) return de[e.parentLocale] || (de[e.parentLocale] = []), de[e.parentLocale].push({
            name: t,
            config: e
          }), null;
          o = i._config;
        }
        return le[t] = new P(C(o, e)), de[t] && bk(n = de[t]).call(n, function (t) {
          pe(t.name, t.config);
        }), fe(t), le[t];
      }

      return delete le[t], null;
    }

    function ve(t) {
      var e;
      if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return se;

      if (!o(t)) {
        if (e = ce(t)) return e;
        t = [t];
      }

      return function (t) {
        for (var e, i, n, o, r = 0; r < t.length;) {
          for (e = (o = ue(t[r]).split("-")).length, i = (i = ue(t[r + 1])) ? i.split("-") : null; e > 0;) {
            if (n = ce(rx(o).call(o, 0, e).join("-"))) return n;
            if (i && i.length >= e && x(o, i, !0) >= e - 1) break;
            e--;
          }

          r++;
        }

        return se;
      }(t);
    }

    function ye(t) {
      var e,
          i = t._a;
      return i && -2 === f(t).overflow && (e = i[gt] < 0 || i[gt] > 11 ? gt : i[mt] < 1 || i[mt] > At(i[yt], i[gt]) ? mt : i[bt] < 0 || i[bt] > 24 || 24 === i[bt] && (0 !== i[wt] || 0 !== i[_t] || 0 !== i[kt]) ? bt : i[wt] < 0 || i[wt] > 59 ? wt : i[_t] < 0 || i[_t] > 59 ? _t : i[kt] < 0 || i[kt] > 999 ? kt : -1, f(t)._overflowDayOfYear && (e < yt || e > mt) && (e = mt), f(t)._overflowWeeks && -1 === e && (e = xt), f(t)._overflowWeekday && -1 === e && (e = Ot), f(t).overflow = e), t;
    }

    function ge(t, e, i) {
      return null != t ? t : null != e ? e : i;
    }

    function me(t) {
      var e,
          i,
          o,
          r,
          s,
          a = [];

      if (!t._d) {
        for (o = function (t) {
          var e = new Date(n.now());
          return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()];
        }(t), t._w && null == t._a[mt] && null == t._a[gt] && function (t) {
          var e, i, n, o, r, s, a, h;
          if (null != (e = t._w).GG || null != e.W || null != e.E) r = 1, s = 4, i = ge(e.GG, t._a[yt], Gt(Ie(), 1, 4).year), n = ge(e.W, 1), ((o = ge(e.E, 1)) < 1 || o > 7) && (h = !0);else {
            r = t._locale._week.dow, s = t._locale._week.doy;
            var l = Gt(Ie(), r, s);
            i = ge(e.gg, t._a[yt], l.year), n = ge(e.w, l.week), null != e.d ? ((o = e.d) < 0 || o > 6) && (h = !0) : null != e.e ? (o = e.e + r, (e.e < 0 || e.e > 6) && (h = !0)) : o = r;
          }
          n < 1 || n > qt(i, r, s) ? f(t)._overflowWeeks = !0 : null != h ? f(t)._overflowWeekday = !0 : (a = Ut(i, n, o, r, s), t._a[yt] = a.year, t._dayOfYear = a.dayOfYear);
        }(t), null != t._dayOfYear && (s = ge(t._a[yt], o[yt]), (t._dayOfYear > St(s) || 0 === t._dayOfYear) && (f(t)._overflowDayOfYear = !0), i = Wt(s, 0, t._dayOfYear), t._a[gt] = i.getUTCMonth(), t._a[mt] = i.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e) t._a[e] = a[e] = o[e];

        for (; e < 7; e++) t._a[e] = a[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];

        24 === t._a[bt] && 0 === t._a[wt] && 0 === t._a[_t] && 0 === t._a[kt] && (t._nextDay = !0, t._a[bt] = 0), t._d = (t._useUTC ? Wt : Ht).apply(null, a), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[bt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (f(t).weekdayMismatch = !0);
      }
    }

    var be = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        we = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        _e = /Z|[+-]\d\d(?::?\d\d)?/,
        ke = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]],
        xe = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
        Oe = /^\/?Date\((\-?\d+)/i;

    function Se(t) {
      var e,
          i,
          n,
          o,
          r,
          s,
          a = t._i,
          h = be.exec(a) || we.exec(a);

      if (h) {
        for (f(t).iso = !0, e = 0, i = ke.length; e < i; e++) if (ke[e][1].exec(h[1])) {
          o = ke[e][0], n = !1 !== ke[e][2];
          break;
        }

        if (null == o) return void (t._isValid = !1);

        if (h[3]) {
          for (e = 0, i = xe.length; e < i; e++) if (xe[e][1].exec(h[3])) {
            r = (h[2] || " ") + xe[e][0];
            break;
          }

          if (null == r) return void (t._isValid = !1);
        }

        if (!n && null != r) return void (t._isValid = !1);

        if (h[4]) {
          if (!_e.exec(h[4])) return void (t._isValid = !1);
          s = "Z";
        }

        t._f = o + (r || "") + (s || ""), Ce(t);
      } else t._isValid = !1;
    }

    var Me = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function Ee(t) {
      var e = Ak(t, 10);
      return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
    }

    var De = {
      UT: 0,
      GMT: 0,
      EDT: -240,
      EST: -300,
      CDT: -300,
      CST: -360,
      MDT: -360,
      MST: -420,
      PDT: -420,
      PST: -480
    };

    function Te(t) {
      var e,
          i,
          n,
          o,
          r,
          s,
          a,
          h = Me.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));

      if (h) {
        var l = (e = h[4], i = h[3], n = h[2], o = h[5], r = h[6], s = h[7], a = [Ee(e), px(Nt).call(Nt, i), Ak(n, 10), Ak(o, 10), Ak(r, 10)], s && a.push(Ak(s, 10)), a);
        if (!function (t, e, i) {
          return !t || px(Kt).call(Kt, t) === new Date(e[0], e[1], e[2]).getDay() || (f(i).weekdayMismatch = !0, i._isValid = !1, !1);
        }(h[1], l, t)) return;
        t._a = l, t._tzm = function (t, e, i) {
          if (t) return De[t];
          if (e) return 0;
          var n = Ak(i, 10),
              o = n % 100;
          return (n - o) / 100 * 60 + o;
        }(h[8], h[9], h[10]), t._d = Wt.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), f(t).rfc2822 = !0;
      } else t._isValid = !1;
    }

    function Ce(t) {
      var e;
      if (t._f !== n.ISO_8601) {
        if (t._f !== n.RFC_2822) {
          t._a = [], f(t).empty = !0;
          var i,
              o,
              r,
              s,
              a,
              h = "" + t._i,
              l = h.length,
              d = 0;

          for (r = U(t._f, t._locale).match(R) || [], i = 0; i < r.length; i++) s = r[i], (o = (h.match(dt(s, t)) || [])[0]) && ((a = h.substr(0, px(h).call(h, o))).length > 0 && f(t).unusedInput.push(a), h = rx(h).call(h, px(h).call(h, o) + o.length), d += o.length), H[s] ? (o ? f(t).empty = !1 : f(t).unusedTokens.push(s), vt(s, o, t)) : t._strict && !o && f(t).unusedTokens.push(s);

          f(t).charsLeftOver = l - d, h.length > 0 && f(t).unusedInput.push(h), t._a[bt] <= 12 && !0 === f(t).bigHour && t._a[bt] > 0 && (f(t).bigHour = void 0), f(t).parsedDateParts = rx(e = t._a).call(e, 0), f(t).meridiem = t._meridiem, t._a[bt] = function (t, e, i) {
            var n;
            return null == i ? e : null != t.meridiemHour ? t.meridiemHour(e, i) : null != t.isPM ? ((n = t.isPM(i)) && e < 12 && (e += 12), n || 12 !== e || (e = 0), e) : e;
          }(t._locale, t._a[bt], t._meridiem), me(t), ye(t);
        } else Te(t);
      } else Se(t);
    }

    function Pe(t) {
      var e = t._i,
          i = t._f;
      return t._locale = t._locale || ve(t._l), null === e || void 0 === i && "" === e ? v({
        nullInput: !0
      }) : ("string" == typeof e && (t._i = e = t._locale.preparse(e)), w(e) ? new b(ye(e)) : (h(e) ? t._d = e : o(i) ? function (t) {
        var e, i, n, o, r;
        if (0 === t._f.length) return f(t).invalidFormat = !0, void (t._d = new Date(NaN));

        for (o = 0; o < t._f.length; o++) r = 0, e = g({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[o], Ce(e), p(e) && (r += f(e).charsLeftOver, r += 10 * f(e).unusedTokens.length, f(e).score = r, (null == n || r < n) && (n = r, i = e));

        u(t, i || e);
      }(t) : i ? Ce(t) : function (t) {
        var e = t._i;
        s(e) ? t._d = new Date(n.now()) : h(e) ? t._d = new Date(e.valueOf()) : "string" == typeof e ? function (t) {
          var e = Oe.exec(t._i);
          null === e ? (Se(t), !1 === t._isValid && (delete t._isValid, Te(t), !1 === t._isValid && (delete t._isValid, n.createFromInputFallback(t)))) : t._d = new Date(+e[1]);
        }(t) : o(e) ? (t._a = l(rx(e).call(e, 0), function (t) {
          return Ak(t, 10);
        }), me(t)) : r(e) ? function (t) {
          if (!t._d) {
            var e = N(t._i);
            t._a = l([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], function (t) {
              return t && Ak(t, 10);
            }), me(t);
          }
        }(t) : a(e) ? t._d = new Date(e) : n.createFromInputFallback(t);
      }(t), p(t) || (t._d = null), t));
    }

    function Ae(t, e, i, n, s) {
      var a,
          h = {};
      return !0 !== i && !1 !== i || (n = i, i = void 0), (r(t) && function (t) {
        if (Ux) return 0 === Ux(t).length;
        var e;

        for (e in t) if (t.hasOwnProperty(e)) return !1;

        return !0;
      }(t) || o(t) && 0 === t.length) && (t = void 0), h._isAMomentObject = !0, h._useUTC = h._isUTC = s, h._l = i, h._i = t, h._f = e, h._strict = n, (a = new b(ye(Pe(h))))._nextDay && (a.add(1, "d"), a._nextDay = void 0), a;
    }

    function Ie(t, e, i, n) {
      return Ae(t, e, i, n, !1);
    }

    n.createFromInputFallback = S("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (t) {
      t._d = new Date(t._i + (t._useUTC ? " UTC" : ""));
    }), n.ISO_8601 = function () {}, n.RFC_2822 = function () {};
    var Fe = S("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
      var t = Ie.apply(null, arguments);
      return this.isValid() && t.isValid() ? t < this ? this : t : v();
    }),
        Ne = S("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
      var t = Ie.apply(null, arguments);
      return this.isValid() && t.isValid() ? t > this ? this : t : v();
    });

    function je(t, e) {
      var i, n;
      if (1 === e.length && o(e[0]) && (e = e[0]), !e.length) return Ie();

      for (i = e[0], n = 1; n < e.length; ++n) e[n].isValid() && !e[n][t](i) || (i = e[n]);

      return i;
    }

    var ze = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

    function Le(t) {
      var e = N(t),
          i = e.year || 0,
          n = e.quarter || 0,
          o = e.month || 0,
          r = e.week || e.isoWeek || 0,
          s = e.day || 0,
          a = e.hour || 0,
          h = e.minute || 0,
          l = e.second || 0,
          d = e.millisecond || 0;
      this._isValid = function (t) {
        for (var e in t) if (-1 === Et.call(ze, e) || null != t[e] && isNaN(t[e])) return !1;

        for (var i = !1, n = 0; n < ze.length; ++n) if (t[ze[n]]) {
          if (i) return !1;
          Sx(t[ze[n]]) !== k(t[ze[n]]) && (i = !0);
        }

        return !0;
      }(e), this._milliseconds = +d + 1e3 * l + 6e4 * h + 1e3 * a * 60 * 60, this._days = +s + 7 * r, this._months = +o + 3 * n + 12 * i, this._data = {}, this._locale = ve(), this._bubble();
    }

    function Re(t) {
      return t instanceof Le;
    }

    function Be(t) {
      return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t);
    }

    function Ye(t, e) {
      W(t, 0, 0, function () {
        var t = this.utcOffset(),
            i = "+";
        return t < 0 && (t = -t, i = "-"), i + L(~~(t / 60), 2) + e + L(~~t % 60, 2);
      });
    }

    Ye("Z", ":"), Ye("ZZ", ""), lt("Z", st), lt("ZZ", st), ft(["Z", "ZZ"], function (t, e, i) {
      i._useUTC = !0, i._tzm = We(st, t);
    });
    var He = /([\+\-]|\d\d)/gi;

    function We(t, e) {
      var i = (e || "").match(t);
      if (null === i) return null;
      var n = ((i[i.length - 1] || []) + "").match(He) || ["-", 0, 0],
          o = 60 * n[1] + k(n[2]);
      return 0 === o ? 0 : "+" === n[0] ? o : -o;
    }

    function Ve(t, e) {
      var i, o;
      return e._isUTC ? (i = e.clone(), o = (w(t) || h(t) ? t.valueOf() : Ie(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + o), n.updateOffset(i, !1), i) : Ie(t).local();
    }

    function Ue(t) {
      return 15 * -Math.round(t._d.getTimezoneOffset() / 15);
    }

    function Ge() {
      return !!this.isValid() && this._isUTC && 0 === this._offset;
    }

    n.updateOffset = function () {};

    var qe = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
        Xe = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function Ze(t, e) {
      var i,
          n,
          o,
          r,
          s,
          h,
          l = t,
          u = null;
      return Re(t) ? l = {
        ms: t._milliseconds,
        d: t._days,
        M: t._months
      } : a(t) ? (l = {}, e ? l[e] = t : l.milliseconds = t) : (u = qe.exec(t)) ? (i = "-" === u[1] ? -1 : 1, l = {
        y: 0,
        d: k(u[mt]) * i,
        h: k(u[bt]) * i,
        m: k(u[wt]) * i,
        s: k(u[_t]) * i,
        ms: k(Be(1e3 * u[kt])) * i
      }) : (u = Xe.exec(t)) ? (i = "-" === u[1] ? -1 : 1, l = {
        y: Ke(u[2], i),
        M: Ke(u[3], i),
        w: Ke(u[4], i),
        d: Ke(u[5], i),
        h: Ke(u[6], i),
        m: Ke(u[7], i),
        s: Ke(u[8], i)
      }) : null == l ? l = {} : "object" === _x(l) && (("from" in l) || ("to" in l)) && (r = Ie(l.from), s = Ie(l.to), o = r.isValid() && s.isValid() ? (s = Ve(s, r), r.isBefore(s) ? h = $e(r, s) : ((h = $e(s, r)).milliseconds = -h.milliseconds, h.months = -h.months), h) : {
        milliseconds: 0,
        months: 0
      }, (l = {}).ms = o.milliseconds, l.M = o.months), n = new Le(l), Re(t) && d(t, "_locale") && (n._locale = t._locale), n;
    }

    function Ke(t, e) {
      var i = t && Sx(t.replace(",", "."));
      return (isNaN(i) ? 0 : i) * e;
    }

    function $e(t, e) {
      var i = {};
      return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i;
    }

    function Je(t, e) {
      return function (i, n) {
        var o;
        return null === n || isNaN(+n) || (D(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), o = i, i = n, n = o), Qe(this, Ze(i = "string" == typeof i ? +i : i, n), t), this;
      };
    }

    function Qe(t, e, i, o) {
      var r = e._milliseconds,
          s = Be(e._days),
          a = Be(e._months);
      t.isValid() && (o = null == o || o, a && zt(t, Ct(t, "Month") + a * i), s && Pt(t, "Date", Ct(t, "Date") + s * i), r && t._d.setTime(t._d.valueOf() + r * i), o && n.updateOffset(t, s || a));
    }

    Ze.fn = Le.prototype, Ze.invalid = function () {
      return Ze(NaN);
    };
    var ti = Je(1, "add"),
        ei = Je(-1, "subtract");

    function ii(t, e) {
      var i = 12 * (e.year() - t.year()) + (e.month() - t.month()),
          n = t.clone().add(i, "months");
      return -(i + (e - n < 0 ? (e - n) / (n - t.clone().add(i - 1, "months")) : (e - n) / (t.clone().add(i + 1, "months") - n))) || 0;
    }

    function ni(t) {
      var e;
      return void 0 === t ? this._locale._abbr : (null != (e = ve(t)) && (this._locale = e), this);
    }

    n.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", n.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var oi = S("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
      return void 0 === t ? this.localeData() : this.locale(t);
    });

    function ri() {
      return this._locale;
    }

    var si = 1e3,
        ai = 60 * si,
        hi = 60 * ai,
        li = 3506328 * hi;

    function di(t, e) {
      return (t % e + e) % e;
    }

    function ui(t, e, i) {
      return t < 100 && t >= 0 ? new Date(t + 400, e, i) - li : new Date(t, e, i).valueOf();
    }

    function ci(t, e, i) {
      return t < 100 && t >= 0 ? Date.UTC(t + 400, e, i) - li : Date.UTC(t, e, i);
    }

    function fi(t, e) {
      W(0, [t, t.length], 0, e);
    }

    function pi(t, e, i, n, o) {
      var r;
      return null == t ? Gt(this, n, o).year : (e > (r = qt(t, n, o)) && (e = r), vi.call(this, t, e, i, n, o));
    }

    function vi(t, e, i, n, o) {
      var r = Ut(t, e, i, n, o),
          s = Wt(r.year, 0, r.dayOfYear);
      return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this;
    }

    W(0, ["gg", 2], 0, function () {
      return this.weekYear() % 100;
    }), W(0, ["GG", 2], 0, function () {
      return this.isoWeekYear() % 100;
    }), fi("gggg", "weekYear"), fi("ggggg", "weekYear"), fi("GGGG", "isoWeekYear"), fi("GGGGG", "isoWeekYear"), I("weekYear", "gg"), I("isoWeekYear", "GG"), z("weekYear", 1), z("isoWeekYear", 1), lt("G", ot), lt("g", ot), lt("GG", $, q), lt("gg", $, q), lt("GGGG", et, Z), lt("gggg", et, Z), lt("GGGGG", it, K), lt("ggggg", it, K), pt(["gggg", "ggggg", "GGGG", "GGGGG"], function (t, e, i, n) {
      e[n.substr(0, 2)] = k(t);
    }), pt(["gg", "GG"], function (t, e, i, o) {
      e[o] = n.parseTwoDigitYear(t);
    }), W("Q", 0, "Qo", "quarter"), I("quarter", "Q"), z("quarter", 7), lt("Q", G), ft("Q", function (t, e) {
      e[gt] = 3 * (k(t) - 1);
    }), W("D", ["DD", 2], "Do", "date"), I("date", "D"), z("date", 9), lt("D", $), lt("DD", $, q), lt("Do", function (t, e) {
      return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
    }), ft(["D", "DD"], mt), ft("Do", function (t, e) {
      e[mt] = k(t.match($)[0]);
    });
    var yi = Tt("Date", !0);
    W("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), I("dayOfYear", "DDD"), z("dayOfYear", 4), lt("DDD", tt), lt("DDDD", X), ft(["DDD", "DDDD"], function (t, e, i) {
      i._dayOfYear = k(t);
    }), W("m", ["mm", 2], 0, "minute"), I("minute", "m"), z("minute", 14), lt("m", $), lt("mm", $, q), ft(["m", "mm"], wt);
    var gi = Tt("Minutes", !1);
    W("s", ["ss", 2], 0, "second"), I("second", "s"), z("second", 15), lt("s", $), lt("ss", $, q), ft(["s", "ss"], _t);
    var mi,
        bi = Tt("Seconds", !1);

    for (W("S", 0, 0, function () {
      return ~~(this.millisecond() / 100);
    }), W(0, ["SS", 2], 0, function () {
      return ~~(this.millisecond() / 10);
    }), W(0, ["SSS", 3], 0, "millisecond"), W(0, ["SSSS", 4], 0, function () {
      return 10 * this.millisecond();
    }), W(0, ["SSSSS", 5], 0, function () {
      return 100 * this.millisecond();
    }), W(0, ["SSSSSS", 6], 0, function () {
      return 1e3 * this.millisecond();
    }), W(0, ["SSSSSSS", 7], 0, function () {
      return 1e4 * this.millisecond();
    }), W(0, ["SSSSSSSS", 8], 0, function () {
      return 1e5 * this.millisecond();
    }), W(0, ["SSSSSSSSS", 9], 0, function () {
      return 1e6 * this.millisecond();
    }), I("millisecond", "ms"), z("millisecond", 16), lt("S", tt, G), lt("SS", tt, q), lt("SSS", tt, X), mi = "SSSS"; mi.length <= 9; mi += "S") lt(mi, nt);

    function wi(t, e) {
      e[kt] = k(1e3 * ("0." + t));
    }

    for (mi = "S"; mi.length <= 9; mi += "S") ft(mi, wi);

    var _i = Tt("Milliseconds", !1);

    W("z", 0, 0, "zoneAbbr"), W("zz", 0, 0, "zoneName");
    var ki = b.prototype;

    function xi(t) {
      return t;
    }

    ki.add = ti, ki.calendar = function (t, e) {
      var i = t || Ie(),
          o = Ve(i, this).startOf("day"),
          r = n.calendarFormat(this, o) || "sameElse",
          s = e && (T(e[r]) ? e[r].call(this, i) : e[r]);
      return this.format(s || this.localeData().calendar(r, this, Ie(i)));
    }, ki.clone = function () {
      return new b(this);
    }, ki.diff = function (t, e, i) {
      var n, o, r;
      if (!this.isValid()) return NaN;
      if (!(n = Ve(t, this)).isValid()) return NaN;

      switch (o = 6e4 * (n.utcOffset() - this.utcOffset()), e = F(e)) {
        case "year":
          r = ii(this, n) / 12;
          break;

        case "month":
          r = ii(this, n);
          break;

        case "quarter":
          r = ii(this, n) / 3;
          break;

        case "second":
          r = (this - n) / 1e3;
          break;

        case "minute":
          r = (this - n) / 6e4;
          break;

        case "hour":
          r = (this - n) / 36e5;
          break;

        case "day":
          r = (this - n - o) / 864e5;
          break;

        case "week":
          r = (this - n - o) / 6048e5;
          break;

        default:
          r = this - n;
      }

      return i ? r : _(r);
    }, ki.endOf = function (t) {
      var e;
      if (void 0 === (t = F(t)) || "millisecond" === t || !this.isValid()) return this;
      var i = this._isUTC ? ci : ui;

      switch (t) {
        case "year":
          e = i(this.year() + 1, 0, 1) - 1;
          break;

        case "quarter":
          e = i(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case "month":
          e = i(this.year(), this.month() + 1, 1) - 1;
          break;

        case "week":
          e = i(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case "isoWeek":
          e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case "day":
        case "date":
          e = i(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case "hour":
          e = this._d.valueOf(), e += hi - di(e + (this._isUTC ? 0 : this.utcOffset() * ai), hi) - 1;
          break;

        case "minute":
          e = this._d.valueOf(), e += ai - di(e, ai) - 1;
          break;

        case "second":
          e = this._d.valueOf(), e += si - di(e, si) - 1;
      }

      return this._d.setTime(e), n.updateOffset(this, !0), this;
    }, ki.format = function (t) {
      t || (t = this.isUtc() ? n.defaultFormatUtc : n.defaultFormat);
      var e = V(this, t);
      return this.localeData().postformat(e);
    }, ki.from = function (t, e) {
      return this.isValid() && (w(t) && t.isValid() || Ie(t).isValid()) ? Ze({
        to: this,
        from: t
      }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
    }, ki.fromNow = function (t) {
      return this.from(Ie(), t);
    }, ki.to = function (t, e) {
      return this.isValid() && (w(t) && t.isValid() || Ie(t).isValid()) ? Ze({
        from: this,
        to: t
      }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
    }, ki.toNow = function (t) {
      return this.to(Ie(), t);
    }, ki.get = function (t) {
      return T(this[t = F(t)]) ? this[t]() : this;
    }, ki.invalidAt = function () {
      return f(this).overflow;
    }, ki.isAfter = function (t, e) {
      var i = w(t) ? t : Ie(t);
      return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = F(e) || "millisecond") ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf());
    }, ki.isBefore = function (t, e) {
      var i = w(t) ? t : Ie(t);
      return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = F(e) || "millisecond") ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf());
    }, ki.isBetween = function (t, e, i, n) {
      var o = w(t) ? t : Ie(t),
          r = w(e) ? e : Ie(e);
      return !!(this.isValid() && o.isValid() && r.isValid()) && ("(" === (n = n || "()")[0] ? this.isAfter(o, i) : !this.isBefore(o, i)) && (")" === n[1] ? this.isBefore(r, i) : !this.isAfter(r, i));
    }, ki.isSame = function (t, e) {
      var i,
          n = w(t) ? t : Ie(t);
      return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = F(e) || "millisecond") ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf()));
    }, ki.isSameOrAfter = function (t, e) {
      return this.isSame(t, e) || this.isAfter(t, e);
    }, ki.isSameOrBefore = function (t, e) {
      return this.isSame(t, e) || this.isBefore(t, e);
    }, ki.isValid = function () {
      return p(this);
    }, ki.lang = oi, ki.locale = ni, ki.localeData = ri, ki.max = Ne, ki.min = Fe, ki.parsingFlags = function () {
      return u({}, f(this));
    }, ki.set = function (t, e) {
      if ("object" === _x(t)) for (var i = function (t) {
        var e = [];

        for (var i in t) e.push({
          unit: i,
          priority: j[i]
        });

        return Fx(e).call(e, function (t, e) {
          return t.priority - e.priority;
        }), e;
      }(t = N(t)), n = 0; n < i.length; n++) this[i[n].unit](t[i[n].unit]);else if (T(this[t = F(t)])) return this[t](e);
      return this;
    }, ki.startOf = function (t) {
      var e;
      if (void 0 === (t = F(t)) || "millisecond" === t || !this.isValid()) return this;
      var i = this._isUTC ? ci : ui;

      switch (t) {
        case "year":
          e = i(this.year(), 0, 1);
          break;

        case "quarter":
          e = i(this.year(), this.month() - this.month() % 3, 1);
          break;

        case "month":
          e = i(this.year(), this.month(), 1);
          break;

        case "week":
          e = i(this.year(), this.month(), this.date() - this.weekday());
          break;

        case "isoWeek":
          e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case "day":
        case "date":
          e = i(this.year(), this.month(), this.date());
          break;

        case "hour":
          e = this._d.valueOf(), e -= di(e + (this._isUTC ? 0 : this.utcOffset() * ai), hi);
          break;

        case "minute":
          e = this._d.valueOf(), e -= di(e, ai);
          break;

        case "second":
          e = this._d.valueOf(), e -= di(e, si);
      }

      return this._d.setTime(e), n.updateOffset(this, !0), this;
    }, ki.subtract = ei, ki.toArray = function () {
      var t = this;
      return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()];
    }, ki.toObject = function () {
      var t = this;
      return {
        years: t.year(),
        months: t.month(),
        date: t.date(),
        hours: t.hours(),
        minutes: t.minutes(),
        seconds: t.seconds(),
        milliseconds: t.milliseconds()
      };
    }, ki.toDate = function () {
      return new Date(this.valueOf());
    }, ki.toISOString = function (t) {
      if (!this.isValid()) return null;
      var e = !0 !== t,
          i = e ? this.clone().utc() : this;
      return i.year() < 0 || i.year() > 9999 ? V(i, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : T(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", V(i, "Z")) : V(i, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }, ki.inspect = function () {
      if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
      var t = "moment",
          e = "";
      this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
      var i = "[" + t + '("]',
          n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
          o = e + '[")]';
      return this.format(i + n + "-MM-DD[T]HH:mm:ss.SSS" + o);
    }, ki.toJSON = function () {
      return this.isValid() ? this.toISOString() : null;
    }, ki.toString = function () {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }, ki.unix = function () {
      return Math.floor(this.valueOf() / 1e3);
    }, ki.valueOf = function () {
      return this._d.valueOf() - 6e4 * (this._offset || 0);
    }, ki.creationData = function () {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }, ki.year = Dt, ki.isLeapYear = function () {
      return Mt(this.year());
    }, ki.weekYear = function (t) {
      return pi.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }, ki.isoWeekYear = function (t) {
      return pi.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4);
    }, ki.quarter = ki.quarters = function (t) {
      return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3);
    }, ki.month = Lt, ki.daysInMonth = function () {
      return At(this.year(), this.month());
    }, ki.week = ki.weeks = function (t) {
      var e = this.localeData().week(this);
      return null == t ? e : this.add(7 * (t - e), "d");
    }, ki.isoWeek = ki.isoWeeks = function (t) {
      var e = Gt(this, 1, 4).week;
      return null == t ? e : this.add(7 * (t - e), "d");
    }, ki.weeksInYear = function () {
      var t = this.localeData()._week;

      return qt(this.year(), t.dow, t.doy);
    }, ki.isoWeeksInYear = function () {
      return qt(this.year(), 1, 4);
    }, ki.date = yi, ki.day = ki.days = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;
      var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      return null != t ? (t = function (t, e) {
        return "string" != typeof t ? t : isNaN(t) ? "number" == typeof (t = e.weekdaysParse(t)) ? t : null : Ak(t, 10);
      }(t, this.localeData()), this.add(t - e, "d")) : e;
    }, ki.weekday = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;
      var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return null == t ? e : this.add(t - e, "d");
    }, ki.isoWeekday = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;

      if (null != t) {
        var e = function (t, e) {
          return "string" == typeof t ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t;
        }(t, this.localeData());

        return this.day(this.day() % 7 ? e : e - 7);
      }

      return this.day() || 7;
    }, ki.dayOfYear = function (t) {
      var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
      return null == t ? e : this.add(t - e, "d");
    }, ki.hour = ki.hours = ae, ki.minute = ki.minutes = gi, ki.second = ki.seconds = bi, ki.millisecond = ki.milliseconds = _i, ki.utcOffset = function (t, e, i) {
      var o,
          r = this._offset || 0;
      if (!this.isValid()) return null != t ? this : NaN;

      if (null != t) {
        if ("string" == typeof t) {
          if (null === (t = We(st, t))) return this;
        } else Math.abs(t) < 16 && !i && (t *= 60);

        return !this._isUTC && e && (o = Ue(this)), this._offset = t, this._isUTC = !0, null != o && this.add(o, "m"), r !== t && (!e || this._changeInProgress ? Qe(this, Ze(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, n.updateOffset(this, !0), this._changeInProgress = null)), this;
      }

      return this._isUTC ? r : Ue(this);
    }, ki.utc = function (t) {
      return this.utcOffset(0, t);
    }, ki.local = function (t) {
      return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Ue(this), "m")), this;
    }, ki.parseZone = function () {
      if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);else if ("string" == typeof this._i) {
        var t = We(rt, this._i);
        null != t ? this.utcOffset(t) : this.utcOffset(0, !0);
      }
      return this;
    }, ki.hasAlignedHourOffset = function (t) {
      return !!this.isValid() && (t = t ? Ie(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0);
    }, ki.isDST = function () {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }, ki.isLocal = function () {
      return !!this.isValid() && !this._isUTC;
    }, ki.isUtcOffset = function () {
      return !!this.isValid() && this._isUTC;
    }, ki.isUtc = Ge, ki.isUTC = Ge, ki.zoneAbbr = function () {
      return this._isUTC ? "UTC" : "";
    }, ki.zoneName = function () {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }, ki.dates = S("dates accessor is deprecated. Use date instead.", yi), ki.months = S("months accessor is deprecated. Use month instead", Lt), ki.years = S("years accessor is deprecated. Use year instead", Dt), ki.zone = S("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (t, e) {
      return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset();
    }), ki.isDSTShifted = S("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
      if (!s(this._isDSTShifted)) return this._isDSTShifted;
      var t = {};

      if (g(t, this), (t = Pe(t))._a) {
        var e = t._isUTC ? c(t._a) : Ie(t._a);
        this._isDSTShifted = this.isValid() && x(t._a, e.toArray()) > 0;
      } else this._isDSTShifted = !1;

      return this._isDSTShifted;
    });
    var Oi = P.prototype;

    function Si(t, e, i, n) {
      var o = ve(),
          r = c().set(n, e);
      return o[i](r, t);
    }

    function Mi(t, e, i) {
      if (a(t) && (e = t, t = void 0), t = t || "", null != e) return Si(t, e, i, "month");
      var n,
          o = [];

      for (n = 0; n < 12; n++) o[n] = Si(t, n, i, "month");

      return o;
    }

    function Ei(t, e, i, n) {
      "boolean" == typeof t ? (a(e) && (i = e, e = void 0), e = e || "") : (i = e = t, t = !1, a(e) && (i = e, e = void 0), e = e || "");
      var o,
          r = ve(),
          s = t ? r._week.dow : 0;
      if (null != i) return Si(e, (i + s) % 7, n, "day");
      var h = [];

      for (o = 0; o < 7; o++) h[o] = Si(e, (o + s) % 7, n, "day");

      return h;
    }

    Oi.calendar = function (t, e, i) {
      var n = this._calendar[t] || this._calendar.sameElse;
      return T(n) ? n.call(e, i) : n;
    }, Oi.longDateFormat = function (t) {
      var e = this._longDateFormat[t],
          i = this._longDateFormat[t.toUpperCase()];

      return e || !i ? e : (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, function (t) {
        return rx(t).call(t, 1);
      }), this._longDateFormat[t]);
    }, Oi.invalidDate = function () {
      return this._invalidDate;
    }, Oi.ordinal = function (t) {
      return this._ordinal.replace("%d", t);
    }, Oi.preparse = xi, Oi.postformat = xi, Oi.relativeTime = function (t, e, i, n) {
      var o = this._relativeTime[i];
      return T(o) ? o(t, e, i, n) : o.replace(/%d/i, t);
    }, Oi.pastFuture = function (t, e) {
      var i = this._relativeTime[t > 0 ? "future" : "past"];
      return T(i) ? i(e) : i.replace(/%s/i, e);
    }, Oi.set = function (t) {
      var e, i;

      for (i in t) T(e = t[i]) ? this[i] = e : this["_" + i] = e;

      this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }, Oi.months = function (t, e) {
      return t ? o(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || It).test(e) ? "format" : "standalone"][t.month()] : o(this._months) ? this._months : this._months.standalone;
    }, Oi.monthsShort = function (t, e) {
      return t ? o(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[It.test(e) ? "format" : "standalone"][t.month()] : o(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }, Oi.monthsParse = function (t, e, i) {
      var n, o, r;
      if (this._monthsParseExact) return jt.call(this, t, e, i);

      for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
        if (o = c([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp("^" + this.months(o, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(o, "").replace(".", "") + "$", "i")), i || this._monthsParse[n] || (r = "^" + this.months(o, "") + "|^" + this.monthsShort(o, ""), this._monthsParse[n] = new RegExp(r.replace(".", ""), "i")), i && "MMMM" === e && this._longMonthsParse[n].test(t)) return n;
        if (i && "MMM" === e && this._shortMonthsParse[n].test(t)) return n;
        if (!i && this._monthsParse[n].test(t)) return n;
      }
    }, Oi.monthsRegex = function (t) {
      return this._monthsParseExact ? (d(this, "_monthsRegex") || Yt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (d(this, "_monthsRegex") || (this._monthsRegex = Bt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex);
    }, Oi.monthsShortRegex = function (t) {
      return this._monthsParseExact ? (d(this, "_monthsRegex") || Yt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (d(this, "_monthsShortRegex") || (this._monthsShortRegex = Rt), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }, Oi.week = function (t) {
      return Gt(t, this._week.dow, this._week.doy).week;
    }, Oi.firstDayOfYear = function () {
      return this._week.doy;
    }, Oi.firstDayOfWeek = function () {
      return this._week.dow;
    }, Oi.weekdays = function (t, e) {
      var i = o(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
      return !0 === t ? Xt(i, this._week.dow) : t ? i[t.day()] : i;
    }, Oi.weekdaysMin = function (t) {
      return !0 === t ? Xt(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin;
    }, Oi.weekdaysShort = function (t) {
      return !0 === t ? Xt(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort;
    }, Oi.weekdaysParse = function (t, e, i) {
      var n, o, r;
      if (this._weekdaysParseExact) return Jt.call(this, t, e, i);

      for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
        if (o = c([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp("^" + this.weekdays(o, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[n] = new RegExp("^" + this.weekdaysShort(o, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[n] = new RegExp("^" + this.weekdaysMin(o, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[n] || (r = "^" + this.weekdays(o, "") + "|^" + this.weekdaysShort(o, "") + "|^" + this.weekdaysMin(o, ""), this._weekdaysParse[n] = new RegExp(r.replace(".", ""), "i")), i && "dddd" === e && this._fullWeekdaysParse[n].test(t)) return n;
        if (i && "ddd" === e && this._shortWeekdaysParse[n].test(t)) return n;
        if (i && "dd" === e && this._minWeekdaysParse[n].test(t)) return n;
        if (!i && this._weekdaysParse[n].test(t)) return n;
      }
    }, Oi.weekdaysRegex = function (t) {
      return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ie.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (d(this, "_weekdaysRegex") || (this._weekdaysRegex = Qt), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }, Oi.weekdaysShortRegex = function (t) {
      return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ie.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (d(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = te), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }, Oi.weekdaysMinRegex = function (t) {
      return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ie.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (d(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = ee), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }, Oi.isPM = function (t) {
      return "p" === (t + "").toLowerCase().charAt(0);
    }, Oi.meridiem = function (t, e, i) {
      return t > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
    }, fe("en", {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (t) {
        var e = t % 10;
        return t + (1 === k(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th");
      }
    }), n.lang = S("moment.lang is deprecated. Use moment.locale instead.", fe), n.langData = S("moment.langData is deprecated. Use moment.localeData instead.", ve);
    var Di = Math.abs;

    function Ti(t, e, i, n) {
      var o = Ze(e, i);
      return t._milliseconds += n * o._milliseconds, t._days += n * o._days, t._months += n * o._months, t._bubble();
    }

    function Ci(t) {
      return t < 0 ? Math.floor(t) : Math.ceil(t);
    }

    function Pi(t) {
      return 4800 * t / 146097;
    }

    function Ai(t) {
      return 146097 * t / 4800;
    }

    function Ii(t) {
      return function () {
        return this.as(t);
      };
    }

    var Fi = Ii("ms"),
        Ni = Ii("s"),
        ji = Ii("m"),
        zi = Ii("h"),
        Li = Ii("d"),
        Ri = Ii("w"),
        Bi = Ii("M"),
        Yi = Ii("Q"),
        Hi = Ii("y");

    function Wi(t) {
      return function () {
        return this.isValid() ? this._data[t] : NaN;
      };
    }

    var Vi = Wi("milliseconds"),
        Ui = Wi("seconds"),
        Gi = Wi("minutes"),
        qi = Wi("hours"),
        Xi = Wi("days"),
        Zi = Wi("months"),
        Ki = Wi("years"),
        $i = Math.round,
        Ji = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };

    function Qi(t, e, i, n, o) {
      return o.relativeTime(e || 1, !!i, t, n);
    }

    var tn = Math.abs;

    function en(t) {
      return (t > 0) - (t < 0) || +t;
    }

    function nn() {
      if (!this.isValid()) return this.localeData().invalidDate();
      var t,
          e,
          i = tn(this._milliseconds) / 1e3,
          n = tn(this._days),
          o = tn(this._months);
      t = _(i / 60), e = _(t / 60), i %= 60, t %= 60;

      var r = _(o / 12),
          s = o %= 12,
          a = n,
          h = e,
          l = t,
          d = i ? i.toFixed(3).replace(/\.?0+$/, "") : "",
          u = this.asSeconds();

      if (!u) return "P0D";
      var c = u < 0 ? "-" : "",
          f = en(this._months) !== en(u) ? "-" : "",
          p = en(this._days) !== en(u) ? "-" : "",
          v = en(this._milliseconds) !== en(u) ? "-" : "";
      return c + "P" + (r ? f + r + "Y" : "") + (s ? f + s + "M" : "") + (a ? p + a + "D" : "") + (h || l || d ? "T" : "") + (h ? v + h + "H" : "") + (l ? v + l + "M" : "") + (d ? v + d + "S" : "");
    }

    var on = Le.prototype;
    return on.isValid = function () {
      return this._isValid;
    }, on.abs = function () {
      var t = this._data;
      return this._milliseconds = Di(this._milliseconds), this._days = Di(this._days), this._months = Di(this._months), t.milliseconds = Di(t.milliseconds), t.seconds = Di(t.seconds), t.minutes = Di(t.minutes), t.hours = Di(t.hours), t.months = Di(t.months), t.years = Di(t.years), this;
    }, on.add = function (t, e) {
      return Ti(this, t, e, 1);
    }, on.subtract = function (t, e) {
      return Ti(this, t, e, -1);
    }, on.as = function (t) {
      if (!this.isValid()) return NaN;
      var e,
          i,
          n = this._milliseconds;
      if ("month" === (t = F(t)) || "quarter" === t || "year" === t) switch (e = this._days + n / 864e5, i = this._months + Pi(e), t) {
        case "month":
          return i;

        case "quarter":
          return i / 3;

        case "year":
          return i / 12;
      } else switch (e = this._days + Math.round(Ai(this._months)), t) {
        case "week":
          return e / 7 + n / 6048e5;

        case "day":
          return e + n / 864e5;

        case "hour":
          return 24 * e + n / 36e5;

        case "minute":
          return 1440 * e + n / 6e4;

        case "second":
          return 86400 * e + n / 1e3;

        case "millisecond":
          return Math.floor(864e5 * e) + n;

        default:
          throw new Error("Unknown unit " + t);
      }
    }, on.asMilliseconds = Fi, on.asSeconds = Ni, on.asMinutes = ji, on.asHours = zi, on.asDays = Li, on.asWeeks = Ri, on.asMonths = Bi, on.asQuarters = Yi, on.asYears = Hi, on.valueOf = function () {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * k(this._months / 12) : NaN;
    }, on._bubble = function () {
      var t,
          e,
          i,
          n,
          o,
          r = this._milliseconds,
          s = this._days,
          a = this._months,
          h = this._data;
      return r >= 0 && s >= 0 && a >= 0 || r <= 0 && s <= 0 && a <= 0 || (r += 864e5 * Ci(Ai(a) + s), s = 0, a = 0), h.milliseconds = r % 1e3, t = _(r / 1e3), h.seconds = t % 60, e = _(t / 60), h.minutes = e % 60, i = _(e / 60), h.hours = i % 24, s += _(i / 24), o = _(Pi(s)), a += o, s -= Ci(Ai(o)), n = _(a / 12), a %= 12, h.days = s, h.months = a, h.years = n, this;
    }, on.clone = function () {
      return Ze(this);
    }, on.get = function (t) {
      return t = F(t), this.isValid() ? this[t + "s"]() : NaN;
    }, on.milliseconds = Vi, on.seconds = Ui, on.minutes = Gi, on.hours = qi, on.days = Xi, on.weeks = function () {
      return _(this.days() / 7);
    }, on.months = Zi, on.years = Ki, on.humanize = function (t) {
      if (!this.isValid()) return this.localeData().invalidDate();

      var e = this.localeData(),
          i = function (t, e, i) {
        var n = Ze(t).abs(),
            o = $i(n.as("s")),
            r = $i(n.as("m")),
            s = $i(n.as("h")),
            a = $i(n.as("d")),
            h = $i(n.as("M")),
            l = $i(n.as("y")),
            d = o <= Ji.ss && ["s", o] || o < Ji.s && ["ss", o] || r <= 1 && ["m"] || r < Ji.m && ["mm", r] || s <= 1 && ["h"] || s < Ji.h && ["hh", s] || a <= 1 && ["d"] || a < Ji.d && ["dd", a] || h <= 1 && ["M"] || h < Ji.M && ["MM", h] || l <= 1 && ["y"] || ["yy", l];
        return d[2] = e, d[3] = +t > 0, d[4] = i, Qi.apply(null, d);
      }(this, !t, e);

      return t && (i = e.pastFuture(+this, i)), e.postformat(i);
    }, on.toISOString = nn, on.toString = nn, on.toJSON = nn, on.locale = ni, on.localeData = ri, on.toIsoString = S("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", nn), on.lang = oi, W("X", 0, 0, "unix"), W("x", 0, 0, "valueOf"), lt("x", ot), lt("X", /[+-]?\d+(\.\d{1,3})?/), ft("X", function (t, e, i) {
      i._d = new Date(1e3 * Sx(t, 10));
    }), ft("x", function (t, e, i) {
      i._d = new Date(k(t));
    }), n.version = "2.24.0", e = Ie, n.fn = ki, n.min = function () {
      return je("isBefore", rx([]).call(arguments, 0));
    }, n.max = function () {
      return je("isAfter", rx([]).call(arguments, 0));
    }, n.now = function () {
      return Mx ? Mx() : +new Date();
    }, n.utc = c, n.unix = function (t) {
      return Ie(1e3 * t);
    }, n.months = function (t, e) {
      return Mi(t, e, "months");
    }, n.isDate = h, n.locale = fe, n.invalid = v, n.duration = Ze, n.isMoment = w, n.weekdays = function (t, e, i) {
      return Ei(t, e, i, "weekdays");
    }, n.parseZone = function () {
      return Ie.apply(null, arguments).parseZone();
    }, n.localeData = ve, n.isDuration = Re, n.monthsShort = function (t, e) {
      return Mi(t, e, "monthsShort");
    }, n.weekdaysMin = function (t, e, i) {
      return Ei(t, e, i, "weekdaysMin");
    }, n.defineLocale = pe, n.updateLocale = function (t, e) {
      if (null != e) {
        var i,
            n,
            o = he;
        null != (n = ce(t)) && (o = n._config), e = C(o, e), (i = new P(e)).parentLocale = le[t], le[t] = i, fe(t);
      } else null != le[t] && (null != le[t].parentLocale ? le[t] = le[t].parentLocale : null != le[t] && delete le[t]);

      return le[t];
    }, n.locales = function () {
      return M(le);
    }, n.weekdaysShort = function (t, e, i) {
      return Ei(t, e, i, "weekdaysShort");
    }, n.normalizeUnits = F, n.relativeTimeRounding = function (t) {
      return void 0 === t ? $i : "function" == typeof t && ($i = t, !0);
    }, n.relativeTimeThreshold = function (t, e) {
      return void 0 !== Ji[t] && (void 0 === e ? Ji[t] : (Ji[t] = e, "s" === t && (Ji.ss = e - 1), !0));
    }, n.calendarFormat = function (t, e) {
      var i = t.diff(e, "days", !0);
      return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
    }, n.prototype = ki, n.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    }, n;
  }();
}), qx = [], Xx = 0; Xx < 256; Xx++) qx[Xx] = (Xx + 256).toString(16).substr(1);

for (var Zx = function () {
  if ("undefined" != typeof crypto && crypto.getRandomValues) {
    var t = new Uint8Array(16);
    return function () {
      return crypto.getRandomValues(t), t;
    };
  }

  var e = new Array(16);
  return function () {
    for (var t, i = 0; i < 16; i++) 0 == (3 & i) && (t = 4294967296 * Math.random()), e[i] = t >>> ((3 & i) << 3) & 255;

    return e;
  };
}(), Kx = [], $x = 0; $x < 256; $x++) Kx[$x] = ($x + 256).toString(16).substr(1);

var Jx = Zx(),
    Qx = (Jx[0], Jx[1], Jx[2], Jx[3], Jx[4], Jx[5], Jx[6], Jx[7], /^\/?Date\((-?\d+)/i);

function tO(t) {
  return t instanceof Number || "number" == typeof t;
}

function eO(t) {
  return t instanceof String || "string" == typeof t;
}

function iO(t) {
  return Gx.isMoment(t);
}

function nO(t, e, i, n) {
  var o = !1;
  !0 === n && (o = null === e[i] && void 0 !== t[i]), o ? delete t[i] : t[i] = e[i];
}

function oO(t, e) {
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
      n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];

  for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o) || !0 === i) if ("object" === _x(e[o]) && null !== e[o] && ax(e[o]) === Object.prototype) void 0 === t[o] ? t[o] = oO({}, e[o], i) : "object" === _x(t[o]) && null !== t[o] && ax(t[o]) === Object.prototype ? oO(t[o], e[o], i) : nO(t, e, o, n);else if (vx(e[o])) {
    var r;
    t[o] = rx(r = e[o]).call(r);
  } else nO(t, e, o, n);

  return t;
}

function rO(t, e) {
  var i;

  if (void 0 !== t) {
    if (null === t) return null;
    if (!e) return t;
    if ("string" != typeof e && !(e instanceof String)) throw new Error("Type must be a string");

    switch (e) {
      case "boolean":
      case "Boolean":
        return Boolean(t);

      case "number":
      case "Number":
        return eO(t) && !isNaN(Date.parse(t)) ? Gx(t).valueOf() : Number(t.valueOf());

      case "string":
      case "String":
        return String(t);

      case "Date":
        if (tO(t)) return new Date(t);
        if (t instanceof Date) return new Date(t.valueOf());
        if (iO(t)) return new Date(t.valueOf());
        if (eO(t)) return (i = Qx.exec(t)) ? new Date(Number(i[1])) : Gx(new Date(t)).toDate();
        throw new Error("Cannot convert object of type " + sO(t) + " to type Date");

      case "Moment":
        if (tO(t)) return Gx(t);
        if (t instanceof Date) return Gx(t.valueOf());
        if (iO(t)) return Gx(t);
        if (eO(t)) return i = Qx.exec(t), Gx(i ? Number(i[1]) : t);
        throw new Error("Cannot convert object of type " + sO(t) + " to type Date");

      case "ISODate":
        if (tO(t)) return new Date(t);
        if (t instanceof Date) return t.toISOString();
        if (iO(t)) return t.toDate().toISOString();
        if (eO(t)) return (i = Qx.exec(t)) ? new Date(Number(i[1])).toISOString() : Gx(t).format();
        throw new Error("Cannot convert object of type " + sO(t) + " to type ISODate");

      case "ASPDate":
        if (tO(t)) return "/Date(" + t + ")/";
        if (t instanceof Date || iO(t)) return "/Date(" + t.valueOf() + ")/";
        if (eO(t)) return "/Date(" + ((i = Qx.exec(t)) ? new Date(Number(i[1])).valueOf() : new Date(t).valueOf()) + ")/";
        throw new Error("Cannot convert object of type " + sO(t) + " to type ASPDate");

      default:
        throw new Error("Unknown type ".concat(e));
    }
  }
}

function sO(t) {
  var e = _x(t);

  return "object" === e ? null === t ? "null" : t instanceof Boolean ? "Boolean" : t instanceof Number ? "Number" : t instanceof String ? "String" : vx(t) ? "Array" : t instanceof Date ? "Date" : "Object" : "number" === e ? "Number" : "boolean" === e ? "Boolean" : "string" === e ? "String" : void 0 === e ? "undefined" : e;
}

function aO(t) {
  return "string" == typeof t || "number" == typeof t;
}

var hO = Math.max,
    lO = Math.min;
yf({
  target: "Array",
  proto: !0,
  forced: !xg("splice")
}, {
  splice: function (t, e) {
    var i,
        n,
        o,
        r,
        s,
        a,
        h = pp(this),
        l = xf(h.length),
        d = Mf(t, l),
        u = arguments.length;
    if (0 === u ? i = n = 0 : 1 === u ? (i = 0, n = l - d) : (i = u - 2, n = lO(hO(_f(e), 0), l - d)), l + i - n > 9007199254740991) throw TypeError("Maximum allowed length exceeded");

    for (o = iv(h, n), r = 0; r < n; r++) (s = d + r) in h && Hf(o, r, h[s]);

    if (o.length = n, i < n) {
      for (r = d; r < l - n; r++) a = r + i, (s = r + n) in h ? h[a] = h[s] : delete h[a];

      for (r = l; r > l - n + i; r--) delete h[r - 1];
    } else if (i > n) for (r = l - n; r > d; r--) a = r + i - 1, (s = r + n - 1) in h ? h[a] = h[s] : delete h[a];

    for (r = 0; r < i; r++) h[r + d] = arguments[r + 2];

    return h.length = l - n + i, o;
  }
});

var dO = lv("Array").splice,
    uO = Array.prototype,
    cO = function (t) {
  var e = t.splice;
  return t === uO || t instanceof Array && e === uO.splice ? dO : e;
},
    fO = [].slice,
    pO = /MSIE .\./.test(gg),
    vO = function (t) {
  return function (e, i) {
    var n = arguments.length > 2,
        o = n ? fO.call(arguments, 2) : void 0;
    return t(n ? function () {
      ("function" == typeof e ? e : Function(e)).apply(this, o);
    } : e, i);
  };
};

yf({
  global: !0,
  bind: !0,
  forced: pO
}, {
  setTimeout: vO(Cc.setTimeout),
  setInterval: vO(Cc.setInterval)
});

var yO = af.setTimeout,
    gO = function () {
  function t(e) {
    ym(this, t), this._queue = [], this._timeout = null, this._extended = null, this.delay = null, this.max = 1 / 0, this.setOptions(e);
  }

  return mm(t, [{
    key: "setOptions",
    value: function (t) {
      t && void 0 !== t.delay && (this.delay = t.delay), t && void 0 !== t.max && (this.max = t.max), this._flushIfNeeded();
    }
  }, {
    key: "destroy",
    value: function () {
      if (this.flush(), this._extended) {
        for (var t = this._extended.object, e = this._extended.methods, i = 0; i < e.length; i++) {
          var n = e[i];
          n.original ? t[n.name] = n.original : delete t[n.name];
        }

        this._extended = null;
      }
    }
  }, {
    key: "replace",
    value: function (t, e) {
      var i = this,
          n = t[e];
      if (!n) throw new Error("Method " + e + " undefined");

      t[e] = function () {
        for (var t = arguments.length, e = new Array(t), o = 0; o < t; o++) e[o] = arguments[o];

        i.queue({
          args: e,
          fn: n,
          context: this
        });
      };
    }
  }, {
    key: "queue",
    value: function (t) {
      "function" == typeof t ? this._queue.push({
        fn: t
      }) : this._queue.push(t), this._flushIfNeeded();
    }
  }, {
    key: "_flushIfNeeded",
    value: function () {
      var t = this;
      this._queue.length > this.max && this.flush(), null != this._timeout && (clearTimeout(this._timeout), this._timeout = null), this.queue.length > 0 && "number" == typeof this.delay && (this._timeout = yO(function () {
        t.flush();
      }, this.delay));
    }
  }, {
    key: "flush",
    value: function () {
      var t, e;
      fv(t = cO(e = this._queue).call(e, 0)).call(t, function (t) {
        t.fn.apply(t.context || t.fn, t.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function (e, i) {
      var n = new t(i);
      if (void 0 !== e.flush) throw new Error("Target object already has a property flush");

      e.flush = function () {
        n.flush();
      };

      var o = [{
        name: "flush",
        original: void 0
      }];
      if (i && i.replace) for (var r = 0; r < i.replace.length; r++) {
        var s = i.replace[r];
        o.push({
          name: s,
          original: e[s]
        }), n.replace(e, s);
      }
      return n._extended = {
        object: e,
        methods: o
      }, n;
    }
  }]), t;
}(),
    mO = function () {
  function t() {
    ym(this, t), this._subscribers = {
      "*": [],
      add: [],
      remove: [],
      update: []
    }, this.subscribe = t.prototype.on, this.unsubscribe = t.prototype.off;
  }

  return mm(t, [{
    key: "_trigger",
    value: function (t, e, i) {
      var n, o;
      if ("*" === t) throw new Error("Cannot trigger event *");
      fv(n = Fg(o = []).call(o, yg(this._subscribers[t]), yg(this._subscribers["*"]))).call(n, function (n) {
        n(t, e, null != i ? i : null);
      });
    }
  }, {
    key: "on",
    value: function (t, e) {
      "function" == typeof e && this._subscribers[t].push(e);
    }
  }, {
    key: "off",
    value: function (t, e) {
      var i;
      this._subscribers[t] = Eg(i = this._subscribers[t]).call(i, function (t) {
        return t !== e;
      });
    }
  }]), t;
}(),
    bO = (sm("Set", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0);
  };
}, fm), af.Set),
    wO = Mm;

exports.Queue = gO;

var _O = function (t) {
  if (Jy(t)) return t;
};

var kO = function (t, e) {
  if (ug(Object(t)) || "[object Arguments]" === Object.prototype.toString.call(t)) {
    var i = [],
        n = !0,
        o = !1,
        r = void 0;

    try {
      for (var s, a = Iy(t); !(n = (s = a.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
    } catch (t) {
      o = !0, r = t;
    } finally {
      try {
        n || null == a.return || a.return();
      } finally {
        if (o) throw r;
      }
    }

    return i;
  }
};

var xO = function () {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
};

var OO = function (t, e) {
  return _O(t) || kO(t, e) || xO();
},
    SO = function () {
  function t(e) {
    ym(this, t), this._pairs = e;
  }

  return mm(t, [{
    key: gy,
    value: uy.mark(function t() {
      var e, i, n, o, r, s, a, h;
      return uy.wrap(function (t) {
        for (;;) switch (t.prev = t.next) {
          case 0:
            e = !0, i = !1, n = void 0, t.prev = 3, o = Iy(this._pairs);

          case 5:
            if (e = (r = o.next()).done) {
              t.next = 12;
              break;
            }

            return s = OO(r.value, 2), a = s[0], h = s[1], t.next = 9, [a, h];

          case 9:
            e = !0, t.next = 5;
            break;

          case 12:
            t.next = 18;
            break;

          case 14:
            t.prev = 14, t.t0 = t.catch(3), i = !0, n = t.t0;

          case 18:
            t.prev = 18, t.prev = 19, e || null == o.return || o.return();

          case 21:
            if (t.prev = 21, !i) {
              t.next = 24;
              break;
            }

            throw n;

          case 24:
            return t.finish(21);

          case 25:
            return t.finish(18);

          case 26:
          case "end":
            return t.stop();
        }
      }, t, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
  }, {
    key: "entries",
    value: uy.mark(function t() {
      var e, i, n, o, r, s, a, h;
      return uy.wrap(function (t) {
        for (;;) switch (t.prev = t.next) {
          case 0:
            e = !0, i = !1, n = void 0, t.prev = 3, o = Iy(this._pairs);

          case 5:
            if (e = (r = o.next()).done) {
              t.next = 12;
              break;
            }

            return s = OO(r.value, 2), a = s[0], h = s[1], t.next = 9, [a, h];

          case 9:
            e = !0, t.next = 5;
            break;

          case 12:
            t.next = 18;
            break;

          case 14:
            t.prev = 14, t.t0 = t.catch(3), i = !0, n = t.t0;

          case 18:
            t.prev = 18, t.prev = 19, e || null == o.return || o.return();

          case 21:
            if (t.prev = 21, !i) {
              t.next = 24;
              break;
            }

            throw n;

          case 24:
            return t.finish(21);

          case 25:
            return t.finish(18);

          case 26:
          case "end":
            return t.stop();
        }
      }, t, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
  }, {
    key: "keys",
    value: uy.mark(function t() {
      var e, i, n, o, r, s, a;
      return uy.wrap(function (t) {
        for (;;) switch (t.prev = t.next) {
          case 0:
            e = !0, i = !1, n = void 0, t.prev = 3, o = Iy(this._pairs);

          case 5:
            if (e = (r = o.next()).done) {
              t.next = 12;
              break;
            }

            return s = OO(r.value, 1), a = s[0], t.next = 9, a;

          case 9:
            e = !0, t.next = 5;
            break;

          case 12:
            t.next = 18;
            break;

          case 14:
            t.prev = 14, t.t0 = t.catch(3), i = !0, n = t.t0;

          case 18:
            t.prev = 18, t.prev = 19, e || null == o.return || o.return();

          case 21:
            if (t.prev = 21, !i) {
              t.next = 24;
              break;
            }

            throw n;

          case 24:
            return t.finish(21);

          case 25:
            return t.finish(18);

          case 26:
          case "end":
            return t.stop();
        }
      }, t, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
  }, {
    key: "values",
    value: uy.mark(function t() {
      var e, i, n, o, r, s, a;
      return uy.wrap(function (t) {
        for (;;) switch (t.prev = t.next) {
          case 0:
            e = !0, i = !1, n = void 0, t.prev = 3, o = Iy(this._pairs);

          case 5:
            if (e = (r = o.next()).done) {
              t.next = 12;
              break;
            }

            return s = OO(r.value, 2), a = s[1], t.next = 9, a;

          case 9:
            e = !0, t.next = 5;
            break;

          case 12:
            t.next = 18;
            break;

          case 14:
            t.prev = 14, t.t0 = t.catch(3), i = !0, n = t.t0;

          case 18:
            t.prev = 18, t.prev = 19, e || null == o.return || o.return();

          case 21:
            if (t.prev = 21, !i) {
              t.next = 24;
              break;
            }

            throw n;

          case 24:
            return t.finish(21);

          case 25:
            return t.finish(18);

          case 26:
          case "end":
            return t.stop();
        }
      }, t, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
  }, {
    key: "toIdArray",
    value: function () {
      var t;
      return Ug(t = yg(this._pairs)).call(t, function (t) {
        return t[0];
      });
    }
  }, {
    key: "toItemArray",
    value: function () {
      var t;
      return Ug(t = yg(this._pairs)).call(t, function (t) {
        return t[1];
      });
    }
  }, {
    key: "toEntryArray",
    value: function () {
      return yg(this._pairs);
    }
  }, {
    key: "toObjectMap",
    value: function () {
      var t = wO(null),
          e = !0,
          i = !1,
          n = void 0;

      try {
        for (var o, r = Iy(this._pairs); !(e = (o = r.next()).done); e = !0) {
          var s = OO(o.value, 2),
              a = s[0],
              h = s[1];
          t[a] = h;
        }
      } catch (t) {
        i = !0, n = t;
      } finally {
        try {
          e || null == r.return || r.return();
        } finally {
          if (i) throw n;
        }
      }

      return t;
    }
  }, {
    key: "toMap",
    value: function () {
      return new pm(this._pairs);
    }
  }, {
    key: "toIdSet",
    value: function () {
      return new bO(this.toIdArray());
    }
  }, {
    key: "toItemSet",
    value: function () {
      return new bO(this.toItemArray());
    }
  }, {
    key: "cache",
    value: function () {
      return new t(yg(this._pairs));
    }
  }, {
    key: "distinct",
    value: function (t) {
      var e = new bO(),
          i = !0,
          n = !1,
          o = void 0;

      try {
        for (var r, s = Iy(this._pairs); !(i = (r = s.next()).done); i = !0) {
          var a = OO(r.value, 2),
              h = a[0],
              l = a[1];
          e.add(t(l, h));
        }
      } catch (t) {
        n = !0, o = t;
      } finally {
        try {
          i || null == s.return || s.return();
        } finally {
          if (n) throw o;
        }
      }

      return e;
    }
  }, {
    key: "filter",
    value: function (e) {
      var i = this._pairs;
      return new t(My({}, gy, uy.mark(function t() {
        var n, o, r, s, a, h, l, d;
        return uy.wrap(function (t) {
          for (;;) switch (t.prev = t.next) {
            case 0:
              n = !0, o = !1, r = void 0, t.prev = 3, s = Iy(i);

            case 5:
              if (n = (a = s.next()).done) {
                t.next = 13;
                break;
              }

              if (h = OO(a.value, 2), l = h[0], d = h[1], !e(d, l)) {
                t.next = 10;
                break;
              }

              return t.next = 10, [l, d];

            case 10:
              n = !0, t.next = 5;
              break;

            case 13:
              t.next = 19;
              break;

            case 15:
              t.prev = 15, t.t0 = t.catch(3), o = !0, r = t.t0;

            case 19:
              t.prev = 19, t.prev = 20, n || null == s.return || s.return();

            case 22:
              if (t.prev = 22, !o) {
                t.next = 25;
                break;
              }

              throw r;

            case 25:
              return t.finish(22);

            case 26:
              return t.finish(19);

            case 27:
            case "end":
              return t.stop();
          }
        }, t, null, [[3, 15, 19, 27], [20,, 22, 26]]);
      })));
    }
  }, {
    key: "forEach",
    value: function (t) {
      var e = !0,
          i = !1,
          n = void 0;

      try {
        for (var o, r = Iy(this._pairs); !(e = (o = r.next()).done); e = !0) {
          var s = OO(o.value, 2),
              a = s[0];
          t(s[1], a);
        }
      } catch (t) {
        i = !0, n = t;
      } finally {
        try {
          e || null == r.return || r.return();
        } finally {
          if (i) throw n;
        }
      }
    }
  }, {
    key: "map",
    value: function (e) {
      var i = this._pairs;
      return new t(My({}, gy, uy.mark(function t() {
        var n, o, r, s, a, h, l, d;
        return uy.wrap(function (t) {
          for (;;) switch (t.prev = t.next) {
            case 0:
              n = !0, o = !1, r = void 0, t.prev = 3, s = Iy(i);

            case 5:
              if (n = (a = s.next()).done) {
                t.next = 12;
                break;
              }

              return h = OO(a.value, 2), l = h[0], d = h[1], t.next = 9, [l, e(d, l)];

            case 9:
              n = !0, t.next = 5;
              break;

            case 12:
              t.next = 18;
              break;

            case 14:
              t.prev = 14, t.t0 = t.catch(3), o = !0, r = t.t0;

            case 18:
              t.prev = 18, t.prev = 19, n || null == s.return || s.return();

            case 21:
              if (t.prev = 21, !o) {
                t.next = 24;
                break;
              }

              throw r;

            case 24:
              return t.finish(21);

            case 25:
              return t.finish(18);

            case 26:
            case "end":
              return t.stop();
          }
        }, t, null, [[3, 14, 18, 26], [19,, 21, 25]]);
      })));
    }
  }, {
    key: "max",
    value: function (t) {
      var e = Iy(this._pairs),
          i = e.next();
      if (i.done) return null;

      for (var n = i.value[1], o = t(i.value[1], i.value[0]); !(i = e.next()).done;) {
        var r = OO(i.value, 2),
            s = r[0],
            a = r[1],
            h = t(a, s);
        h > o && (o = h, n = a);
      }

      return n;
    }
  }, {
    key: "min",
    value: function (t) {
      var e = Iy(this._pairs),
          i = e.next();
      if (i.done) return null;

      for (var n = i.value[1], o = t(i.value[1], i.value[0]); !(i = e.next()).done;) {
        var r = OO(i.value, 2),
            s = r[0],
            a = r[1],
            h = t(a, s);
        h < o && (o = h, n = a);
      }

      return n;
    }
  }, {
    key: "reduce",
    value: function (t, e) {
      var i = !0,
          n = !1,
          o = void 0;

      try {
        for (var r, s = Iy(this._pairs); !(i = (r = s.next()).done); i = !0) {
          var a = OO(r.value, 2),
              h = a[0];
          e = t(e, a[1], h);
        }
      } catch (t) {
        n = !0, o = t;
      } finally {
        try {
          i || null == s.return || s.return();
        } finally {
          if (n) throw o;
        }
      }

      return e;
    }
  }, {
    key: "sort",
    value: function (e) {
      var i = this;
      return new t(My({}, gy, function () {
        var t;
        return Iy(Yy(t = yg(i._pairs)).call(t, function (t, i) {
          var n = OO(t, 2),
              o = n[0],
              r = n[1],
              s = OO(i, 2),
              a = s[0],
              h = s[1];
          return e(r, h, o, a);
        }));
      }));
    }
  }]), t;
}();

function MO(t, e) {
  var i = $g(t);

  if (Qv) {
    var n = Qv(t);
    e && (n = Eg(n).call(n, function (e) {
      return yv(t, e).enumerable;
    })), i.push.apply(i, n);
  }

  return i;
}

var EO = function (t) {
  function e(t, i) {
    var n;
    if (ym(this, e), n = wm(this, Om(e).call(this)), t && !vm(t) && (i = t, t = []), n._options = i || {}, n._data = new pm(), n.length = 0, n._idProp = n._options.fieldId || "id", n._type = {}, n._options.type) for (var o = $g(n._options.type), r = 0, s = o.length; r < s; r++) {
      var a = o[r],
          h = n._options.type[a];
      n._type[a] = "Date" == h || "ISODate" == h || "ASPDate" == h ? "Date" : h;
    }
    return t && t.length && n.add(t), n.setOptions(i), n;
  }

  return Tm(e, mO), mm(e, [{
    key: "setOptions",
    value: function (t) {
      t && void 0 !== t.queue && (!1 === t.queue ? this._queue && (this._queue.destroy(), delete this._queue) : (this._queue || (this._queue = gO.extend(this, {
        replace: ["add", "update", "remove"]
      })), t.queue && "object" === Zg(t.queue) && this._queue.setOptions(t.queue)));
    }
  }, {
    key: "add",
    value: function (t, e) {
      var i,
          n = this,
          o = [];

      if (vm(t)) {
        var r = Ug(t).call(t, function (t) {
          return t[n._idProp];
        });
        if (Yg(r).call(r, function (t) {
          return n._data.has(t);
        })) throw new Error("A duplicate id was found in the parameter array.");

        for (var s = 0, a = t.length; s < a; s++) i = this._addItem(t[s]), o.push(i);
      } else {
        if (!t || "object" !== Zg(t)) throw new Error("Unknown dataType");
        i = this._addItem(t), o.push(i);
      }

      return o.length && this._trigger("add", {
        items: o
      }, e), o;
    }
  }, {
    key: "update",
    value: function (t, e) {
      var i = this,
          n = [],
          o = [],
          r = [],
          s = [],
          a = this._idProp,
          h = function (t) {
        var e = t[a];

        if (null != e && i._data.has(e)) {
          var h = t,
              l = zg({}, i._data.get(e)),
              d = i._updateItem(h);

          o.push(d), s.push(h), r.push(l);
        } else {
          var u = i._addItem(t);

          n.push(u);
        }
      };

      if (vm(t)) for (var l = 0, d = t.length; l < d; l++) t[l] && "object" === Zg(t[l]) ? h(t[l]) : console.warn("Ignoring input item, which is not an object at index " + l);else {
        if (!t || "object" !== Zg(t)) throw new Error("Unknown dataType");
        h(t);
      }

      if (n.length && this._trigger("add", {
        items: n
      }, e), o.length) {
        var u = {
          items: o,
          oldData: r,
          data: s
        };

        this._trigger("update", u, e);
      }

      return Fg(n).call(n, o);
    }
  }, {
    key: "updateOnly",
    value: function (t, e) {
      var i,
          n = this;
      vm(t) || (t = [t]);
      var o = Ug(i = Ug(t).call(t, function (t) {
        var e = n._data.get(t[n._idProp]);

        if (null == e) throw new Error("Updating non-existent items is not allowed.");
        return {
          oldData: e,
          update: t
        };
      })).call(i, function (t) {
        var e = t.oldData,
            i = t.update,
            o = e[n._idProp],
            r = oO(oO({}, e), i);
        return n._data.set(o, r), {
          id: o,
          oldData: e,
          updatedData: r
        };
      });

      if (o.length) {
        var r = {
          items: Ug(o).call(o, function (t) {
            return t.id;
          }),
          oldData: Ug(o).call(o, function (t) {
            return t.oldData;
          }),
          data: Ug(o).call(o, function (t) {
            return t.updatedData;
          })
        };
        return this._trigger("update", r, e), r.items;
      }

      return [];
    }
  }, {
    key: "get",
    value: function (t, e) {
      var i = void 0,
          n = void 0,
          o = void 0;
      aO(t) ? (i = t, o = e) : vm(t) ? (n = t, o = e) : o = t;
      var r = o && "Object" === o.returnType ? "Object" : "Array",
          s = o && o.type || this._options.type,
          a = o && Eg(o),
          h = [],
          l = null,
          d = null,
          u = null;
      if (null != i) (l = this._getItem(i, s)) && a && !a(l) && (l = null);else if (null != n) for (var c = 0, f = n.length; c < f; c++) null == (l = this._getItem(n[c], s)) || a && !a(l) || h.push(l);else for (var p, v = 0, y = (d = yg(Ky(p = this._data).call(p))).length; v < y; v++) u = d[v], null == (l = this._getItem(u, s)) || a && !a(l) || h.push(l);

      if (o && o.order && null == i && this._sort(h, o.order), o && o.fields) {
        var g = o.fields;
        if (null != i && null != l) l = this._filterFields(l, g);else for (var m = 0, b = h.length; m < b; m++) h[m] = this._filterFields(h[m], g);
      }

      if ("Object" == r) {
        for (var w = {}, _ = 0, k = h.length; _ < k; _++) {
          var x = h[_];
          w[x[this._idProp]] = x;
        }

        return w;
      }

      return null != i ? l : h;
    }
  }, {
    key: "getIds",
    value: function (t) {
      var e,
          i,
          n = this._data,
          o = t && Eg(t),
          r = t && t.order,
          s = t && t.type || this._options.type,
          a = yg(Ky(n).call(n)),
          h = [];
      if (o) {
        if (r) {
          i = [];

          for (var l = 0, d = a.length; l < d; l++) {
            var u = a[l];
            o(e = this._getItem(u, s)) && i.push(e);
          }

          this._sort(i, r);

          for (var c = 0, f = i.length; c < f; c++) h.push(i[c][this._idProp]);
        } else for (var p = 0, v = a.length; p < v; p++) {
          var y = a[p];
          o(e = this._getItem(y, s)) && h.push(e[this._idProp]);
        }
      } else if (r) {
        i = [];

        for (var g = 0, m = a.length; g < m; g++) {
          var b = a[g];
          i.push(n.get(b));
        }

        this._sort(i, r);

        for (var w = 0, _ = i.length; w < _; w++) h.push(i[w][this._idProp]);
      } else for (var k = 0, x = a.length; k < x; k++) {
        var O = a[k];
        e = n.get(O), h.push(e[this._idProp]);
      }
      return h;
    }
  }, {
    key: "getDataSet",
    value: function () {
      return this;
    }
  }, {
    key: "forEach",
    value: function (t, e) {
      var i = e && Eg(e),
          n = e && e.type || this._options.type,
          o = this._data,
          r = yg(Ky(o).call(o));
      if (e && e.order) for (var s = this.get(e), a = 0, h = s.length; a < h; a++) {
        var l = s[a];
        t(l, l[this._idProp]);
      } else for (var d = 0, u = r.length; d < u; d++) {
        var c = r[d],
            f = this._getItem(c, n);

        i && !i(f) || t(f, c);
      }
    }
  }, {
    key: "map",
    value: function (t, e) {
      for (var i = e && Eg(e), n = e && e.type || this._options.type, o = [], r = this._data, s = yg(Ky(r).call(r)), a = 0, h = s.length; a < h; a++) {
        var l = s[a],
            d = this._getItem(l, n);

        i && !i(d) || o.push(t(d, l));
      }

      return e && e.order && this._sort(o, e.order), o;
    }
  }, {
    key: "_filterFields",
    value: function (t, e) {
      var i;
      return t ? Gy(i = vm(e) ? e : $g(e)).call(i, function (e, i) {
        return e[i] = t[i], e;
      }, {}) : t;
    }
  }, {
    key: "_sort",
    value: function (t, e) {
      if ("string" == typeof e) {
        var i = e;
        Yy(t).call(t, function (t, e) {
          var n = t[i],
              o = e[i];
          return n > o ? 1 : n < o ? -1 : 0;
        });
      } else {
        if ("function" != typeof e) throw new TypeError("Order must be a function or a string");
        Yy(t).call(t, e);
      }
    }
  }, {
    key: "remove",
    value: function (t, e) {
      for (var i = [], n = [], o = vm(t) ? t : [t], r = 0, s = o.length; r < s; r++) {
        var a = this._remove(o[r]);

        if (a) {
          var h = a[this._idProp];
          null != h && (i.push(h), n.push(a));
        }
      }

      return i.length && this._trigger("remove", {
        items: i,
        oldData: n
      }, e), i;
    }
  }, {
    key: "_remove",
    value: function (t) {
      var e;

      if (aO(t) ? e = t : t && "object" === Zg(t) && (e = t[this._idProp]), null != e && this._data.has(e)) {
        var i = this._data.get(e) || null;
        return this._data.delete(e), --this.length, i;
      }

      return null;
    }
  }, {
    key: "clear",
    value: function (t) {
      for (var e, i = yg(Ky(e = this._data).call(e)), n = [], o = 0, r = i.length; o < r; o++) n.push(this._data.get(i[o]));

      return this._data.clear(), this.length = 0, this._trigger("remove", {
        items: i,
        oldData: n
      }, t), i;
    }
  }, {
    key: "max",
    value: function (t) {
      var e = null,
          i = null,
          n = !0,
          o = !1,
          r = void 0;

      try {
        for (var s, a = Iy(Cy(h = this._data).call(h)); !(n = (s = a.next()).done); n = !0) {
          var h,
              l = s.value,
              d = l[t];
          "number" == typeof d && (null == i || d > i) && (e = l, i = d);
        }
      } catch (t) {
        o = !0, r = t;
      } finally {
        try {
          n || null == a.return || a.return();
        } finally {
          if (o) throw r;
        }
      }

      return e || null;
    }
  }, {
    key: "min",
    value: function (t) {
      var e = null,
          i = null,
          n = !0,
          o = !1,
          r = void 0;

      try {
        for (var s, a = Iy(Cy(h = this._data).call(h)); !(n = (s = a.next()).done); n = !0) {
          var h,
              l = s.value,
              d = l[t];
          "number" == typeof d && (null == i || d < i) && (e = l, i = d);
        }
      } catch (t) {
        o = !0, r = t;
      } finally {
        try {
          n || null == a.return || a.return();
        } finally {
          if (o) throw r;
        }
      }

      return e || null;
    }
  }, {
    key: "distinct",
    value: function (t) {
      for (var e = this._data, i = yg(Ky(e).call(e)), n = [], o = this._options.type && this._options.type[t] || null, r = 0, s = 0, a = i.length; s < a; s++) {
        for (var h = i[s], l = e.get(h)[t], d = !1, u = 0; u < r; u++) if (n[u] == l) {
          d = !0;
          break;
        }

        d || void 0 === l || (n[r] = l, r++);
      }

      if (o) for (var c = 0, f = n.length; c < f; c++) n[c] = rO(n[c], o);
      return n;
    }
  }, {
    key: "_addItem",
    value: function (t) {
      var e = t[this._idProp];

      if (null != e) {
        if (this._data.has(e)) throw new Error("Cannot add item: item with id " + e + " already exists");
      } else e = jm(), t[this._idProp] = e;

      for (var i = {}, n = $g(t), o = 0, r = n.length; o < r; o++) {
        var s = n[o],
            a = this._type[s];
        i[s] = rO(t[s], a);
      }

      return this._data.set(e, i), ++this.length, e;
    }
  }, {
    key: "_getItem",
    value: function (t, e) {
      var i,
          n = this._data.get(t);

      if (!n) return null;
      var o = $g(n);

      if (e) {
        i = {};

        for (var r = 0, s = o.length; r < s; r++) {
          var a = o[r],
              h = n[a];
          i[a] = rO(h, e[a]);
        }
      } else i = function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var i,
              n = null != arguments[e] ? arguments[e] : {};
          if (e % 2) fv(i = MO(n, !0)).call(i, function (e) {
            My(t, e, n[e]);
          });else if (Gf) Nf(t, Gf(n));else {
            var o;
            fv(o = MO(n)).call(o, function (e) {
              mf(t, e, yv(n, e));
            });
          }
        }

        return t;
      }({}, n);

      return null == i[this._idProp] && (i[this._idProp] = n.id), i;
    }
  }, {
    key: "_updateItem",
    value: function (t) {
      var e = t[this._idProp];
      if (null == e) throw new Error("Cannot update item: item has no id (item: " + Oy(t) + ")");

      var i = this._data.get(e);

      if (!i) throw new Error("Cannot update item: no item with id " + e + " found");

      for (var n = $g(t), o = 0, r = n.length; o < r; o++) {
        var s = n[o],
            a = this._type[s];
        i[s] = rO(t[s], a);
      }

      return e;
    }
  }, {
    key: "stream",
    value: function (t) {
      if (t) {
        var e = this._data;
        return new SO(My({}, gy, uy.mark(function i() {
          var n, o, r, s, a, h, l;
          return uy.wrap(function (i) {
            for (;;) switch (i.prev = i.next) {
              case 0:
                n = !0, o = !1, r = void 0, i.prev = 3, s = Iy(t);

              case 5:
                if (n = (a = s.next()).done) {
                  i.next = 14;
                  break;
                }

                if (h = a.value, null == (l = e.get(h))) {
                  i.next = 11;
                  break;
                }

                return i.next = 11, [h, l];

              case 11:
                n = !0, i.next = 5;
                break;

              case 14:
                i.next = 20;
                break;

              case 16:
                i.prev = 16, i.t0 = i.catch(3), o = !0, r = i.t0;

              case 20:
                i.prev = 20, i.prev = 21, n || null == s.return || s.return();

              case 23:
                if (i.prev = 23, !o) {
                  i.next = 26;
                  break;
                }

                throw r;

              case 26:
                return i.finish(23);

              case 27:
                return i.finish(20);

              case 28:
              case "end":
                return i.stop();
            }
          }, i, null, [[3, 16, 20, 28], [21,, 23, 27]]);
        })));
      }

      var i;
      return new SO(My({}, gy, dy(i = ny(this._data)).call(i, this._data)));
    }
  }]), e;
}(),
    DO = function (t) {
  function e(t, i) {
    var n, o;
    return ym(this, e), (o = wm(this, Om(e).call(this))).length = 0, o._ids = new bO(), o._options = i || {}, o._listener = dy(n = o._onEvent).call(n, bm(o)), o.setData(t), o;
  }

  return Tm(e, mO), mm(e, [{
    key: "setData",
    value: function (t) {
      if (this._data) {
        this._data.off && this._data.off("*", this._listener);

        var e = this._data.getIds({
          filter: Eg(this._options)
        }),
            i = this._data.get(e);

        this._ids.clear(), this.length = 0, this._trigger("remove", {
          items: e,
          oldData: i
        });
      }

      if (null != t) {
        this._data = t;

        for (var n = this._data.getIds({
          filter: Eg(this._options)
        }), o = 0, r = n.length; o < r; o++) {
          var s = n[o];

          this._ids.add(s);
        }

        this.length = n.length, this._trigger("add", {
          items: n
        });
      } else this._data = new EO();

      this._data.on && this._data.on("*", this._listener);
    }
  }, {
    key: "refresh",
    value: function () {
      for (var t = this._data.getIds({
        filter: Eg(this._options)
      }), e = yg(this._ids), i = {}, n = [], o = [], r = [], s = 0, a = t.length; s < a; s++) {
        var h = t[s];
        i[h] = !0, this._ids.has(h) || (n.push(h), this._ids.add(h));
      }

      for (var l = 0, d = e.length; l < d; l++) {
        var u = e[l],
            c = this._data.get(u);

        null == c ? console.error("If you see this, report it please.") : i[u] || (o.push(u), r.push(c), this._ids.delete(u));
      }

      this.length += n.length - o.length, n.length && this._trigger("add", {
        items: n
      }), o.length && this._trigger("remove", {
        items: o,
        oldData: r
      });
    }
  }, {
    key: "get",
    value: function (t, e) {
      if (null == this._data) return null;
      var i,
          n = null;
      aO(t) || vm(t) ? (n = t, i = e) : i = t;
      var o = zg({}, this._options, i),
          r = Eg(this._options),
          s = i && Eg(i);
      return r && s && (o.filter = function (t) {
        return r(t) && s(t);
      }), null == n ? this._data.get(o) : this._data.get(n, o);
    }
  }, {
    key: "getIds",
    value: function (t) {
      if (this._data.length) {
        var e,
            i = Eg(this._options),
            n = null != t ? Eg(t) : null;
        return e = n ? i ? function (t) {
          return i(t) && n(t);
        } : n : i, this._data.getIds({
          filter: e,
          order: t && t.order
        });
      }

      return [];
    }
  }, {
    key: "forEach",
    value: function (t, e) {
      if (this._data) {
        var i,
            n,
            o = Eg(this._options),
            r = e && Eg(e);
        n = r ? o ? function (t) {
          return o(t) && r(t);
        } : r : o, fv(i = this._data).call(i, t, {
          filter: n,
          order: e && e.order
        });
      }
    }
  }, {
    key: "map",
    value: function (t, e) {
      if (this._data) {
        var i,
            n,
            o = Eg(this._options),
            r = e && Eg(e);
        return n = r ? o ? function (t) {
          return o(t) && r(t);
        } : r : o, Ug(i = this._data).call(i, t, {
          filter: n,
          order: e && e.order
        });
      }

      return [];
    }
  }, {
    key: "getDataSet",
    value: function () {
      return this._data.getDataSet();
    }
  }, {
    key: "stream",
    value: function (t) {
      var e;
      return this._data.stream(t || My({}, gy, dy(e = Ky(this._ids)).call(e, this._ids)));
    }
  }, {
    key: "_onEvent",
    value: function (t, e, i) {
      if (e && e.items && this._data) {
        var n = e.items,
            o = [],
            r = [],
            s = [],
            a = [],
            h = [],
            l = [];

        switch (t) {
          case "add":
            for (var d = 0, u = n.length; d < u; d++) {
              var c = n[d];
              this.get(c) && (this._ids.add(c), o.push(c));
            }

            break;

          case "update":
            for (var f = 0, p = n.length; f < p; f++) {
              var v = n[f];
              this.get(v) ? this._ids.has(v) ? (r.push(v), h.push(e.data[f]), a.push(e.oldData[f])) : (this._ids.add(v), o.push(v)) : this._ids.has(v) && (this._ids.delete(v), s.push(v), l.push(e.oldData[f]));
            }

            break;

          case "remove":
            for (var y = 0, g = n.length; y < g; y++) {
              var m = n[y];
              this._ids.has(m) && (this._ids.delete(m), s.push(m), l.push(e.oldData[y]));
            }

        }

        this.length += o.length - s.length, o.length && this._trigger("add", {
          items: o
        }, i), r.length && this._trigger("update", {
          items: r,
          oldData: a,
          data: h
        }, i), s.length && this._trigger("remove", {
          items: s,
          oldData: l
        }, i);
      }
    }
  }]), e;
}(),
    TO = {
  DataSet: EO,
  DataView: DO,
  Queue: gO
},
    CO = Object.freeze({
  __proto__: null,
  default: TO,
  DataSet: EO,
  DataStream: SO,
  DataView: DO,
  Queue: gO
}),
    PO = rc;

exports.data = CO;
exports.DataView = DO;
exports.DataSet = EO;
W({
  target: "Object",
  stat: !0,
  forced: !s,
  sham: !s
}, {
  defineProperties: Aa
});

var AO = i(function (t) {
  var e = F.Object,
      i = t.exports = function (t, i) {
    return e.defineProperties(t, i);
  };

  e.defineProperties.sham && (i.sham = !0);
}),
    IO = Ca.concat("length", "prototype"),
    FO = {
  f: Object.getOwnPropertyNames || function (t) {
    return Ta(t, IO);
  }
},
    NO = {
  f: Object.getOwnPropertySymbols
},
    jO = Fa("Reflect", "ownKeys") || function (t) {
  var e = FO.f(z(t)),
      i = NO.f;
  return i ? e.concat(i(t)) : e;
};

W({
  target: "Object",
  stat: !0,
  sham: !s
}, {
  getOwnPropertyDescriptors: function (t) {
    for (var e, i, n = y(t), o = M.f, r = jO(n), s = {}, a = 0; r.length > a;) void 0 !== (i = o(n, e = r[a++])) && Eh(s, e, i);

    return s;
  }
});
var zO = F.Object.getOwnPropertyDescriptors,
    LO = M.f,
    RO = r(function () {
  LO(1);
});
W({
  target: "Object",
  stat: !0,
  forced: !s || RO,
  sham: !s
}, {
  getOwnPropertyDescriptor: function (t, e) {
    return LO(y(t), e);
  }
});
var BO = i(function (t) {
  var e = F.Object,
      i = t.exports = function (t, i) {
    return e.getOwnPropertyDescriptor(t, i);
  };

  e.getOwnPropertyDescriptor.sham && (i.sham = !0);
}),
    YO = BO,
    HO = vh.filter;
W({
  target: "Array",
  proto: !0,
  forced: !Fh("filter")
}, {
  filter: function (t) {
    return HO(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var WO = X("Array").filter,
    VO = Array.prototype,
    UO = function (t) {
  var e = t.filter;
  return t === VO || t instanceof Array && e === VO.filter ? WO : e;
},
    GO = FO.f,
    qO = {}.toString,
    XO = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
    ZO = {
  f: function (t) {
    return XO && "[object Window]" == qO.call(t) ? function (t) {
      try {
        return GO(t);
      } catch (t) {
        return XO.slice();
      }
    }(t) : GO(y(t));
  }
},
    KO = {
  f: va
},
    $O = R.f,
    JO = function (t) {
  var e = F.Symbol || (F.Symbol = {});
  w(e, t) || $O(e, t, {
    value: KO.f(t)
  });
},
    QO = vh.forEach,
    tS = Zs("hidden"),
    eS = va("toPrimitive"),
    iS = sa.set,
    nS = sa.getterFor("Symbol"),
    oS = Object.prototype,
    rS = o.Symbol,
    sS = Fa("JSON", "stringify"),
    aS = M.f,
    hS = R.f,
    lS = ZO.f,
    dS = l.f,
    uS = Ys("symbols"),
    cS = Ys("op-symbols"),
    fS = Ys("string-to-symbol-registry"),
    pS = Ys("symbol-to-string-registry"),
    vS = Ys("wks"),
    yS = o.QObject,
    gS = !yS || !yS.prototype || !yS.prototype.findChild,
    mS = s && r(function () {
  return 7 != Ra(hS({}, "a", {
    get: function () {
      return hS(this, "a", {
        value: 7
      }).a;
    }
  })).a;
}) ? function (t, e, i) {
  var n = aS(oS, e);
  n && delete oS[e], hS(t, e, i), n && t !== oS && hS(oS, e, n);
} : hS,
    bS = function (t, e) {
  var i = uS[t] = Ra(rS.prototype);
  return iS(i, {
    type: "Symbol",
    tag: t,
    description: e
  }), s || (i.description = e), i;
},
    wS = ca && "symbol" == typeof rS.iterator ? function (t) {
  return "symbol" == typeof t;
} : function (t) {
  return Object(t) instanceof rS;
},
    _S = function (t, e, i) {
  t === oS && _S(cS, e, i), z(t);
  var n = m(e, !0);
  return z(i), w(uS, n) ? (i.enumerable ? (w(t, tS) && t[tS][n] && (t[tS][n] = !1), i = Ra(i, {
    enumerable: d(0, !1)
  })) : (w(t, tS) || hS(t, tS, d(1, {})), t[tS][n] = !0), mS(t, n, i)) : hS(t, n, i);
},
    kS = function (t, e) {
  z(t);
  var i = y(e),
      n = Pa(i).concat(MS(i));
  return QO(n, function (e) {
    s && !xS.call(i, e) || _S(t, e, i[e]);
  }), t;
},
    xS = function (t) {
  var e = m(t, !0),
      i = dS.call(this, e);
  return !(this === oS && w(uS, e) && !w(cS, e)) && (!(i || !w(this, e) || !w(uS, e) || w(this, tS) && this[tS][e]) || i);
},
    OS = function (t, e) {
  var i = y(t),
      n = m(e, !0);

  if (i !== oS || !w(uS, n) || w(cS, n)) {
    var o = aS(i, n);
    return !o || !w(uS, n) || w(i, tS) && i[tS][n] || (o.enumerable = !0), o;
  }
},
    SS = function (t) {
  var e = lS(y(t)),
      i = [];
  return QO(e, function (t) {
    w(uS, t) || w(Ks, t) || i.push(t);
  }), i;
},
    MS = function (t) {
  var e = t === oS,
      i = lS(e ? cS : y(t)),
      n = [];
  return QO(i, function (t) {
    !w(uS, t) || e && !w(oS, t) || n.push(uS[t]);
  }), n;
};

if (ca || (Ja((rS = function () {
  if (this instanceof rS) throw TypeError("Symbol is not a constructor");

  var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
      e = qs(t),
      i = function (t) {
    this === oS && i.call(cS, t), w(this, tS) && w(this[tS], e) && (this[tS][e] = !1), mS(this, e, d(1, t));
  };

  return s && gS && mS(oS, e, {
    configurable: !0,
    set: i
  }), bS(e, t);
}).prototype, "toString", function () {
  return nS(this).tag;
}), l.f = xS, R.f = _S, M.f = OS, FO.f = ZO.f = SS, NO.f = MS, s && hS(rS.prototype, "description", {
  configurable: !0,
  get: function () {
    return nS(this).description;
  }
}), KO.f = function (t) {
  return bS(va(t), t);
}), W({
  global: !0,
  wrap: !0,
  forced: !ca,
  sham: !ca
}, {
  Symbol: rS
}), QO(Pa(vS), function (t) {
  JO(t);
}), W({
  target: "Symbol",
  stat: !0,
  forced: !ca
}, {
  for: function (t) {
    var e = String(t);
    if (w(fS, e)) return fS[e];
    var i = rS(e);
    return fS[e] = i, pS[i] = e, i;
  },
  keyFor: function (t) {
    if (!wS(t)) throw TypeError(t + " is not a symbol");
    if (w(pS, t)) return pS[t];
  },
  useSetter: function () {
    gS = !0;
  },
  useSimple: function () {
    gS = !1;
  }
}), W({
  target: "Object",
  stat: !0,
  forced: !ca,
  sham: !s
}, {
  create: function (t, e) {
    return void 0 === e ? Ra(t) : kS(Ra(t), e);
  },
  defineProperty: _S,
  defineProperties: kS,
  getOwnPropertyDescriptor: OS
}), W({
  target: "Object",
  stat: !0,
  forced: !ca
}, {
  getOwnPropertyNames: SS,
  getOwnPropertySymbols: MS
}), W({
  target: "Object",
  stat: !0,
  forced: r(function () {
    NO.f(1);
  })
}, {
  getOwnPropertySymbols: function (t) {
    return NO.f(aa(t));
  }
}), sS) {
  var ES = !ca || r(function () {
    var t = rS();
    return "[null]" != sS([t]) || "{}" != sS({
      a: t
    }) || "{}" != sS(Object(t));
  });
  W({
    target: "JSON",
    stat: !0,
    forced: ES
  }, {
    stringify: function (t, e, i) {
      for (var n, o = [t], r = 1; arguments.length > r;) o.push(arguments[r++]);

      if (n = e, (g(e) || void 0 !== t) && !wS(t)) return dh(e) || (e = function (t, e) {
        if ("function" == typeof n && (e = n.call(this, t, e)), !wS(e)) return e;
      }), o[1] = e, sS.apply(null, o);
    }
  });
}

rS.prototype[eS] || B(rS.prototype, eS, rS.prototype.valueOf), Xa(rS, "Symbol"), Ks[tS] = !0;
var DS = F.Object.getOwnPropertySymbols,
    TS = r(function () {
  Pa(1);
});
W({
  target: "Object",
  stat: !0,
  forced: TS
}, {
  keys: function (t) {
    return Pa(aa(t));
  }
});
var CS = F.Object.keys;

var PS = function (t, e, i) {
  return e in t ? sc(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
},
    AS = "\t\n\v\f\r \u2028\u2029\ufeff",
    IS = "[" + AS + "]",
    FS = RegExp("^" + IS + IS + "*"),
    NS = RegExp(IS + IS + "*$"),
    jS = function (t) {
  return function (e) {
    var i = String(v(e));
    return 1 & t && (i = i.replace(FS, "")), 2 & t && (i = i.replace(NS, "")), i;
  };
},
    zS = {
  start: jS(1),
  end: jS(2),
  trim: jS(3)
},
    LS = zS.trim,
    RS = o.parseFloat,
    BS = 1 / RS(AS + "-0") != -1 / 0 ? function (t) {
  var e = LS(String(t)),
      i = RS(e);
  return 0 === i && "-" == e.charAt(0) ? -0 : i;
} : RS;

W({
  global: !0,
  forced: parseFloat != BS
}, {
  parseFloat: BS
});
var YS = F.parseFloat,
    HS = zS.trim,
    WS = o.parseInt,
    VS = /^[+-]?0[Xx]/,
    US = 8 !== WS(AS + "08") || 22 !== WS(AS + "0x16") ? function (t, e) {
  var i = HS(String(t));
  return WS(i, e >>> 0 || (VS.test(i) ? 16 : 10));
} : WS;
W({
  global: !0,
  forced: parseInt != US
}, {
  parseInt: US
});
var GS = F.parseInt,
    qS = Sh;

var XS = function (t) {
  if (qS(t)) return t;
},
    ZS = va("iterator"),
    KS = function (t) {
  var e = Object(t);
  return void 0 !== e[ZS] || "@@iterator" in e || Rs.hasOwnProperty(Ha(e));
};

var $S = function (t, e) {
  if (KS(Object(t)) || "[object Arguments]" === Object.prototype.toString.call(t)) {
    var i = [],
        n = !0,
        o = !1,
        r = void 0;

    try {
      for (var s, a = kc(t); !(n = (s = a.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
    } catch (t) {
      o = !0, r = t;
    } finally {
      try {
        n || null == a.return || a.return();
      } finally {
        if (o) throw r;
      }
    }

    return i;
  }
};

var JS = function () {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
};

var QS = function (t, e) {
  return XS(t) || $S(t, e) || JS();
};

JO("iterator");

var tM = KO.f("iterator"),
    eM = va("isConcatSpreadable"),
    iM = Ah >= 51 || !r(function () {
  var t = [];
  return t[eM] = !1, t.concat()[0] !== t;
}),
    nM = Fh("concat"),
    oM = function (t) {
  if (!g(t)) return !1;
  var e = t[eM];
  return void 0 !== e ? !!e : dh(t);
};

W({
  target: "Array",
  proto: !0,
  forced: !iM || !nM
}, {
  concat: function (t) {
    var e,
        i,
        n,
        o,
        r,
        s = aa(this),
        a = ch(s, 0),
        h = 0;

    for (e = -1, n = arguments.length; e < n; e++) if (r = -1 === e ? s : arguments[e], oM(r)) {
      if (h + (o = ka(r.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");

      for (i = 0; i < o; i++, h++) i in r && Eh(a, h, r[i]);
    } else {
      if (h >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
      Eh(a, h++, r);
    }

    return a.length = h, a;
  }
}), JO("asyncIterator"), JO("hasInstance"), JO("isConcatSpreadable"), JO("match"), JO("matchAll"), JO("replace"), JO("search"), JO("species"), JO("split"), JO("toPrimitive"), JO("toStringTag"), JO("unscopables"), Xa(Math, "Math", !0), Xa(o.JSON, "JSON", !0);
var rM = F.Symbol;
JO("asyncDispose"), JO("dispose"), JO("observable"), JO("patternMatch"), JO("replaceAll");

var sM = rM,
    aM = i(function (t) {
  function e(t) {
    return (e = "function" == typeof sM && "symbol" == typeof tM ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof sM && t.constructor === sM && t !== sM.prototype ? "symbol" : typeof t;
    })(t);
  }

  function i(n) {
    return "function" == typeof sM && "symbol" === e(tM) ? t.exports = i = function (t) {
      return e(t);
    } : t.exports = i = function (t) {
      return t && "function" == typeof sM && t.constructor === sM && t !== sM.prototype ? "symbol" : e(t);
    }, i(n);
  }

  t.exports = i;
}),
    hM = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "choosify",
    value: function (t, e) {
      var i = ["node", "edge", "label"],
          n = !0,
          o = Is(e, "chosen");
      if ("boolean" == typeof o) n = o;else if ("object" === aM(o)) {
        if (-1 === el(i).call(i, t)) throw new Error("choosify: subOption '" + t + "' should be one of '" + i.join("', '") + "'");
        var r = Is(e, ["chosen", t]);
        "boolean" != typeof r && "function" != typeof r || (n = r);
      }
      return n;
    }
  }, {
    key: "pointInRect",
    value: function (t, e, i) {
      if (t.width <= 0 || t.height <= 0) return !1;

      if (void 0 !== i) {
        var n = {
          x: e.x - i.x,
          y: e.y - i.y
        };

        if (0 !== i.angle) {
          var o = -i.angle;
          e = {
            x: Math.cos(o) * n.x - Math.sin(o) * n.y,
            y: Math.sin(o) * n.x + Math.cos(o) * n.y
          };
        } else e = n;
      }

      var r = t.x + t.width,
          s = t.y + t.width;
      return t.left < e.x && r > e.x && t.top < e.y && s > e.y;
    }
  }, {
    key: "isValidLabel",
    value: function (t) {
      return "string" == typeof t && "" !== t;
    }
  }]), t;
}(),
    lM = va("species"),
    dM = [].slice,
    uM = Math.max;

W({
  target: "Array",
  proto: !0,
  forced: !Fh("slice")
}, {
  slice: function (t, e) {
    var i,
        n,
        o,
        r = y(this),
        s = ka(r.length),
        a = Sa(t, s),
        h = Sa(void 0 === e ? s : e, s);
    if (dh(r) && ("function" != typeof (i = r.constructor) || i !== Array && !dh(i.prototype) ? g(i) && null === (i = i[lM]) && (i = void 0) : i = void 0, i === Array || void 0 === i)) return dM.call(r, a, h);

    for (n = new (void 0 === i ? Array : i)(uM(h - a, 0)), o = 0; a < h; a++, o++) a in r && Eh(n, o, r[a]);

    return n.length = o, n;
  }
});

var cM = X("Array").slice,
    fM = Array.prototype,
    pM = function (t) {
  var e = t.slice;
  return t === fM || t instanceof Array && e === fM.slice ? cM : e;
},
    vM = X("Array").values,
    yM = Array.prototype,
    gM = {
  DOMTokenList: !0,
  NodeList: !0
},
    mM = function (t) {
  var e = t.values;
  return t === yM || t instanceof Array && e === yM.values || gM.hasOwnProperty(Ha(t)) ? vM : e;
},
    bM = Object.assign,
    wM = !bM || r(function () {
  var t = {},
      e = {},
      i = Symbol();
  return t[i] = 7, "abcdefghijklmnopqrst".split("").forEach(function (t) {
    e[t] = t;
  }), 7 != bM({}, t)[i] || "abcdefghijklmnopqrst" != Pa(bM({}, e)).join("");
}) ? function (t, e) {
  for (var i = aa(t), n = arguments.length, o = 1, r = NO.f, a = l.f; n > o;) for (var h, d = p(arguments[o++]), u = r ? Pa(d).concat(r(d)) : Pa(d), c = u.length, f = 0; c > f;) h = u[f++], s && !a.call(d, h) || (i[h] = d[h]);

  return i;
} : bM;

W({
  target: "Object",
  stat: !0,
  forced: Object.assign !== wM
}, {
  assign: wM
});

var _M = F.Object.assign,
    kM = function () {
  function t(e) {
    oc(this, t), this.measureText = e, this.current = 0, this.width = 0, this.height = 0, this.lines = [];
  }

  return hc(t, [{
    key: "_add",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "normal";
      void 0 === this.lines[t] && (this.lines[t] = {
        width: 0,
        height: 0,
        blocks: []
      });
      var n = e;
      void 0 !== e && "" !== e || (n = " ");

      var o = this.measureText(n, i),
          r = _M({}, mM(o));

      r.text = e, r.width = o.width, r.mod = i, void 0 !== e && "" !== e || (r.width = 0), this.lines[t].blocks.push(r), this.lines[t].width += r.width;
    }
  }, {
    key: "curWidth",
    value: function () {
      var t = this.lines[this.current];
      return void 0 === t ? 0 : t.width;
    }
  }, {
    key: "append",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal";

      this._add(this.current, t, e);
    }
  }, {
    key: "newLine",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal";
      this._add(this.current, t, e), this.current++;
    }
  }, {
    key: "determineLineHeights",
    value: function () {
      for (var t = 0; t < this.lines.length; t++) {
        var e = this.lines[t],
            i = 0;
        if (void 0 !== e.blocks) for (var n = 0; n < e.blocks.length; n++) {
          var o = e.blocks[n];
          i < o.height && (i = o.height);
        }
        e.height = i;
      }
    }
  }, {
    key: "determineLabelSize",
    value: function () {
      for (var t = 0, e = 0, i = 0; i < this.lines.length; i++) {
        var n = this.lines[i];
        n.width > t && (t = n.width), e += n.height;
      }

      this.width = t, this.height = e;
    }
  }, {
    key: "removeEmptyBlocks",
    value: function () {
      for (var t = [], e = 0; e < this.lines.length; e++) {
        var i = this.lines[e];

        if (0 !== i.blocks.length && (e !== this.lines.length - 1 || 0 !== i.width)) {
          var n = {};
          _M(n, i), n.blocks = [];

          for (var o = void 0, r = [], s = 0; s < i.blocks.length; s++) {
            var a = i.blocks[s];
            0 !== a.width ? r.push(a) : void 0 === o && (o = a);
          }

          0 === r.length && void 0 !== o && r.push(o), n.blocks = r, t.push(n);
        }
      }

      return t;
    }
  }, {
    key: "finalize",
    value: function () {
      this.determineLineHeights(), this.determineLabelSize();
      var t = this.removeEmptyBlocks();
      return {
        width: this.width,
        height: this.height,
        lines: t
      };
    }
  }]), t;
}(),
    xM = {
  "<b>": /<b>/,
  "<i>": /<i>/,
  "<code>": /<code>/,
  "</b>": /<\/b>/,
  "</i>": /<\/i>/,
  "</code>": /<\/code>/,
  "*": /\*/,
  _: /\_/,
  "`": /`/,
  afterBold: /[^\*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/
},
    OM = function () {
  function t(e) {
    oc(this, t), this.text = e, this.bold = !1, this.ital = !1, this.mono = !1, this.spacing = !1, this.position = 0, this.buffer = "", this.modStack = [], this.blocks = [];
  }

  return hc(t, [{
    key: "mod",
    value: function () {
      return 0 === this.modStack.length ? "normal" : this.modStack[0];
    }
  }, {
    key: "modName",
    value: function () {
      return 0 === this.modStack.length ? "normal" : "mono" === this.modStack[0] ? "mono" : this.bold && this.ital ? "boldital" : this.bold ? "bold" : this.ital ? "ital" : void 0;
    }
  }, {
    key: "emitBlock",
    value: function () {
      this.spacing && (this.add(" "), this.spacing = !1), this.buffer.length > 0 && (this.blocks.push({
        text: this.buffer,
        mod: this.modName()
      }), this.buffer = "");
    }
  }, {
    key: "add",
    value: function (t) {
      " " === t && (this.spacing = !0), this.spacing && (this.buffer += " ", this.spacing = !1), " " != t && (this.buffer += t);
    }
  }, {
    key: "parseWS",
    value: function (t) {
      return !!/[ \t]/.test(t) && (this.mono ? this.add(t) : this.spacing = !0, !0);
    }
  }, {
    key: "setTag",
    value: function (t) {
      this.emitBlock(), this[t] = !0, this.modStack.unshift(t);
    }
  }, {
    key: "unsetTag",
    value: function (t) {
      this.emitBlock(), this[t] = !1, this.modStack.shift();
    }
  }, {
    key: "parseStartTag",
    value: function (t, e) {
      return !(this.mono || this[t] || !this.match(e)) && (this.setTag(t), !0);
    }
  }, {
    key: "match",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = this.prepareRegExp(t),
          n = QS(i, 2),
          o = n[0],
          r = n[1],
          s = o.test(this.text.substr(this.position, r));
      return s && e && (this.position += r - 1), s;
    }
  }, {
    key: "parseEndTag",
    value: function (t, e, i) {
      var n = this.mod() === t;
      return !(!(n = "mono" === t ? n && this.mono : n && !this.mono) || !this.match(e)) && (void 0 !== i ? (this.position === this.text.length - 1 || this.match(i, !1)) && this.unsetTag(t) : this.unsetTag(t), !0);
    }
  }, {
    key: "replace",
    value: function (t, e) {
      return !!this.match(t) && (this.add(e), this.position += length - 1, !0);
    }
  }, {
    key: "prepareRegExp",
    value: function (t) {
      var e, i;
      if (t instanceof RegExp) i = t, e = 1;else {
        var n = xM[t];
        i = void 0 !== n ? n : new RegExp(t), e = t.length;
      }
      return [i, e];
    }
  }]), t;
}(),
    SM = function () {
  function t(e, i, n, o) {
    var r = this;
    oc(this, t), this.ctx = e, this.parent = i, this.selected = n, this.hover = o;
    this.lines = new kM(function (t, i) {
      if (void 0 === t) return 0;
      var s = r.parent.getFormattingValues(e, n, o, i),
          a = 0;
      "" !== t && (a = r.ctx.measureText(t).width);
      return {
        width: a,
        values: s
      };
    });
  }

  return hc(t, [{
    key: "process",
    value: function (t) {
      if (!hM.isValidLabel(t)) return this.lines.finalize();
      var e = this.parent.fontOptions;
      t = (t = t.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
      var i = String(t).split("\n"),
          n = i.length;
      if (e.multi) for (var o = 0; o < n; o++) {
        var r = this.splitBlocks(i[o], e.multi);
        if (void 0 !== r) if (0 !== r.length) {
          if (e.maxWdt > 0) for (var s = 0; s < r.length; s++) {
            var a = r[s].mod,
                h = r[s].text;
            this.splitStringIntoLines(h, a, !0);
          } else for (var l = 0; l < r.length; l++) {
            var d = r[l].mod,
                u = r[l].text;
            this.lines.append(u, d);
          }
          this.lines.newLine();
        } else this.lines.newLine("");
      } else if (e.maxWdt > 0) for (var c = 0; c < n; c++) this.splitStringIntoLines(i[c]);else for (var f = 0; f < n; f++) this.lines.newLine(i[f]);
      return this.lines.finalize();
    }
  }, {
    key: "decodeMarkupSystem",
    value: function (t) {
      var e = "none";
      return "markdown" === t || "md" === t ? e = "markdown" : !0 !== t && "html" !== t || (e = "html"), e;
    }
  }, {
    key: "splitHtmlBlocks",
    value: function (t) {
      for (var e = new OM(t), i = function (t) {
        return !!/&/.test(t) && (e.replace(e.text, "&lt;", "<") || e.replace(e.text, "&amp;", "&") || e.add("&"), !0);
      }; e.position < e.text.length;) {
        var n = e.text.charAt(e.position);
        e.parseWS(n) || /</.test(n) && (e.parseStartTag("bold", "<b>") || e.parseStartTag("ital", "<i>") || e.parseStartTag("mono", "<code>") || e.parseEndTag("bold", "</b>") || e.parseEndTag("ital", "</i>") || e.parseEndTag("mono", "</code>")) || i(n) || e.add(n), e.position++;
      }

      return e.emitBlock(), e.blocks;
    }
  }, {
    key: "splitMarkdownBlocks",
    value: function (t) {
      for (var e = this, i = new OM(t), n = !0, o = function (t) {
        return !!/\\/.test(t) && (i.position < e.text.length + 1 && (i.position++, t = e.text.charAt(i.position), / \t/.test(t) ? i.spacing = !0 : (i.add(t), n = !1)), !0);
      }; i.position < i.text.length;) {
        var r = i.text.charAt(i.position);
        i.parseWS(r) || o(r) || (n || i.spacing) && (i.parseStartTag("bold", "*") || i.parseStartTag("ital", "_") || i.parseStartTag("mono", "`")) || i.parseEndTag("bold", "*", "afterBold") || i.parseEndTag("ital", "_", "afterItal") || i.parseEndTag("mono", "`", "afterMono") || (i.add(r), n = !1), i.position++;
      }

      return i.emitBlock(), i.blocks;
    }
  }, {
    key: "splitBlocks",
    value: function (t, e) {
      var i = this.decodeMarkupSystem(e);
      return "none" === i ? [{
        text: t,
        mod: "normal"
      }] : "markdown" === i ? this.splitMarkdownBlocks(t) : "html" === i ? this.splitHtmlBlocks(t) : void 0;
    }
  }, {
    key: "overMaxWidth",
    value: function (t) {
      var e = this.ctx.measureText(t).width;
      return this.lines.curWidth() + e > this.parent.fontOptions.maxWdt;
    }
  }, {
    key: "getLongestFit",
    value: function (t) {
      for (var e = "", i = 0; i < t.length;) {
        var n = e + ("" === e ? "" : " ") + t[i];
        if (this.overMaxWidth(n)) break;
        e = n, i++;
      }

      return i;
    }
  }, {
    key: "getLongestFitWord",
    value: function (t) {
      for (var e = 0; e < t.length && !this.overMaxWidth(pM(t).call(t, 0, e));) e++;

      return e;
    }
  }, {
    key: "splitStringIntoLines",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal",
          i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, e);

      for (var n = (t = (t = t.replace(/^( +)/g, "$1\r")).replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r")).split("\r"); n.length > 0;) {
        var o = this.getLongestFit(n);

        if (0 === o) {
          var r = n[0],
              s = this.getLongestFitWord(r);
          this.lines.newLine(pM(r).call(r, 0, s), e), n[0] = pM(r).call(r, s);
        } else {
          var a = o;
          " " === n[o - 1] ? o-- : " " === n[a] && a++;
          var h = pM(n).call(n, 0, o).join("");
          o == n.length && i ? this.lines.append(h, e) : this.lines.newLine(h, e), n = pM(n).call(n, a);
        }
      }
    }
  }]), t;
}(),
    MM = ["bold", "ital", "boldital", "mono"],
    EM = function () {
  function t(e, i) {
    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    oc(this, t), this.body = e, this.pointToSelf = !1, this.baseSize = void 0, this.fontOptions = {}, this.setOptions(i), this.size = {
      top: 0,
      left: 0,
      width: 0,
      height: 0,
      yLine: 0
    }, this.isEdgeLabel = n;
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      if (this.elementOptions = t, this.initFontOptions(t.font), hM.isValidLabel(t.label) ? this.labelDirty = !0 : t.label = void 0, void 0 !== t.font && null !== t.font) if ("string" == typeof t.font) this.baseSize = this.fontOptions.size;else if ("object" === aM(t.font)) {
        var e = t.font.size;
        void 0 !== e && (this.baseSize = e);
      }
    }
  }, {
    key: "initFontOptions",
    value: function (e) {
      var i = this;
      es(MM, function (t) {
        i.fontOptions[t] = {};
      }), t.parseFontString(this.fontOptions, e) ? this.fontOptions.vadjust = 0 : es(e, function (t, e) {
        null != t && "object" !== aM(t) && (i.fontOptions[e] = t);
      });
    }
  }, {
    key: "constrain",
    value: function (t) {
      var e = {
        constrainWidth: !1,
        maxWdt: -1,
        minWdt: -1,
        constrainHeight: !1,
        minHgt: -1,
        valign: "middle"
      },
          i = Is(t, "widthConstraint");
      if ("number" == typeof i) e.maxWdt = Number(i), e.minWdt = Number(i);else if ("object" === aM(i)) {
        var n = Is(t, ["widthConstraint", "maximum"]);
        "number" == typeof n && (e.maxWdt = Number(n));
        var o = Is(t, ["widthConstraint", "minimum"]);
        "number" == typeof o && (e.minWdt = Number(o));
      }
      var r = Is(t, "heightConstraint");
      if ("number" == typeof r) e.minHgt = Number(r);else if ("object" === aM(r)) {
        var s = Is(t, ["heightConstraint", "minimum"]);
        "number" == typeof s && (e.minHgt = Number(s));
        var a = Is(t, ["heightConstraint", "valign"]);
        "string" == typeof a && ("top" !== a && "bottom" !== a || (e.valign = a));
      }
      return e;
    }
  }, {
    key: "update",
    value: function (t, e) {
      this.setOptions(t, !0), this.propagateFonts(e), Ur(this.fontOptions, this.constrain(e)), this.fontOptions.chooser = hM.choosify("label", e);
    }
  }, {
    key: "adjustSizes",
    value: function (t) {
      var e = t ? t.right + t.left : 0;
      this.fontOptions.constrainWidth && (this.fontOptions.maxWdt -= e, this.fontOptions.minWdt -= e);
      var i = t ? t.top + t.bottom : 0;
      this.fontOptions.constrainHeight && (this.fontOptions.minHgt -= i);
    }
  }, {
    key: "addFontOptionsToPile",
    value: function (t, e) {
      for (var i = 0; i < e.length; ++i) this.addFontToPile(t, e[i]);
    }
  }, {
    key: "addFontToPile",
    value: function (t, e) {
      if (void 0 !== e && void 0 !== e.font && null !== e.font) {
        var i = e.font;
        t.push(i);
      }
    }
  }, {
    key: "getBasicOptions",
    value: function (e) {
      for (var i = {}, n = 0; n < e.length; ++n) {
        var o = e[n],
            r = {};
        t.parseFontString(r, o) && (o = r), es(o, function (t, e) {
          void 0 !== t && (i.hasOwnProperty(e) || (-1 !== el(MM).call(MM, e) ? i[e] = {} : i[e] = t));
        });
      }

      return i;
    }
  }, {
    key: "getFontOption",
    value: function (e, i, n) {
      for (var o, r = 0; r < e.length; ++r) {
        var s = e[r];

        if (s.hasOwnProperty(i)) {
          if (null == (o = s[i])) continue;
          var a = {};
          if (t.parseFontString(a, o) && (o = a), o.hasOwnProperty(n)) return o[n];
        }
      }

      if (this.fontOptions.hasOwnProperty(n)) return this.fontOptions[n];
      throw new Error("Did not find value for multi-font for property: '" + n + "'");
    }
  }, {
    key: "getFontOptions",
    value: function (t, e) {
      for (var i = {}, n = ["color", "size", "face", "mod", "vadjust"], o = 0; o < n.length; ++o) {
        var r = n[o];
        i[r] = this.getFontOption(t, e, r);
      }

      return i;
    }
  }, {
    key: "propagateFonts",
    value: function (t) {
      var e = this,
          i = [];
      this.addFontOptionsToPile(i, t), this.fontOptions = this.getBasicOptions(i);

      for (var n = function (t) {
        var n = MM[t],
            o = e.fontOptions[n];
        es(e.getFontOptions(i, n), function (t, e) {
          o[e] = t;
        }), o.size = Number(o.size), o.vadjust = Number(o.vadjust);
      }, o = 0; o < MM.length; ++o) n(o);
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o) {
      var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "middle";

      if (void 0 !== this.elementOptions.label) {
        var s = this.fontOptions.size * this.body.view.scale;
        this.elementOptions.label && s < this.elementOptions.scaling.label.drawThreshold - 1 || (s >= this.elementOptions.scaling.label.maxVisible && (s = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale), this.calculateLabelSize(t, n, o, e, i, r), this._drawBackground(t), this._drawText(t, e, this.size.yLine, r, s));
      }
    }
  }, {
    key: "_drawBackground",
    value: function (t) {
      if (void 0 !== this.fontOptions.background && "none" !== this.fontOptions.background) {
        t.fillStyle = this.fontOptions.background;
        var e = this.getSize();
        t.fillRect(e.left, e.top, e.width, e.height);
      }
    }
  }, {
    key: "_drawText",
    value: function (t, e, i) {
      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "middle",
          o = arguments.length > 4 ? arguments[4] : void 0,
          r = this._setAlignment(t, e, i, n),
          s = QS(r, 2);

      e = s[0], i = s[1], t.textAlign = "left", e -= this.size.width / 2, this.fontOptions.valign && this.size.height > this.size.labelHeight && ("top" === this.fontOptions.valign && (i -= (this.size.height - this.size.labelHeight) / 2), "bottom" === this.fontOptions.valign && (i += (this.size.height - this.size.labelHeight) / 2));

      for (var a = 0; a < this.lineCount; a++) {
        var h = this.lines[a];

        if (h && h.blocks) {
          var l = 0;
          this.isEdgeLabel || "center" === this.fontOptions.align ? l += (this.size.width - h.width) / 2 : "right" === this.fontOptions.align && (l += this.size.width - h.width);

          for (var d = 0; d < h.blocks.length; d++) {
            var u = h.blocks[d];
            t.font = u.font;

            var c = this._getColor(u.color, o, u.strokeColor),
                f = QS(c, 2),
                p = f[0],
                v = f[1];

            u.strokeWidth > 0 && (t.lineWidth = u.strokeWidth, t.strokeStyle = v, t.lineJoin = "round"), t.fillStyle = p, u.strokeWidth > 0 && t.strokeText(u.text, e + l, i + u.vadjust), t.fillText(u.text, e + l, i + u.vadjust), l += u.width;
          }

          i += h.height;
        }
      }
    }
  }, {
    key: "_setAlignment",
    value: function (t, e, i, n) {
      if (this.isEdgeLabel && "horizontal" !== this.fontOptions.align && !1 === this.pointToSelf) {
        e = 0, i = 0;
        "top" === this.fontOptions.align ? (t.textBaseline = "alphabetic", i -= 4) : "bottom" === this.fontOptions.align ? (t.textBaseline = "hanging", i += 4) : t.textBaseline = "middle";
      } else t.textBaseline = n;

      return [e, i];
    }
  }, {
    key: "_getColor",
    value: function (t, e, i) {
      var n = t || "#000000",
          o = i || "#ffffff";

      if (e <= this.elementOptions.scaling.label.drawThreshold) {
        var r = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - e)));
        n = cs(n, r), o = cs(o, r);
      }

      return [n, o];
    }
  }, {
    key: "getTextSize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return this._processLabel(t, e, i), {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }
  }, {
    key: "getSize",
    value: function () {
      var t = this.size.left,
          e = this.size.top - 1;

      if (this.isEdgeLabel) {
        var i = .5 * -this.size.width;

        switch (this.fontOptions.align) {
          case "middle":
            t = i, e = .5 * -this.size.height;
            break;

          case "top":
            t = i, e = -(this.size.height + 2);
            break;

          case "bottom":
            t = i, e = 2;
        }
      }

      return {
        left: t,
        top: e,
        width: this.size.width,
        height: this.size.height
      };
    }
  }, {
    key: "calculateLabelSize",
    value: function (t, e, i) {
      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
          o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
          r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "middle";
      this._processLabel(t, e, i), this.size.left = n - .5 * this.size.width, this.size.top = o - .5 * this.size.height, this.size.yLine = o + .5 * (1 - this.lineCount) * this.fontOptions.size, "hanging" === r && (this.size.top += .5 * this.fontOptions.size, this.size.top += 4, this.size.yLine += 4);
    }
  }, {
    key: "getFormattingValues",
    value: function (t, e, i, n) {
      var o = function (t, e, i) {
        return "normal" === e ? "mod" === i ? "" : t[i] : void 0 !== t[e][i] ? t[e][i] : t[i];
      },
          r = {
        color: o(this.fontOptions, n, "color"),
        size: o(this.fontOptions, n, "size"),
        face: o(this.fontOptions, n, "face"),
        mod: o(this.fontOptions, n, "mod"),
        vadjust: o(this.fontOptions, n, "vadjust"),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };

      (e || i) && ("normal" === n && !0 === this.fontOptions.chooser && this.elementOptions.labelHighlightBold ? r.mod = "bold" : "function" == typeof this.fontOptions.chooser && this.fontOptions.chooser(r, this.elementOptions.id, e, i));
      var s = "";
      return void 0 !== r.mod && "" !== r.mod && (s += r.mod + " "), s += r.size + "px " + r.face, t.font = s.replace(/"/g, ""), r.font = t.font, r.height = r.size, r;
    }
  }, {
    key: "differentState",
    value: function (t, e) {
      return t !== this.selectedState || e !== this.hoverState;
    }
  }, {
    key: "_processLabelText",
    value: function (t, e, i, n) {
      return new SM(t, this, e, i).process(n);
    }
  }, {
    key: "_processLabel",
    value: function (t, e, i) {
      if (!1 !== this.labelDirty || this.differentState(e, i)) {
        var n = this._processLabelText(t, e, i, this.elementOptions.label);

        this.fontOptions.minWdt > 0 && n.width < this.fontOptions.minWdt && (n.width = this.fontOptions.minWdt), this.size.labelHeight = n.height, this.fontOptions.minHgt > 0 && n.height < this.fontOptions.minHgt && (n.height = this.fontOptions.minHgt), this.lines = n.lines, this.lineCount = n.lines.length, this.size.width = n.width, this.size.height = n.height, this.selectedState = e, this.hoverState = i, this.labelDirty = !1;
      }
    }
  }, {
    key: "visible",
    value: function () {
      return 0 !== this.size.width && 0 !== this.size.height && void 0 !== this.elementOptions.label && !(this.fontOptions.size * this.body.view.scale < this.elementOptions.scaling.label.drawThreshold - 1);
    }
  }], [{
    key: "parseFontString",
    value: function (t, e) {
      if (!e || "string" != typeof e) return !1;
      var i = e.split(" ");
      return t.size = +i[0].replace("px", ""), t.face = i[1], t.color = i[2], !0;
    }
  }]), t;
}();

var DM = function (t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
};

var TM = function (t, e) {
  return !e || "object" !== aM(e) && "function" != typeof e ? DM(t) : e;
},
    CM = r(function () {
  ua(1);
});

W({
  target: "Object",
  stat: !0,
  forced: CM,
  sham: !ha
}, {
  getPrototypeOf: function (t) {
    return ua(aa(t));
  }
});
var PM = F.Object.getPrototypeOf;
W({
  target: "Object",
  stat: !0
}, {
  setPrototypeOf: $a
});
var AM = F.Object.setPrototypeOf,
    IM = i(function (t) {
  function e(i) {
    return t.exports = e = AM ? PM : function (t) {
      return t.__proto__ || PM(t);
    }, e(i);
  }

  t.exports = e;
}),
    FM = nl,
    NM = i(function (t) {
  function e(i, n) {
    return t.exports = e = AM || function (t, e) {
      return t.__proto__ = e, t;
    }, e(i, n);
  }

  t.exports = e;
});

var jM = function (t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = FM(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), e && NM(t, e);
};

W({
  target: "Array",
  proto: !0
}, {
  fill: function (t) {
    for (var e = aa(this), i = ka(e.length), n = arguments.length, o = Sa(n > 1 ? arguments[1] : void 0, i), r = n > 2 ? arguments[2] : void 0, s = void 0 === r ? i : Sa(r, i); s > o;) e[o++] = t;

    return e;
  }
});

var zM = X("Array").fill,
    LM = Array.prototype,
    RM = function (t) {
  var e = t.fill;
  return t === LM || t instanceof Array && e === LM.fill ? zM : e;
},
    BM = function () {
  function t(e, i, n) {
    oc(this, t), this.body = i, this.labelModule = n, this.setOptions(e), this.top = void 0, this.left = void 0, this.height = void 0, this.width = void 0, this.radius = void 0, this.margin = void 0, this.refreshNeeded = !0, this.boundingBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t;
    }
  }, {
    key: "_setMargins",
    value: function (t) {
      this.margin = {}, this.options.margin && ("object" == aM(this.options.margin) ? (this.margin.top = this.options.margin.top, this.margin.right = this.options.margin.right, this.margin.bottom = this.options.margin.bottom, this.margin.left = this.options.margin.left) : (this.margin.top = this.options.margin, this.margin.right = this.options.margin, this.margin.bottom = this.options.margin, this.margin.left = this.options.margin)), t.adjustSizes(this.margin);
    }
  }, {
    key: "_distanceToBorder",
    value: function (t, e) {
      var i = this.options.borderWidth;
      return this.resize(t), Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;
    }
  }, {
    key: "enableShadow",
    value: function (t, e) {
      e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);
    }
  }, {
    key: "disableShadow",
    value: function (t, e) {
      e.shadow && (t.shadowColor = "rgba(0,0,0,0)", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);
    }
  }, {
    key: "enableBorderDashes",
    value: function (t, e) {
      if (!1 !== e.borderDashes) if (void 0 !== t.setLineDash) {
        var i = e.borderDashes;
        !0 === i && (i = [5, 15]), t.setLineDash(i);
      } else console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1;
    }
  }, {
    key: "disableBorderDashes",
    value: function (t, e) {
      !1 !== e.borderDashes && (void 0 !== t.setLineDash ? t.setLineDash([0]) : (console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1));
    }
  }, {
    key: "needsRefresh",
    value: function (t, e) {
      return !0 === this.refreshNeeded ? (this.refreshNeeded = !1, !0) : void 0 === this.width || this.labelModule.differentState(t, e);
    }
  }, {
    key: "initContextForDraw",
    value: function (t, e) {
      var i = e.borderWidth / this.body.view.scale;
      t.lineWidth = Math.min(this.width, i), t.strokeStyle = e.borderColor, t.fillStyle = e.color;
    }
  }, {
    key: "performStroke",
    value: function (t, e) {
      var i = e.borderWidth / this.body.view.scale;
      t.save(), i > 0 && (this.enableBorderDashes(t, e), t.stroke(), this.disableBorderDashes(t, e)), t.restore();
    }
  }, {
    key: "performFill",
    value: function (t, e) {
      this.enableShadow(t, e), RM(t).call(t), this.disableShadow(t, e), this.performStroke(t, e);
    }
  }, {
    key: "_addBoundingBoxMargin",
    value: function (t) {
      this.boundingBox.left -= t, this.boundingBox.top -= t, this.boundingBox.bottom += t, this.boundingBox.right += t;
    }
  }, {
    key: "_updateBoundingBox",
    value: function (t, e, i, n, o) {
      void 0 !== i && this.resize(i, n, o), this.left = t - this.width / 2, this.top = e - this.height / 2, this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width;
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e, i, n, o) {
      this._updateBoundingBox(t, e, i, n, o);
    }
  }, {
    key: "getDimensionsFromLabel",
    value: function (t, e, i) {
      this.textSize = this.labelModule.getTextSize(t, e, i);
      var n = this.textSize.width,
          o = this.textSize.height;
      return 0 === n && (n = 14, o = 14), {
        width: n,
        height: o
      };
    }
  }]), t;
}(),
    YM = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n)))._setMargins(n), o;
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;

      if (this.needsRefresh(e, i)) {
        var n = this.getDimensionsFromLabel(t, e, i);
        this.width = n.width + this.margin.right + this.margin.left, this.height = n.height + this.margin.top + this.margin.bottom, this.radius = this.width / 2;
      }
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.resize(t, n, o), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, r), Q(t, this.left, this.top, this.width, this.height, r.borderRadius), this.performFill(t, r), this.updateBoundingBox(e, i, t, n, o), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n, o);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e, i, n, o) {
      this._updateBoundingBox(t, e, i, n, o);

      var r = this.options.shapeProperties.borderRadius;

      this._addBoundingBoxMargin(r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      this.resize(t);
      var i = this.options.borderWidth;
      return Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;
    }
  }]), e;
}(),
    HM = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n))).labelOffset = 0, o.selected = !1, o;
  }

  return jM(e, BM), hc(e, [{
    key: "setOptions",
    value: function (t, e, i) {
      this.options = t, void 0 === e && void 0 === i || this.setImages(e, i);
    }
  }, {
    key: "setImages",
    value: function (t, e) {
      e && this.selected ? (this.imageObj = e, this.imageObjAlt = t) : (this.imageObj = t, this.imageObjAlt = e);
    }
  }, {
    key: "switchImages",
    value: function (t) {
      var e = t && !this.selected || !t && this.selected;

      if (this.selected = t, void 0 !== this.imageObjAlt && e) {
        var i = this.imageObj;
        this.imageObj = this.imageObjAlt, this.imageObjAlt = i;
      }
    }
  }, {
    key: "_getImagePadding",
    value: function () {
      var t = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };

      if (this.options.imagePadding) {
        var e = this.options.imagePadding;
        "object" == aM(e) ? (t.top = e.top, t.right = e.right, t.bottom = e.bottom, t.left = e.left) : (t.top = e, t.right = e, t.bottom = e, t.left = e);
      }

      return t;
    }
  }, {
    key: "_resizeImage",
    value: function () {
      var t, e;

      if (!1 === this.options.shapeProperties.useImageSize) {
        var i = 1,
            n = 1;
        this.imageObj.width && this.imageObj.height && (this.imageObj.width > this.imageObj.height ? i = this.imageObj.width / this.imageObj.height : n = this.imageObj.height / this.imageObj.width), t = 2 * this.options.size * i, e = 2 * this.options.size * n;
      } else {
        var o = this._getImagePadding();

        t = this.imageObj.width + o.left + o.right, e = this.imageObj.height + o.top + o.bottom;
      }

      this.width = t, this.height = e, this.radius = .5 * this.width;
    }
  }, {
    key: "_drawRawCircle",
    value: function (t, e, i, n) {
      this.initContextForDraw(t, n), J(t, e, i, n.size), this.performFill(t, n);
    }
  }, {
    key: "_drawImageAtPosition",
    value: function (t, e) {
      if (0 != this.imageObj.width) {
        t.globalAlpha = 1, this.enableShadow(t, e);
        var i = 1;
        !0 === this.options.shapeProperties.interpolation && (i = this.imageObj.width / this.width / this.body.view.scale);

        var n = this._getImagePadding(),
            o = this.left + n.left,
            r = this.top + n.top,
            s = this.width - n.left - n.right,
            a = this.height - n.top - n.bottom;

        this.imageObj.drawImageAtPosition(t, i, o, r, s, a), this.disableShadow(t, e);
      }
    }
  }, {
    key: "_drawImageLabel",
    value: function (t, e, i, n, o) {
      var r,
          s = 0;

      if (void 0 !== this.height) {
        s = .5 * this.height;
        var a = this.labelModule.getTextSize(t, n, o);
        a.lineCount >= 1 && (s += a.height / 2);
      }

      r = i + s, this.options.label && (this.labelOffset = s), this.labelModule.draw(t, e, r, n, o, "hanging");
    }
  }]), e;
}(),
    WM = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n)))._setMargins(n), o;
  }

  return jM(e, HM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;

      if (this.needsRefresh(e, i)) {
        var n = this.getDimensionsFromLabel(t, e, i),
            o = Math.max(n.width + this.margin.right + this.margin.left, n.height + this.margin.top + this.margin.bottom);
        this.options.size = o / 2, this.width = o, this.height = o, this.radius = this.width / 2;
      }
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.resize(t, n, o), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, r), this.updateBoundingBox(e, i), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, i, n, o);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e) {
      this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size;
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this.resize(t), .5 * this.width;
    }
  }]), e;
}(),
    VM = function (t) {
  function e(t, i, n, o, r) {
    var s;
    return oc(this, e), (s = TM(this, IM(e).call(this, t, i, n))).setImages(o, r), s;
  }

  return jM(e, HM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,
          n = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height;

      if (n) {
        var o = 2 * this.options.size;
        return this.width = o, this.height = o, void (this.radius = .5 * this.width);
      }

      this.needsRefresh(e, i) && this._resizeImage();
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.switchImages(n), this.resize(), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, r), t.save(), t.clip(), this._drawImageAtPosition(t, r), t.restore(), this._drawImageLabel(t, e, i, n, o), this.updateBoundingBox(e, i);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e) {
      this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this.resize(t), .5 * this.width;
    }
  }]), e;
}(),
    UM = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n)))._setMargins(n), o;
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t, e, i) {
      if (this.needsRefresh(e, i)) {
        var n = this.getDimensionsFromLabel(t, e, i).width + this.margin.right + this.margin.left;
        this.width = n, this.height = n, this.radius = this.width / 2;
      }
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.resize(t, n, o), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, r), et(t, e - this.width / 2, i - this.height / 2, this.width, this.height), this.performFill(t, r), this.updateBoundingBox(e, i, t, n, o), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n, o);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    GM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,
          n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
        size: this.options.size
      };

      if (this.needsRefresh(e, i)) {
        this.labelModule.getTextSize(t, e, i);
        var o = 2 * n.size;
        this.width = o, this.height = o, this.radius = .5 * this.width;
      }
    }
  }, {
    key: "_drawShape",
    value: function (t, e, i, n, o, r, s, a) {
      var h;

      if (this.resize(t, r, s, a), this.left = n - this.width / 2, this.top = o - this.height / 2, this.initContextForDraw(t, a), (h = e, Object.prototype.hasOwnProperty.call(nt, h) ? nt[h] : function (t) {
        for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];

        CanvasRenderingContext2D.prototype[h].call(t, i);
      })(t, n, o, a.size), this.performFill(t, a), void 0 !== this.options.icon && void 0 !== this.options.icon.code && (t.font = (r ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome"), t.fillStyle = this.options.icon.color || "black", t.textAlign = "center", t.textBaseline = "middle", t.fillText(this.options.icon.code, n, o)), void 0 !== this.options.label) {
        this.labelModule.calculateLabelSize(t, r, s, n, o, "hanging");
        var l = o + .5 * this.height + .5 * this.labelModule.size.height;
        this.labelModule.draw(t, n, l, r, s, "hanging");
      }

      this.updateBoundingBox(n, o);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e) {
      this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height));
    }
  }]), e;
}(),
    qM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "diamond", 4, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    XM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "circle", 2, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this.resize(t), this.options.size;
    }
  }]), e;
}(),
    ZM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;

      if (this.needsRefresh(e, i)) {
        var n = this.getDimensionsFromLabel(t, e, i);
        this.height = 2 * n.height, this.width = n.width + n.height, this.radius = .5 * this.width;
      }
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.resize(t, n, o), this.left = e - .5 * this.width, this.top = i - .5 * this.height, this.initContextForDraw(t, r), tt(t, this.left, this.top, this.width, this.height), this.performFill(t, r), this.updateBoundingBox(e, i, t, n, o), this.labelModule.draw(t, e, i, n, o);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      this.resize(t);
      var i = .5 * this.width,
          n = .5 * this.height,
          o = Math.sin(e) * i,
          r = Math.cos(e) * n;
      return i * n / Math.sqrt(o * o + r * r);
    }
  }]), e;
}(),
    KM = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n)))._setMargins(n), o;
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t, e, i) {
      this.needsRefresh(e, i) && (this.iconSize = {
        width: Number(this.options.icon.size),
        height: Number(this.options.icon.size)
      }, this.width = this.iconSize.width + this.margin.right + this.margin.left, this.height = this.iconSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      if (this.resize(t, n, o), this.options.icon.size = this.options.icon.size || 50, this.left = e - this.width / 2, this.top = i - this.height / 2, this._icon(t, e, i, n, o, r), void 0 !== this.options.label) {
        this.labelModule.draw(t, this.left + this.iconSize.width / 2 + this.margin.left, i + this.height / 2 + 5, n);
      }

      this.updateBoundingBox(e, i);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e) {
      if (this.boundingBox.top = e - .5 * this.options.icon.size, this.boundingBox.left = t - .5 * this.options.icon.size, this.boundingBox.right = t + .5 * this.options.icon.size, this.boundingBox.bottom = e + .5 * this.options.icon.size, void 0 !== this.options.label && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 5);
      }
    }
  }, {
    key: "_icon",
    value: function (t, e, i, n, o, r) {
      var s = Number(this.options.icon.size);
      void 0 !== this.options.icon.code ? (t.font = [null != this.options.icon.weight ? this.options.icon.weight : n ? "bold" : "", (null != this.options.icon.weight && n ? 5 : 0) + s + "px", this.options.icon.face].join(" "), t.fillStyle = this.options.icon.color || "black", t.textAlign = "center", t.textBaseline = "middle", this.enableShadow(t, r), t.fillText(this.options.icon.code, e, i), this.disableShadow(t, r)) : console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    $M = function (t) {
  function e(t, i, n, o, r) {
    var s;
    return oc(this, e), (s = TM(this, IM(e).call(this, t, i, n))).setImages(o, r), s;
  }

  return jM(e, HM), hc(e, [{
    key: "resize",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,
          n = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height;

      if (n) {
        var o = 2 * this.options.size;
        return this.width = o, void (this.height = o);
      }

      this.needsRefresh(e, i) && this._resizeImage();
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      if (this.switchImages(n), this.resize(), this.left = e - this.width / 2, this.top = i - this.height / 2, !0 === this.options.shapeProperties.useBorderWithImage) {
        var s = this.options.borderWidth,
            a = this.options.borderWidthSelected || 2 * this.options.borderWidth,
            h = (n ? a : s) / this.body.view.scale;
        t.lineWidth = Math.min(this.width, h), t.beginPath(), t.strokeStyle = n ? this.options.color.highlight.border : o ? this.options.color.hover.border : this.options.color.border, t.fillStyle = n ? this.options.color.highlight.background : o ? this.options.color.hover.background : this.options.color.background, t.rect(this.left - .5 * t.lineWidth, this.top - .5 * t.lineWidth, this.width + t.lineWidth, this.height + t.lineWidth), RM(t).call(t), this.performStroke(t, r), t.closePath();
      }

      this._drawImageAtPosition(t, r), this._drawImageLabel(t, e, i, n, o), this.updateBoundingBox(e, i);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t, e) {
      this.resize(), this._updateBoundingBox(t, e), void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset));
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    JM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "square", 2, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    QM = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "hexagon", 4, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    tE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "star", 4, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    eE = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n)))._setMargins(n), o;
  }

  return jM(e, BM), hc(e, [{
    key: "resize",
    value: function (t, e, i) {
      this.needsRefresh(e, i) && (this.textSize = this.labelModule.getTextSize(t, e, i), this.width = this.textSize.width + this.margin.right + this.margin.left, this.height = this.textSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);
    }
  }, {
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this.resize(t, n, o), this.left = e - this.width / 2, this.top = i - this.height / 2, this.enableShadow(t, r), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n, o), this.disableShadow(t, r), this.updateBoundingBox(e, i, t, n, o);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    iE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "triangle", 3, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    nE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, GM), hc(e, [{
    key: "draw",
    value: function (t, e, i, n, o, r) {
      this._drawShape(t, "triangleDown", 3, e, i, n, o, r);
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this._distanceToBorder(t, e);
    }
  }]), e;
}(),
    oE = Fa("JSON", "stringify"),
    rE = /[\uD800-\uDFFF]/g,
    sE = /^[\uD800-\uDBFF]$/,
    aE = /^[\uDC00-\uDFFF]$/,
    hE = function (t, e, i) {
  var n = i.charAt(e - 1),
      o = i.charAt(e + 1);
  return sE.test(t) && !aE.test(o) || aE.test(t) && !sE.test(n) ? "\\u" + t.charCodeAt(0).toString(16) : t;
},
    lE = r(function () {
  return '"\\udf06\\ud834"' !== oE("\udf06\ud834") || '"\\udead"' !== oE("\udead");
});

oE && W({
  target: "JSON",
  stat: !0,
  forced: lE
}, {
  stringify: function (t, e, i) {
    var n = oE.apply(null, arguments);
    return "string" == typeof n ? n.replace(rE, hE) : n;
  }
}), F.JSON || (F.JSON = {
  stringify: JSON.stringify
});

var dE,
    uE = function (t, e, i) {
  return F.JSON.stringify.apply(null, arguments);
},
    cE = !1,
    fE = "background: #FFeeee; color: #dd0000",
    pE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "validate",
    value: function (e, i, n) {
      cE = !1, dE = i;
      var o = i;
      return void 0 !== n && (o = i[n]), t.parse(e, o, []), cE;
    }
  }, {
    key: "parse",
    value: function (e, i, n) {
      for (var o in e) e.hasOwnProperty(o) && t.check(o, e, i, n);
    }
  }, {
    key: "check",
    value: function (e, i, n, o) {
      if (void 0 !== n[e] || void 0 !== n.__any__) {
        var r = e,
            s = !0;
        void 0 === n[e] && void 0 !== n.__any__ && (r = "__any__", s = "object" === t.getType(i[e]));
        var a = n[r];
        s && void 0 !== a.__type__ && (a = a.__type__), t.checkFields(e, i, n, r, a, o);
      } else t.getSuggestion(e, n, o);
    }
  }, {
    key: "checkFields",
    value: function (e, i, n, o, r, s) {
      var a = function (i) {
        console.log("%c" + i + t.printLocation(s, e), fE);
      },
          h = t.getType(i[e]),
          l = r[h];

      void 0 !== l ? "array" === t.getType(l) && -1 === el(l).call(l, i[e]) ? (a('Invalid option detected in "' + e + '". Allowed values are:' + t.print(l) + ' not "' + i[e] + '". '), cE = !0) : "object" === h && "__any__" !== o && (s = Xr(s, e), t.parse(i[e], n[o], s)) : void 0 === r.any && (a('Invalid type received for "' + e + '". Expected: ' + t.print(CS(r)) + ". Received [" + h + '] "' + i[e] + '"'), cE = !0);
    }
  }, {
    key: "getType",
    value: function (t) {
      var e = aM(t);
      return "object" === e ? null === t ? "null" : t instanceof Boolean ? "boolean" : t instanceof Number ? "number" : t instanceof String ? "string" : Mh(t) ? "array" : t instanceof Date ? "date" : void 0 !== t.nodeType ? "dom" : !0 === t._isAMomentObject ? "moment" : "object" : "number" === e ? "number" : "boolean" === e ? "boolean" : "string" === e ? "string" : void 0 === e ? "undefined" : e;
    }
  }, {
    key: "getSuggestion",
    value: function (e, i, n) {
      var o,
          r = t.findInOptions(e, i, n, !1),
          s = t.findInOptions(e, dE, [], !0);
      o = void 0 !== r.indexMatch ? " in " + t.printLocation(r.path, e, "") + 'Perhaps it was incomplete? Did you mean: "' + r.indexMatch + '"?\n\n' : s.distance <= 4 && r.distance > s.distance ? " in " + t.printLocation(r.path, e, "") + "Perhaps it was misplaced? Matching option found at: " + t.printLocation(s.path, s.closestMatch, "") : r.distance <= 8 ? '. Did you mean "' + r.closestMatch + '"?' + t.printLocation(r.path, e) : ". Did you mean one of these: " + t.print(CS(i)) + t.printLocation(n, e), console.log('%cUnknown option detected: "' + e + '"' + o, fE), cE = !0;
    }
  }, {
    key: "findInOptions",
    value: function (e, i, n) {
      var o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
          r = 1e9,
          s = "",
          a = [],
          h = e.toLowerCase(),
          l = void 0;

      for (var d in i) {
        var u = void 0;

        if (void 0 !== i[d].__type__ && !0 === o) {
          var c = t.findInOptions(e, i[d], Xr(n, d));
          r > c.distance && (s = c.closestMatch, a = c.path, r = c.distance, l = c.indexMatch);
        } else {
          var f;
          -1 !== el(f = d.toLowerCase()).call(f, h) && (l = d), r > (u = t.levenshteinDistance(e, d)) && (s = d, a = Zr(n), r = u);
        }
      }

      return {
        closestMatch: s,
        path: a,
        distance: r,
        indexMatch: l
      };
    }
  }, {
    key: "printLocation",
    value: function (t, e) {
      for (var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Problem value found at: \n", n = "\n\n" + i + "options = {\n", o = 0; o < t.length; o++) {
        for (var r = 0; r < o + 1; r++) n += "  ";

        n += t[o] + ": {\n";
      }

      for (var s = 0; s < t.length + 1; s++) n += "  ";

      n += e + "\n";

      for (var a = 0; a < t.length + 1; a++) {
        for (var h = 0; h < t.length - a; h++) n += "  ";

        n += "}\n";
      }

      return n + "\n\n";
    }
  }, {
    key: "print",
    value: function (t) {
      return uE(t).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
    }
  }, {
    key: "levenshteinDistance",
    value: function (t, e) {
      if (0 === t.length) return e.length;
      if (0 === e.length) return t.length;
      var i,
          n,
          o = [];

      for (i = 0; i <= e.length; i++) o[i] = [i];

      for (n = 0; n <= t.length; n++) o[0][n] = n;

      for (i = 1; i <= e.length; i++) for (n = 1; n <= t.length; n++) e.charAt(i - 1) == t.charAt(n - 1) ? o[i][n] = o[i - 1][n - 1] : o[i][n] = Math.min(o[i - 1][n - 1] + 1, Math.min(o[i][n - 1] + 1, o[i - 1][n] + 1));

      return o[e.length][t.length];
    }
  }]), t;
}();

function vE(t, e) {
  var i = CS(t);

  if (DS) {
    var n = DS(t);
    e && (n = UO(n).call(n, function (e) {
      return YO(t, e).enumerable;
    })), i.push.apply(i, n);
  }

  return i;
}

var yE = function () {
  function t(e, i, n, o, r, s) {
    oc(this, t), this.options = Ms(r), this.globalOptions = r, this.defaultOptions = s, this.body = i, this.edges = [], this.id = void 0, this.imagelist = n, this.grouplist = o, this.x = void 0, this.y = void 0, this.baseSize = this.options.size, this.baseFontSize = this.options.font.size, this.predefinedPosition = !1, this.selected = !1, this.hover = !1, this.labelModule = new EM(this.body, this.options, !1), this.setOptions(e);
  }

  return hc(t, [{
    key: "attachEdge",
    value: function (t) {
      var e;
      -1 === el(e = this.edges).call(e, t) && this.edges.push(t);
    }
  }, {
    key: "detachEdge",
    value: function (t) {
      var e,
          i,
          n = el(e = this.edges).call(e, t);
      -1 != n && Rh(i = this.edges).call(i, n, 1);
    }
  }, {
    key: "setOptions",
    value: function (e) {
      var i = this.options.shape;

      if (e) {
        if (void 0 !== e.color && (this._localColor = e.color), void 0 !== e.id && (this.id = e.id), void 0 === this.id) throw new Error("Node must have an id");
        t.checkMass(e, this.id), void 0 !== e.x && (null === e.x ? (this.x = void 0, this.predefinedPosition = !1) : (this.x = GS(e.x), this.predefinedPosition = !0)), void 0 !== e.y && (null === e.y ? (this.y = void 0, this.predefinedPosition = !1) : (this.y = GS(e.y), this.predefinedPosition = !0)), void 0 !== e.size && (this.baseSize = e.size), void 0 !== e.value && (e.value = YS(e.value)), t.parseOptions(this.options, e, !0, this.globalOptions, this.grouplist);
        var n = [e, this.options, this.defaultOptions];
        return this.chooser = hM.choosify("node", n), this._load_images(), this.updateLabelModule(e), this.updateShape(i), void 0 !== e.hidden || void 0 !== e.physics;
      }
    }
  }, {
    key: "_load_images",
    value: function () {
      if (("circularImage" === this.options.shape || "image" === this.options.shape) && void 0 === this.options.image) throw new Error("Option image must be defined for node type '" + this.options.shape + "'");

      if (void 0 !== this.options.image) {
        if (void 0 === this.imagelist) throw new Error("Internal Error: No images provided");
        if ("string" == typeof this.options.image) this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);else {
          if (void 0 === this.options.image.unselected) throw new Error("No unselected image provided");
          this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id), void 0 !== this.options.image.selected ? this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id) : this.imageObjAlt = void 0;
        }
      }
    }
  }, {
    key: "getFormattingValues",
    value: function () {
      var t = {
        color: this.options.color.background,
        borderWidth: this.options.borderWidth,
        borderColor: this.options.color.border,
        size: this.options.size,
        borderDashes: this.options.shapeProperties.borderDashes,
        borderRadius: this.options.shapeProperties.borderRadius,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y
      };
      return this.selected || this.hover ? !0 === this.chooser ? this.selected ? (t.borderWidth *= 2, t.color = this.options.color.highlight.background, t.borderColor = this.options.color.highlight.border, t.shadow = this.options.shadow.enabled) : this.hover && (t.color = this.options.color.hover.background, t.borderColor = this.options.color.hover.border, t.shadow = this.options.shadow.enabled) : "function" == typeof this.chooser && (this.chooser(t, this.options.id, this.selected, this.hover), !1 === t.shadow && (t.shadowColor === this.options.shadow.color && t.shadowSize === this.options.shadow.size && t.shadowX === this.options.shadow.x && t.shadowY === this.options.shadow.y || (t.shadow = !0))) : t.shadow = this.options.shadow.enabled, t;
    }
  }, {
    key: "updateLabelModule",
    value: function (e) {
      void 0 !== this.options.label && null !== this.options.label || (this.options.label = ""), t.updateGroupOptions(this.options, function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var i,
              n = null != arguments[e] ? arguments[e] : {};
          if (e % 2) kh(i = vE(Object(n), !0)).call(i, function (e) {
            PS(t, e, n[e]);
          });else if (zO) AO(t, zO(n));else {
            var o;
            kh(o = vE(Object(n))).call(o, function (e) {
              PO(t, e, YO(n, e));
            });
          }
        }

        return t;
      }({}, e, {
        color: e && e.color || this._localColor || void 0
      }), this.grouplist);
      var i = this.grouplist.get(this.options.group, !1),
          n = [e, this.options, i, this.globalOptions, this.defaultOptions];
      this.labelModule.update(this.options, n), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);
    }
  }, {
    key: "updateShape",
    value: function (t) {
      if (t === this.options.shape && this.shape) this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);else switch (this.options.shape) {
        case "box":
          this.shape = new YM(this.options, this.body, this.labelModule);
          break;

        case "circle":
          this.shape = new WM(this.options, this.body, this.labelModule);
          break;

        case "circularImage":
          this.shape = new VM(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
          break;

        case "database":
          this.shape = new UM(this.options, this.body, this.labelModule);
          break;

        case "diamond":
          this.shape = new qM(this.options, this.body, this.labelModule);
          break;

        case "dot":
          this.shape = new XM(this.options, this.body, this.labelModule);
          break;

        case "ellipse":
          this.shape = new ZM(this.options, this.body, this.labelModule);
          break;

        case "icon":
          this.shape = new KM(this.options, this.body, this.labelModule);
          break;

        case "image":
          this.shape = new $M(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
          break;

        case "square":
          this.shape = new JM(this.options, this.body, this.labelModule);
          break;

        case "hexagon":
          this.shape = new QM(this.options, this.body, this.labelModule);
          break;

        case "star":
          this.shape = new tE(this.options, this.body, this.labelModule);
          break;

        case "text":
          this.shape = new eE(this.options, this.body, this.labelModule);
          break;

        case "triangle":
          this.shape = new iE(this.options, this.body, this.labelModule);
          break;

        case "triangleDown":
          this.shape = new nE(this.options, this.body, this.labelModule);
          break;

        default:
          this.shape = new ZM(this.options, this.body, this.labelModule);
      }
      this.needsRefresh();
    }
  }, {
    key: "select",
    value: function () {
      this.selected = !0, this.needsRefresh();
    }
  }, {
    key: "unselect",
    value: function () {
      this.selected = !1, this.needsRefresh();
    }
  }, {
    key: "needsRefresh",
    value: function () {
      this.shape.refreshNeeded = !0;
    }
  }, {
    key: "getTitle",
    value: function () {
      return this.options.title;
    }
  }, {
    key: "distanceToBorder",
    value: function (t, e) {
      return this.shape.distanceToBorder(t, e);
    }
  }, {
    key: "isFixed",
    value: function () {
      return this.options.fixed.x && this.options.fixed.y;
    }
  }, {
    key: "isSelected",
    value: function () {
      return this.selected;
    }
  }, {
    key: "getValue",
    value: function () {
      return this.options.value;
    }
  }, {
    key: "getLabelSize",
    value: function () {
      return this.labelModule.size();
    }
  }, {
    key: "setValueRange",
    value: function (t, e, i) {
      if (void 0 !== this.options.value) {
        var n = this.options.scaling.customScalingFunction(t, e, i, this.options.value),
            o = this.options.scaling.max - this.options.scaling.min;

        if (!0 === this.options.scaling.label.enabled) {
          var r = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + n * r;
        }

        this.options.size = this.options.scaling.min + n * o;
      } else this.options.size = this.baseSize, this.options.font.size = this.baseFontSize;

      this.updateLabelModule();
    }
  }, {
    key: "draw",
    value: function (t) {
      var e = this.getFormattingValues();
      this.shape.draw(t, this.x, this.y, this.selected, this.hover, e);
    }
  }, {
    key: "updateBoundingBox",
    value: function (t) {
      this.shape.updateBoundingBox(this.x, this.y, t);
    }
  }, {
    key: "resize",
    value: function (t) {
      var e = this.getFormattingValues();
      this.shape.resize(t, this.selected, this.hover, e);
    }
  }, {
    key: "getItemsOnPoint",
    value: function (t) {
      var e = [];
      return this.labelModule.visible() && hM.pointInRect(this.labelModule.getSize(), t) && e.push({
        nodeId: this.id,
        labelId: 0
      }), hM.pointInRect(this.shape.boundingBox, t) && e.push({
        nodeId: this.id
      }), e;
    }
  }, {
    key: "isOverlappingWith",
    value: function (t) {
      return this.shape.left < t.right && this.shape.left + this.shape.width > t.left && this.shape.top < t.bottom && this.shape.top + this.shape.height > t.top;
    }
  }, {
    key: "isBoundingBoxOverlappingWith",
    value: function (t) {
      return this.shape.boundingBox.left < t.right && this.shape.boundingBox.right > t.left && this.shape.boundingBox.top < t.bottom && this.shape.boundingBox.bottom > t.top;
    }
  }], [{
    key: "updateGroupOptions",
    value: function (t, e, i) {
      if (void 0 !== i) {
        var n = t.group;
        if (void 0 !== e && void 0 !== e.group && n !== e.group) throw new Error("updateGroupOptions: group values in options don't match.");

        if ("number" == typeof n || "string" == typeof n && "" != n) {
          var o = i.get(n),
              r = ["font"];
          void 0 !== e && void 0 !== e.color && null != e.color && r.push("color"), Vr(r, t, o), t.color = ps(t.color);
        }
      }
    }
  }, {
    key: "parseOptions",
    value: function (e, i) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
          r = arguments.length > 4 ? arguments[4] : void 0,
          s = ["color", "fixed", "shadow"];

      if (Vr(s, e, i, n), t.checkMass(i), Ds(e, i, "shadow", o), void 0 !== i.color && null !== i.color) {
        var a = ps(i.color);
        Br(e.color, a);
      } else !0 === n && null === i.color && (e.color = Ms(o.color));

      void 0 !== i.fixed && null !== i.fixed && ("boolean" == typeof i.fixed ? (e.fixed.x = i.fixed, e.fixed.y = i.fixed) : (void 0 !== i.fixed.x && "boolean" == typeof i.fixed.x && (e.fixed.x = i.fixed.x), void 0 !== i.fixed.y && "boolean" == typeof i.fixed.y && (e.fixed.y = i.fixed.y))), !0 === n && null === i.font && (e.font = Ms(o.font)), t.updateGroupOptions(e, i, r), void 0 !== i.scaling && Ds(e.scaling, i.scaling, "label", o.scaling);
    }
  }, {
    key: "checkMass",
    value: function (t, e) {
      if (void 0 !== t.mass && t.mass <= 0) {
        var i = "";
        void 0 !== e && (i = " in node id: " + e), console.log("%cNegative or zero mass disallowed" + i + ", setting mass to 1.", fE), t.mass = 1;
      }
    }
  }]), t;
}(),
    gE = function () {
  function t(e, i, n, o) {
    var r,
        s = this;
    if (oc(this, t), this.body = e, this.images = i, this.groups = n, this.layoutEngine = o, this.body.functions.createNode = $(r = this.create).call(r, this), this.nodesListeners = {
      add: function (t, e) {
        s.add(e.items);
      },
      update: function (t, e) {
        s.update(e.items, e.data, e.oldData);
      },
      remove: function (t, e) {
        s.remove(e.items);
      }
    }, this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: 2,
      brokenImage: void 0,
      color: {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      fixed: {
        x: !1,
        y: !1
      },
      font: {
        color: "#343434",
        size: 14,
        face: "arial",
        background: "none",
        strokeWidth: 0,
        strokeColor: "#ffffff",
        align: "center",
        vadjust: 0,
        multi: !1,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          face: "monospace",
          vadjust: 2
        }
      },
      group: void 0,
      hidden: !1,
      icon: {
        face: "FontAwesome",
        code: void 0,
        size: 50,
        color: "#2B7CE9"
      },
      image: void 0,
      imagePadding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      label: void 0,
      labelHighlightBold: !0,
      level: void 0,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: !0,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: !1,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function (t, e, i, n) {
          if (e === t) return .5;
          var o = 1 / (e - t);
          return Math.max(0, (n - t) * o);
        }
      },
      shadow: {
        enabled: !1,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      shape: "ellipse",
      shapeProperties: {
        borderDashes: !1,
        borderRadius: 6,
        interpolation: !0,
        useImageSize: !1,
        useBorderWithImage: !1
      },
      size: 25,
      title: void 0,
      value: void 0,
      x: void 0,
      y: void 0
    }, this.defaultOptions.mass <= 0) throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
    this.options = Ms(this.defaultOptions), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t,
          e,
          i = this;
      this.body.emitter.on("refreshNodes", $(t = this.refresh).call(t, this)), this.body.emitter.on("refresh", $(e = this.refresh).call(e, this)), this.body.emitter.on("destroy", function () {
        es(i.nodesListeners, function (t, e) {
          i.body.data.nodes && i.body.data.nodes.off(e, t);
        }), delete i.body.functions.createNode, delete i.nodesListeners.add, delete i.nodesListeners.update, delete i.nodesListeners.remove, delete i.nodesListeners;
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        if (yE.parseOptions(this.options, t), void 0 !== t.shape) for (var e in this.body.nodes) this.body.nodes.hasOwnProperty(e) && this.body.nodes[e].updateShape();
        if (void 0 !== t.font) for (var i in this.body.nodes) this.body.nodes.hasOwnProperty(i) && (this.body.nodes[i].updateLabelModule(), this.body.nodes[i].needsRefresh());
        if (void 0 !== t.size) for (var n in this.body.nodes) this.body.nodes.hasOwnProperty(n) && this.body.nodes[n].needsRefresh();
        void 0 === t.hidden && void 0 === t.physics || this.body.emitter.emit("_dataChanged");
      }
    }
  }, {
    key: "setData",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          i = this.body.data.nodes;
      if (t instanceof EO || t instanceof DO) this.body.data.nodes = t;else if (Mh(t)) this.body.data.nodes = new EO(), this.body.data.nodes.add(t);else {
        if (t) throw new TypeError("Array or DataSet expected");
        this.body.data.nodes = new EO();
      }

      if (i && es(this.nodesListeners, function (t, e) {
        i.off(e, t);
      }), this.body.nodes = {}, this.body.data.nodes) {
        var n = this;
        es(this.nodesListeners, function (t, e) {
          n.body.data.nodes.on(e, t);
        });
        var o = this.body.data.nodes.getIds();
        this.add(o, !0);
      }

      !1 === e && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "add",
    value: function (t) {
      for (var e, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = [], o = 0; o < t.length; o++) {
        e = t[o];
        var r = this.body.data.nodes.get(e),
            s = this.create(r);
        n.push(s), this.body.nodes[e] = s;
      }

      this.layoutEngine.positionInitially(n), !1 === i && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "update",
    value: function (t, e, i) {
      for (var n = this.body.nodes, o = !1, r = 0; r < t.length; r++) {
        var s = t[r],
            a = n[s],
            h = e[r];
        void 0 !== a ? a.setOptions(h) && (o = !0) : (o = !0, a = this.create(h), n[s] = a);
      }

      o || void 0 === i || (o = Mc(e).call(e, function (t, e) {
        var n = i[e];
        return n && n.level !== t.level;
      })), !0 === o ? this.body.emitter.emit("_dataChanged") : this.body.emitter.emit("_dataUpdated");
    }
  }, {
    key: "remove",
    value: function (t) {
      for (var e = this.body.nodes, i = 0; i < t.length; i++) {
        delete e[t[i]];
      }

      this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "create",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yE;
      return new e(t, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }
  }, {
    key: "refresh",
    value: function () {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      es(this.body.nodes, function (i, n) {
        var o = t.body.data.nodes.get(n);
        void 0 !== o && (!0 === e && i.setOptions({
          x: null,
          y: null
        }), i.setOptions({
          fixed: !1
        }), i.setOptions(o));
      });
    }
  }, {
    key: "getPositions",
    value: function (t) {
      var e = {};

      if (void 0 !== t) {
        if (!0 === Mh(t)) {
          for (var i = 0; i < t.length; i++) if (void 0 !== this.body.nodes[t[i]]) {
            var n = this.body.nodes[t[i]];
            e[t[i]] = {
              x: Math.round(n.x),
              y: Math.round(n.y)
            };
          }
        } else if (void 0 !== this.body.nodes[t]) {
          var o = this.body.nodes[t];
          e[t] = {
            x: Math.round(o.x),
            y: Math.round(o.y)
          };
        }
      } else for (var r = 0; r < this.body.nodeIndices.length; r++) {
        var s = this.body.nodes[this.body.nodeIndices[r]];
        e[this.body.nodeIndices[r]] = {
          x: Math.round(s.x),
          y: Math.round(s.y)
        };
      }

      return e;
    }
  }, {
    key: "storePositions",
    value: function () {
      var t = [],
          e = this.body.data.nodes.getDataSet(),
          i = !0,
          n = !1,
          o = void 0;

      try {
        for (var r, s = kc(e.get()); !(i = (r = s.next()).done); i = !0) {
          var a = r.value,
              h = a.id,
              l = this.body.nodes[h],
              d = Math.round(l.x),
              u = Math.round(l.y);
          a.x === d && a.y === u || t.push({
            id: h,
            x: d,
            y: u
          });
        }
      } catch (t) {
        n = !0, o = t;
      } finally {
        try {
          i || null == s.return || s.return();
        } finally {
          if (n) throw o;
        }
      }

      e.update(t);
    }
  }, {
    key: "getBoundingBox",
    value: function (t) {
      if (void 0 !== this.body.nodes[t]) return this.body.nodes[t].shape.boundingBox;
    }
  }, {
    key: "getConnectedNodes",
    value: function (t, e) {
      var i = [];
      if (void 0 !== this.body.nodes[t]) for (var n = this.body.nodes[t], o = {}, r = 0; r < n.edges.length; r++) {
        var s = n.edges[r];
        "to" !== e && s.toId == n.id ? void 0 === o[s.fromId] && (i.push(s.fromId), o[s.fromId] = !0) : "from" !== e && s.fromId == n.id && void 0 === o[s.toId] && (i.push(s.toId), o[s.toId] = !0);
      }
      return i;
    }
  }, {
    key: "getConnectedEdges",
    value: function (t) {
      var e = [];
      if (void 0 !== this.body.nodes[t]) for (var i = this.body.nodes[t], n = 0; n < i.edges.length; n++) e.push(i.edges[n].id);else console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", t);
      return e;
    }
  }, {
    key: "moveNode",
    value: function (t, e, i) {
      var n = this;
      void 0 !== this.body.nodes[t] ? (this.body.nodes[t].x = Number(e), this.body.nodes[t].y = Number(i), vc(function () {
        n.body.emitter.emit("startSimulation");
      }, 0)) : console.log("Node id supplied to moveNode does not exist. Provided: ", t);
    }
  }]), t;
}(),
    mE = BO;

W({
  target: "Reflect",
  stat: !0
}, {
  get: function t(e, i) {
    var n,
        o,
        r = arguments.length < 3 ? e : arguments[2];
    return z(e) === r ? e[i] : (n = M.f(e, i)) ? w(n, "value") ? n.value : void 0 === n.get ? void 0 : n.get.call(r) : g(o = ua(e)) ? t(o, i, r) : void 0;
  }
});
var bE = F.Reflect.get;

var wE = function (t, e) {
  for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = IM(t)););

  return t;
},
    _E = i(function (t) {
  function e(i, n, o) {
    return "undefined" != typeof Reflect && bE ? t.exports = e = bE : t.exports = e = function (t, e, i) {
      var n = wE(t, e);

      if (n) {
        var o = mE(n, e);
        return o.get ? o.get.call(i) : o.value;
      }
    }, e(i, n, o || i);
  }

  t.exports = e;
}),
    kE = Math.hypot,
    xE = Math.abs,
    OE = Math.sqrt,
    SE = !!kE && kE(1 / 0, NaN) !== 1 / 0;

W({
  target: "Math",
  stat: !0,
  forced: SE
}, {
  hypot: function (t, e) {
    for (var i, n, o = 0, r = 0, s = arguments.length, a = 0; r < s;) a < (i = xE(arguments[r++])) ? (o = o * (n = a / i) * n + 1, a = i) : o += i > 0 ? (n = i / a) * n : i;

    return a === 1 / 0 ? 1 / 0 : a * OE(o);
  }
});

var ME = F.Math.hypot,
    EE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "transform",
    value: function (t, e) {
      Mh(t) || (t = [t]);

      for (var i = e.point.x, n = e.point.y, o = e.angle, r = e.length, s = 0; s < t.length; ++s) {
        var a = t[s],
            h = a.x * Math.cos(o) - a.y * Math.sin(o),
            l = a.x * Math.sin(o) + a.y * Math.cos(o);
        a.x = i + r * h, a.y = n + r * l;
      }
    }
  }, {
    key: "drawPath",
    value: function (t, e) {
      t.beginPath(), t.moveTo(e[0].x, e[0].y);

      for (var i = 1; i < e.length; ++i) t.lineTo(e[i].x, e[i].y);

      t.closePath();
    }
  }]), t;
}(),
    DE = function (t) {
  function e() {
    return oc(this, e), TM(this, IM(e).apply(this, arguments));
  }

  return jM(e, EE), hc(e, null, [{
    key: "draw",
    value: function (t, e) {
      if (e.image) {
        t.save(), t.translate(e.point.x, e.point.y), t.rotate(Math.PI / 2 + e.angle);
        var i = null != e.imageWidth ? e.imageWidth : e.image.width,
            n = null != e.imageHeight ? e.imageHeight : e.image.height;
        e.image.drawImageAtPosition(t, 1, -i / 2, 0, i, n), t.restore();
      }

      return !1;
    }
  }]), e;
}(),
    TE = function (t) {
  function e() {
    return oc(this, e), TM(this, IM(e).apply(this, arguments));
  }

  return jM(e, EE), hc(e, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: 0,
        y: 0
      }, {
        x: -1,
        y: .3
      }, {
        x: -.9,
        y: 0
      }, {
        x: -1,
        y: -.3
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), e;
}(),
    CE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: -1,
        y: 0
      }, {
        x: 0,
        y: .3
      }, {
        x: -.4,
        y: 0
      }, {
        x: 0,
        y: -.3
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    PE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = {
        x: -.4,
        y: 0
      };
      EE.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = "rgba(0, 0, 0, 0)";
      var n = Math.PI,
          o = e.angle - n / 2,
          r = e.angle + n / 2;
      return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, o, r, !1), t.stroke(), !0;
    }
  }]), t;
}(),
    AE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = {
        x: -.3,
        y: 0
      };
      EE.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = "rgba(0, 0, 0, 0)";
      var n = Math.PI,
          o = e.angle + n / 2,
          r = e.angle + 3 * n / 2;
      return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, o, r, !1), t.stroke(), !0;
    }
  }]), t;
}(),
    IE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: .02,
        y: 0
      }, {
        x: -1,
        y: .3
      }, {
        x: -1,
        y: -.3
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    FE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: 0,
        y: .3
      }, {
        x: 0,
        y: -.3
      }, {
        x: -1,
        y: 0
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    NE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = {
        x: -.4,
        y: 0
      };
      return EE.transform(i, e), J(t, i.x, i.y, .4 * e.length), !0;
    }
  }]), t;
}(),
    jE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: 0,
        y: .5
      }, {
        x: 0,
        y: -.5
      }, {
        x: -.15,
        y: -.5
      }, {
        x: -.15,
        y: .5
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    zE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: 0,
        y: .3
      }, {
        x: 0,
        y: -.3
      }, {
        x: -.6,
        y: -.3
      }, {
        x: -.6,
        y: .3
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    LE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: 0,
        y: 0
      }, {
        x: -.5,
        y: -.3
      }, {
        x: -1,
        y: 0
      }, {
        x: -.5,
        y: .3
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    RE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i = [{
        x: -1,
        y: .3
      }, {
        x: -.5,
        y: 0
      }, {
        x: -1,
        y: -.3
      }, {
        x: 0,
        y: 0
      }];
      return EE.transform(i, e), EE.drawPath(t, i), !0;
    }
  }]), t;
}(),
    BE = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "draw",
    value: function (t, e) {
      var i;

      switch (e.type && (i = e.type.toLowerCase()), i) {
        case "image":
          return DE.draw(t, e);

        case "circle":
          return NE.draw(t, e);

        case "box":
          return zE.draw(t, e);

        case "crow":
          return CE.draw(t, e);

        case "curve":
          return PE.draw(t, e);

        case "diamond":
          return LE.draw(t, e);

        case "inv_curve":
          return AE.draw(t, e);

        case "triangle":
          return IE.draw(t, e);

        case "inv_triangle":
          return FE.draw(t, e);

        case "bar":
          return jE.draw(t, e);

        case "vee":
          return RE.draw(t, e);

        case "arrow":
        default:
          return TE.draw(t, e);
      }
    }
  }]), t;
}();

function YE(t, e) {
  var i = CS(t);

  if (DS) {
    var n = DS(t);
    e && (n = UO(n).call(n, function (e) {
      return YO(t, e).enumerable;
    })), i.push.apply(i, n);
  }

  return i;
}

var HE = function () {
  function t(e, i, n) {
    oc(this, t), this._body = i, this._labelModule = n, this.color = {}, this.colorDirty = !0, this.hoverWidth = 1.5, this.selectionWidth = 2, this.setOptions(e), this.fromPoint = this.from, this.toPoint = this.to;
  }

  return hc(t, [{
    key: "connect",
    value: function () {
      this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to];
    }
  }, {
    key: "cleanup",
    value: function () {
      return !1;
    }
  }, {
    key: "setOptions",
    value: function (t) {
      this.options = t, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.id = this.options.id;
    }
  }, {
    key: "drawLine",
    value: function (t, e, i, n) {
      var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.getViaNode();
      t.strokeStyle = this.getColor(t, e), t.lineWidth = e.width, !1 !== e.dashes ? this._drawDashedLine(t, e, o) : this._drawLine(t, e, o);
    }
  }, {
    key: "_drawLine",
    value: function (t, e, i, n, o) {
      if (this.from != this.to) this._line(t, e, i, n, o);else {
        var r = this._getCircleData(t),
            s = QS(r, 3),
            a = s[0],
            h = s[1],
            l = s[2];

        this._circle(t, e, a, h, l);
      }
    }
  }, {
    key: "_drawDashedLine",
    value: function (t, e, i, n, o) {
      t.lineCap = "round";
      var r = Mh(e.dashes) ? e.dashes : [5, 5];

      if (void 0 !== t.setLineDash) {
        if (t.save(), t.setLineDash(r), t.lineDashOffset = 0, this.from != this.to) this._line(t, e, i);else {
          var s = this._getCircleData(t),
              a = QS(s, 3),
              h = a[0],
              l = a[1],
              d = a[2];

          this._circle(t, e, h, l, d);
        }
        t.setLineDash([0]), t.lineDashOffset = 0, t.restore();
      } else {
        if (this.from != this.to) it(t, this.from.x, this.from.y, this.to.x, this.to.y, r);else {
          var u = this._getCircleData(t),
              c = QS(u, 3),
              f = c[0],
              p = c[1],
              v = c[2];

          this._circle(t, e, f, p, v);
        }
        this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);
      }
    }
  }, {
    key: "findBorderPosition",
    value: function (t, e, i) {
      return this.from != this.to ? this._findBorderPosition(t, e, i) : this._findBorderPositionCircle(t, e, i);
    }
  }, {
    key: "findBorderPositions",
    value: function (t) {
      if (this.from != this.to) return {
        from: this._findBorderPosition(this.from, t),
        to: this._findBorderPosition(this.to, t)
      };
      var e,
          i = pM(e = this._getCircleData(t)).call(e, 0, 2),
          n = QS(i, 2),
          o = n[0],
          r = n[1];
      return {
        from: this._findBorderPositionCircle(this.from, t, {
          x: o,
          y: r,
          low: .25,
          high: .6,
          direction: -1
        }),
        to: this._findBorderPositionCircle(this.from, t, {
          x: o,
          y: r,
          low: .6,
          high: .8,
          direction: 1
        })
      };
    }
  }, {
    key: "_getCircleData",
    value: function (t) {
      var e,
          i,
          n = this.from,
          o = this.options.selfReferenceSize;
      return void 0 !== t && void 0 === n.shape.width && n.shape.resize(t), n.shape.width > n.shape.height ? (e = n.x + .5 * n.shape.width, i = n.y - o) : (e = n.x + o, i = n.y - .5 * n.shape.height), [e, i, o];
    }
  }, {
    key: "_pointOnCircle",
    value: function (t, e, i, n) {
      var o = 2 * n * Math.PI;
      return {
        x: t + i * Math.cos(o),
        y: e - i * Math.sin(o)
      };
    }
  }, {
    key: "_findBorderPositionCircle",
    value: function (t, e, i) {
      var n,
          o = i.x,
          r = i.y,
          s = i.low,
          a = i.high,
          h = i.direction,
          l = this.options.selfReferenceSize,
          d = .5 * (s + a),
          u = 0;

      do {
        d = .5 * (s + a), n = this._pointOnCircle(o, r, l, d);
        var c = Math.atan2(t.y - n.y, t.x - n.x),
            f = t.distanceToBorder(e, c) - Math.sqrt(Math.pow(n.x - t.x, 2) + Math.pow(n.y - t.y, 2));
        if (Math.abs(f) < .05) break;
        f > 0 ? h > 0 ? s = d : a = d : h > 0 ? a = d : s = d, ++u;
      } while (s <= a && u < 10);

      return function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var i,
              n = null != arguments[e] ? arguments[e] : {};
          if (e % 2) kh(i = YE(Object(n), !0)).call(i, function (e) {
            PS(t, e, n[e]);
          });else if (zO) AO(t, zO(n));else {
            var o;
            kh(o = YE(Object(n))).call(o, function (e) {
              PO(t, e, YO(n, e));
            });
          }
        }

        return t;
      }({}, n, {
        t: d
      });
    }
  }, {
    key: "getLineWidth",
    value: function (t, e) {
      return !0 === t ? Math.max(this.selectionWidth, .3 / this._body.view.scale) : !0 === e ? Math.max(this.hoverWidth, .3 / this._body.view.scale) : Math.max(this.options.width, .3 / this._body.view.scale);
    }
  }, {
    key: "getColor",
    value: function (t, e) {
      if (!1 !== e.inheritsColor) {
        if ("both" === e.inheritsColor && this.from.id !== this.to.id) {
          var i = t.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y),
              n = this.from.options.color.highlight.border,
              o = this.to.options.color.highlight.border;
          return !1 === this.from.selected && !1 === this.to.selected ? (n = cs(this.from.options.color.border, e.opacity), o = cs(this.to.options.color.border, e.opacity)) : !0 === this.from.selected && !1 === this.to.selected ? o = this.to.options.color.border : !1 === this.from.selected && !0 === this.to.selected && (n = this.from.options.color.border), i.addColorStop(0, n), i.addColorStop(1, o), i;
        }

        return "to" === e.inheritsColor ? cs(this.to.options.color.border, e.opacity) : cs(this.from.options.color.border, e.opacity);
      }

      return cs(e.color, e.opacity);
    }
  }, {
    key: "_circle",
    value: function (t, e, i, n, o) {
      this.enableShadow(t, e), t.beginPath(), t.arc(i, n, o, 0, 2 * Math.PI, !1), t.stroke(), this.disableShadow(t, e);
    }
  }, {
    key: "getDistanceToEdge",
    value: function (t, e, i, n, o, r) {
      if (this.from != this.to) return this._getDistanceToEdge(t, e, i, n, o, r);

      var s = this._getCircleData(void 0),
          a = QS(s, 3),
          h = a[0],
          l = a[1],
          d = a[2],
          u = h - o,
          c = l - r;

      return Math.abs(Math.sqrt(u * u + c * c) - d);
    }
  }, {
    key: "_getDistanceToLine",
    value: function (t, e, i, n, o, r) {
      var s = i - t,
          a = n - e,
          h = ((o - t) * s + (r - e) * a) / (s * s + a * a);
      h > 1 ? h = 1 : h < 0 && (h = 0);
      var l = t + h * s - o,
          d = e + h * a - r;
      return Math.sqrt(l * l + d * d);
    }
  }, {
    key: "getArrowData",
    value: function (t, e, i, n, o, r) {
      var s,
          a,
          h,
          l,
          d,
          u,
          c,
          f = r.width;
      "from" === e ? (h = this.from, l = this.to, d = r.fromArrowScale < 0, u = Math.abs(r.fromArrowScale), c = r.fromArrowType) : "to" === e ? (h = this.to, l = this.from, d = r.toArrowScale < 0, u = Math.abs(r.toArrowScale), c = r.toArrowType) : (h = this.to, l = this.from, d = r.middleArrowScale < 0, u = Math.abs(r.middleArrowScale), c = r.middleArrowType);
      var p = 15 * u + 3 * f;

      if (h != l) {
        var v = p / ME(h.x - l.x, h.y - l.y);
        if ("middle" !== e) {
          if (!0 === this.options.smooth.enabled) {
            var y = this._findBorderPosition(h, t, {
              via: i
            }),
                g = this.getPoint(y.t + v * ("from" === e ? 1 : -1), i);

            s = Math.atan2(y.y - g.y, y.x - g.x), a = y;
          } else s = Math.atan2(h.y - l.y, h.x - l.x), a = this._findBorderPosition(h, t);
        } else {
          var m = (d ? -v : v) / 2,
              b = this.getPoint(.5 + m, i),
              w = this.getPoint(.5 - m, i);
          s = Math.atan2(b.y - w.y, b.x - w.x), a = this.getPoint(.5, i);
        }
      } else {
        var _ = this._getCircleData(t),
            k = QS(_, 3),
            x = k[0],
            O = k[1],
            S = k[2];

        if ("from" === e) {
          var M = this._findBorderPositionCircle(this.from, t, {
            x: x,
            y: O,
            low: .25,
            high: .6,
            direction: -1
          });

          s = -2 * M.t * Math.PI + 1.5 * Math.PI + .1 * Math.PI, a = M;
        } else if ("to" === e) {
          var E = this._findBorderPositionCircle(this.from, t, {
            x: x,
            y: O,
            low: .6,
            high: 1,
            direction: 1
          });

          s = -2 * E.t * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI, a = E;
        } else a = this._pointOnCircle(x, O, S, .175), s = 3.9269908169872414;
      }

      return {
        point: a,
        core: {
          x: a.x - .9 * p * Math.cos(s),
          y: a.y - .9 * p * Math.sin(s)
        },
        angle: s,
        length: p,
        type: c
      };
    }
  }, {
    key: "drawArrowHead",
    value: function (t, e, i, n, o) {
      t.strokeStyle = this.getColor(t, e), t.fillStyle = t.strokeStyle, t.lineWidth = e.width, BE.draw(t, o) && (this.enableShadow(t, e), RM(t).call(t), this.disableShadow(t, e));
    }
  }, {
    key: "enableShadow",
    value: function (t, e) {
      !0 === e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);
    }
  }, {
    key: "disableShadow",
    value: function (t, e) {
      !0 === e.shadow && (t.shadowColor = "rgba(0,0,0,0)", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);
    }
  }, {
    key: "drawBackground",
    value: function (t, e) {
      if (!1 !== e.background) {
        var i = {
          strokeStyle: t.strokeStyle,
          lineWidth: t.lineWidth,
          dashes: t.dashes
        };
        t.strokeStyle = e.backgroundColor, t.lineWidth = e.backgroundSize, this.setStrokeDashed(t, e.backgroundDashes), t.stroke(), t.strokeStyle = i.strokeStyle, t.lineWidth = i.lineWidth, t.dashes = i.dashes, this.setStrokeDashed(t, e.dashes);
      }
    }
  }, {
    key: "setStrokeDashed",
    value: function (t, e) {
      if (!1 !== e) {
        if (void 0 !== t.setLineDash) {
          var i = Mh(e) ? e : [5, 5];
          t.setLineDash(i);
        } else console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
      } else void 0 !== t.setLineDash ? t.setLineDash([]) : console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
    }
  }]), t;
}();

function WE(t, e) {
  var i = CS(t);

  if (DS) {
    var n = DS(t);
    e && (n = UO(n).call(n, function (e) {
      return YO(t, e).enumerable;
    })), i.push.apply(i, n);
  }

  return i;
}

function VE(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i,
        n = null != arguments[e] ? arguments[e] : {};
    if (e % 2) kh(i = WE(Object(n), !0)).call(i, function (e) {
      PS(t, e, n[e]);
    });else if (zO) AO(t, zO(n));else {
      var o;
      kh(o = WE(Object(n))).call(o, function (e) {
        PO(t, e, YO(n, e));
      });
    }
  }

  return t;
}

var UE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, HE), hc(e, [{
    key: "_findBorderPositionBezier",
    value: function (t, e) {
      var i,
          n,
          o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._getViaCoordinates(),
          r = 10,
          s = .2,
          a = !1,
          h = 1,
          l = 0,
          d = this.to;
      t.id === this.from.id && (d = this.from, a = !0);
      var u = 0;

      do {
        n = .5 * (l + h), i = this.getPoint(n, o);
        var c = Math.atan2(d.y - i.y, d.x - i.x),
            f = d.distanceToBorder(e, c),
            p = Math.sqrt(Math.pow(i.x - d.x, 2) + Math.pow(i.y - d.y, 2)),
            v = f - p;
        if (Math.abs(v) < s) break;
        v < 0 ? !1 === a ? l = n : h = n : !1 === a ? h = n : l = n, ++u;
      } while (l <= h && u < r);

      return VE({}, i, {
        t: n
      });
    }
  }, {
    key: "_getDistanceToBezierEdge",
    value: function (t, e, i, n, o, r, s) {
      var a,
          h,
          l,
          d,
          u,
          c = 1e9,
          f = t,
          p = e;

      for (h = 1; h < 10; h++) l = .1 * h, d = Math.pow(1 - l, 2) * t + 2 * l * (1 - l) * s.x + Math.pow(l, 2) * i, u = Math.pow(1 - l, 2) * e + 2 * l * (1 - l) * s.y + Math.pow(l, 2) * n, h > 0 && (c = (a = this._getDistanceToLine(f, p, d, u, o, r)) < c ? a : c), f = d, p = u;

      return c;
    }
  }, {
    key: "_bezierCurve",
    value: function (t, e, i, n) {
      t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), null != i && null != i.x ? null != n && null != n.x ? t.bezierCurveTo(i.x, i.y, n.x, n.y, this.toPoint.x, this.toPoint.y) : t.quadraticCurveTo(i.x, i.y, this.toPoint.x, this.toPoint.y) : t.lineTo(this.toPoint.x, this.toPoint.y), this.drawBackground(t, e), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);
    }
  }, {
    key: "getViaNode",
    value: function () {
      return this._getViaCoordinates();
    }
  }]), e;
}(),
    GE = function (t) {
  function e(t, i, n) {
    var o;
    return oc(this, e), (o = TM(this, IM(e).call(this, t, i, n))).via = o.via, o._boundFunction = function () {
      o.positionBezierNode();
    }, o._body.emitter.on("_repositionBezierNodes", o._boundFunction), o;
  }

  return jM(e, UE), hc(e, [{
    key: "setOptions",
    value: function (t) {
      _E(IM(e.prototype), "setOptions", this).call(this, t);

      var i = !1;
      this.options.physics !== t.physics && (i = !0), this.options = t, this.id = this.options.id, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.setupSupportNode(), this.connect(), !0 === i && (this.via.setOptions({
        physics: this.options.physics
      }), this.positionBezierNode());
    }
  }, {
    key: "connect",
    value: function () {
      this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], void 0 === this.from || void 0 === this.to || !1 === this.options.physics ? this.via.setOptions({
        physics: !1
      }) : this.from.id === this.to.id ? this.via.setOptions({
        physics: !1
      }) : this.via.setOptions({
        physics: !0
      });
    }
  }, {
    key: "cleanup",
    value: function () {
      return this._body.emitter.off("_repositionBezierNodes", this._boundFunction), void 0 !== this.via && (delete this._body.nodes[this.via.id], this.via = void 0, !0);
    }
  }, {
    key: "setupSupportNode",
    value: function () {
      if (void 0 === this.via) {
        var t = "edgeId:" + this.id,
            e = this._body.functions.createNode({
          id: t,
          shape: "circle",
          physics: !0,
          hidden: !0
        });

        this._body.nodes[t] = e, this.via = e, this.via.parentEdgeId = this.id, this.positionBezierNode();
      }
    }
  }, {
    key: "positionBezierNode",
    value: function () {
      void 0 !== this.via && void 0 !== this.from && void 0 !== this.to ? (this.via.x = .5 * (this.from.x + this.to.x), this.via.y = .5 * (this.from.y + this.to.y)) : void 0 !== this.via && (this.via.x = 0, this.via.y = 0);
    }
  }, {
    key: "_line",
    value: function (t, e, i) {
      this._bezierCurve(t, e, i);
    }
  }, {
    key: "_getViaCoordinates",
    value: function () {
      return this.via;
    }
  }, {
    key: "getViaNode",
    value: function () {
      return this.via;
    }
  }, {
    key: "getPoint",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.via;

      if (this.from === this.to) {
        var i = this._getCircleData(),
            n = QS(i, 3),
            o = n[0],
            r = n[1],
            s = n[2],
            a = 2 * Math.PI * (1 - t);

        return {
          x: o + s * Math.sin(a),
          y: r + s - s * (1 - Math.cos(a))
        };
      }

      return {
        x: Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * e.x + Math.pow(t, 2) * this.toPoint.x,
        y: Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * e.y + Math.pow(t, 2) * this.toPoint.y
      };
    }
  }, {
    key: "_findBorderPosition",
    value: function (t, e) {
      return this._findBorderPositionBezier(t, e, this.via);
    }
  }, {
    key: "_getDistanceToEdge",
    value: function (t, e, i, n, o, r) {
      return this._getDistanceToBezierEdge(t, e, i, n, o, r, this.via);
    }
  }]), e;
}(),
    qE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, UE), hc(e, [{
    key: "_line",
    value: function (t, e, i) {
      this._bezierCurve(t, e, i);
    }
  }, {
    key: "getViaNode",
    value: function () {
      return this._getViaCoordinates();
    }
  }, {
    key: "_getViaCoordinates",
    value: function () {
      var t,
          e,
          i = this.options.smooth.roundness,
          n = this.options.smooth.type,
          o = Math.abs(this.from.x - this.to.x),
          r = Math.abs(this.from.y - this.to.y);

      if ("discrete" === n || "diagonalCross" === n) {
        var s, a;
        s = a = o <= r ? i * r : i * o, this.from.x > this.to.x && (s = -s), this.from.y >= this.to.y && (a = -a);
        var h = this.from.x + s,
            l = this.from.y + a;
        return "discrete" === n && (o <= r ? h = o < i * r ? this.from.x : h : l = r < i * o ? this.from.y : l), {
          x: h,
          y: l
        };
      }

      if ("straightCross" === n) {
        var d = (1 - i) * o,
            u = (1 - i) * r;
        return o <= r ? (d = 0, this.from.y < this.to.y && (u = -u)) : (this.from.x < this.to.x && (d = -d), u = 0), {
          x: this.to.x + d,
          y: this.to.y + u
        };
      }

      if ("horizontal" === n) {
        var c = (1 - i) * o;
        return this.from.x < this.to.x && (c = -c), {
          x: this.to.x + c,
          y: this.from.y
        };
      }

      if ("vertical" === n) {
        var f = (1 - i) * r;
        return this.from.y < this.to.y && (f = -f), {
          x: this.from.x,
          y: this.to.y + f
        };
      }

      if ("curvedCW" === n) {
        o = this.to.x - this.from.x, r = this.from.y - this.to.y;
        var p = Math.sqrt(o * o + r * r),
            v = Math.PI,
            y = (Math.atan2(r, o) + (.5 * i + .5) * v) % (2 * v);
        return {
          x: this.from.x + (.5 * i + .5) * p * Math.sin(y),
          y: this.from.y + (.5 * i + .5) * p * Math.cos(y)
        };
      }

      if ("curvedCCW" === n) {
        o = this.to.x - this.from.x, r = this.from.y - this.to.y;
        var g = Math.sqrt(o * o + r * r),
            m = Math.PI,
            b = (Math.atan2(r, o) + (.5 * -i + .5) * m) % (2 * m);
        return {
          x: this.from.x + (.5 * i + .5) * g * Math.sin(b),
          y: this.from.y + (.5 * i + .5) * g * Math.cos(b)
        };
      }

      t = e = o <= r ? i * r : i * o, this.from.x > this.to.x && (t = -t), this.from.y >= this.to.y && (e = -e);

      var w = this.from.x + t,
          _ = this.from.y + e;

      return o <= r ? w = this.from.x <= this.to.x ? this.to.x < w ? this.to.x : w : this.to.x > w ? this.to.x : w : _ = this.from.y >= this.to.y ? this.to.y > _ ? this.to.y : _ : this.to.y < _ ? this.to.y : _, {
        x: w,
        y: _
      };
    }
  }, {
    key: "_findBorderPosition",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      return this._findBorderPositionBezier(t, e, i.via);
    }
  }, {
    key: "_getDistanceToEdge",
    value: function (t, e, i, n, o, r) {
      var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates();
      return this._getDistanceToBezierEdge(t, e, i, n, o, r, s);
    }
  }, {
    key: "getPoint",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(),
          i = t,
          n = Math.pow(1 - i, 2) * this.fromPoint.x + 2 * i * (1 - i) * e.x + Math.pow(i, 2) * this.toPoint.x,
          o = Math.pow(1 - i, 2) * this.fromPoint.y + 2 * i * (1 - i) * e.y + Math.pow(i, 2) * this.toPoint.y;
      return {
        x: n,
        y: o
      };
    }
  }]), e;
}(),
    XE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, UE), hc(e, [{
    key: "_getDistanceToBezierEdge2",
    value: function (t, e, i, n, o, r, s, a) {
      for (var h = 1e9, l = t, d = e, u = [0, 0, 0, 0], c = 1; c < 10; c++) {
        var f = .1 * c;
        u[0] = Math.pow(1 - f, 3), u[1] = 3 * f * Math.pow(1 - f, 2), u[2] = 3 * Math.pow(f, 2) * (1 - f), u[3] = Math.pow(f, 3);
        var p = u[0] * t + u[1] * s.x + u[2] * a.x + u[3] * i,
            v = u[0] * e + u[1] * s.y + u[2] * a.y + u[3] * n;

        if (c > 0) {
          var y = this._getDistanceToLine(l, d, p, v, o, r);

          h = y < h ? y : h;
        }

        l = p, d = v;
      }

      return h;
    }
  }]), e;
}(),
    ZE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, XE), hc(e, [{
    key: "_line",
    value: function (t, e, i) {
      var n = i[0],
          o = i[1];

      this._bezierCurve(t, e, n, o);
    }
  }, {
    key: "_getViaCoordinates",
    value: function () {
      var t,
          e,
          i,
          n,
          o = this.from.x - this.to.x,
          r = this.from.y - this.to.y,
          s = this.options.smooth.roundness;
      return (Math.abs(o) > Math.abs(r) || !0 === this.options.smooth.forceDirection || "horizontal" === this.options.smooth.forceDirection) && "vertical" !== this.options.smooth.forceDirection ? (e = this.from.y, n = this.to.y, t = this.from.x - s * o, i = this.to.x + s * o) : (e = this.from.y - s * r, n = this.to.y + s * r, t = this.from.x, i = this.to.x), [{
        x: t,
        y: e
      }, {
        x: i,
        y: n
      }];
    }
  }, {
    key: "getViaNode",
    value: function () {
      return this._getViaCoordinates();
    }
  }, {
    key: "_findBorderPosition",
    value: function (t, e) {
      return this._findBorderPositionBezier(t, e);
    }
  }, {
    key: "_getDistanceToEdge",
    value: function (t, e, i, n, o, r) {
      var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates(),
          a = QS(s, 2),
          h = a[0],
          l = a[1];
      return this._getDistanceToBezierEdge2(t, e, i, n, o, r, h, l);
    }
  }, {
    key: "getPoint",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(),
          i = QS(e, 2),
          n = i[0],
          o = i[1],
          r = t,
          s = [Math.pow(1 - r, 3), 3 * r * Math.pow(1 - r, 2), 3 * Math.pow(r, 2) * (1 - r), Math.pow(r, 3)],
          a = s[0] * this.fromPoint.x + s[1] * n.x + s[2] * o.x + s[3] * this.toPoint.x,
          h = s[0] * this.fromPoint.y + s[1] * n.y + s[2] * o.y + s[3] * this.toPoint.y;
      return {
        x: a,
        y: h
      };
    }
  }]), e;
}(),
    KE = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, HE), hc(e, [{
    key: "_line",
    value: function (t, e) {
      t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), t.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);
    }
  }, {
    key: "getViaNode",
    value: function () {}
  }, {
    key: "getPoint",
    value: function (t) {
      return {
        x: (1 - t) * this.fromPoint.x + t * this.toPoint.x,
        y: (1 - t) * this.fromPoint.y + t * this.toPoint.y
      };
    }
  }, {
    key: "_findBorderPosition",
    value: function (t, e) {
      var i = this.to,
          n = this.from;
      t.id === this.from.id && (i = this.from, n = this.to);
      var o = Math.atan2(i.y - n.y, i.x - n.x),
          r = i.x - n.x,
          s = i.y - n.y,
          a = Math.sqrt(r * r + s * s),
          h = (a - t.distanceToBorder(e, o)) / a;
      return {
        x: (1 - h) * n.x + h * i.x,
        y: (1 - h) * n.y + h * i.y,
        t: 0
      };
    }
  }, {
    key: "_getDistanceToEdge",
    value: function (t, e, i, n, o, r) {
      return this._getDistanceToLine(t, e, i, n, o, r);
    }
  }]), e;
}(),
    $E = function () {
  function t(e, i, n, o, r) {
    if (oc(this, t), void 0 === i) throw new Error("No body provided");
    this.options = Ms(o), this.globalOptions = o, this.defaultOptions = r, this.body = i, this.imagelist = n, this.id = void 0, this.fromId = void 0, this.toId = void 0, this.selected = !1, this.hover = !1, this.labelDirty = !0, this.baseWidth = this.options.width, this.baseFontSize = this.options.font.size, this.from = void 0, this.to = void 0, this.edgeType = void 0, this.connected = !1, this.labelModule = new EM(this.body, this.options, !0), this.setOptions(e);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (e) {
      if (e) {
        var i = void 0 !== e.physics && this.options.physics !== e.physics || void 0 !== e.hidden && (this.options.hidden || !1) !== (e.hidden || !1) || void 0 !== e.from && this.options.from !== e.from || void 0 !== e.to && this.options.to !== e.to;
        t.parseOptions(this.options, e, !0, this.globalOptions), void 0 !== e.id && (this.id = e.id), void 0 !== e.from && (this.fromId = e.from), void 0 !== e.to && (this.toId = e.to), void 0 !== e.title && (this.title = e.title), void 0 !== e.value && (e.value = YS(e.value));
        var n = [e, this.options, this.defaultOptions];
        return this.chooser = hM.choosify("edge", n), this.updateLabelModule(e), i = this.updateEdgeType() || i, this._setInteractionWidths(), this.connect(), i;
      }
    }
  }, {
    key: "getFormattingValues",
    value: function () {
      var t = !0 === this.options.arrows.to || !0 === this.options.arrows.to.enabled,
          e = !0 === this.options.arrows.from || !0 === this.options.arrows.from.enabled,
          i = !0 === this.options.arrows.middle || !0 === this.options.arrows.middle.enabled,
          n = this.options.color.inherit,
          o = {
        toArrow: t,
        toArrowScale: this.options.arrows.to.scaleFactor,
        toArrowType: this.options.arrows.to.type,
        toArrowSrc: this.options.arrows.to.src,
        toArrowImageWidth: this.options.arrows.to.imageWidth,
        toArrowImageHeight: this.options.arrows.to.imageHeight,
        middleArrow: i,
        middleArrowScale: this.options.arrows.middle.scaleFactor,
        middleArrowType: this.options.arrows.middle.type,
        middleArrowSrc: this.options.arrows.middle.src,
        middleArrowImageWidth: this.options.arrows.middle.imageWidth,
        middleArrowImageHeight: this.options.arrows.middle.imageHeight,
        fromArrow: e,
        fromArrowScale: this.options.arrows.from.scaleFactor,
        fromArrowType: this.options.arrows.from.type,
        fromArrowSrc: this.options.arrows.from.src,
        fromArrowImageWidth: this.options.arrows.from.imageWidth,
        fromArrowImageHeight: this.options.arrows.from.imageHeight,
        arrowStrikethrough: this.options.arrowStrikethrough,
        color: n ? void 0 : this.options.color.color,
        inheritsColor: n,
        opacity: this.options.color.opacity,
        hidden: this.options.hidden,
        length: this.options.length,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y,
        dashes: this.options.dashes,
        width: this.options.width,
        background: this.options.background.enabled,
        backgroundColor: this.options.background.color,
        backgroundSize: this.options.background.size,
        backgroundDashes: this.options.background.dashes
      };
      if (this.selected || this.hover) {
        if (!0 === this.chooser) {
          if (this.selected) {
            var r = this.options.selectionWidth;
            "function" == typeof r ? o.width = r(o.width) : "number" == typeof r && (o.width += r), o.width = Math.max(o.width, .3 / this.body.view.scale), o.color = this.options.color.highlight, o.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            var s = this.options.hoverWidth;
            "function" == typeof s ? o.width = s(o.width) : "number" == typeof s && (o.width += s), o.width = Math.max(o.width, .3 / this.body.view.scale), o.color = this.options.color.hover, o.shadow = this.options.shadow.enabled;
          }
        } else "function" == typeof this.chooser && (this.chooser(o, this.options.id, this.selected, this.hover), void 0 !== o.color && (o.inheritsColor = !1), !1 === o.shadow && (o.shadowColor === this.options.shadow.color && o.shadowSize === this.options.shadow.size && o.shadowX === this.options.shadow.x && o.shadowY === this.options.shadow.y || (o.shadow = !0)));
      } else o.shadow = this.options.shadow.enabled, o.width = Math.max(o.width, .3 / this.body.view.scale);
      return o;
    }
  }, {
    key: "updateLabelModule",
    value: function (t) {
      var e = [t, this.options, this.globalOptions, this.defaultOptions];
      this.labelModule.update(this.options, e), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);
    }
  }, {
    key: "updateEdgeType",
    value: function () {
      var t = this.options.smooth,
          e = !1,
          i = !0;
      return void 0 !== this.edgeType && ((this.edgeType instanceof GE && !0 === t.enabled && "dynamic" === t.type || this.edgeType instanceof ZE && !0 === t.enabled && "cubicBezier" === t.type || this.edgeType instanceof qE && !0 === t.enabled && "dynamic" !== t.type && "cubicBezier" !== t.type || this.edgeType instanceof KE && !1 === t.type.enabled) && (i = !1), !0 === i && (e = this.cleanup())), !0 === i ? !0 === t.enabled ? "dynamic" === t.type ? (e = !0, this.edgeType = new GE(this.options, this.body, this.labelModule)) : "cubicBezier" === t.type ? this.edgeType = new ZE(this.options, this.body, this.labelModule) : this.edgeType = new qE(this.options, this.body, this.labelModule) : this.edgeType = new KE(this.options, this.body, this.labelModule) : this.edgeType.setOptions(this.options), e;
    }
  }, {
    key: "connect",
    value: function () {
      this.disconnect(), this.from = this.body.nodes[this.fromId] || void 0, this.to = this.body.nodes[this.toId] || void 0, this.connected = void 0 !== this.from && void 0 !== this.to, !0 === this.connected ? (this.from.attachEdge(this), this.to.attachEdge(this)) : (this.from && this.from.detachEdge(this), this.to && this.to.detachEdge(this)), this.edgeType.connect();
    }
  }, {
    key: "disconnect",
    value: function () {
      this.from && (this.from.detachEdge(this), this.from = void 0), this.to && (this.to.detachEdge(this), this.to = void 0), this.connected = !1;
    }
  }, {
    key: "getTitle",
    value: function () {
      return this.title;
    }
  }, {
    key: "isSelected",
    value: function () {
      return this.selected;
    }
  }, {
    key: "getValue",
    value: function () {
      return this.options.value;
    }
  }, {
    key: "setValueRange",
    value: function (t, e, i) {
      if (void 0 !== this.options.value) {
        var n = this.options.scaling.customScalingFunction(t, e, i, this.options.value),
            o = this.options.scaling.max - this.options.scaling.min;

        if (!0 === this.options.scaling.label.enabled) {
          var r = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + n * r;
        }

        this.options.width = this.options.scaling.min + n * o;
      } else this.options.width = this.baseWidth, this.options.font.size = this.baseFontSize;

      this._setInteractionWidths(), this.updateLabelModule();
    }
  }, {
    key: "_setInteractionWidths",
    value: function () {
      "function" == typeof this.options.hoverWidth ? this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width) : this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width, "function" == typeof this.options.selectionWidth ? this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width) : this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
    }
  }, {
    key: "draw",
    value: function (t) {
      var e = this.getFormattingValues();

      if (!e.hidden) {
        var i = this.edgeType.getViaNode(),
            n = {};
        this.edgeType.fromPoint = this.edgeType.from, this.edgeType.toPoint = this.edgeType.to, e.fromArrow && (n.from = this.edgeType.getArrowData(t, "from", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.fromPoint = n.from.core), e.fromArrowSrc && (n.from.image = this.imagelist.load(e.fromArrowSrc)), e.fromArrowImageWidth && (n.from.imageWidth = e.fromArrowImageWidth), e.fromArrowImageHeight && (n.from.imageHeight = e.fromArrowImageHeight)), e.toArrow && (n.to = this.edgeType.getArrowData(t, "to", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.toPoint = n.to.core), e.toArrowSrc && (n.to.image = this.imagelist.load(e.toArrowSrc)), e.toArrowImageWidth && (n.to.imageWidth = e.toArrowImageWidth), e.toArrowImageHeight && (n.to.imageHeight = e.toArrowImageHeight)), e.middleArrow && (n.middle = this.edgeType.getArrowData(t, "middle", i, this.selected, this.hover, e), e.middleArrowSrc && (n.middle.image = this.imagelist.load(e.middleArrowSrc)), e.middleArrowImageWidth && (n.middle.imageWidth = e.middleArrowImageWidth), e.middleArrowImageHeight && (n.middle.imageHeight = e.middleArrowImageHeight)), this.edgeType.drawLine(t, e, this.selected, this.hover, i), this.drawArrows(t, n, e), this.drawLabel(t, i);
      }
    }
  }, {
    key: "drawArrows",
    value: function (t, e, i) {
      i.fromArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.from), i.middleArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.middle), i.toArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.to);
    }
  }, {
    key: "drawLabel",
    value: function (t, e) {
      if (void 0 !== this.options.label) {
        var i = this.from,
            n = this.to;

        if (this.labelModule.differentState(this.selected, this.hover) && this.labelModule.getTextSize(t, this.selected, this.hover), i.id != n.id) {
          this.labelModule.pointToSelf = !1;
          var o = this.edgeType.getPoint(.5, e);
          t.save();

          var r = this._getRotation(t);

          0 != r.angle && (t.translate(r.x, r.y), t.rotate(r.angle)), this.labelModule.draw(t, o.x, o.y, this.selected, this.hover), t.restore();
        } else {
          var s, a;
          this.labelModule.pointToSelf = !0;
          var h = this.options.selfReferenceSize;
          i.shape.width > i.shape.height ? (s = i.x + .5 * i.shape.width, a = i.y - h) : (s = i.x + h, a = i.y - .5 * i.shape.height), o = this._pointOnCircle(s, a, h, .125), this.labelModule.draw(t, o.x, o.y, this.selected, this.hover);
        }
      }
    }
  }, {
    key: "getItemsOnPoint",
    value: function (t) {
      var e = [];

      if (this.labelModule.visible()) {
        var i = this._getRotation();

        hM.pointInRect(this.labelModule.getSize(), t, i) && e.push({
          edgeId: this.id,
          labelId: 0
        });
      }

      var n = {
        left: t.x,
        top: t.y
      };
      return this.isOverlappingWith(n) && e.push({
        edgeId: this.id
      }), e;
    }
  }, {
    key: "isOverlappingWith",
    value: function (t) {
      if (this.connected) {
        var e = this.from.x,
            i = this.from.y,
            n = this.to.x,
            o = this.to.y,
            r = t.left,
            s = t.top;
        return this.edgeType.getDistanceToEdge(e, i, n, o, r, s) < 10;
      }

      return !1;
    }
  }, {
    key: "_getRotation",
    value: function (t) {
      var e = this.edgeType.getViaNode(),
          i = this.edgeType.getPoint(.5, e);
      void 0 !== t && this.labelModule.calculateLabelSize(t, this.selected, this.hover, i.x, i.y);
      var n = {
        x: i.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };
      if (!this.labelModule.visible()) return n;
      if ("horizontal" === this.options.font.align) return n;
      var o = this.from.y - this.to.y,
          r = this.from.x - this.to.x,
          s = Math.atan2(o, r);
      return (s < -1 && r < 0 || s > 0 && r < 0) && (s += Math.PI), n.angle = s, n;
    }
  }, {
    key: "_pointOnCircle",
    value: function (t, e, i, n) {
      var o = 2 * n * Math.PI;
      return {
        x: t + i * Math.cos(o),
        y: e - i * Math.sin(o)
      };
    }
  }, {
    key: "select",
    value: function () {
      this.selected = !0;
    }
  }, {
    key: "unselect",
    value: function () {
      this.selected = !1;
    }
  }, {
    key: "cleanup",
    value: function () {
      return this.edgeType.cleanup();
    }
  }, {
    key: "remove",
    value: function () {
      this.cleanup(), this.disconnect(), delete this.body.edges[this.id];
    }
  }, {
    key: "endPointsValid",
    value: function () {
      return void 0 !== this.body.nodes[this.fromId] && void 0 !== this.body.nodes[this.toId];
    }
  }], [{
    key: "parseOptions",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
          o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
          r = ["arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
      if (Wr(r, t, e, i), hM.isValidLabel(e.label) ? t.label = e.label : hM.isValidLabel(t.label) || (t.label = void 0), Ds(t, e, "smooth", n), Ds(t, e, "shadow", n), Ds(t, e, "background", n), void 0 !== e.dashes && null !== e.dashes ? t.dashes = e.dashes : !0 === i && null === e.dashes && (t.dashes = ol(n.dashes)), void 0 !== e.scaling && null !== e.scaling ? (void 0 !== e.scaling.min && (t.scaling.min = e.scaling.min), void 0 !== e.scaling.max && (t.scaling.max = e.scaling.max), Ds(t.scaling, e.scaling, "label", n.scaling)) : !0 === i && null === e.scaling && (t.scaling = ol(n.scaling)), void 0 !== e.arrows && null !== e.arrows) {
        if ("string" == typeof e.arrows) {
          var s = e.arrows.toLowerCase();
          t.arrows.to.enabled = -1 != el(s).call(s, "to"), t.arrows.middle.enabled = -1 != el(s).call(s, "middle"), t.arrows.from.enabled = -1 != el(s).call(s, "from");
        } else {
          if ("object" !== aM(e.arrows)) throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + uE(e.arrows));
          Ds(t.arrows, e.arrows, "to", n.arrows), Ds(t.arrows, e.arrows, "middle", n.arrows), Ds(t.arrows, e.arrows, "from", n.arrows);
        }
      } else !0 === i && null === e.arrows && (t.arrows = ol(n.arrows));

      if (void 0 !== e.color && null !== e.color) {
        var a = jr(e.color) ? {
          color: e.color,
          highlight: e.color,
          hover: e.color,
          inherit: !1,
          opacity: 1
        } : e.color,
            h = t.color;
        if (o) Ur(h, n.color, !1, i);else for (var l in h) h.hasOwnProperty(l) && delete h[l];
        if (jr(h)) h.color = h, h.highlight = h, h.hover = h, h.inherit = !1, void 0 === a.opacity && (h.opacity = 1);else {
          var d = !1;
          void 0 !== a.color && (h.color = a.color, d = !0), void 0 !== a.highlight && (h.highlight = a.highlight, d = !0), void 0 !== a.hover && (h.hover = a.hover, d = !0), void 0 !== a.inherit && (h.inherit = a.inherit), void 0 !== a.opacity && (h.opacity = Math.min(1, Math.max(0, a.opacity))), !0 === d ? h.inherit = !1 : void 0 === h.inherit && (h.inherit = "from");
        }
      } else !0 === i && null === e.color && (t.color = Ms(n.color));

      !0 === i && null === e.font && (t.font = Ms(n.font));
    }
  }]), t;
}(),
    JE = function () {
  function t(e, i, n) {
    var o,
        r = this;
    oc(this, t), this.body = e, this.images = i, this.groups = n, this.body.functions.createEdge = $(o = this.create).call(o, this), this.edgesListeners = {
      add: function (t, e) {
        r.add(e.items);
      },
      update: function (t, e) {
        r.update(e.items);
      },
      remove: function (t, e) {
        r.remove(e.items);
      }
    }, this.options = {}, this.defaultOptions = {
      arrows: {
        to: {
          enabled: !1,
          scaleFactor: 1,
          type: "arrow"
        },
        middle: {
          enabled: !1,
          scaleFactor: 1,
          type: "arrow"
        },
        from: {
          enabled: !1,
          scaleFactor: 1,
          type: "arrow"
        }
      },
      arrowStrikethrough: !0,
      color: {
        color: "#848484",
        highlight: "#848484",
        hover: "#848484",
        inherit: "from",
        opacity: 1
      },
      dashes: !1,
      font: {
        color: "#343434",
        size: 14,
        face: "arial",
        background: "none",
        strokeWidth: 2,
        strokeColor: "#ffffff",
        align: "horizontal",
        multi: !1,
        vadjust: 0,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          face: "courier new",
          vadjust: 2
        }
      },
      hidden: !1,
      hoverWidth: 1.5,
      label: void 0,
      labelHighlightBold: !0,
      length: void 0,
      physics: !0,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: !0,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function (t, e, i, n) {
          if (e === t) return .5;
          var o = 1 / (e - t);
          return Math.max(0, (n - t) * o);
        }
      },
      selectionWidth: 1.5,
      selfReferenceSize: 20,
      shadow: {
        enabled: !1,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: !1,
        color: "rgba(111,111,111,1)",
        size: 10,
        dashes: !1
      },
      smooth: {
        enabled: !0,
        type: "dynamic",
        forceDirection: "none",
        roundness: .5
      },
      title: void 0,
      width: 1,
      value: void 0
    }, Ur(this.options, this.defaultOptions), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t,
          e,
          i = this;
      this.body.emitter.on("_forceDisableDynamicCurves", function (t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        "dynamic" === t && (t = "continuous");
        var n = !1;

        for (var o in i.body.edges) if (i.body.edges.hasOwnProperty(o)) {
          var r = i.body.edges[o],
              s = i.body.data.edges.get(o);

          if (null != s) {
            var a = s.smooth;
            void 0 !== a && !0 === a.enabled && "dynamic" === a.type && (void 0 === t ? r.setOptions({
              smooth: !1
            }) : r.setOptions({
              smooth: {
                type: t
              }
            }), n = !0);
          }
        }

        !0 === e && !0 === n && i.body.emitter.emit("_dataChanged");
      }), this.body.emitter.on("_dataUpdated", function () {
        i.reconnectEdges();
      }), this.body.emitter.on("refreshEdges", $(t = this.refresh).call(t, this)), this.body.emitter.on("refresh", $(e = this.refresh).call(e, this)), this.body.emitter.on("destroy", function () {
        es(i.edgesListeners, function (t, e) {
          i.body.data.edges && i.body.data.edges.off(e, t);
        }), delete i.body.functions.createEdge, delete i.edgesListeners.add, delete i.edgesListeners.update, delete i.edgesListeners.remove, delete i.edgesListeners;
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        $E.parseOptions(this.options, t, !0, this.defaultOptions, !0);
        var e = !1;
        if (void 0 !== t.smooth) for (var i in this.body.edges) this.body.edges.hasOwnProperty(i) && (e = this.body.edges[i].updateEdgeType() || e);
        if (void 0 !== t.font) for (var n in this.body.edges) this.body.edges.hasOwnProperty(n) && this.body.edges[n].updateLabelModule();
        void 0 === t.hidden && void 0 === t.physics && !0 !== e || this.body.emitter.emit("_dataChanged");
      }
    }
  }, {
    key: "setData",
    value: function (t) {
      var e = this,
          i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          n = this.body.data.edges;
      if (t instanceof EO || t instanceof DO) this.body.data.edges = t;else if (Mh(t)) this.body.data.edges = new EO(), this.body.data.edges.add(t);else {
        if (t) throw new TypeError("Array or DataSet expected");
        this.body.data.edges = new EO();
      }

      if (n && es(this.edgesListeners, function (t, e) {
        n.off(e, t);
      }), this.body.edges = {}, this.body.data.edges) {
        es(this.edgesListeners, function (t, i) {
          e.body.data.edges.on(i, t);
        });
        var o = this.body.data.edges.getIds();
        this.add(o, !0);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), !1 === i && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "add",
    value: function (t) {
      for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.body.edges, n = this.body.data.edges, o = 0; o < t.length; o++) {
        var r = t[o],
            s = i[r];
        s && s.disconnect();
        var a = n.get(r, {
          showInternalIds: !0
        });
        i[r] = this.create(a);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), !1 === e && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "update",
    value: function (t) {
      for (var e = this.body.edges, i = this.body.data.edges, n = !1, o = 0; o < t.length; o++) {
        var r = t[o],
            s = i.get(r),
            a = e[r];
        void 0 !== a ? (a.disconnect(), n = a.setOptions(s) || n, a.connect()) : (this.body.edges[r] = this.create(s), n = !0);
      }

      !0 === n ? (this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), this.body.emitter.emit("_dataChanged")) : this.body.emitter.emit("_dataUpdated");
    }
  }, {
    key: "remove",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];

      if (0 !== t.length) {
        var i = this.body.edges;
        es(t, function (t) {
          var e = i[t];
          void 0 !== e && e.remove();
        }), e && this.body.emitter.emit("_dataChanged");
      }
    }
  }, {
    key: "refresh",
    value: function () {
      var t = this;
      es(this.body.edges, function (e, i) {
        var n = t.body.data.edges.get(i);
        void 0 !== n && e.setOptions(n);
      });
    }
  }, {
    key: "create",
    value: function (t) {
      return new $E(t, this.body, this.images, this.options, this.defaultOptions);
    }
  }, {
    key: "reconnectEdges",
    value: function () {
      var t,
          e = this.body.nodes,
          i = this.body.edges;

      for (t in e) e.hasOwnProperty(t) && (e[t].edges = []);

      for (t in i) if (i.hasOwnProperty(t)) {
        var n = i[t];
        n.from = null, n.to = null, n.connect();
      }
    }
  }, {
    key: "getConnectedNodes",
    value: function (t) {
      var e = [];

      if (void 0 !== this.body.edges[t]) {
        var i = this.body.edges[t];
        void 0 !== i.fromId && e.push(i.fromId), void 0 !== i.toId && e.push(i.toId);
      }

      return e;
    }
  }, {
    key: "_updateState",
    value: function () {
      this._addMissingEdges(), this._removeInvalidEdges();
    }
  }, {
    key: "_removeInvalidEdges",
    value: function () {
      var t = this,
          e = [];
      es(this.body.edges, function (i, n) {
        var o = t.body.nodes[i.toId],
            r = t.body.nodes[i.fromId];
        void 0 !== o && !0 === o.isCluster || void 0 !== r && !0 === r.isCluster || void 0 !== o && void 0 !== r || e.push(n);
      }), this.remove(e, !1);
    }
  }, {
    key: "_addMissingEdges",
    value: function () {
      var t = this.body.data.edges;

      if (null != t) {
        var e = this.body.edges,
            i = [];
        kh(t).call(t, function (t, n) {
          void 0 === e[n] && i.push(n);
        }), this.add(i, !0);
      }
    }
  }]), t;
}();

W({
  target: "Date",
  stat: !0
}, {
  now: function () {
    return new Date().getTime();
  }
});

var QE = F.Date.now,
    tD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.barnesHutTree, this.setOptions(n), this.randomSeed = 5;
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t, this.thetaInversed = 1 / this.options.theta, this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }
  }, {
    key: "seededRandom",
    value: function () {
      var t = 1e4 * Math.sin(this.randomSeed++);
      return t - Math.floor(t);
    }
  }, {
    key: "solve",
    value: function () {
      if (0 !== this.options.gravitationalConstant && this.physicsBody.physicsNodeIndices.length > 0) {
        var t,
            e = this.body.nodes,
            i = this.physicsBody.physicsNodeIndices,
            n = i.length,
            o = this._formBarnesHutTree(e, i);

        this.barnesHutTree = o;

        for (var r = 0; r < n; r++) (t = e[i[r]]).options.mass > 0 && this._getForceContributions(o.root, t);
      }
    }
  }, {
    key: "_getForceContributions",
    value: function (t, e) {
      this._getForceContribution(t.children.NW, e), this._getForceContribution(t.children.NE, e), this._getForceContribution(t.children.SW, e), this._getForceContribution(t.children.SE, e);
    }
  }, {
    key: "_getForceContribution",
    value: function (t, e) {
      var i, n, o;
      t.childrenCount > 0 && (i = t.centerOfMass.x - e.x, n = t.centerOfMass.y - e.y, (o = Math.sqrt(i * i + n * n)) * t.calcSize > this.thetaInversed ? this._calculateForces(o, i, n, e, t) : 4 === t.childrenCount ? this._getForceContributions(t, e) : t.children.data.id != e.id && this._calculateForces(o, i, n, e, t));
    }
  }, {
    key: "_calculateForces",
    value: function (t, e, i, n, o) {
      0 === t && (e = t = .1), this.overlapAvoidanceFactor < 1 && n.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * n.shape.radius, t - n.shape.radius));
      var r = this.options.gravitationalConstant * o.mass * n.options.mass / Math.pow(t, 3),
          s = e * r,
          a = i * r;
      this.physicsBody.forces[n.id].x += s, this.physicsBody.forces[n.id].y += a;
    }
  }, {
    key: "_formBarnesHutTree",
    value: function (t, e) {
      for (var i, n = e.length, o = t[e[0]].x, r = t[e[0]].y, s = t[e[0]].x, a = t[e[0]].y, h = 1; h < n; h++) {
        var l = t[e[h]],
            d = l.x,
            u = l.y;
        l.options.mass > 0 && (d < o && (o = d), d > s && (s = d), u < r && (r = u), u > a && (a = u));
      }

      var c = Math.abs(s - o) - Math.abs(a - r);
      c > 0 ? (r -= .5 * c, a += .5 * c) : (o += .5 * c, s -= .5 * c);
      var f = Math.max(1e-5, Math.abs(s - o)),
          p = .5 * f,
          v = .5 * (o + s),
          y = .5 * (r + a),
          g = {
        root: {
          centerOfMass: {
            x: 0,
            y: 0
          },
          mass: 0,
          range: {
            minX: v - p,
            maxX: v + p,
            minY: y - p,
            maxY: y + p
          },
          size: f,
          calcSize: 1 / f,
          children: {
            data: null
          },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };

      this._splitBranch(g.root);

      for (var m = 0; m < n; m++) (i = t[e[m]]).options.mass > 0 && this._placeInTree(g.root, i);

      return g;
    }
  }, {
    key: "_updateBranchMass",
    value: function (t, e) {
      var i = t.centerOfMass,
          n = t.mass + e.options.mass,
          o = 1 / n;
      i.x = i.x * t.mass + e.x * e.options.mass, i.x *= o, i.y = i.y * t.mass + e.y * e.options.mass, i.y *= o, t.mass = n;
      var r = Math.max(Math.max(e.height, e.radius), e.width);
      t.maxWidth = t.maxWidth < r ? r : t.maxWidth;
    }
  }, {
    key: "_placeInTree",
    value: function (t, e, i) {
      1 == i && void 0 !== i || this._updateBranchMass(t, e);
      var n,
          o = t.children.NW.range;
      n = o.maxX > e.x ? o.maxY > e.y ? "NW" : "SW" : o.maxY > e.y ? "NE" : "SE", this._placeInRegion(t, e, n);
    }
  }, {
    key: "_placeInRegion",
    value: function (t, e, i) {
      var n = t.children[i];

      switch (n.childrenCount) {
        case 0:
          n.children.data = e, n.childrenCount = 1, this._updateBranchMass(n, e);
          break;

        case 1:
          n.children.data.x === e.x && n.children.data.y === e.y ? (e.x += this.seededRandom(), e.y += this.seededRandom()) : (this._splitBranch(n), this._placeInTree(n, e));
          break;

        case 4:
          this._placeInTree(n, e);

      }
    }
  }, {
    key: "_splitBranch",
    value: function (t) {
      var e = null;
      1 === t.childrenCount && (e = t.children.data, t.mass = 0, t.centerOfMass.x = 0, t.centerOfMass.y = 0), t.childrenCount = 4, t.children.data = null, this._insertRegion(t, "NW"), this._insertRegion(t, "NE"), this._insertRegion(t, "SW"), this._insertRegion(t, "SE"), null != e && this._placeInTree(t, e);
    }
  }, {
    key: "_insertRegion",
    value: function (t, e) {
      var i,
          n,
          o,
          r,
          s = .5 * t.size;

      switch (e) {
        case "NW":
          i = t.range.minX, n = t.range.minX + s, o = t.range.minY, r = t.range.minY + s;
          break;

        case "NE":
          i = t.range.minX + s, n = t.range.maxX, o = t.range.minY, r = t.range.minY + s;
          break;

        case "SW":
          i = t.range.minX, n = t.range.minX + s, o = t.range.minY + s, r = t.range.maxY;
          break;

        case "SE":
          i = t.range.minX + s, n = t.range.maxX, o = t.range.minY + s, r = t.range.maxY;
      }

      t.children[e] = {
        centerOfMass: {
          x: 0,
          y: 0
        },
        mass: 0,
        range: {
          minX: i,
          maxX: n,
          minY: o,
          maxY: r
        },
        size: .5 * t.size,
        calcSize: 2 * t.calcSize,
        children: {
          data: null
        },
        maxWidth: 0,
        level: t.level + 1,
        childrenCount: 0
      };
    }
  }, {
    key: "_debug",
    value: function (t, e) {
      void 0 !== this.barnesHutTree && (t.lineWidth = 1, this._drawBranch(this.barnesHutTree.root, t, e));
    }
  }, {
    key: "_drawBranch",
    value: function (t, e, i) {
      void 0 === i && (i = "#FF0000"), 4 === t.childrenCount && (this._drawBranch(t.children.NW, e), this._drawBranch(t.children.NE, e), this._drawBranch(t.children.SE, e), this._drawBranch(t.children.SW, e)), e.strokeStyle = i, e.beginPath(), e.moveTo(t.range.minX, t.range.minY), e.lineTo(t.range.maxX, t.range.minY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.minY), e.lineTo(t.range.maxX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.maxY), e.lineTo(t.range.minX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.minX, t.range.maxY), e.lineTo(t.range.minX, t.range.minY), e.stroke();
    }
  }]), t;
}(),
    eD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.setOptions(n);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t;
    }
  }, {
    key: "solve",
    value: function () {
      for (var t, e, i, n, o, r, s, a, h = this.body.nodes, l = this.physicsBody.physicsNodeIndices, d = this.physicsBody.forces, u = this.options.nodeDistance, c = -2 / 3 / u, f = 0; f < l.length - 1; f++) {
        s = h[l[f]];

        for (var p = f + 1; p < l.length; p++) t = (a = h[l[p]]).x - s.x, e = a.y - s.y, 0 === (i = Math.sqrt(t * t + e * e)) && (t = i = .1 * Math.random()), i < 2 * u && (r = i < .5 * u ? 1 : c * i + 4 / 3, n = t * (r /= i), o = e * r, d[s.id].x -= n, d[s.id].y -= o, d[a.id].x += n, d[a.id].y += o);
      }
    }
  }]), t;
}();

var iD = function (t) {
  throw new Error('"' + t + '" is read-only');
},
    nD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.setOptions(n);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t, this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
    }
  }, {
    key: "solve",
    value: function () {
      for (var t = this.body.nodes, e = this.physicsBody.physicsNodeIndices, i = this.physicsBody.forces, n = this.options.nodeDistance, o = 0; o < e.length - 1; o++) for (var r = t[e[o]], s = o + 1; s < e.length; s++) {
        var a = t[e[s]];

        if (r.level === a.level) {
          var h = n + this.overlapAvoidanceFactor * ((r.shape.radius || 0) / 2 + (a.shape.radius || 0) / 2),
              l = a.x - r.x,
              d = a.y - r.y,
              u = Math.sqrt(l * l + d * d),
              c = void 0;
          c = u < h ? -Math.pow(.05 * u, 2) + Math.pow(.05 * h, 2) : 0, 0 === u ? (iD("distance"), u = .01) : c /= u;
          var f = l * c,
              p = d * c;
          i[r.id].x -= f, i[r.id].y -= p, i[a.id].x += f, i[a.id].y += p;
        }
      }
    }
  }]), t;
}(),
    oD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.setOptions(n);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t;
    }
  }, {
    key: "solve",
    value: function () {
      for (var t, e, i, n, o, r = this.physicsBody.physicsEdgeIndices, s = this.body.edges, a = 0; a < r.length; a++) !0 === (e = s[r[a]]).connected && e.toId !== e.fromId && void 0 !== this.body.nodes[e.toId] && void 0 !== this.body.nodes[e.fromId] && (void 0 !== e.edgeType.via ? (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.to, n = e.edgeType.via, o = e.from, this._calculateSpringForce(i, n, .5 * t), this._calculateSpringForce(n, o, .5 * t)) : (t = void 0 === e.options.length ? 1.5 * this.options.springLength : e.options.length, this._calculateSpringForce(e.from, e.to, t)));
    }
  }, {
    key: "_calculateSpringForce",
    value: function (t, e, i) {
      var n = t.x - e.x,
          o = t.y - e.y,
          r = Math.max(Math.sqrt(n * n + o * o), .01),
          s = this.options.springConstant * (i - r) / r,
          a = n * s,
          h = o * s;
      void 0 !== this.physicsBody.forces[t.id] && (this.physicsBody.forces[t.id].x += a, this.physicsBody.forces[t.id].y += h), void 0 !== this.physicsBody.forces[e.id] && (this.physicsBody.forces[e.id].x -= a, this.physicsBody.forces[e.id].y -= h);
    }
  }]), t;
}(),
    rD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.setOptions(n);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t;
    }
  }, {
    key: "solve",
    value: function () {
      for (var t, e, i, n, o, r, s, a, h, l, d = this.body.edges, u = this.physicsBody.physicsEdgeIndices, c = this.physicsBody.physicsNodeIndices, f = this.physicsBody.forces, p = 0; p < c.length; p++) {
        var v = c[p];
        f[v].springFx = 0, f[v].springFy = 0;
      }

      for (var y = 0; y < u.length; y++) !0 === (e = d[u[y]]).connected && (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.from.x - e.to.x, n = e.from.y - e.to.y, a = 0 === (a = Math.sqrt(i * i + n * n)) ? .01 : a, o = i * (s = this.options.springConstant * (t - a) / a), r = n * s, e.to.level != e.from.level ? (void 0 !== f[e.toId] && (f[e.toId].springFx -= o, f[e.toId].springFy -= r), void 0 !== f[e.fromId] && (f[e.fromId].springFx += o, f[e.fromId].springFy += r)) : (void 0 !== f[e.toId] && (f[e.toId].x -= .5 * o, f[e.toId].y -= .5 * r), void 0 !== f[e.fromId] && (f[e.fromId].x += .5 * o, f[e.fromId].y += .5 * r)));

      s = 1;

      for (var g = 0; g < c.length; g++) {
        var m = c[g];
        h = Math.min(s, Math.max(-s, f[m].springFx)), l = Math.min(s, Math.max(-s, f[m].springFy)), f[m].x += h, f[m].y += l;
      }

      for (var b = 0, w = 0, _ = 0; _ < c.length; _++) {
        var k = c[_];
        b += f[k].x, w += f[k].y;
      }

      for (var x = b / c.length, O = w / c.length, S = 0; S < c.length; S++) {
        var M = c[S];
        f[M].x -= x, f[M].y -= O;
      }
    }
  }]), t;
}(),
    sD = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.physicsBody = i, this.setOptions(n);
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      this.options = t;
    }
  }, {
    key: "solve",
    value: function () {
      for (var t, e, i, n, o = this.body.nodes, r = this.physicsBody.physicsNodeIndices, s = this.physicsBody.forces, a = 0; a < r.length; a++) {
        t = -(n = o[r[a]]).x, e = -n.y, i = Math.sqrt(t * t + e * e), this._calculateForces(i, t, e, s, n);
      }
    }
  }, {
    key: "_calculateForces",
    value: function (t, e, i, n, o) {
      var r = 0 === t ? 0 : this.options.centralGravity / t;
      n[o.id].x = e * r, n[o.id].y = i * r;
    }
  }]), t;
}(),
    aD = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, tD), hc(e, [{
    key: "_calculateForces",
    value: function (t, e, i, n, o) {
      0 === t && (e = t = .1 * Math.random()), this.overlapAvoidanceFactor < 1 && n.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * n.shape.radius, t - n.shape.radius));
      var r = n.edges.length + 1,
          s = this.options.gravitationalConstant * o.mass * n.options.mass * r / Math.pow(t, 2),
          a = e * s,
          h = i * s;
      this.physicsBody.forces[n.id].x += a, this.physicsBody.forces[n.id].y += h;
    }
  }]), e;
}(),
    hD = function (t) {
  function e(t, i, n) {
    return oc(this, e), TM(this, IM(e).call(this, t, i, n));
  }

  return jM(e, sD), hc(e, [{
    key: "_calculateForces",
    value: function (t, e, i, n, o) {
      if (t > 0) {
        var r = o.edges.length + 1,
            s = this.options.centralGravity * r * o.options.mass;
        n[o.id].x = e * s, n[o.id].y = i * s;
      }
    }
  }]), e;
}(),
    lD = function () {
  function t(e) {
    oc(this, t), this.body = e, this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    }, this.physicsEnabled = !0, this.simulationInterval = 1e3 / 60, this.requiresTimeout = !0, this.previousStates = {}, this.referenceState = {}, this.freezeCache = {}, this.renderTimer = void 0, this.adaptiveTimestep = !1, this.adaptiveTimestepEnabled = !1, this.adaptiveCounter = 0, this.adaptiveInterval = 3, this.stabilized = !1, this.startedStabilization = !1, this.stabilizationIterations = 0, this.ready = !1, this.options = {}, this.defaultOptions = {
      enabled: !0,
      barnesHut: {
        theta: .5,
        gravitationalConstant: -2e3,
        centralGravity: .3,
        springLength: 95,
        springConstant: .04,
        damping: .09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: .5,
        gravitationalConstant: -50,
        centralGravity: .01,
        springConstant: .08,
        springLength: 100,
        damping: .4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: .2,
        springLength: 200,
        springConstant: .05,
        nodeDistance: 100,
        damping: .09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0,
        springLength: 100,
        springConstant: .01,
        nodeDistance: 120,
        damping: .09
      },
      maxVelocity: 50,
      minVelocity: .75,
      solver: "barnesHut",
      stabilization: {
        enabled: !0,
        iterations: 1e3,
        updateInterval: 50,
        onlyDynamicEdges: !1,
        fit: !0
      },
      timestep: .5,
      adaptiveTimestep: !0
    }, Yr(this.options, this.defaultOptions), this.timestep = .5, this.layoutFailed = !1, this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t = this;
      this.body.emitter.on("initPhysics", function () {
        t.initPhysics();
      }), this.body.emitter.on("_layoutFailed", function () {
        t.layoutFailed = !0;
      }), this.body.emitter.on("resetPhysics", function () {
        t.stopSimulation(), t.ready = !1;
      }), this.body.emitter.on("disablePhysics", function () {
        t.physicsEnabled = !1, t.stopSimulation();
      }), this.body.emitter.on("restorePhysics", function () {
        t.setOptions(t.options), !0 === t.ready && t.startSimulation();
      }), this.body.emitter.on("startSimulation", function () {
        !0 === t.ready && t.startSimulation();
      }), this.body.emitter.on("stopSimulation", function () {
        t.stopSimulation();
      }), this.body.emitter.on("destroy", function () {
        t.stopSimulation(!1), t.body.emitter.off();
      }), this.body.emitter.on("_dataChanged", function () {
        t.updatePhysicsData();
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      void 0 !== t && (!1 === t ? (this.options.enabled = !1, this.physicsEnabled = !1, this.stopSimulation()) : !0 === t ? (this.options.enabled = !0, this.physicsEnabled = !0, this.startSimulation()) : (this.physicsEnabled = !0, Vr(["stabilization"], this.options, t), Ds(this.options, t, "stabilization"), void 0 === t.enabled && (this.options.enabled = !0), !1 === this.options.enabled && (this.physicsEnabled = !1, this.stopSimulation()), this.timestep = this.options.timestep)), this.init();
    }
  }, {
    key: "init",
    value: function () {
      var t;
      "forceAtlas2Based" === this.options.solver ? (t = this.options.forceAtlas2Based, this.nodesSolver = new aD(this.body, this.physicsBody, t), this.edgesSolver = new oD(this.body, this.physicsBody, t), this.gravitySolver = new hD(this.body, this.physicsBody, t)) : "repulsion" === this.options.solver ? (t = this.options.repulsion, this.nodesSolver = new eD(this.body, this.physicsBody, t), this.edgesSolver = new oD(this.body, this.physicsBody, t), this.gravitySolver = new sD(this.body, this.physicsBody, t)) : "hierarchicalRepulsion" === this.options.solver ? (t = this.options.hierarchicalRepulsion, this.nodesSolver = new nD(this.body, this.physicsBody, t), this.edgesSolver = new rD(this.body, this.physicsBody, t), this.gravitySolver = new sD(this.body, this.physicsBody, t)) : (t = this.options.barnesHut, this.nodesSolver = new tD(this.body, this.physicsBody, t), this.edgesSolver = new oD(this.body, this.physicsBody, t), this.gravitySolver = new sD(this.body, this.physicsBody, t)), this.modelOptions = t;
    }
  }, {
    key: "initPhysics",
    value: function () {
      !0 === this.physicsEnabled && !0 === this.options.enabled ? !0 === this.options.stabilization.enabled ? this.stabilize() : (this.stabilized = !1, this.ready = !0, this.body.emitter.emit("fit", {}, this.layoutFailed), this.startSimulation()) : (this.ready = !0, this.body.emitter.emit("fit"));
    }
  }, {
    key: "startSimulation",
    value: function () {
      var t;
      !0 === this.physicsEnabled && !0 === this.options.enabled ? (this.stabilized = !1, this.adaptiveTimestep = !1, this.body.emitter.emit("_resizeNodes"), void 0 === this.viewFunction && (this.viewFunction = $(t = this.simulationStep).call(t, this), this.body.emitter.on("initRedraw", this.viewFunction), this.body.emitter.emit("_startRendering"))) : this.body.emitter.emit("_redraw");
    }
  }, {
    key: "stopSimulation",
    value: function () {
      var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      this.stabilized = !0, !0 === t && this._emitStabilized(), void 0 !== this.viewFunction && (this.body.emitter.off("initRedraw", this.viewFunction), this.viewFunction = void 0, !0 === t && this.body.emitter.emit("_stopRendering"));
    }
  }, {
    key: "simulationStep",
    value: function () {
      var t = QE();
      this.physicsTick(), (QE() - t < .4 * this.simulationInterval || !0 === this.runDoubleSpeed) && !1 === this.stabilized && (this.physicsTick(), this.runDoubleSpeed = !0), !0 === this.stabilized && this.stopSimulation();
    }
  }, {
    key: "_emitStabilized",
    value: function () {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.stabilizationIterations;
      (this.stabilizationIterations > 1 || !0 === this.startedStabilization) && vc(function () {
        t.body.emitter.emit("stabilized", {
          iterations: e
        }), t.startedStabilization = !1, t.stabilizationIterations = 0;
      }, 0);
    }
  }, {
    key: "physicsStep",
    value: function () {
      this.gravitySolver.solve(), this.nodesSolver.solve(), this.edgesSolver.solve(), this.moveNodes();
    }
  }, {
    key: "adjustTimeStep",
    value: function () {
      !0 === this._evaluateStepQuality() ? this.timestep = 1.2 * this.timestep : this.timestep / 1.2 < this.options.timestep ? this.timestep = this.options.timestep : (this.adaptiveCounter = -1, this.timestep = Math.max(this.options.timestep, this.timestep / 1.2));
    }
  }, {
    key: "physicsTick",
    value: function () {
      if (this._startStabilizing(), !0 !== this.stabilized) {
        if (!0 === this.adaptiveTimestep && !0 === this.adaptiveTimestepEnabled) this.adaptiveCounter % this.adaptiveInterval == 0 ? (this.timestep = 2 * this.timestep, this.physicsStep(), this.revert(), this.timestep = .5 * this.timestep, this.physicsStep(), this.physicsStep(), this.adjustTimeStep()) : this.physicsStep(), this.adaptiveCounter += 1;else this.timestep = this.options.timestep, this.physicsStep();
        !0 === this.stabilized && this.revert(), this.stabilizationIterations++;
      }
    }
  }, {
    key: "updatePhysicsData",
    value: function () {
      this.physicsBody.forces = {}, this.physicsBody.physicsNodeIndices = [], this.physicsBody.physicsEdgeIndices = [];
      var t = this.body.nodes,
          e = this.body.edges;

      for (var i in t) t.hasOwnProperty(i) && !0 === t[i].options.physics && this.physicsBody.physicsNodeIndices.push(t[i].id);

      for (var n in e) e.hasOwnProperty(n) && !0 === e[n].options.physics && this.physicsBody.physicsEdgeIndices.push(e[n].id);

      for (var o = 0; o < this.physicsBody.physicsNodeIndices.length; o++) {
        var r = this.physicsBody.physicsNodeIndices[o];
        this.physicsBody.forces[r] = {
          x: 0,
          y: 0
        }, void 0 === this.physicsBody.velocities[r] && (this.physicsBody.velocities[r] = {
          x: 0,
          y: 0
        });
      }

      for (var s in this.physicsBody.velocities) void 0 === t[s] && delete this.physicsBody.velocities[s];
    }
  }, {
    key: "revert",
    value: function () {
      var t = CS(this.previousStates),
          e = this.body.nodes,
          i = this.physicsBody.velocities;
      this.referenceState = {};

      for (var n = 0; n < t.length; n++) {
        var o = t[n];
        void 0 !== e[o] ? !0 === e[o].options.physics && (this.referenceState[o] = {
          positions: {
            x: e[o].x,
            y: e[o].y
          }
        }, i[o].x = this.previousStates[o].vx, i[o].y = this.previousStates[o].vy, e[o].x = this.previousStates[o].x, e[o].y = this.previousStates[o].y) : delete this.previousStates[o];
      }
    }
  }, {
    key: "_evaluateStepQuality",
    value: function () {
      var t,
          e,
          i = this.body.nodes,
          n = this.referenceState;

      for (var o in this.referenceState) if (this.referenceState.hasOwnProperty(o) && void 0 !== i[o] && (t = i[o].x - n[o].positions.x, e = i[o].y - n[o].positions.y, Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)) > .3)) return !1;

      return !0;
    }
  }, {
    key: "moveNodes",
    value: function () {
      for (var t = this.physicsBody.physicsNodeIndices, e = 0, i = 0, n = 0; n < t.length; n++) {
        var o = t[n],
            r = this._performStep(o);

        e = Math.max(e, r), i += r;
      }

      this.adaptiveTimestepEnabled = i / t.length < 5, this.stabilized = e < this.options.minVelocity;
    }
  }, {
    key: "calculateComponentVelocity",
    value: function (t, e, i) {
      t += (e - this.modelOptions.damping * t) / i * this.timestep;
      var n = this.options.maxVelocity || 1e9;
      return Math.abs(t) > n && (t = t > 0 ? n : -n), t;
    }
  }, {
    key: "_performStep",
    value: function (t) {
      var e = this.body.nodes[t],
          i = this.physicsBody.forces[t],
          n = this.physicsBody.velocities[t];
      return this.previousStates[t] = {
        x: e.x,
        y: e.y,
        vx: n.x,
        vy: n.y
      }, !1 === e.options.fixed.x ? (n.x = this.calculateComponentVelocity(n.x, i.x, e.options.mass), e.x += n.x * this.timestep) : (i.x = 0, n.x = 0), !1 === e.options.fixed.y ? (n.y = this.calculateComponentVelocity(n.y, i.y, e.options.mass), e.y += n.y * this.timestep) : (i.y = 0, n.y = 0), Math.sqrt(Math.pow(n.x, 2) + Math.pow(n.y, 2));
    }
  }, {
    key: "_freezeNodes",
    value: function () {
      var t = this.body.nodes;

      for (var e in t) if (t.hasOwnProperty(e) && t[e].x && t[e].y) {
        var i = t[e].options.fixed;
        this.freezeCache[e] = {
          x: i.x,
          y: i.y
        }, i.x = !0, i.y = !0;
      }
    }
  }, {
    key: "_restoreFrozenNodes",
    value: function () {
      var t = this.body.nodes;

      for (var e in t) t.hasOwnProperty(e) && void 0 !== this.freezeCache[e] && (t[e].options.fixed.x = this.freezeCache[e].x, t[e].options.fixed.y = this.freezeCache[e].y);

      this.freezeCache = {};
    }
  }, {
    key: "stabilize",
    value: function () {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.stabilization.iterations;
      "number" != typeof e && (e = this.options.stabilization.iterations, console.log("The stabilize method needs a numeric amount of iterations. Switching to default: ", e)), 0 !== this.physicsBody.physicsNodeIndices.length ? (this.adaptiveTimestep = this.options.adaptiveTimestep, this.body.emitter.emit("_resizeNodes"), this.stopSimulation(), this.stabilized = !1, this.body.emitter.emit("_blockRedraw"), this.targetIterations = e, !0 === this.options.stabilization.onlyDynamicEdges && this._freezeNodes(), this.stabilizationIterations = 0, vc(function () {
        return t._stabilizationBatch();
      }, 0)) : this.ready = !0;
    }
  }, {
    key: "_startStabilizing",
    value: function () {
      return !0 !== this.startedStabilization && (this.body.emitter.emit("startStabilizing"), this.startedStabilization = !0, !0);
    }
  }, {
    key: "_stabilizationBatch",
    value: function () {
      var t = this,
          e = function () {
        return !1 === t.stabilized && t.stabilizationIterations < t.targetIterations;
      },
          i = function () {
        t.body.emitter.emit("stabilizationProgress", {
          iterations: t.stabilizationIterations,
          total: t.targetIterations
        });
      };

      this._startStabilizing() && i();

      for (var n, o = 0; e() && o < this.options.stabilization.updateInterval;) this.physicsTick(), o++;

      (i(), e()) ? vc($(n = this._stabilizationBatch).call(n, this), 0) : this._finalizeStabilization();
    }
  }, {
    key: "_finalizeStabilization",
    value: function () {
      this.body.emitter.emit("_allowRedraw"), !0 === this.options.stabilization.fit && this.body.emitter.emit("fit"), !0 === this.options.stabilization.onlyDynamicEdges && this._restoreFrozenNodes(), this.body.emitter.emit("stabilizationIterationsDone"), this.body.emitter.emit("_requestRedraw"), !0 === this.stabilized ? this._emitStabilized() : this.startSimulation(), this.ready = !0;
    }
  }, {
    key: "_drawForces",
    value: function (t) {
      for (var e = 0; e < this.physicsBody.physicsNodeIndices.length; e++) {
        var i = this.physicsBody.physicsNodeIndices[e],
            n = this.body.nodes[i],
            o = this.physicsBody.forces[i],
            r = Math.sqrt(Math.pow(o.x, 2) + Math.pow(o.x, 2)),
            s = Math.min(Math.max(5, r), 15),
            a = 3 * s,
            h = ws((180 - 180 * Math.min(1, Math.max(0, .03 * r))) / 360, 1, 1),
            l = {
          x: n.x + 20 * o.x,
          y: n.y + 20 * o.y
        };
        t.lineWidth = s, t.strokeStyle = h, t.beginPath(), t.moveTo(n.x, n.y), t.lineTo(l.x, l.y), t.stroke();
        var d = Math.atan2(o.y, o.x);
        t.fillStyle = h, BE.draw(t, {
          type: "arrow",
          point: l,
          angle: d,
          length: a
        }), RM(t).call(t);
      }
    }
  }]), t;
}(),
    dD = [].reverse,
    uD = [1, 2];

W({
  target: "Array",
  proto: !0,
  forced: String(uD) === String(uD.reverse())
}, {
  reverse: function () {
    return dh(this) && (this.length = this.length), dD.call(this);
  }
});

var cD = X("Array").reverse,
    fD = Array.prototype,
    pD = function (t) {
  var e = t.reverse;
  return t === fD || t instanceof Array && e === fD.reverse ? cD : e;
},
    vD = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, null, [{
    key: "getRange",
    value: function (t) {
      var e,
          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
          n = 1e9,
          o = -1e9,
          r = 1e9,
          s = -1e9;
      if (i.length > 0) for (var a = 0; a < i.length; a++) r > (e = t[i[a]]).shape.boundingBox.left && (r = e.shape.boundingBox.left), s < e.shape.boundingBox.right && (s = e.shape.boundingBox.right), n > e.shape.boundingBox.top && (n = e.shape.boundingBox.top), o < e.shape.boundingBox.bottom && (o = e.shape.boundingBox.bottom);
      return 1e9 === r && -1e9 === s && 1e9 === n && -1e9 === o && (n = 0, o = 0, r = 0, s = 0), {
        minX: r,
        maxX: s,
        minY: n,
        maxY: o
      };
    }
  }, {
    key: "getRangeCore",
    value: function (t) {
      var e,
          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
          n = 1e9,
          o = -1e9,
          r = 1e9,
          s = -1e9;
      if (i.length > 0) for (var a = 0; a < i.length; a++) r > (e = t[i[a]]).x && (r = e.x), s < e.x && (s = e.x), n > e.y && (n = e.y), o < e.y && (o = e.y);
      return 1e9 === r && -1e9 === s && 1e9 === n && -1e9 === o && (n = 0, o = 0, r = 0, s = 0), {
        minX: r,
        maxX: s,
        minY: n,
        maxY: o
      };
    }
  }, {
    key: "findCenter",
    value: function (t) {
      return {
        x: .5 * (t.maxX + t.minX),
        y: .5 * (t.maxY + t.minY)
      };
    }
  }, {
    key: "cloneOptions",
    value: function (t, e) {
      var i = {};
      return void 0 === e || "node" === e ? (Ur(i, t.options, !0), i.x = t.x, i.y = t.y, i.amountOfConnections = t.edges.length) : Ur(i, t.options, !0), i;
    }
  }]), t;
}(),
    yD = function (t) {
  function e(t, i, n, o, r, s) {
    var a;
    return oc(this, e), (a = TM(this, IM(e).call(this, t, i, n, o, r, s))).isCluster = !0, a.containedNodes = {}, a.containedEdges = {}, a;
  }

  return jM(e, yE), hc(e, [{
    key: "_openChildCluster",
    value: function (t) {
      var e = this,
          i = this.body.nodes[t];
      if (void 0 === this.containedNodes[t]) throw new Error("node with id: " + t + " not in current cluster");
      if (!i.isCluster) throw new Error("node with id: " + t + " is not a cluster");
      delete this.containedNodes[t], es(i.edges, function (t) {
        delete e.containedEdges[t.id];
      }), es(i.containedNodes, function (t, i) {
        e.containedNodes[i] = t;
      }), i.containedNodes = {}, es(i.containedEdges, function (t, i) {
        e.containedEdges[i] = t;
      }), i.containedEdges = {}, es(i.edges, function (t) {
        es(e.edges, function (i) {
          var n,
              o,
              r = el(n = i.clusteringEdgeReplacingIds).call(n, t.id);
          -1 !== r && (es(t.clusteringEdgeReplacingIds, function (t) {
            i.clusteringEdgeReplacingIds.push(t), e.body.edges[t].edgeReplacedById = i.id;
          }), Rh(o = i.clusteringEdgeReplacingIds).call(o, r, 1));
        });
      }), i.edges = [];
    }
  }]), e;
}(),
    gD = function () {
  function t(e) {
    var i = this;
    oc(this, t), this.body = e, this.clusteredNodes = {}, this.clusteredEdges = {}, this.options = {}, this.defaultOptions = {}, Yr(this.options, this.defaultOptions), this.body.emitter.on("_resetData", function () {
      i.clusteredNodes = {}, i.clusteredEdges = {};
    });
  }

  return hc(t, [{
    key: "clusterByHubsize",
    value: function (t, e) {
      void 0 === t ? t = this._getHubSize() : "object" === aM(t) && (e = this._checkOptions(t), t = this._getHubSize());

      for (var i = [], n = 0; n < this.body.nodeIndices.length; n++) {
        var o = this.body.nodes[this.body.nodeIndices[n]];
        o.edges.length >= t && i.push(o.id);
      }

      for (var r = 0; r < i.length; r++) this.clusterByConnection(i[r], e, !0);

      this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "cluster",
    value: function () {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (void 0 === e.joinCondition) throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
      e = this._checkOptions(e);
      var n = {},
          o = {};
      es(this.body.nodes, function (i, r) {
        i.options && !0 === e.joinCondition(i.options) && (n[r] = i, es(i.edges, function (e) {
          void 0 === t.clusteredEdges[e.id] && (o[e.id] = e);
        }));
      }), this._cluster(n, o, e, i);
    }
  }, {
    key: "clusterByEdgeCount",
    value: function (t, e) {
      var i = this,
          n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      e = this._checkOptions(e);

      for (var o, r, s, a = [], h = {}, l = function (n) {
        var l = {},
            d = {},
            f = i.body.nodeIndices[n],
            p = i.body.nodes[f];

        if (void 0 === h[f]) {
          s = 0, r = [];

          for (var v = 0; v < p.edges.length; v++) o = p.edges[v], void 0 === i.clusteredEdges[o.id] && (o.toId !== o.fromId && s++, r.push(o));

          if (s === t) {
            u = function (t) {
              if (void 0 === e.joinCondition || null === e.joinCondition) return !0;
              var i = vD.cloneOptions(t);
              return e.joinCondition(i);
            };

            for (var y = !0, g = 0; g < r.length; g++) {
              o = r[g];

              var m = i._getConnectedId(o, f);

              if (!u(p)) {
                y = !1;
                break;
              }

              d[o.id] = o, l[f] = p, l[m] = i.body.nodes[m], h[f] = !0;
            }

            if (CS(l).length > 0 && CS(d).length > 0 && !0 === y) if (void 0 !== (c = function () {
              for (var t = 0; t < a.length; ++t) for (var e in l) if (void 0 !== a[t].nodes[e]) return a[t];
            }())) {
              for (var b in l) void 0 === c.nodes[b] && (c.nodes[b] = l[b]);

              for (var w in d) void 0 === c.edges[w] && (c.edges[w] = d[w]);
            } else a.push({
              nodes: l,
              edges: d
            });
          }
        }
      }, d = 0; d < this.body.nodeIndices.length; d++) {
        var u, c;
        l(d);
      }

      for (var f = 0; f < a.length; f++) this._cluster(a[f].nodes, a[f].edges, e, !1);

      !0 === n && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "clusterOutliers",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.clusterByEdgeCount(1, t, e);
    }
  }, {
    key: "clusterBridges",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.clusterByEdgeCount(2, t, e);
    }
  }, {
    key: "clusterByConnection",
    value: function (t, e) {
      var i,
          n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      if (void 0 === t) throw new Error("No nodeId supplied to clusterByConnection!");
      if (void 0 === this.body.nodes[t]) throw new Error("The nodeId given to clusterByConnection does not exist!");
      var o = this.body.nodes[t];
      void 0 === (e = this._checkOptions(e, o)).clusterNodeProperties.x && (e.clusterNodeProperties.x = o.x), void 0 === e.clusterNodeProperties.y && (e.clusterNodeProperties.y = o.y), void 0 === e.clusterNodeProperties.fixed && (e.clusterNodeProperties.fixed = {}, e.clusterNodeProperties.fixed.x = o.options.fixed.x, e.clusterNodeProperties.fixed.y = o.options.fixed.y);
      var r = {},
          s = {},
          a = o.id,
          h = vD.cloneOptions(o);
      r[a] = o;

      for (var l = 0; l < o.edges.length; l++) {
        var d = o.edges[l];

        if (void 0 === this.clusteredEdges[d.id]) {
          var u = this._getConnectedId(d, a);

          if (void 0 === this.clusteredNodes[u]) if (u !== a) {
            if (void 0 === e.joinCondition) s[d.id] = d, r[u] = this.body.nodes[u];else {
              var c = vD.cloneOptions(this.body.nodes[u]);
              !0 === e.joinCondition(h, c) && (s[d.id] = d, r[u] = this.body.nodes[u]);
            }
          } else s[d.id] = d;
        }
      }

      var f = Yl(i = CS(r)).call(i, function (t) {
        return r[t].id;
      });

      for (p in r) if (r.hasOwnProperty(p)) for (var p = r[p], v = 0; v < p.edges.length; v++) {
        var y = p.edges[v];
        el(f).call(f, this._getConnectedId(y, p.id)) > -1 && (s[y.id] = y);
      }

      this._cluster(r, s, e, n);
    }
  }, {
    key: "_createClusterEdges",
    value: function (t, e, i, n) {
      for (var o, r, s, a, h, l, d = CS(t), u = [], c = 0; c < d.length; c++) {
        s = t[r = d[c]];

        for (var f = 0; f < s.edges.length; f++) o = s.edges[f], void 0 === this.clusteredEdges[o.id] && (o.toId == o.fromId ? e[o.id] = o : o.toId == r ? (a = i.id, l = h = o.fromId) : (a = o.toId, h = i.id, l = a), void 0 === t[l] && u.push({
          edge: o,
          fromId: h,
          toId: a
        }));
      }

      for (var p = [], v = function (t) {
        for (var e = 0; e < p.length; e++) {
          var i = p[e],
              n = t.fromId === i.fromId && t.toId === i.toId,
              o = t.fromId === i.toId && t.toId === i.fromId;
          if (n || o) return i;
        }

        return null;
      }, y = 0; y < u.length; y++) {
        var g = u[y],
            m = g.edge,
            b = v(g);
        null === b ? (b = this._createClusteredEdge(g.fromId, g.toId, m, n), p.push(b)) : b.clusteringEdgeReplacingIds.push(m.id), this.body.edges[m.id].edgeReplacedById = b.id, this._backupEdgeOptions(m), m.setOptions({
          physics: !1
        });
      }
    }
  }, {
    key: "_checkOptions",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return void 0 === t.clusterEdgeProperties && (t.clusterEdgeProperties = {}), void 0 === t.clusterNodeProperties && (t.clusterNodeProperties = {}), t;
    }
  }, {
    key: "_cluster",
    value: function (t, e, i) {
      var n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
          o = [];

      for (var r in t) t.hasOwnProperty(r) && void 0 !== this.clusteredNodes[r] && o.push(r);

      for (var s = 0; s < o.length; ++s) delete t[o[s]];

      if (0 != CS(t).length && (1 != CS(t).length || 1 == i.clusterNodeProperties.allowSingleNodeCluster)) {
        var a = Ur({}, i.clusterNodeProperties);

        if (void 0 !== i.processProperties) {
          var h = [];

          for (var l in t) if (t.hasOwnProperty(l)) {
            var d = vD.cloneOptions(t[l]);
            h.push(d);
          }

          var u = [];

          for (var c in e) if (e.hasOwnProperty(c) && "clusterEdge:" !== c.substr(0, 12)) {
            var f = vD.cloneOptions(e[c], "edge");
            u.push(f);
          }

          if (!(a = i.processProperties(a, h, u))) throw new Error("The processProperties function does not return properties!");
        }

        void 0 === a.id && (a.id = "cluster:" + Er());
        var p = a.id;
        void 0 === a.label && (a.label = "cluster");
        var v = void 0;
        void 0 === a.x && (v = this._getClusterPosition(t), a.x = v.x), void 0 === a.y && (void 0 === v && (v = this._getClusterPosition(t)), a.y = v.y), a.id = p;
        var y = this.body.functions.createNode(a, yD);
        y.containedNodes = t, y.containedEdges = e, y.clusterEdgeProperties = i.clusterEdgeProperties, this.body.nodes[a.id] = y, this._clusterEdges(t, e, a, i.clusterEdgeProperties), a.id = void 0, !0 === n && this.body.emitter.emit("_dataChanged");
      }
    }
  }, {
    key: "_backupEdgeOptions",
    value: function (t) {
      void 0 === this.clusteredEdges[t.id] && (this.clusteredEdges[t.id] = {
        physics: t.options.physics
      });
    }
  }, {
    key: "_restoreEdge",
    value: function (t) {
      var e = this.clusteredEdges[t.id];
      void 0 !== e && (t.setOptions({
        physics: e.physics
      }), delete this.clusteredEdges[t.id]);
    }
  }, {
    key: "isCluster",
    value: function (t) {
      return void 0 !== this.body.nodes[t] ? !0 === this.body.nodes[t].isCluster : (console.log("Node does not exist."), !1);
    }
  }, {
    key: "_getClusterPosition",
    value: function (t) {
      for (var e, i = CS(t), n = t[i[0]].x, o = t[i[0]].x, r = t[i[0]].y, s = t[i[0]].y, a = 1; a < i.length; a++) n = (e = t[i[a]]).x < n ? e.x : n, o = e.x > o ? e.x : o, r = e.y < r ? e.y : r, s = e.y > s ? e.y : s;

      return {
        x: .5 * (n + o),
        y: .5 * (r + s)
      };
    }
  }, {
    key: "openCluster",
    value: function (t, e) {
      var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      if (void 0 === t) throw new Error("No clusterNodeId supplied to openCluster.");
      var n = this.body.nodes[t];
      if (void 0 === n) throw new Error("The clusterNodeId supplied to openCluster does not exist.");
      if (!0 !== n.isCluster || void 0 === n.containedNodes || void 0 === n.containedEdges) throw new Error("The node:" + t + " is not a valid cluster.");
      var o = this.findNode(t),
          r = el(o).call(o, t) - 1;

      if (r >= 0) {
        var s = o[r],
            a = this.body.nodes[s];
        return a._openChildCluster(t), delete this.body.nodes[t], void (!0 === i && this.body.emitter.emit("_dataChanged"));
      }

      var h = n.containedNodes,
          l = n.containedEdges;

      if (void 0 !== e && void 0 !== e.releaseFunction && "function" == typeof e.releaseFunction) {
        var d = {},
            u = {
          x: n.x,
          y: n.y
        };

        for (var c in h) if (h.hasOwnProperty(c)) {
          var f = this.body.nodes[c];
          d[c] = {
            x: f.x,
            y: f.y
          };
        }

        var p = e.releaseFunction(u, d);

        for (var v in h) if (h.hasOwnProperty(v)) {
          var y = this.body.nodes[v];
          void 0 !== p[v] && (y.x = void 0 === p[v].x ? n.x : p[v].x, y.y = void 0 === p[v].y ? n.y : p[v].y);
        }
      } else es(h, function (t) {
        !1 === t.options.fixed.x && (t.x = n.x), !1 === t.options.fixed.y && (t.y = n.y);
      });

      for (var g in h) if (h.hasOwnProperty(g)) {
        var m = this.body.nodes[g];
        m.vx = n.vx, m.vy = n.vy, m.setOptions({
          physics: !0
        }), delete this.clusteredNodes[g];
      }

      for (var b = [], w = 0; w < n.edges.length; w++) b.push(n.edges[w]);

      for (var _ = 0; _ < b.length; _++) {
        for (var k = b[_], x = this._getConnectedId(k, t), O = this.clusteredNodes[x], S = 0; S < k.clusteringEdgeReplacingIds.length; S++) {
          var M = k.clusteringEdgeReplacingIds[S],
              E = this.body.edges[M];
          if (void 0 !== E) if (void 0 !== O) {
            var D = this.body.nodes[O.clusterId];
            D.containedEdges[E.id] = E, delete l[E.id];
            var T = E.fromId,
                C = E.toId;
            E.toId == x ? C = O.clusterId : T = O.clusterId, this._createClusteredEdge(T, C, E, D.clusterEdgeProperties, {
              hidden: !1,
              physics: !0
            });
          } else this._restoreEdge(E);
        }

        k.remove();
      }

      for (var P in l) l.hasOwnProperty(P) && this._restoreEdge(l[P]);

      delete this.body.nodes[t], !0 === i && this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "getNodesInCluster",
    value: function (t) {
      var e = [];

      if (!0 === this.isCluster(t)) {
        var i = this.body.nodes[t].containedNodes;

        for (var n in i) i.hasOwnProperty(n) && e.push(this.body.nodes[n].id);
      }

      return e;
    }
  }, {
    key: "findNode",
    value: function (t) {
      for (var e, i = [], n = 0; void 0 !== this.clusteredNodes[t] && n < 100;) {
        if (void 0 === (e = this.body.nodes[t])) return [];
        i.push(e.id), t = this.clusteredNodes[t].clusterId, n++;
      }

      return void 0 === (e = this.body.nodes[t]) ? [] : (i.push(e.id), pD(i).call(i), i);
    }
  }, {
    key: "updateClusteredNode",
    value: function (t, e) {
      if (void 0 === t) throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
      if (void 0 === e) throw new Error("No newOptions supplied to updateClusteredNode.");
      if (void 0 === this.body.nodes[t]) throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
      this.body.nodes[t].setOptions(e), this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "updateEdge",
    value: function (t, e) {
      if (void 0 === t) throw new Error("No startEdgeId supplied to updateEdge.");
      if (void 0 === e) throw new Error("No newOptions supplied to updateEdge.");
      if (void 0 === this.body.edges[t]) throw new Error("The startEdgeId supplied to updateEdge does not exist.");

      for (var i = this.getClusteredEdges(t), n = 0; n < i.length; n++) {
        this.body.edges[i[n]].setOptions(e);
      }

      this.body.emitter.emit("_dataChanged");
    }
  }, {
    key: "getClusteredEdges",
    value: function (t) {
      for (var e = [], i = 0; void 0 !== t && void 0 !== this.body.edges[t] && i < 100;) e.push(this.body.edges[t].id), t = this.body.edges[t].edgeReplacedById, i++;

      return pD(e).call(e), e;
    }
  }, {
    key: "getBaseEdge",
    value: function (t) {
      return this.getBaseEdges(t)[0];
    }
  }, {
    key: "getBaseEdges",
    value: function (t) {
      for (var e = [t], i = [], n = [], o = 0; e.length > 0 && o < 100;) {
        var r = e.pop();

        if (void 0 !== r) {
          var s = this.body.edges[r];

          if (void 0 !== s) {
            o++;
            var a = s.clusteringEdgeReplacingIds;
            if (void 0 === a) n.push(r);else for (var h = 0; h < a.length; ++h) {
              var l = a[h];
              -1 === el(e).call(e, a) && -1 === el(i).call(i, a) && e.push(l);
            }
            i.push(r);
          }
        }
      }

      return n;
    }
  }, {
    key: "_getConnectedId",
    value: function (t, e) {
      return t.toId != e ? t.toId : (t.fromId, t.fromId);
    }
  }, {
    key: "_getHubSize",
    value: function () {
      for (var t = 0, e = 0, i = 0, n = 0, o = 0; o < this.body.nodeIndices.length; o++) {
        var r = this.body.nodes[this.body.nodeIndices[o]];
        r.edges.length > n && (n = r.edges.length), t += r.edges.length, e += Math.pow(r.edges.length, 2), i += 1;
      }

      t /= i;
      var s = (e /= i) - Math.pow(t, 2),
          a = Math.sqrt(s),
          h = Math.floor(t + 2 * a);
      return h > n && (h = n), h;
    }
  }, {
    key: "_createClusteredEdge",
    value: function (t, e, i, n, o) {
      var r = vD.cloneOptions(i, "edge");
      Ur(r, n), r.from = t, r.to = e, r.id = "clusterEdge:" + Er(), void 0 !== o && Ur(r, o);
      var s = this.body.functions.createEdge(r);
      return s.clusteringEdgeReplacingIds = [i.id], s.connect(), this.body.edges[s.id] = s, s;
    }
  }, {
    key: "_clusterEdges",
    value: function (t, e, i, n) {
      if (e instanceof $E) {
        var o = e,
            r = {};
        r[o.id] = o, e = r;
      }

      if (t instanceof yE) {
        var s = t,
            a = {};
        a[s.id] = s, t = a;
      }

      if (null == i) throw new Error("_clusterEdges: parameter clusterNode required");

      for (var h in void 0 === n && (n = i.clusterEdgeProperties), this._createClusterEdges(t, e, i, n), e) if (e.hasOwnProperty(h) && void 0 !== this.body.edges[h]) {
        var l = this.body.edges[h];
        this._backupEdgeOptions(l), l.setOptions({
          physics: !1
        });
      }

      for (var d in t) t.hasOwnProperty(d) && (this.clusteredNodes[d] = {
        clusterId: i.id,
        node: this.body.nodes[d]
      }, this.body.nodes[d].setOptions({
        physics: !1
      }));
    }
  }, {
    key: "_getClusterNodeForNode",
    value: function (t) {
      if (void 0 !== t) {
        var e = this.clusteredNodes[t];

        if (void 0 !== e) {
          var i = e.clusterId;
          if (void 0 !== i) return this.body.nodes[i];
        }
      }
    }
  }, {
    key: "_filter",
    value: function (t, e) {
      var i = [];
      return es(t, function (t) {
        e(t) && i.push(t);
      }), i;
    }
  }, {
    key: "_updateState",
    value: function () {
      var t,
          e = this,
          i = [],
          n = {},
          o = function (t) {
        es(e.body.nodes, function (e) {
          !0 === e.isCluster && t(e);
        });
      };

      for (t in this.clusteredNodes) {
        if (this.clusteredNodes.hasOwnProperty(t)) void 0 === this.body.nodes[t] && i.push(t);
      }

      o(function (t) {
        for (var e = 0; e < i.length; e++) delete t.containedNodes[i[e]];
      });

      for (var r = 0; r < i.length; r++) delete this.clusteredNodes[i[r]];

      es(this.clusteredEdges, function (t) {
        var i = e.body.edges[t];
        void 0 !== i && i.endPointsValid() || (n[t] = t);
      }), o(function (t) {
        es(t.containedEdges, function (t, e) {
          t.endPointsValid() || n[e] || (n[e] = e);
        });
      }), es(this.body.edges, function (t, i) {
        var o = !0,
            r = t.clusteringEdgeReplacingIds;

        if (void 0 !== r) {
          var s = 0;
          es(r, function (t) {
            var i = e.body.edges[t];
            void 0 !== i && i.endPointsValid() && (s += 1);
          }), o = s > 0;
        }

        t.endPointsValid() && o || (n[i] = i);
      }), o(function (t) {
        es(n, function (i) {
          delete t.containedEdges[i], es(t.edges, function (o, r) {
            o.id !== i ? o.clusteringEdgeReplacingIds = e._filter(o.clusteringEdgeReplacingIds, function (t) {
              return !n[t];
            }) : t.edges[r] = null;
          }), t.edges = e._filter(t.edges, function (t) {
            return null !== t;
          });
        });
      }), es(n, function (t) {
        delete e.clusteredEdges[t];
      }), es(n, function (t) {
        delete e.body.edges[t];
      }), es(CS(this.body.edges), function (t) {
        var i = e.body.edges[t],
            n = e._isClusteredNode(i.fromId) || e._isClusteredNode(i.toId);

        if (n !== e._isClusteredEdge(i.id)) if (n) {
          var o = e._getClusterNodeForNode(i.fromId);

          void 0 !== o && e._clusterEdges(e.body.nodes[i.fromId], i, o);

          var r = e._getClusterNodeForNode(i.toId);

          void 0 !== r && e._clusterEdges(e.body.nodes[i.toId], i, r);
        } else delete e._clusterEdges[t], e._restoreEdge(i);
      });

      for (var s = !1, a = !0, h = function () {
        var t = [];
        o(function (e) {
          var i = CS(e.containedNodes).length,
              n = !0 === e.options.allowSingleNodeCluster;
          (n && i < 1 || !n && i < 2) && t.push(e.id);
        });

        for (var i = 0; i < t.length; ++i) e.openCluster(t[i], {}, !1);

        a = t.length > 0, s = s || a;
      }; a;) h();

      s && this._updateState();
    }
  }, {
    key: "_isClusteredNode",
    value: function (t) {
      return void 0 !== this.clusteredNodes[t];
    }
  }, {
    key: "_isClusteredEdge",
    value: function (t) {
      return void 0 !== this.clusteredEdges[t];
    }
  }]), t;
}();

var mD = function () {
  function t(e, i) {
    var n;
    oc(this, t), void 0 !== window && (n = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame), window.requestAnimationFrame = void 0 === n ? function (t) {
      t();
    } : n, this.body = e, this.canvas = i, this.redrawRequested = !1, this.renderTimer = void 0, this.requiresTimeout = !0, this.renderingActive = !1, this.renderRequests = 0, this.allowRedraw = !0, this.dragging = !1, this.zooming = !1, this.options = {}, this.defaultOptions = {
      hideEdgesOnDrag: !1,
      hideEdgesOnZoom: !1,
      hideNodesOnDrag: !1
    }, Yr(this.options, this.defaultOptions), this._determineBrowserMethod(), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t,
          e = this;
      this.body.emitter.on("dragStart", function () {
        e.dragging = !0;
      }), this.body.emitter.on("dragEnd", function () {
        e.dragging = !1;
      }), this.body.emitter.on("zoom", function () {
        e.zooming = !0, window.clearTimeout(e.zoomTimeoutId), e.zoomTimeoutId = window.setTimeout(function () {
          var t;
          e.zooming = !1, $(t = e._requestRedraw).call(t, e)();
        }, 250);
      }), this.body.emitter.on("_resizeNodes", function () {
        e._resizeNodes();
      }), this.body.emitter.on("_redraw", function () {
        !1 === e.renderingActive && e._redraw();
      }), this.body.emitter.on("_blockRedraw", function () {
        e.allowRedraw = !1;
      }), this.body.emitter.on("_allowRedraw", function () {
        e.allowRedraw = !0, e.redrawRequested = !1;
      }), this.body.emitter.on("_requestRedraw", $(t = this._requestRedraw).call(t, this)), this.body.emitter.on("_startRendering", function () {
        e.renderRequests += 1, e.renderingActive = !0, e._startRendering();
      }), this.body.emitter.on("_stopRendering", function () {
        e.renderRequests -= 1, e.renderingActive = e.renderRequests > 0, e.renderTimer = void 0;
      }), this.body.emitter.on("destroy", function () {
        e.renderRequests = 0, e.allowRedraw = !1, e.renderingActive = !1, !0 === e.requiresTimeout ? clearTimeout(e.renderTimer) : window.cancelAnimationFrame(e.renderTimer), e.body.emitter.off();
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        Wr(["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"], this.options, t);
      }
    }
  }, {
    key: "_requestNextFrame",
    value: function (t, e) {
      if ("undefined" != typeof window) {
        var i,
            n = window;
        return !0 === this.requiresTimeout ? i = n.setTimeout(t, e) : n.requestAnimationFrame && (i = n.requestAnimationFrame(t)), i;
      }
    }
  }, {
    key: "_startRendering",
    value: function () {
      var t;
      !0 === this.renderingActive && void 0 === this.renderTimer && (this.renderTimer = this._requestNextFrame($(t = this._renderStep).call(t, this), this.simulationInterval));
    }
  }, {
    key: "_renderStep",
    value: function () {
      !0 === this.renderingActive && (this.renderTimer = void 0, !0 === this.requiresTimeout && this._startRendering(), this._redraw(), !1 === this.requiresTimeout && this._startRendering());
    }
  }, {
    key: "redraw",
    value: function () {
      this.body.emitter.emit("setSize"), this._redraw();
    }
  }, {
    key: "_requestRedraw",
    value: function () {
      var t = this;
      !0 !== this.redrawRequested && !1 === this.renderingActive && !0 === this.allowRedraw && (this.redrawRequested = !0, this._requestNextFrame(function () {
        t._redraw(!1);
      }, 0));
    }
  }, {
    key: "_redraw",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];

      if (!0 === this.allowRedraw) {
        this.body.emitter.emit("initRedraw"), this.redrawRequested = !1, 0 !== this.canvas.frame.canvas.width && 0 !== this.canvas.frame.canvas.height || this.canvas.setSize(), this.canvas.setTransform();
        var e = this.canvas.getContext(),
            i = this.canvas.frame.canvas.clientWidth,
            n = this.canvas.frame.canvas.clientHeight;
        if (e.clearRect(0, 0, i, n), 0 === this.canvas.frame.clientWidth) return;
        e.save(), e.translate(this.body.view.translation.x, this.body.view.translation.y), e.scale(this.body.view.scale, this.body.view.scale), e.beginPath(), this.body.emitter.emit("beforeDrawing", e), e.closePath(), !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && (!1 === this.zooming || !0 === this.zooming && !1 === this.options.hideEdgesOnZoom) && this._drawEdges(e), (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideNodesOnDrag) && this._drawNodes(e, t), e.beginPath(), this.body.emitter.emit("afterDrawing", e), e.closePath(), e.restore(), !0 === t && e.clearRect(0, 0, i, n);
      }
    }
  }, {
    key: "_resizeNodes",
    value: function () {
      this.canvas.setTransform();
      var t = this.canvas.getContext();
      t.save(), t.translate(this.body.view.translation.x, this.body.view.translation.y), t.scale(this.body.view.scale, this.body.view.scale);
      var e,
          i = this.body.nodes;

      for (var n in i) i.hasOwnProperty(n) && ((e = i[n]).resize(t), e.updateBoundingBox(t, e.selected));

      t.restore();
    }
  }, {
    key: "_drawNodes",
    value: function (t) {
      for (var e, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = this.body.nodes, o = this.body.nodeIndices, r = [], s = 20, a = this.canvas.DOMtoCanvas({
        x: -s,
        y: -s
      }), h = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + s,
        y: this.canvas.frame.canvas.clientHeight + s
      }), l = {
        top: a.y,
        left: a.x,
        bottom: h.y,
        right: h.x
      }, d = 0; d < o.length; d++) (e = n[o[d]]).isSelected() ? r.push(o[d]) : !0 === i ? e.draw(t) : !0 === e.isBoundingBoxOverlappingWith(l) ? e.draw(t) : e.updateBoundingBox(t, e.selected);

      for (var u = 0; u < r.length; u++) (e = n[r[u]]).draw(t);
    }
  }, {
    key: "_drawEdges",
    value: function (t) {
      for (var e, i = this.body.edges, n = this.body.edgeIndices, o = 0; o < n.length; o++) !0 === (e = i[n[o]]).connected && e.draw(t);
    }
  }, {
    key: "_determineBrowserMethod",
    value: function () {
      if ("undefined" != typeof window) {
        var t = navigator.userAgent.toLowerCase();
        this.requiresTimeout = !1, -1 != el(t).call(t, "msie 9.0") ? this.requiresTimeout = !0 : -1 != el(t).call(t, "safari") && el(t).call(t, "chrome") <= -1 && (this.requiresTimeout = !0);
      } else this.requiresTimeout = !0;
    }
  }]), t;
}(),
    bD = F.setInterval,
    wD = i(function (t, e) {
  e.onTouch = function (t, e) {
    e.inputHandler = function (t) {
      t.isFirst && e(t);
    }, t.on("hammer.input", e.inputHandler);
  }, e.onRelease = function (t, e) {
    return e.inputHandler = function (t) {
      t.isFinal && e(t);
    }, t.on("hammer.input", e.inputHandler);
  }, e.offTouch = function (t, e) {
    t.off("hammer.input", e.inputHandler);
  }, e.offRelease = e.offTouch, e.disablePreventDefaultVertically = function (t) {
    return t.getTouchAction = function () {
      return ["pan-y"];
    }, t;
  };
}),
    _D = (wD.onTouch, wD.onRelease, wD.offTouch, wD.offRelease, wD.disablePreventDefaultVertically, function () {
  function t(e) {
    var i;
    oc(this, t), this.body = e, this.pixelRatio = 1, this.resizeTimer = void 0, this.resizeFunction = $(i = this._onResize).call(i, this), this.cameraState = {}, this.initialized = !1, this.canvasViewCenter = {}, this.options = {}, this.defaultOptions = {
      autoResize: !0,
      height: "100%",
      width: "100%"
    }, Yr(this.options, this.defaultOptions), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t,
          e = this;
      this.body.emitter.once("resize", function (t) {
        0 !== t.width && (e.body.view.translation.x = .5 * t.width), 0 !== t.height && (e.body.view.translation.y = .5 * t.height);
      }), this.body.emitter.on("setSize", $(t = this.setSize).call(t, this)), this.body.emitter.on("destroy", function () {
        e.hammerFrame.destroy(), e.hammer.destroy(), e._cleanUp();
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      var e,
          i = this;

      if (void 0 !== t) {
        Wr(["width", "height", "autoResize"], this.options, t);
      }

      !0 === this.options.autoResize && (this._cleanUp(), this.resizeTimer = bD(function () {
        !0 === i.setSize() && i.body.emitter.emit("_requestRedraw");
      }, 1e3), this.resizeFunction = $(e = this._onResize).call(e, this), rs(window, "resize", this.resizeFunction));
    }
  }, {
    key: "_cleanUp",
    value: function () {
      void 0 !== this.resizeTimer && clearInterval(this.resizeTimer), ss(window, "resize", this.resizeFunction), this.resizeFunction = void 0;
    }
  }, {
    key: "_onResize",
    value: function () {
      this.setSize(), this.body.emitter.emit("_redraw");
    }
  }, {
    key: "_getCameraState",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pixelRatio;
      !0 === this.initialized && (this.cameraState.previousWidth = this.frame.canvas.width / t, this.cameraState.previousHeight = this.frame.canvas.height / t, this.cameraState.scale = this.body.view.scale, this.cameraState.position = this.DOMtoCanvas({
        x: .5 * this.frame.canvas.width / t,
        y: .5 * this.frame.canvas.height / t
      }));
    }
  }, {
    key: "_setCameraState",
    value: function () {
      if (void 0 !== this.cameraState.scale && 0 !== this.frame.canvas.clientWidth && 0 !== this.frame.canvas.clientHeight && 0 !== this.pixelRatio && this.cameraState.previousWidth > 0) {
        var t = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth,
            e = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight,
            i = this.cameraState.scale;
        1 != t && 1 != e ? i = .5 * this.cameraState.scale * (t + e) : 1 != t ? i = this.cameraState.scale * t : 1 != e && (i = this.cameraState.scale * e), this.body.view.scale = i;
        var n = this.DOMtoCanvas({
          x: .5 * this.frame.canvas.clientWidth,
          y: .5 * this.frame.canvas.clientHeight
        }),
            o = {
          x: n.x - this.cameraState.position.x,
          y: n.y - this.cameraState.position.y
        };
        this.body.view.translation.x += o.x * this.body.view.scale, this.body.view.translation.y += o.y * this.body.view.scale;
      }
    }
  }, {
    key: "_prepareValue",
    value: function (t) {
      if ("number" == typeof t) return t + "px";

      if ("string" == typeof t) {
        if (-1 !== el(t).call(t, "%") || -1 !== el(t).call(t, "px")) return t;
        if (-1 === el(t).call(t, "%")) return t + "px";
      }

      throw new Error("Could not use the value supplied for width or height:" + t);
    }
  }, {
    key: "_create",
    value: function () {
      for (; this.body.container.hasChildNodes();) this.body.container.removeChild(this.body.container.firstChild);

      if (this.frame = document.createElement("div"), this.frame.className = "vis-network", this.frame.style.position = "relative", this.frame.style.overflow = "hidden", this.frame.tabIndex = 900, this.frame.canvas = document.createElement("canvas"), this.frame.canvas.style.position = "relative", this.frame.appendChild(this.frame.canvas), this.frame.canvas.getContext) this._setPixelRatio(), this.setTransform();else {
        var t = document.createElement("DIV");
        t.style.color = "red", t.style.fontWeight = "bold", t.style.padding = "10px", t.innerHTML = "Error: your browser does not support HTML canvas", this.frame.canvas.appendChild(t);
      }
      this.body.container.appendChild(this.frame), this.body.view.scale = 1, this.body.view.translation = {
        x: .5 * this.frame.canvas.clientWidth,
        y: .5 * this.frame.canvas.clientHeight
      }, this._bindHammer();
    }
  }, {
    key: "_bindHammer",
    value: function () {
      var t = this;
      void 0 !== this.hammer && this.hammer.destroy(), this.drag = {}, this.pinch = {}, this.hammer = new Qu(this.frame.canvas), this.hammer.get("pinch").set({
        enable: !0
      }), this.hammer.get("pan").set({
        threshold: 5,
        direction: Qu.DIRECTION_ALL
      }), wD.onTouch(this.hammer, function (e) {
        t.body.eventListeners.onTouch(e);
      }), this.hammer.on("tap", function (e) {
        t.body.eventListeners.onTap(e);
      }), this.hammer.on("doubletap", function (e) {
        t.body.eventListeners.onDoubleTap(e);
      }), this.hammer.on("press", function (e) {
        t.body.eventListeners.onHold(e);
      }), this.hammer.on("panstart", function (e) {
        t.body.eventListeners.onDragStart(e);
      }), this.hammer.on("panmove", function (e) {
        t.body.eventListeners.onDrag(e);
      }), this.hammer.on("panend", function (e) {
        t.body.eventListeners.onDragEnd(e);
      }), this.hammer.on("pinch", function (e) {
        t.body.eventListeners.onPinch(e);
      }), this.frame.canvas.addEventListener("wheel", function (e) {
        t.body.eventListeners.onMouseWheel(e);
      }), this.frame.canvas.addEventListener("mousemove", function (e) {
        t.body.eventListeners.onMouseMove(e);
      }), this.frame.canvas.addEventListener("contextmenu", function (e) {
        t.body.eventListeners.onContext(e);
      }), this.hammerFrame = new Qu(this.frame), wD.onRelease(this.hammerFrame, function (e) {
        t.body.eventListeners.onRelease(e);
      });
    }
  }, {
    key: "setSize",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.width,
          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.height;
      t = this._prepareValue(t), e = this._prepareValue(e);
      var i = !1,
          n = this.frame.canvas.width,
          o = this.frame.canvas.height,
          r = this.pixelRatio;
      if (this._setPixelRatio(), t != this.options.width || e != this.options.height || this.frame.style.width != t || this.frame.style.height != e) this._getCameraState(r), this.frame.style.width = t, this.frame.style.height = e, this.frame.canvas.style.width = "100%", this.frame.canvas.style.height = "100%", this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio), this.options.width = t, this.options.height = e, this.canvasViewCenter = {
        x: .5 * this.frame.clientWidth,
        y: .5 * this.frame.clientHeight
      }, i = !0;else {
        var s = Math.round(this.frame.canvas.clientWidth * this.pixelRatio),
            a = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        this.frame.canvas.width === s && this.frame.canvas.height === a || this._getCameraState(r), this.frame.canvas.width !== s && (this.frame.canvas.width = s, i = !0), this.frame.canvas.height !== a && (this.frame.canvas.height = a, i = !0);
      }
      return !0 === i && (this.body.emitter.emit("resize", {
        width: Math.round(this.frame.canvas.width / this.pixelRatio),
        height: Math.round(this.frame.canvas.height / this.pixelRatio),
        oldWidth: Math.round(n / this.pixelRatio),
        oldHeight: Math.round(o / this.pixelRatio)
      }), this._setCameraState()), this.initialized = !0, i;
    }
  }, {
    key: "getContext",
    value: function () {
      return this.frame.canvas.getContext("2d");
    }
  }, {
    key: "_determinePixelRatio",
    value: function () {
      var t = this.getContext();
      if (void 0 === t) throw new Error("Could not get canvax context");
      var e = 1;
      return "undefined" != typeof window && (e = window.devicePixelRatio || 1), e / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1);
    }
  }, {
    key: "_setPixelRatio",
    value: function () {
      this.pixelRatio = this._determinePixelRatio();
    }
  }, {
    key: "setTransform",
    value: function () {
      var t = this.getContext();
      if (void 0 === t) throw new Error("Could not get canvax context");
      t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
  }, {
    key: "_XconvertDOMtoCanvas",
    value: function (t) {
      return (t - this.body.view.translation.x) / this.body.view.scale;
    }
  }, {
    key: "_XconvertCanvasToDOM",
    value: function (t) {
      return t * this.body.view.scale + this.body.view.translation.x;
    }
  }, {
    key: "_YconvertDOMtoCanvas",
    value: function (t) {
      return (t - this.body.view.translation.y) / this.body.view.scale;
    }
  }, {
    key: "_YconvertCanvasToDOM",
    value: function (t) {
      return t * this.body.view.scale + this.body.view.translation.y;
    }
  }, {
    key: "canvasToDOM",
    value: function (t) {
      return {
        x: this._XconvertCanvasToDOM(t.x),
        y: this._YconvertCanvasToDOM(t.y)
      };
    }
  }, {
    key: "DOMtoCanvas",
    value: function (t) {
      return {
        x: this._XconvertDOMtoCanvas(t.x),
        y: this._YconvertDOMtoCanvas(t.y)
      };
    }
  }]), t;
}()),
    kD = o.isFinite,
    xD = Number.isFinite || function (t) {
  return "number" == typeof t && kD(t);
};

W({
  target: "Number",
  stat: !0
}, {
  isFinite: xD
});

var OD = F.Number.isFinite,
    SD = function () {
  function t(e, i) {
    var n,
        o,
        r = this;
    oc(this, t), this.body = e, this.canvas = i, this.animationSpeed = 1 / this.renderRefreshRate, this.animationEasingFunction = "easeInOutQuint", this.easingTime = 0, this.sourceScale = 0, this.targetScale = 0, this.sourceTranslation = 0, this.targetTranslation = 0, this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0, this.touchTime = 0, this.viewFunction = void 0, this.body.emitter.on("fit", $(n = this.fit).call(n, this)), this.body.emitter.on("animationFinished", function () {
      r.body.emitter.emit("_stopRendering");
    }), this.body.emitter.on("unlockNode", $(o = this.releaseNode).call(o, this));
  }

  return hc(t, [{
    key: "setOptions",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.options = t;
    }
  }, {
    key: "fit",
    value: function () {
      var t,
          e,
          i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        nodes: []
      },
          n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];

      if (void 0 !== (i = _M({}, i)).nodes && 0 !== i.nodes.length || (i.nodes = this.body.nodeIndices), !0 === n) {
        var o = 0;

        for (var r in this.body.nodes) if (this.body.nodes.hasOwnProperty(r)) {
          var s = this.body.nodes[r];
          !0 === s.predefinedPosition && (o += 1);
        }

        if (o > .5 * this.body.nodeIndices.length) return void this.fit(i, !1);
        t = vD.getRange(this.body.nodes, i.nodes);
        var a = this.body.nodeIndices.length;
        e = 12.662 / (a + 7.4147) + .0964822;
        var h = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
        e *= h;
      } else {
        this.body.emitter.emit("_resizeNodes"), t = vD.getRange(this.body.nodes, i.nodes);
        var l = 1.1 * Math.abs(t.maxX - t.minX),
            d = 1.1 * Math.abs(t.maxY - t.minY),
            u = this.canvas.frame.canvas.clientWidth / l,
            c = this.canvas.frame.canvas.clientHeight / d;
        e = u <= c ? u : c;
      }

      e > 1 ? e = 1 : 0 === e && (e = 1);
      var f = vD.findCenter(t),
          p = {
        position: f,
        scale: e,
        animation: i.animation
      };
      this.moveTo(p);
    }
  }, {
    key: "focus",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};

      if (void 0 !== this.body.nodes[t]) {
        var i = {
          x: this.body.nodes[t].x,
          y: this.body.nodes[t].y
        };
        e.position = i, e.lockedOnNode = t, this.moveTo(e);
      } else console.log("Node: " + t + " cannot be found.");
    }
  }, {
    key: "moveTo",
    value: function (t) {
      if (void 0 !== t) {
        if (null != t.offset) {
          if (null != t.offset.x) {
            if (t.offset.x = +t.offset.x, !OD(t.offset.x)) throw new TypeError('The option "offset.x" has to be a finite number.');
          } else t.offset.x = 0;

          if (null != t.offset.y) {
            if (t.offset.y = +t.offset.y, !OD(t.offset.y)) throw new TypeError('The option "offset.y" has to be a finite number.');
          } else t.offset.x = 0;
        } else t.offset = {
          x: 0,
          y: 0
        };

        if (null != t.position) {
          if (null != t.position.x) {
            if (t.position.x = +t.position.x, !OD(t.position.x)) throw new TypeError('The option "position.x" has to be a finite number.');
          } else t.position.x = 0;

          if (null != t.position.y) {
            if (t.position.y = +t.position.y, !OD(t.position.y)) throw new TypeError('The option "position.y" has to be a finite number.');
          } else t.position.x = 0;
        } else t.position = this.getViewPosition();

        if (null != t.scale) {
          if (t.scale = +t.scale, !(t.scale > 0)) throw new TypeError('The option "scale" has to be a number greater than zero.');
        } else t.scale = this.body.view.scale;

        void 0 === t.animation && (t.animation = {
          duration: 0
        }), !1 === t.animation && (t.animation = {
          duration: 0
        }), !0 === t.animation && (t.animation = {}), void 0 === t.animation.duration && (t.animation.duration = 1e3), void 0 === t.animation.easingFunction && (t.animation.easingFunction = "easeInOutQuad"), this.animateView(t);
      } else t = {};
    }
  }, {
    key: "animateView",
    value: function (t) {
      if (void 0 !== t) {
        this.animationEasingFunction = t.animation.easingFunction, this.releaseNode(), !0 === t.locked && (this.lockedOnNodeId = t.lockedOnNode, this.lockedOnNodeOffset = t.offset), 0 != this.easingTime && this._transitionRedraw(!0), this.sourceScale = this.body.view.scale, this.sourceTranslation = this.body.view.translation, this.targetScale = t.scale, this.body.view.scale = this.targetScale;
        var e,
            i,
            n = this.canvas.DOMtoCanvas({
          x: .5 * this.canvas.frame.canvas.clientWidth,
          y: .5 * this.canvas.frame.canvas.clientHeight
        }),
            o = n.x - t.position.x,
            r = n.y - t.position.y;
        if (this.targetTranslation = {
          x: this.sourceTranslation.x + o * this.targetScale + t.offset.x,
          y: this.sourceTranslation.y + r * this.targetScale + t.offset.y
        }, 0 === t.animation.duration) {
          if (null != this.lockedOnNodeId) this.viewFunction = $(e = this._lockedRedraw).call(e, this), this.body.emitter.on("initRedraw", this.viewFunction);else this.body.view.scale = this.targetScale, this.body.view.translation = this.targetTranslation, this.body.emitter.emit("_requestRedraw");
        } else this.animationSpeed = 1 / (60 * t.animation.duration * .001) || 1 / 60, this.animationEasingFunction = t.animation.easingFunction, this.viewFunction = $(i = this._transitionRedraw).call(i, this), this.body.emitter.on("initRedraw", this.viewFunction), this.body.emitter.emit("_startRendering");
      }
    }
  }, {
    key: "_lockedRedraw",
    value: function () {
      var t = this.body.nodes[this.lockedOnNodeId].x,
          e = this.body.nodes[this.lockedOnNodeId].y,
          i = this.canvas.DOMtoCanvas({
        x: .5 * this.canvas.frame.canvas.clientWidth,
        y: .5 * this.canvas.frame.canvas.clientHeight
      }),
          n = i.x - t,
          o = i.y - e,
          r = this.body.view.translation,
          s = {
        x: r.x + n * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: r.y + o * this.body.view.scale + this.lockedOnNodeOffset.y
      };
      this.body.view.translation = s;
    }
  }, {
    key: "releaseNode",
    value: function () {
      void 0 !== this.lockedOnNodeId && void 0 !== this.viewFunction && (this.body.emitter.off("initRedraw", this.viewFunction), this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0);
    }
  }, {
    key: "_transitionRedraw",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      this.easingTime += this.animationSpeed, this.easingTime = !0 === t ? 1 : this.easingTime;
      var e = Ps[this.animationEasingFunction](this.easingTime);

      if (this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * e, this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * e,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * e
      }, this.easingTime >= 1) {
        var i;
        if (this.body.emitter.off("initRedraw", this.viewFunction), this.easingTime = 0, null != this.lockedOnNodeId) this.viewFunction = $(i = this._lockedRedraw).call(i, this), this.body.emitter.on("initRedraw", this.viewFunction);
        this.body.emitter.emit("animationFinished");
      }
    }
  }, {
    key: "getScale",
    value: function () {
      return this.body.view.scale;
    }
  }, {
    key: "getViewPosition",
    value: function () {
      return this.canvas.DOMtoCanvas({
        x: .5 * this.canvas.frame.canvas.clientWidth,
        y: .5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]), t;
}(),
    MD = function () {
  function t(e, i) {
    var n = this;
    oc(this, t), this.body = e, this.canvas = i, this.iconsCreated = !1, this.navigationHammers = [], this.boundFunctions = {}, this.touchTime = 0, this.activated = !1, this.body.emitter.on("activate", function () {
      n.activated = !0, n.configureKeyboardBindings();
    }), this.body.emitter.on("deactivate", function () {
      n.activated = !1, n.configureKeyboardBindings();
    }), this.body.emitter.on("destroy", function () {
      void 0 !== n.keycharm && n.keycharm.destroy();
    }), this.options = {};
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      void 0 !== t && (this.options = t, this.create());
    }
  }, {
    key: "create",
    value: function () {
      !0 === this.options.navigationButtons ? !1 === this.iconsCreated && this.loadNavigationElements() : !0 === this.iconsCreated && this.cleanNavigation(), this.configureKeyboardBindings();
    }
  }, {
    key: "cleanNavigation",
    value: function () {
      if (0 != this.navigationHammers.length) {
        for (var t = 0; t < this.navigationHammers.length; t++) this.navigationHammers[t].destroy();

        this.navigationHammers = [];
      }

      this.navigationDOM && this.navigationDOM.wrapper && this.navigationDOM.wrapper.parentNode && this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper), this.iconsCreated = !1;
    }
  }, {
    key: "loadNavigationElements",
    value: function () {
      var t = this;
      this.cleanNavigation(), this.navigationDOM = {};
      var e = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"],
          i = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
      this.navigationDOM.wrapper = document.createElement("div"), this.navigationDOM.wrapper.className = "vis-navigation", this.canvas.frame.appendChild(this.navigationDOM.wrapper);

      for (var n = 0; n < e.length; n++) {
        this.navigationDOM[e[n]] = document.createElement("div"), this.navigationDOM[e[n]].className = "vis-button vis-" + e[n], this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[n]]);
        var o,
            r,
            s = new Qu(this.navigationDOM[e[n]]);
        if ("_fit" === i[n]) wD.onTouch(s, $(o = this._fit).call(o, this));else wD.onTouch(s, $(r = this.bindToRedraw).call(r, this, i[n]));
        this.navigationHammers.push(s);
      }

      var a = new Qu(this.canvas.frame);
      wD.onRelease(a, function () {
        t._stopMovement();
      }), this.navigationHammers.push(a), this.iconsCreated = !0;
    }
  }, {
    key: "bindToRedraw",
    value: function (t) {
      var e;
      void 0 === this.boundFunctions[t] && (this.boundFunctions[t] = $(e = this[t]).call(e, this), this.body.emitter.on("initRedraw", this.boundFunctions[t]), this.body.emitter.emit("_startRendering"));
    }
  }, {
    key: "unbindFromRedraw",
    value: function (t) {
      void 0 !== this.boundFunctions[t] && (this.body.emitter.off("initRedraw", this.boundFunctions[t]), this.body.emitter.emit("_stopRendering"), delete this.boundFunctions[t]);
    }
  }, {
    key: "_fit",
    value: function () {
      new Date().valueOf() - this.touchTime > 700 && (this.body.emitter.emit("fit", {
        duration: 700
      }), this.touchTime = new Date().valueOf());
    }
  }, {
    key: "_stopMovement",
    value: function () {
      for (var t in this.boundFunctions) this.boundFunctions.hasOwnProperty(t) && (this.body.emitter.off("initRedraw", this.boundFunctions[t]), this.body.emitter.emit("_stopRendering"));

      this.boundFunctions = {};
    }
  }, {
    key: "_moveUp",
    value: function () {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
  }, {
    key: "_moveDown",
    value: function () {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
  }, {
    key: "_moveLeft",
    value: function () {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
  }, {
    key: "_moveRight",
    value: function () {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
  }, {
    key: "_zoomIn",
    value: function () {
      var t = this.body.view.scale,
          e = this.body.view.scale * (1 + this.options.keyboard.speed.zoom),
          i = this.body.view.translation,
          n = e / t,
          o = (1 - n) * this.canvas.canvasViewCenter.x + i.x * n,
          r = (1 - n) * this.canvas.canvasViewCenter.y + i.y * n;
      this.body.view.scale = e, this.body.view.translation = {
        x: o,
        y: r
      }, this.body.emitter.emit("zoom", {
        direction: "+",
        scale: this.body.view.scale,
        pointer: null
      });
    }
  }, {
    key: "_zoomOut",
    value: function () {
      var t = this.body.view.scale,
          e = this.body.view.scale / (1 + this.options.keyboard.speed.zoom),
          i = this.body.view.translation,
          n = e / t,
          o = (1 - n) * this.canvas.canvasViewCenter.x + i.x * n,
          r = (1 - n) * this.canvas.canvasViewCenter.y + i.y * n;
      this.body.view.scale = e, this.body.view.translation = {
        x: o,
        y: r
      }, this.body.emitter.emit("zoom", {
        direction: "-",
        scale: this.body.view.scale,
        pointer: null
      });
    }
  }, {
    key: "configureKeyboardBindings",
    value: function () {
      var t,
          e,
          i,
          n,
          o,
          r,
          s,
          a,
          h,
          l,
          d,
          u,
          c,
          f,
          p,
          v,
          y,
          g,
          m,
          b,
          w,
          _,
          k,
          x,
          O = this;

      (void 0 !== this.keycharm && this.keycharm.destroy(), !0 === this.options.keyboard.enabled) && (!0 === this.options.keyboard.bindToWindow ? this.keycharm = Ul({
        container: window,
        preventDefault: !0
      }) : this.keycharm = Ul({
        container: this.canvas.frame,
        preventDefault: !0
      }), this.keycharm.reset(), !0 === this.activated && ($(t = this.keycharm).call(t, "up", function () {
        O.bindToRedraw("_moveUp");
      }, "keydown"), $(e = this.keycharm).call(e, "down", function () {
        O.bindToRedraw("_moveDown");
      }, "keydown"), $(i = this.keycharm).call(i, "left", function () {
        O.bindToRedraw("_moveLeft");
      }, "keydown"), $(n = this.keycharm).call(n, "right", function () {
        O.bindToRedraw("_moveRight");
      }, "keydown"), $(o = this.keycharm).call(o, "=", function () {
        O.bindToRedraw("_zoomIn");
      }, "keydown"), $(r = this.keycharm).call(r, "num+", function () {
        O.bindToRedraw("_zoomIn");
      }, "keydown"), $(s = this.keycharm).call(s, "num-", function () {
        O.bindToRedraw("_zoomOut");
      }, "keydown"), $(a = this.keycharm).call(a, "-", function () {
        O.bindToRedraw("_zoomOut");
      }, "keydown"), $(h = this.keycharm).call(h, "[", function () {
        O.bindToRedraw("_zoomOut");
      }, "keydown"), $(l = this.keycharm).call(l, "]", function () {
        O.bindToRedraw("_zoomIn");
      }, "keydown"), $(d = this.keycharm).call(d, "pageup", function () {
        O.bindToRedraw("_zoomIn");
      }, "keydown"), $(u = this.keycharm).call(u, "pagedown", function () {
        O.bindToRedraw("_zoomOut");
      }, "keydown"), $(c = this.keycharm).call(c, "up", function () {
        O.unbindFromRedraw("_moveUp");
      }, "keyup"), $(f = this.keycharm).call(f, "down", function () {
        O.unbindFromRedraw("_moveDown");
      }, "keyup"), $(p = this.keycharm).call(p, "left", function () {
        O.unbindFromRedraw("_moveLeft");
      }, "keyup"), $(v = this.keycharm).call(v, "right", function () {
        O.unbindFromRedraw("_moveRight");
      }, "keyup"), $(y = this.keycharm).call(y, "=", function () {
        O.unbindFromRedraw("_zoomIn");
      }, "keyup"), $(g = this.keycharm).call(g, "num+", function () {
        O.unbindFromRedraw("_zoomIn");
      }, "keyup"), $(m = this.keycharm).call(m, "num-", function () {
        O.unbindFromRedraw("_zoomOut");
      }, "keyup"), $(b = this.keycharm).call(b, "-", function () {
        O.unbindFromRedraw("_zoomOut");
      }, "keyup"), $(w = this.keycharm).call(w, "[", function () {
        O.unbindFromRedraw("_zoomOut");
      }, "keyup"), $(_ = this.keycharm).call(_, "]", function () {
        O.unbindFromRedraw("_zoomIn");
      }, "keyup"), $(k = this.keycharm).call(k, "pageup", function () {
        O.unbindFromRedraw("_zoomIn");
      }, "keyup"), $(x = this.keycharm).call(x, "pagedown", function () {
        O.unbindFromRedraw("_zoomOut");
      }, "keyup")));
    }
  }]), t;
}(),
    ED = function () {
  function t(e, i) {
    oc(this, t), this.container = e, this.overflowMethod = i || "cap", this.x = 0, this.y = 0, this.padding = 5, this.hidden = !1, this.frame = document.createElement("div"), this.frame.className = "vis-tooltip", this.container.appendChild(this.frame);
  }

  return hc(t, [{
    key: "setPosition",
    value: function (t, e) {
      this.x = GS(t), this.y = GS(e);
    }
  }, {
    key: "setText",
    value: function (t) {
      t instanceof Element ? (this.frame.innerHTML = "", this.frame.appendChild(t)) : this.frame.innerHTML = t;
    }
  }, {
    key: "show",
    value: function (t) {
      if (void 0 === t && (t = !0), !0 === t) {
        var e = this.frame.clientHeight,
            i = this.frame.clientWidth,
            n = this.frame.parentNode.clientHeight,
            o = this.frame.parentNode.clientWidth,
            r = 0,
            s = 0;

        if ("flip" == this.overflowMethod) {
          var a = !1,
              h = !0;
          this.y - e < this.padding && (h = !1), this.x + i > o - this.padding && (a = !0), r = a ? this.x - i : this.x, s = h ? this.y - e : this.y;
        } else (s = this.y - e) + e + this.padding > n && (s = n - e - this.padding), s < this.padding && (s = this.padding), (r = this.x) + i + this.padding > o && (r = o - i - this.padding), r < this.padding && (r = this.padding);

        this.frame.style.left = r + "px", this.frame.style.top = s + "px", this.frame.style.visibility = "visible", this.hidden = !1;
      } else this.hide();
    }
  }, {
    key: "hide",
    value: function () {
      this.hidden = !0, this.frame.style.left = "0", this.frame.style.top = "0", this.frame.style.visibility = "hidden";
    }
  }, {
    key: "destroy",
    value: function () {
      this.frame.parentNode.removeChild(this.frame);
    }
  }]), t;
}(),
    DD = function () {
  function t(e, i, n) {
    var o, r, s, a, h, l, d, u, c, f, p, v, y;
    oc(this, t), this.body = e, this.canvas = i, this.selectionHandler = n, this.navigationHandler = new MD(e, i), this.body.eventListeners.onTap = $(o = this.onTap).call(o, this), this.body.eventListeners.onTouch = $(r = this.onTouch).call(r, this), this.body.eventListeners.onDoubleTap = $(s = this.onDoubleTap).call(s, this), this.body.eventListeners.onHold = $(a = this.onHold).call(a, this), this.body.eventListeners.onDragStart = $(h = this.onDragStart).call(h, this), this.body.eventListeners.onDrag = $(l = this.onDrag).call(l, this), this.body.eventListeners.onDragEnd = $(d = this.onDragEnd).call(d, this), this.body.eventListeners.onMouseWheel = $(u = this.onMouseWheel).call(u, this), this.body.eventListeners.onPinch = $(c = this.onPinch).call(c, this), this.body.eventListeners.onMouseMove = $(f = this.onMouseMove).call(f, this), this.body.eventListeners.onRelease = $(p = this.onRelease).call(p, this), this.body.eventListeners.onContext = $(v = this.onContext).call(v, this), this.touchTime = 0, this.drag = {}, this.pinch = {}, this.popup = void 0, this.popupObj = void 0, this.popupTimer = void 0, this.body.functions.getPointer = $(y = this.getPointer).call(y, this), this.options = {}, this.defaultOptions = {
      dragNodes: !0,
      dragView: !0,
      hover: !1,
      keyboard: {
        enabled: !1,
        speed: {
          x: 10,
          y: 10,
          zoom: .02
        },
        bindToWindow: !0
      },
      navigationButtons: !1,
      tooltipDelay: 300,
      zoomView: !0,
      zoomSpeed: 1
    }, Yr(this.options, this.defaultOptions), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t = this;
      this.body.emitter.on("destroy", function () {
        clearTimeout(t.popupTimer), delete t.body.functions.getPointer;
      });
    }
  }, {
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        Vr(["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"], this.options, t), Ds(this.options, t, "keyboard"), t.tooltip && (Yr(this.options.tooltip, t.tooltip), t.tooltip.color && (this.options.tooltip.color = ps(t.tooltip.color)));
      }

      this.navigationHandler.setOptions(this.options);
    }
  }, {
    key: "getPointer",
    value: function (t) {
      return {
        x: t.x - Kr(this.canvas.frame.canvas),
        y: t.y - Jr(this.canvas.frame.canvas)
      };
    }
  }, {
    key: "onTouch",
    value: function (t) {
      new Date().valueOf() - this.touchTime > 50 && (this.drag.pointer = this.getPointer(t.center), this.drag.pinched = !1, this.pinch.scale = this.body.view.scale, this.touchTime = new Date().valueOf());
    }
  }, {
    key: "onTap",
    value: function (t) {
      var e = this.getPointer(t.center),
          i = this.selectionHandler.options.multiselect && (t.changedPointers[0].ctrlKey || t.changedPointers[0].metaKey);
      this.checkSelectionChanges(e, t, i), this.selectionHandler._generateClickEvent("click", t, e);
    }
  }, {
    key: "onDoubleTap",
    value: function (t) {
      var e = this.getPointer(t.center);

      this.selectionHandler._generateClickEvent("doubleClick", t, e);
    }
  }, {
    key: "onHold",
    value: function (t) {
      var e = this.getPointer(t.center),
          i = this.selectionHandler.options.multiselect;
      this.checkSelectionChanges(e, t, i), this.selectionHandler._generateClickEvent("click", t, e), this.selectionHandler._generateClickEvent("hold", t, e);
    }
  }, {
    key: "onRelease",
    value: function (t) {
      if (new Date().valueOf() - this.touchTime > 10) {
        var e = this.getPointer(t.center);
        this.selectionHandler._generateClickEvent("release", t, e), this.touchTime = new Date().valueOf();
      }
    }
  }, {
    key: "onContext",
    value: function (t) {
      var e = this.getPointer({
        x: t.clientX,
        y: t.clientY
      });

      this.selectionHandler._generateClickEvent("oncontext", t, e);
    }
  }, {
    key: "checkSelectionChanges",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = this.selectionHandler.getSelection(),
          o = !1;
      o = !0 === i ? this.selectionHandler.selectAdditionalOnPoint(t) : this.selectionHandler.selectOnPoint(t);

      var r = this.selectionHandler.getSelection(),
          s = this._determineDifference(n, r),
          a = this._determineDifference(r, n);

      s.edges.length > 0 && (this.selectionHandler._generateClickEvent("deselectEdge", e, t, n), o = !0), s.nodes.length > 0 && (this.selectionHandler._generateClickEvent("deselectNode", e, t, n), o = !0), a.nodes.length > 0 && (this.selectionHandler._generateClickEvent("selectNode", e, t), o = !0), a.edges.length > 0 && (this.selectionHandler._generateClickEvent("selectEdge", e, t), o = !0), !0 === o && this.selectionHandler._generateClickEvent("select", e, t);
    }
  }, {
    key: "_determineDifference",
    value: function (t, e) {
      var i = function (t, e) {
        for (var i = [], n = 0; n < t.length; n++) {
          var o = t[n];
          -1 === el(e).call(e, o) && i.push(o);
        }

        return i;
      };

      return {
        nodes: i(t.nodes, e.nodes),
        edges: i(t.edges, e.edges)
      };
    }
  }, {
    key: "onDragStart",
    value: function (t) {
      void 0 === this.drag.pointer && this.onTouch(t);
      var e = this.selectionHandler.getNodeAt(this.drag.pointer);

      if (this.drag.dragging = !0, this.drag.selection = [], this.drag.translation = Yr({}, this.body.view.translation), this.drag.nodeId = void 0, void 0 !== e && !0 === this.options.dragNodes) {
        this.drag.nodeId = e.id, !1 === e.isSelected() && (this.selectionHandler.unselectAll(), this.selectionHandler.selectObject(e)), this.selectionHandler._generateClickEvent("dragStart", t, this.drag.pointer);
        var i = this.selectionHandler.selectionObj.nodes;

        for (var n in i) if (i.hasOwnProperty(n)) {
          var o = i[n],
              r = {
            id: o.id,
            node: o,
            x: o.x,
            y: o.y,
            xFixed: o.options.fixed.x,
            yFixed: o.options.fixed.y
          };
          o.options.fixed.x = !0, o.options.fixed.y = !0, this.drag.selection.push(r);
        }
      } else this.selectionHandler._generateClickEvent("dragStart", t, this.drag.pointer, void 0, !0);
    }
  }, {
    key: "onDrag",
    value: function (t) {
      var e = this;

      if (!0 !== this.drag.pinched) {
        this.body.emitter.emit("unlockNode");
        var i = this.getPointer(t.center),
            n = this.drag.selection;

        if (n && n.length && !0 === this.options.dragNodes) {
          this.selectionHandler._generateClickEvent("dragging", t, i);

          var o = i.x - this.drag.pointer.x,
              r = i.y - this.drag.pointer.y;
          kh(n).call(n, function (t) {
            var i = t.node;
            !1 === t.xFixed && (i.x = e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x) + o)), !1 === t.yFixed && (i.y = e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y) + r));
          }), this.body.emitter.emit("startSimulation");
        } else if (!0 === this.options.dragView) {
          if (this.selectionHandler._generateClickEvent("dragging", t, i, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t);
          var s = i.x - this.drag.pointer.x,
              a = i.y - this.drag.pointer.y;
          this.body.view.translation = {
            x: this.drag.translation.x + s,
            y: this.drag.translation.y + a
          }, this.body.emitter.emit("_requestRedraw");
        }
      }
    }
  }, {
    key: "onDragEnd",
    value: function (t) {
      this.drag.dragging = !1;
      var e = this.drag.selection;
      e && e.length ? (kh(e).call(e, function (t) {
        t.node.options.fixed.x = t.xFixed, t.node.options.fixed.y = t.yFixed;
      }), this.selectionHandler._generateClickEvent("dragEnd", t, this.getPointer(t.center)), this.body.emitter.emit("startSimulation")) : (this.selectionHandler._generateClickEvent("dragEnd", t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit("_requestRedraw"));
    }
  }, {
    key: "onPinch",
    value: function (t) {
      var e = this.getPointer(t.center);
      this.drag.pinched = !0, void 0 === this.pinch.scale && (this.pinch.scale = 1);
      var i = this.pinch.scale * t.scale;
      this.zoom(i, e);
    }
  }, {
    key: "zoom",
    value: function (t, e) {
      if (!0 === this.options.zoomView) {
        var i = this.body.view.scale;
        t < 1e-5 && (t = 1e-5), t > 10 && (t = 10);
        var n = void 0;
        void 0 !== this.drag && !0 === this.drag.dragging && (n = this.canvas.DOMtoCanvas(this.drag.pointer));
        var o = this.body.view.translation,
            r = t / i,
            s = (1 - r) * e.x + o.x * r,
            a = (1 - r) * e.y + o.y * r;

        if (this.body.view.scale = t, this.body.view.translation = {
          x: s,
          y: a
        }, null != n) {
          var h = this.canvas.canvasToDOM(n);
          this.drag.pointer.x = h.x, this.drag.pointer.y = h.y;
        }

        this.body.emitter.emit("_requestRedraw"), i < t ? this.body.emitter.emit("zoom", {
          direction: "+",
          scale: this.body.view.scale,
          pointer: e
        }) : this.body.emitter.emit("zoom", {
          direction: "-",
          scale: this.body.view.scale,
          pointer: e
        });
      }
    }
  }, {
    key: "onMouseWheel",
    value: function (t) {
      if (!0 === this.options.zoomView) {
        if (0 !== t.deltaY) {
          var e = this.body.view.scale;
          e *= 1 + (t.deltaY < 0 ? 1 : -1) * (.1 * this.options.zoomSpeed);
          var i = this.getPointer({
            x: t.clientX,
            y: t.clientY
          });
          this.zoom(e, i);
        }

        t.preventDefault();
      }
    }
  }, {
    key: "onMouseMove",
    value: function (t) {
      var e = this,
          i = this.getPointer({
        x: t.clientX,
        y: t.clientY
      }),
          n = !1;
      void 0 !== this.popup && (!1 === this.popup.hidden && this._checkHidePopup(i), !1 === this.popup.hidden && (n = !0, this.popup.setPosition(i.x + 3, i.y - 5), this.popup.show())), !1 === this.options.keyboard.bindToWindow && !0 === this.options.keyboard.enabled && this.canvas.frame.focus(), !1 === n && (void 0 !== this.popupTimer && (clearInterval(this.popupTimer), this.popupTimer = void 0), this.drag.dragging || (this.popupTimer = vc(function () {
        return e._checkShowPopup(i);
      }, this.options.tooltipDelay))), !0 === this.options.hover && this.selectionHandler.hoverObject(t, i);
    }
  }, {
    key: "_checkShowPopup",
    value: function (t) {
      var e = this.canvas._XconvertDOMtoCanvas(t.x),
          i = this.canvas._YconvertDOMtoCanvas(t.y),
          n = {
        left: e,
        top: i,
        right: e,
        bottom: i
      },
          o = void 0 === this.popupObj ? void 0 : this.popupObj.id,
          r = !1,
          s = "node";

      if (void 0 === this.popupObj) {
        for (var a, h = this.body.nodeIndices, l = this.body.nodes, d = [], u = 0; u < h.length; u++) !0 === (a = l[h[u]]).isOverlappingWith(n) && (r = !0, void 0 !== a.getTitle() && d.push(h[u]));

        d.length > 0 && (this.popupObj = l[d[d.length - 1]], r = !0);
      }

      if (void 0 === this.popupObj && !1 === r) {
        for (var c, f = this.body.edgeIndices, p = this.body.edges, v = [], y = 0; y < f.length; y++) !0 === (c = p[f[y]]).isOverlappingWith(n) && !0 === c.connected && void 0 !== c.getTitle() && v.push(f[y]);

        v.length > 0 && (this.popupObj = p[v[v.length - 1]], s = "edge");
      }

      void 0 !== this.popupObj ? this.popupObj.id !== o && (void 0 === this.popup && (this.popup = new ED(this.canvas.frame)), this.popup.popupTargetType = s, this.popup.popupTargetId = this.popupObj.id, this.popup.setPosition(t.x + 3, t.y - 5), this.popup.setText(this.popupObj.getTitle()), this.popup.show(), this.body.emitter.emit("showPopup", this.popupObj.id)) : void 0 !== this.popup && (this.popup.hide(), this.body.emitter.emit("hidePopup"));
    }
  }, {
    key: "_checkHidePopup",
    value: function (t) {
      var e = this.selectionHandler._pointerToPositionObject(t),
          i = !1;

      if ("node" === this.popup.popupTargetType) {
        if (void 0 !== this.body.nodes[this.popup.popupTargetId] && !0 === (i = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e))) {
          var n = this.selectionHandler.getNodeAt(t);
          i = void 0 !== n && n.id === this.popup.popupTargetId;
        }
      } else void 0 === this.selectionHandler.getNodeAt(t) && void 0 !== this.body.edges[this.popup.popupTargetId] && (i = this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));

      !1 === i && (this.popupObj = void 0, this.popup.hide(), this.body.emitter.emit("hidePopup"));
    }
  }]), t;
}(),
    TD = function () {
  function t(e, i) {
    var n = this;
    oc(this, t), this.body = e, this.canvas = i, this.selectionObj = {
      nodes: [],
      edges: []
    }, this.hoverObj = {
      nodes: {},
      edges: {}
    }, this.options = {}, this.defaultOptions = {
      multiselect: !1,
      selectable: !0,
      selectConnectedEdges: !0,
      hoverConnectedEdges: !0
    }, Yr(this.options, this.defaultOptions), this.body.emitter.on("_dataChanged", function () {
      n.updateSelection();
    });
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        Wr(["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"], this.options, t);
      }
    }
  }, {
    key: "selectOnPoint",
    value: function (t) {
      var e = !1;

      if (!0 === this.options.selectable) {
        var i = this.getNodeAt(t) || this.getEdgeAt(t);
        this.unselectAll(), void 0 !== i && (e = this.selectObject(i)), this.body.emitter.emit("_requestRedraw");
      }

      return e;
    }
  }, {
    key: "selectAdditionalOnPoint",
    value: function (t) {
      var e = !1;

      if (!0 === this.options.selectable) {
        var i = this.getNodeAt(t) || this.getEdgeAt(t);
        void 0 !== i && (e = !0, !0 === i.isSelected() ? this.deselectObject(i) : this.selectObject(i), this.body.emitter.emit("_requestRedraw"));
      }

      return e;
    }
  }, {
    key: "_initBaseEvent",
    value: function (t, e) {
      var i = {};
      return i.pointer = {
        DOM: {
          x: e.x,
          y: e.y
        },
        canvas: this.canvas.DOMtoCanvas(e)
      }, i.event = t, i;
    }
  }, {
    key: "_generateClickEvent",
    value: function (t, e, i, n) {
      var o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
          r = this._initBaseEvent(e, i);

      if (!0 === o) r.nodes = [], r.edges = [];else {
        var s = this.getSelection();
        r.nodes = s.nodes, r.edges = s.edges;
      }
      void 0 !== n && (r.previousSelection = n), "click" == t && (r.items = this.getClickedItems(i)), void 0 !== e.controlEdge && (r.controlEdge = e.controlEdge), this.body.emitter.emit(t, r);
    }
  }, {
    key: "selectObject",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.selectConnectedEdges;
      return void 0 !== t && (t instanceof yE && !0 === e && this._selectConnectedEdges(t), t.select(), this._addToSelection(t), !0);
    }
  }, {
    key: "deselectObject",
    value: function (t) {
      !0 === t.isSelected() && (t.selected = !1, this._removeFromSelection(t));
    }
  }, {
    key: "_getAllNodesOverlappingWith",
    value: function (t) {
      for (var e = [], i = this.body.nodes, n = 0; n < this.body.nodeIndices.length; n++) {
        var o = this.body.nodeIndices[n];
        i[o].isOverlappingWith(t) && e.push(o);
      }

      return e;
    }
  }, {
    key: "_pointerToPositionObject",
    value: function (t) {
      var e = this.canvas.DOMtoCanvas(t);
      return {
        left: e.x - 1,
        top: e.y + 1,
        right: e.x + 1,
        bottom: e.y - 1
      };
    }
  }, {
    key: "getNodeAt",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = this._pointerToPositionObject(t),
          n = this._getAllNodesOverlappingWith(i);

      return n.length > 0 ? !0 === e ? this.body.nodes[n[n.length - 1]] : n[n.length - 1] : void 0;
    }
  }, {
    key: "_getEdgesOverlappingWith",
    value: function (t, e) {
      for (var i = this.body.edges, n = 0; n < this.body.edgeIndices.length; n++) {
        var o = this.body.edgeIndices[n];
        i[o].isOverlappingWith(t) && e.push(o);
      }
    }
  }, {
    key: "_getAllEdgesOverlappingWith",
    value: function (t) {
      var e = [];
      return this._getEdgesOverlappingWith(t, e), e;
    }
  }, {
    key: "getEdgeAt",
    value: function (t) {
      for (var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this.canvas.DOMtoCanvas(t), n = 10, o = null, r = this.body.edges, s = 0; s < this.body.edgeIndices.length; s++) {
        var a = this.body.edgeIndices[s],
            h = r[a];

        if (h.connected) {
          var l = h.from.x,
              d = h.from.y,
              u = h.to.x,
              c = h.to.y,
              f = h.edgeType.getDistanceToEdge(l, d, u, c, i.x, i.y);
          f < n && (o = a, n = f);
        }
      }

      return null !== o ? !0 === e ? this.body.edges[o] : o : void 0;
    }
  }, {
    key: "_addToSelection",
    value: function (t) {
      t instanceof yE ? this.selectionObj.nodes[t.id] = t : this.selectionObj.edges[t.id] = t;
    }
  }, {
    key: "_addToHover",
    value: function (t) {
      t instanceof yE ? this.hoverObj.nodes[t.id] = t : this.hoverObj.edges[t.id] = t;
    }
  }, {
    key: "_removeFromSelection",
    value: function (t) {
      t instanceof yE ? (delete this.selectionObj.nodes[t.id], this._unselectConnectedEdges(t)) : delete this.selectionObj.edges[t.id];
    }
  }, {
    key: "unselectAll",
    value: function () {
      for (var t in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(t) && this.selectionObj.nodes[t].unselect();

      for (var e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && this.selectionObj.edges[e].unselect();

      this.selectionObj = {
        nodes: {},
        edges: {}
      };
    }
  }, {
    key: "_getSelectedNodeCount",
    value: function () {
      var t = 0;

      for (var e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && (t += 1);

      return t;
    }
  }, {
    key: "_getSelectedNode",
    value: function () {
      for (var t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t)) return this.selectionObj.nodes[t];
    }
  }, {
    key: "_getSelectedEdge",
    value: function () {
      for (var t in this.selectionObj.edges) if (this.selectionObj.edges.hasOwnProperty(t)) return this.selectionObj.edges[t];
    }
  }, {
    key: "_getSelectedEdgeCount",
    value: function () {
      var t = 0;

      for (var e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && (t += 1);

      return t;
    }
  }, {
    key: "_getSelectedObjectCount",
    value: function () {
      var t = 0;

      for (var e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && (t += 1);

      for (var i in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(i) && (t += 1);

      return t;
    }
  }, {
    key: "_selectionIsEmpty",
    value: function () {
      for (var t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t)) return !1;

      for (var e in this.selectionObj.edges) if (this.selectionObj.edges.hasOwnProperty(e)) return !1;

      return !0;
    }
  }, {
    key: "_clusterInSelection",
    value: function () {
      for (var t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t) && this.selectionObj.nodes[t].clusterSize > 1) return !0;

      return !1;
    }
  }, {
    key: "_selectConnectedEdges",
    value: function (t) {
      for (var e = 0; e < t.edges.length; e++) {
        var i = t.edges[e];
        i.select(), this._addToSelection(i);
      }
    }
  }, {
    key: "_hoverConnectedEdges",
    value: function (t) {
      for (var e = 0; e < t.edges.length; e++) {
        var i = t.edges[e];
        i.hover = !0, this._addToHover(i);
      }
    }
  }, {
    key: "_unselectConnectedEdges",
    value: function (t) {
      for (var e = 0; e < t.edges.length; e++) {
        var i = t.edges[e];
        i.unselect(), this._removeFromSelection(i);
      }
    }
  }, {
    key: "emitBlurEvent",
    value: function (t, e, i) {
      var n = this._initBaseEvent(t, e);

      !0 === i.hover && (i.hover = !1, i instanceof yE ? (n.node = i.id, this.body.emitter.emit("blurNode", n)) : (n.edge = i.id, this.body.emitter.emit("blurEdge", n)));
    }
  }, {
    key: "emitHoverEvent",
    value: function (t, e, i) {
      var n = this._initBaseEvent(t, e),
          o = !1;

      return !1 === i.hover && (i.hover = !0, this._addToHover(i), o = !0, i instanceof yE ? (n.node = i.id, this.body.emitter.emit("hoverNode", n)) : (n.edge = i.id, this.body.emitter.emit("hoverEdge", n))), o;
    }
  }, {
    key: "hoverObject",
    value: function (t, e) {
      var i = this.getNodeAt(e);
      void 0 === i && (i = this.getEdgeAt(e));
      var n = !1;

      for (var o in this.hoverObj.nodes) this.hoverObj.nodes.hasOwnProperty(o) && (void 0 === i || i instanceof yE && i.id != o || i instanceof $E) && (this.emitBlurEvent(t, e, this.hoverObj.nodes[o]), delete this.hoverObj.nodes[o], n = !0);

      for (var r in this.hoverObj.edges) this.hoverObj.edges.hasOwnProperty(r) && (!0 === n ? (this.hoverObj.edges[r].hover = !1, delete this.hoverObj.edges[r]) : (void 0 === i || i instanceof $E && i.id != r || i instanceof yE && !i.hover) && (this.emitBlurEvent(t, e, this.hoverObj.edges[r]), delete this.hoverObj.edges[r], n = !0));

      if (void 0 !== i) {
        var s = CS(this.hoverObj.edges).length,
            a = CS(this.hoverObj.nodes).length;
        (n || i instanceof $E && 0 === s && 0 === a || i instanceof yE && 0 === s && 0 === a) && (n = this.emitHoverEvent(t, e, i)), i instanceof yE && !0 === this.options.hoverConnectedEdges && this._hoverConnectedEdges(i);
      }

      !0 === n && this.body.emitter.emit("_requestRedraw");
    }
  }, {
    key: "getSelection",
    value: function () {
      return {
        nodes: this.getSelectedNodes(),
        edges: this.getSelectedEdges()
      };
    }
  }, {
    key: "getSelectedNodes",
    value: function () {
      var t = [];
      if (!0 === this.options.selectable) for (var e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && t.push(this.selectionObj.nodes[e].id);
      return t;
    }
  }, {
    key: "getSelectedEdges",
    value: function () {
      var t = [];
      if (!0 === this.options.selectable) for (var e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && t.push(this.selectionObj.edges[e].id);
      return t;
    }
  }, {
    key: "setSelection",
    value: function (t) {
      var e,
          i,
          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (!t || !t.nodes && !t.edges) throw "Selection must be an object with nodes and/or edges properties";
      if ((n.unselectAll || void 0 === n.unselectAll) && this.unselectAll(), t.nodes) for (e = 0; e < t.nodes.length; e++) {
        i = t.nodes[e];
        var o = this.body.nodes[i];
        if (!o) throw new RangeError('Node with id "' + i + '" not found');
        this.selectObject(o, n.highlightEdges);
      }
      if (t.edges) for (e = 0; e < t.edges.length; e++) {
        i = t.edges[e];
        var r = this.body.edges[i];
        if (!r) throw new RangeError('Edge with id "' + i + '" not found');
        this.selectObject(r);
      }
      this.body.emitter.emit("_requestRedraw");
    }
  }, {
    key: "selectNodes",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      if (!t || void 0 === t.length) throw "Selection must be an array with ids";
      this.setSelection({
        nodes: t
      }, {
        highlightEdges: e
      });
    }
  }, {
    key: "selectEdges",
    value: function (t) {
      if (!t || void 0 === t.length) throw "Selection must be an array with ids";
      this.setSelection({
        edges: t
      });
    }
  }, {
    key: "updateSelection",
    value: function () {
      for (var t in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(t) && (this.body.nodes.hasOwnProperty(t) || delete this.selectionObj.nodes[t]);

      for (var e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && (this.body.edges.hasOwnProperty(e) || delete this.selectionObj.edges[e]);
    }
  }, {
    key: "getClickedItems",
    value: function (t) {
      for (var e = this.canvas.DOMtoCanvas(t), i = [], n = this.body.nodeIndices, o = this.body.nodes, r = n.length - 1; r >= 0; r--) {
        var s = o[n[r]].getItemsOnPoint(e);
        i.push.apply(i, s);
      }

      for (var a = this.body.edgeIndices, h = this.body.edges, l = a.length - 1; l >= 0; l--) {
        var d = h[a[l]].getItemsOnPoint(e);
        i.push.apply(i, d);
      }

      return i;
    }
  }]), t;
}(),
    CD = !r(function () {
  return Object.isExtensible(Object.preventExtensions({}));
}),
    PD = i(function (t) {
  var e = R.f,
      i = qs("meta"),
      n = 0,
      o = Object.isExtensible || function () {
    return !0;
  },
      r = function (t) {
    e(t, i, {
      value: {
        objectID: "O" + ++n,
        weakData: {}
      }
    });
  },
      s = t.exports = {
    REQUIRED: !1,
    fastKey: function (t, e) {
      if (!g(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;

      if (!w(t, i)) {
        if (!o(t)) return "F";
        if (!e) return "E";
        r(t);
      }

      return t[i].objectID;
    },
    getWeakData: function (t, e) {
      if (!w(t, i)) {
        if (!o(t)) return !0;
        if (!e) return !1;
        r(t);
      }

      return t[i].weakData;
    },
    onFreeze: function (t) {
      return CD && s.REQUIRED && o(t) && !w(t, i) && r(t), t;
    }
  };

  Ks[i] = !0;
}),
    AD = (PD.REQUIRED, PD.fastKey, PD.getWeakData, PD.onFreeze, va("iterator")),
    ID = Array.prototype,
    FD = function (t, e, i, n) {
  try {
    return n ? e(z(i)[0], i[1]) : e(i);
  } catch (e) {
    var o = t.return;
    throw void 0 !== o && z(o.call(t)), e;
  }
},
    ND = i(function (t) {
  var e = function (t, e) {
    this.stopped = t, this.result = e;
  };

  (t.exports = function (t, i, n, o, r) {
    var s,
        a,
        h,
        l,
        d,
        u,
        c,
        f,
        p = j(i, n, o ? 2 : 1);
    if (r) s = t;else {
      if ("function" != typeof (a = _c(t))) throw TypeError("Target is not iterable");

      if (void 0 !== (f = a) && (Rs.Array === f || ID[AD] === f)) {
        for (h = 0, l = ka(t.length); l > h; h++) if ((d = o ? p(z(c = t[h])[0], c[1]) : p(t[h])) && d instanceof e) return d;

        return new e(!1);
      }

      s = a.call(t);
    }

    for (u = s.next; !(c = u.call(s)).done;) if ("object" == typeof (d = FD(s, p, c.value, o)) && d && d instanceof e) return d;

    return new e(!1);
  }).stop = function (t) {
    return new e(!0, t);
  };
}),
    jD = function (t, e, i) {
  if (!(t instanceof e)) throw TypeError("Incorrect " + (i ? i + " " : "") + "invocation");
  return t;
},
    zD = R.f,
    LD = vh.forEach,
    RD = sa.set,
    BD = sa.getterFor,
    YD = function (t, e, i, n, a) {
  var h,
      l = o[t],
      d = l && l.prototype,
      u = n ? "set" : "add",
      c = {};

  if (s && "function" == typeof l && (a || d.forEach && !r(function () {
    new l().entries().next();
  }))) {
    h = e(function (e, i) {
      RD(jD(e, h, t), {
        type: t,
        collection: new l()
      }), null != i && ND(i, e[u], e, n);
    });
    var f = BD(t);
    LD(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function (t) {
      var e = "add" == t || "set" == t;
      t in d && (!a || "clear" != t) && B(h.prototype, t, function (i, n) {
        var o = f(this).collection;
        if (!e && a && !g(i)) return "get" == t && void 0;
        var r = o[t](0 === i ? 0 : i, n);
        return e ? this : r;
      });
    }), a || zD(h.prototype, "size", {
      get: function () {
        return f(this).collection.size;
      }
    });
  } else h = i.getConstructor(e, t, n, u), PD.REQUIRED = !0;

  return Xa(h, t, !1, !0), c[t] = h, W({
    global: !0,
    forced: !0
  }, c), a || i.setStrong(h, t, n), h;
},
    HD = function (t, e, i) {
  for (var n in e) i && i.unsafe && t[n] ? t[n] = e[n] : Ja(t, n, e[n], i);

  return t;
},
    WD = va("species"),
    VD = R.f,
    UD = PD.fastKey,
    GD = sa.set,
    qD = sa.getterFor,
    XD = {
  getConstructor: function (t, e, i, n) {
    var o = t(function (t, r) {
      jD(t, o, e), GD(t, {
        type: e,
        index: Ra(null),
        first: void 0,
        last: void 0,
        size: 0
      }), s || (t.size = 0), null != r && ND(r, t[n], t, i);
    }),
        r = qD(e),
        a = function (t, e, i) {
      var n,
          o,
          a = r(t),
          l = h(t, e);
      return l ? l.value = i : (a.last = l = {
        index: o = UD(e, !0),
        key: e,
        value: i,
        previous: n = a.last,
        next: void 0,
        removed: !1
      }, a.first || (a.first = l), n && (n.next = l), s ? a.size++ : t.size++, "F" !== o && (a.index[o] = l)), t;
    },
        h = function (t, e) {
      var i,
          n = r(t),
          o = UD(e);
      if ("F" !== o) return n.index[o];

      for (i = n.first; i; i = i.next) if (i.key == e) return i;
    };

    return HD(o.prototype, {
      clear: function () {
        for (var t = r(this), e = t.index, i = t.first; i;) i.removed = !0, i.previous && (i.previous = i.previous.next = void 0), delete e[i.index], i = i.next;

        t.first = t.last = void 0, s ? t.size = 0 : this.size = 0;
      },
      delete: function (t) {
        var e = r(this),
            i = h(this, t);

        if (i) {
          var n = i.next,
              o = i.previous;
          delete e.index[i.index], i.removed = !0, o && (o.next = n), n && (n.previous = o), e.first == i && (e.first = n), e.last == i && (e.last = o), s ? e.size-- : this.size--;
        }

        return !!i;
      },
      forEach: function (t) {
        for (var e, i = r(this), n = j(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : i.first;) for (n(e.value, e.key, this); e && e.removed;) e = e.previous;
      },
      has: function (t) {
        return !!h(this, t);
      }
    }), HD(o.prototype, i ? {
      get: function (t) {
        var e = h(this, t);
        return e && e.value;
      },
      set: function (t, e) {
        return a(this, 0 === t ? 0 : t, e);
      }
    } : {
      add: function (t) {
        return a(this, t = 0 === t ? 0 : t, t);
      }
    }), s && VD(o.prototype, "size", {
      get: function () {
        return r(this).size;
      }
    }), o;
  },
  setStrong: function (t, e, i) {
    var n = e + " Iterator",
        o = qD(e),
        r = qD(n);
    nh(t, e, function (t, e) {
      GD(this, {
        type: n,
        target: t,
        state: o(t),
        kind: e,
        last: void 0
      });
    }, function () {
      for (var t = r(this), e = t.kind, i = t.last; i && i.removed;) i = i.previous;

      return t.target && (t.last = i = i ? i.next : t.state.first) ? "keys" == e ? {
        value: i.key,
        done: !1
      } : "values" == e ? {
        value: i.value,
        done: !1
      } : {
        value: [i.key, i.value],
        done: !1
      } : (t.target = void 0, {
        value: void 0,
        done: !0
      });
    }, i ? "entries" : "values", !i, !0), function (t) {
      var e = Fa(t),
          i = R.f;
      s && e && !e[WD] && i(e, WD, {
        configurable: !0,
        get: function () {
          return this;
        }
      });
    }(e);
  }
},
    ZD = (YD("Map", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0);
  };
}, XD, !0), F.Map),
    KD = function (t) {
  return function (e, i, n, o) {
    N(i);
    var r = aa(e),
        s = p(r),
        a = ka(r.length),
        h = t ? a - 1 : 0,
        l = t ? -1 : 1;
    if (n < 2) for (;;) {
      if (h in s) {
        o = s[h], h += l;
        break;
      }

      if (h += l, t ? h < 0 : a <= h) throw TypeError("Reduce of empty array with no initial value");
    }

    for (; t ? h >= 0 : a > h; h += l) h in s && (o = i(o, s[h], h, r));

    return o;
  };
},
    $D = {
  left: KD(!1),
  right: KD(!0)
}.left;

W({
  target: "Array",
  proto: !0,
  forced: yh("reduce")
}, {
  reduce: function (t) {
    return $D(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var JD = X("Array").reduce,
    QD = Array.prototype,
    tT = function (t) {
  var e = t.reduce;
  return t === QD || t instanceof Array && e === QD.reduce ? JD : e;
},
    eT = [],
    iT = eT.sort,
    nT = r(function () {
  eT.sort(void 0);
}),
    oT = r(function () {
  eT.sort(null);
}),
    rT = yh("sort");

W({
  target: "Array",
  proto: !0,
  forced: nT || !oT || rT
}, {
  sort: function (t) {
    return void 0 === t ? iT.call(aa(this)) : iT.call(aa(this), N(t));
  }
});

var sT,
    aT = X("Array").sort,
    hT = Array.prototype,
    lT = function (t) {
  var e = t.sort;
  return t === hT || t instanceof Array && e === hT.sort ? aT : e;
},
    dT = i(function (t, e) {
  !function (t) {
    t.__esModule = !0, t.sort = function (t, i, n, o) {
      if (!Array.isArray(t)) throw new TypeError("Can only sort arrays");
      i ? "function" != typeof i && (o = n, n = i, i = s) : i = s, n || (n = 0), o || (o = t.length);
      var r = o - n;

      if (!(r < 2)) {
        var l = 0;
        if (r < e) return l = a(t, n, o, i), void h(t, n, o, n + l, i);

        var d = new u(t, i),
            c = function (t) {
          for (var i = 0; t >= e;) i |= 1 & t, t >>= 1;

          return t + i;
        }(r);

        do {
          if ((l = a(t, n, o, i)) < c) {
            var f = r;
            f > c && (f = c), h(t, n, n + f, n + l, i), l = f;
          }

          d.pushRun(n, l), d.mergeRuns(), r -= l, n += l;
        } while (0 !== r);

        d.forceMergeRuns();
      }
    };
    var e = 32,
        i = 7,
        n = 256,
        o = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

    function r(t) {
      return t < 1e5 ? t < 100 ? t < 10 ? 0 : 1 : t < 1e4 ? t < 1e3 ? 2 : 3 : 4 : t < 1e7 ? t < 1e6 ? 5 : 6 : t < 1e9 ? t < 1e8 ? 7 : 8 : 9;
    }

    function s(t, e) {
      if (t === e) return 0;

      if (~~t === t && ~~e === e) {
        if (0 === t || 0 === e) return t < e ? -1 : 1;

        if (t < 0 || e < 0) {
          if (e >= 0) return -1;
          if (t >= 0) return 1;
          t = -t, e = -e;
        }

        var i = r(t),
            n = r(e),
            s = 0;
        return i < n ? (t *= o[n - i - 1], e /= 10, s = -1) : i > n && (e *= o[i - n - 1], t /= 10, s = 1), t === e ? s : t < e ? -1 : 1;
      }

      var a = String(t),
          h = String(e);
      return a === h ? 0 : a < h ? -1 : 1;
    }

    function a(t, e, i, n) {
      var o = e + 1;
      if (o === i) return 1;

      if (n(t[o++], t[e]) < 0) {
        for (; o < i && n(t[o], t[o - 1]) < 0;) o++;

        !function (t, e, i) {
          for (i--; e < i;) {
            var n = t[e];
            t[e++] = t[i], t[i--] = n;
          }
        }(t, e, o);
      } else for (; o < i && n(t[o], t[o - 1]) >= 0;) o++;

      return o - e;
    }

    function h(t, e, i, n, o) {
      for (n === e && n++; n < i; n++) {
        for (var r = t[n], s = e, a = n; s < a;) {
          var h = s + a >>> 1;
          o(r, t[h]) < 0 ? a = h : s = h + 1;
        }

        var l = n - s;

        switch (l) {
          case 3:
            t[s + 3] = t[s + 2];

          case 2:
            t[s + 2] = t[s + 1];

          case 1:
            t[s + 1] = t[s];
            break;

          default:
            for (; l > 0;) t[s + l] = t[s + l - 1], l--;

        }

        t[s] = r;
      }
    }

    function l(t, e, i, n, o, r) {
      var s = 0,
          a = 0,
          h = 1;

      if (r(t, e[i + o]) > 0) {
        for (a = n - o; h < a && r(t, e[i + o + h]) > 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);

        h > a && (h = a), s += o, h += o;
      } else {
        for (a = o + 1; h < a && r(t, e[i + o - h]) <= 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);

        h > a && (h = a);
        var l = s;
        s = o - h, h = o - l;
      }

      for (s++; s < h;) {
        var d = s + (h - s >>> 1);
        r(t, e[i + d]) > 0 ? s = d + 1 : h = d;
      }

      return h;
    }

    function d(t, e, i, n, o, r) {
      var s = 0,
          a = 0,
          h = 1;

      if (r(t, e[i + o]) < 0) {
        for (a = o + 1; h < a && r(t, e[i + o - h]) < 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);

        h > a && (h = a);
        var l = s;
        s = o - h, h = o - l;
      } else {
        for (a = n - o; h < a && r(t, e[i + o + h]) >= 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);

        h > a && (h = a), s += o, h += o;
      }

      for (s++; s < h;) {
        var d = s + (h - s >>> 1);
        r(t, e[i + d]) < 0 ? h = d : s = d + 1;
      }

      return h;
    }

    var u = function () {
      function t(e, o) {
        !function (t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }(this, t), this.array = null, this.compare = null, this.minGallop = i, this.length = 0, this.tmpStorageLength = n, this.stackLength = 0, this.runStart = null, this.runLength = null, this.stackSize = 0, this.array = e, this.compare = o, this.length = e.length, this.length < 2 * n && (this.tmpStorageLength = this.length >>> 1), this.tmp = new Array(this.tmpStorageLength), this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, this.runStart = new Array(this.stackLength), this.runLength = new Array(this.stackLength);
      }

      return t.prototype.pushRun = function (t, e) {
        this.runStart[this.stackSize] = t, this.runLength[this.stackSize] = e, this.stackSize += 1;
      }, t.prototype.mergeRuns = function () {
        for (; this.stackSize > 1;) {
          var t = this.stackSize - 2;
          if (t >= 1 && this.runLength[t - 1] <= this.runLength[t] + this.runLength[t + 1] || t >= 2 && this.runLength[t - 2] <= this.runLength[t] + this.runLength[t - 1]) this.runLength[t - 1] < this.runLength[t + 1] && t--;else if (this.runLength[t] > this.runLength[t + 1]) break;
          this.mergeAt(t);
        }
      }, t.prototype.forceMergeRuns = function () {
        for (; this.stackSize > 1;) {
          var t = this.stackSize - 2;
          t > 0 && this.runLength[t - 1] < this.runLength[t + 1] && t--, this.mergeAt(t);
        }
      }, t.prototype.mergeAt = function (t) {
        var e = this.compare,
            i = this.array,
            n = this.runStart[t],
            o = this.runLength[t],
            r = this.runStart[t + 1],
            s = this.runLength[t + 1];
        this.runLength[t] = o + s, t === this.stackSize - 3 && (this.runStart[t + 1] = this.runStart[t + 2], this.runLength[t + 1] = this.runLength[t + 2]), this.stackSize--;
        var a = d(i[r], i, n, o, 0, e);
        n += a, 0 != (o -= a) && 0 !== (s = l(i[n + o - 1], i, r, s, s - 1, e)) && (o <= s ? this.mergeLow(n, o, r, s) : this.mergeHigh(n, o, r, s));
      }, t.prototype.mergeLow = function (t, e, n, o) {
        var r = this.compare,
            s = this.array,
            a = this.tmp,
            h = 0;

        for (h = 0; h < e; h++) a[h] = s[t + h];

        var u = 0,
            c = n,
            f = t;
        if (s[f++] = s[c++], 0 != --o) {
          if (1 !== e) {
            for (var p = this.minGallop;;) {
              var v = 0,
                  y = 0,
                  g = !1;

              do {
                if (r(s[c], a[u]) < 0) {
                  if (s[f++] = s[c++], y++, v = 0, 0 == --o) {
                    g = !0;
                    break;
                  }
                } else if (s[f++] = a[u++], v++, y = 0, 1 == --e) {
                  g = !0;
                  break;
                }
              } while ((v | y) < p);

              if (g) break;

              do {
                if (0 !== (v = d(s[c], a, u, e, 0, r))) {
                  for (h = 0; h < v; h++) s[f + h] = a[u + h];

                  if (f += v, u += v, (e -= v) <= 1) {
                    g = !0;
                    break;
                  }
                }

                if (s[f++] = s[c++], 0 == --o) {
                  g = !0;
                  break;
                }

                if (0 !== (y = l(a[u], s, c, o, 0, r))) {
                  for (h = 0; h < y; h++) s[f + h] = s[c + h];

                  if (f += y, c += y, 0 == (o -= y)) {
                    g = !0;
                    break;
                  }
                }

                if (s[f++] = a[u++], 1 == --e) {
                  g = !0;
                  break;
                }

                p--;
              } while (v >= i || y >= i);

              if (g) break;
              p < 0 && (p = 0), p += 2;
            }

            if (this.minGallop = p, p < 1 && (this.minGallop = 1), 1 === e) {
              for (h = 0; h < o; h++) s[f + h] = s[c + h];

              s[f + o] = a[u];
            } else {
              if (0 === e) throw new Error("mergeLow preconditions were not respected");

              for (h = 0; h < e; h++) s[f + h] = a[u + h];
            }
          } else {
            for (h = 0; h < o; h++) s[f + h] = s[c + h];

            s[f + o] = a[u];
          }
        } else for (h = 0; h < e; h++) s[f + h] = a[u + h];
      }, t.prototype.mergeHigh = function (t, e, n, o) {
        var r = this.compare,
            s = this.array,
            a = this.tmp,
            h = 0;

        for (h = 0; h < o; h++) a[h] = s[n + h];

        var u = t + e - 1,
            c = o - 1,
            f = n + o - 1,
            p = 0,
            v = 0;
        if (s[f--] = s[u--], 0 != --e) {
          if (1 !== o) {
            for (var y = this.minGallop;;) {
              var g = 0,
                  m = 0,
                  b = !1;

              do {
                if (r(a[c], s[u]) < 0) {
                  if (s[f--] = s[u--], g++, m = 0, 0 == --e) {
                    b = !0;
                    break;
                  }
                } else if (s[f--] = a[c--], m++, g = 0, 1 == --o) {
                  b = !0;
                  break;
                }
              } while ((g | m) < y);

              if (b) break;

              do {
                if (0 != (g = e - d(a[c], s, t, e, e - 1, r))) {
                  for (e -= g, v = 1 + (f -= g), p = 1 + (u -= g), h = g - 1; h >= 0; h--) s[v + h] = s[p + h];

                  if (0 === e) {
                    b = !0;
                    break;
                  }
                }

                if (s[f--] = a[c--], 1 == --o) {
                  b = !0;
                  break;
                }

                if (0 != (m = o - l(s[u], a, 0, o, o - 1, r))) {
                  for (o -= m, v = 1 + (f -= m), p = 1 + (c -= m), h = 0; h < m; h++) s[v + h] = a[p + h];

                  if (o <= 1) {
                    b = !0;
                    break;
                  }
                }

                if (s[f--] = s[u--], 0 == --e) {
                  b = !0;
                  break;
                }

                y--;
              } while (g >= i || m >= i);

              if (b) break;
              y < 0 && (y = 0), y += 2;
            }

            if (this.minGallop = y, y < 1 && (this.minGallop = 1), 1 === o) {
              for (v = 1 + (f -= e), p = 1 + (u -= e), h = e - 1; h >= 0; h--) s[v + h] = s[p + h];

              s[f] = a[c];
            } else {
              if (0 === o) throw new Error("mergeHigh preconditions were not respected");

              for (p = f - (o - 1), h = 0; h < o; h++) s[p + h] = a[h];
            }
          } else {
            for (v = 1 + (f -= e), p = 1 + (u -= e), h = e - 1; h >= 0; h--) s[v + h] = s[p + h];

            s[f] = a[c];
          }
        } else for (p = f - (o - 1), h = 0; h < o; h++) s[p + h] = a[h];
      }, t;
    }();
  }(e);
});

(sT = dT) && sT.__esModule && Object.prototype.hasOwnProperty.call(sT, "default") && sT.default;

var uT = dT,
    cT = uT.sort,
    fT = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, [{
    key: "abstract",
    value: function () {
      throw new Error("Can't instantiate abstract class!");
    }
  }, {
    key: "fake_use",
    value: function () {}
  }, {
    key: "curveType",
    value: function () {
      return this.abstract();
    }
  }, {
    key: "getPosition",
    value: function (t) {
      return this.fake_use(t), this.abstract();
    }
  }, {
    key: "setPosition",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
      this.fake_use(t, e, i), this.abstract();
    }
  }, {
    key: "getTreeSize",
    value: function (t) {
      return this.fake_use(t), this.abstract();
    }
  }, {
    key: "sort",
    value: function (t) {
      this.fake_use(t), this.abstract();
    }
  }, {
    key: "fix",
    value: function (t, e) {
      this.fake_use(t, e), this.abstract();
    }
  }, {
    key: "shift",
    value: function (t, e) {
      this.fake_use(t, e), this.abstract();
    }
  }]), t;
}(),
    pT = function (t) {
  function e(t) {
    var i;
    return oc(this, e), (i = TM(this, IM(e).call(this))).layout = t, i;
  }

  return jM(e, fT), hc(e, [{
    key: "curveType",
    value: function () {
      return "horizontal";
    }
  }, {
    key: "getPosition",
    value: function (t) {
      return t.x;
    }
  }, {
    key: "setPosition",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
      void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.x = e;
    }
  }, {
    key: "getTreeSize",
    value: function (t) {
      var e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);
      return {
        min: e.min_x,
        max: e.max_x
      };
    }
  }, {
    key: "sort",
    value: function (t) {
      cT(t, function (t, e) {
        return t.x - e.x;
      });
    }
  }, {
    key: "fix",
    value: function (t, e) {
      t.y = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.y = !0;
    }
  }, {
    key: "shift",
    value: function (t, e) {
      this.layout.body.nodes[t].x += e;
    }
  }]), e;
}(),
    vT = function (t) {
  function e(t) {
    var i;
    return oc(this, e), (i = TM(this, IM(e).call(this))).layout = t, i;
  }

  return jM(e, fT), hc(e, [{
    key: "curveType",
    value: function () {
      return "vertical";
    }
  }, {
    key: "getPosition",
    value: function (t) {
      return t.y;
    }
  }, {
    key: "setPosition",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
      void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.y = e;
    }
  }, {
    key: "getTreeSize",
    value: function (t) {
      var e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);
      return {
        min: e.min_y,
        max: e.max_y
      };
    }
  }, {
    key: "sort",
    value: function (t) {
      cT(t, function (t, e) {
        return t.y - e.y;
      });
    }
  }, {
    key: "fix",
    value: function (t, e) {
      t.x = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.x = !0;
    }
  }, {
    key: "shift",
    value: function (t, e) {
      this.layout.body.nodes[t].y += e;
    }
  }]), e;
}(),
    yT = vh.every;

W({
  target: "Array",
  proto: !0,
  forced: yh("every")
}, {
  every: function (t) {
    return yT(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});

var gT = X("Array").every,
    mT = Array.prototype,
    bT = function (t) {
  var e = t.every;
  return t === mT || t instanceof Array && e === mT.every ? gT : e;
},
    wT = (YD("Set", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0);
  };
}, XD), F.Set);

function _T(t, e) {
  var i = new wT();
  return kh(t).call(t, function (t) {
    var e;
    kh(e = t.edges).call(e, function (t) {
      t.connected && i.add(t);
    });
  }), kh(i).call(i, function (t) {
    var i = t.from.id,
        n = t.to.id;
    null == e[i] && (e[i] = 0), (null == e[n] || e[i] >= e[n]) && (e[n] = e[i] + 1);
  }), e;
}

function kT(t, e, i, n, o) {
  var r = n.size,
      s = i + "Id",
      a = "to" === i ? 1 : -1,
      h = !0,
      l = !1,
      d = void 0;

  try {
    for (var u, c = function () {
      var h = QS(u.value, 2),
          l = h[0],
          d = h[1];
      if (!n.has(l) || !t(d)) return "continue";
      o[l] = 0;

      for (var c = [d], f = 0, p = void 0, v = function () {
        var t, h;
        if (!n.has(l)) return "continue";
        var d = o[p.id] + a;
        if (kh(t = UO(h = p.edges).call(h, function (t) {
          return t.connected && t.to !== t.from && t[i] !== p && n.has(t.toId) && n.has(t.fromId);
        })).call(t, function (t) {
          var n = t[s],
              r = o[n];
          (null == r || e(d, r)) && (o[n] = d, c.push(t[i]));
        }), f > r) return {
          v: {
            v: _T(n, o)
          }
        };
        ++f;
      }; p = c.pop();) {
        var y = v();

        switch (y) {
          case "continue":
            continue;

          default:
            if ("object" === aM(y)) return y.v;
        }
      }
    }, f = kc(n); !(h = (u = f.next()).done); h = !0) {
      var p = c();

      switch (p) {
        case "continue":
          continue;

        default:
          if ("object" === aM(p)) return p.v;
      }
    }
  } catch (t) {
    l = !0, d = t;
  } finally {
    try {
      h || null == f.return || f.return();
    } finally {
      if (l) throw d;
    }
  }

  return o;
}

var xT = function () {
  function t() {
    oc(this, t), this.childrenReference = {}, this.parentReference = {}, this.trees = {}, this.distributionOrdering = {}, this.levels = {}, this.distributionIndex = {}, this.isTree = !1, this.treeIndex = -1;
  }

  return hc(t, [{
    key: "addRelation",
    value: function (t, e) {
      void 0 === this.childrenReference[t] && (this.childrenReference[t] = []), this.childrenReference[t].push(e), void 0 === this.parentReference[e] && (this.parentReference[e] = []), this.parentReference[e].push(t);
    }
  }, {
    key: "checkIfTree",
    value: function () {
      for (var t in this.parentReference) if (this.parentReference[t].length > 1) return void (this.isTree = !1);

      this.isTree = !0;
    }
  }, {
    key: "numTrees",
    value: function () {
      return this.treeIndex + 1;
    }
  }, {
    key: "setTreeIndex",
    value: function (t, e) {
      void 0 !== e && void 0 === this.trees[t.id] && (this.trees[t.id] = e, this.treeIndex = Math.max(e, this.treeIndex));
    }
  }, {
    key: "ensureLevel",
    value: function (t) {
      void 0 === this.levels[t] && (this.levels[t] = 0);
    }
  }, {
    key: "getMaxLevel",
    value: function (t) {
      var e = this,
          i = {};
      return function t(n) {
        if (void 0 !== i[n]) return i[n];
        var o = e.levels[n];

        if (e.childrenReference[n]) {
          var r = e.childrenReference[n];
          if (r.length > 0) for (var s = 0; s < r.length; s++) o = Math.max(o, t(r[s]));
        }

        return i[n] = o, o;
      }(t);
    }
  }, {
    key: "levelDownstream",
    value: function (t, e) {
      void 0 === this.levels[e.id] && (void 0 === this.levels[t.id] && (this.levels[t.id] = 0), this.levels[e.id] = this.levels[t.id] + 1);
    }
  }, {
    key: "setMinLevelToZero",
    value: function (t) {
      var e = 1e9;

      for (var i in t) t.hasOwnProperty(i) && void 0 !== this.levels[i] && (e = Math.min(this.levels[i], e));

      for (var n in t) t.hasOwnProperty(n) && void 0 !== this.levels[n] && (this.levels[n] -= e);
    }
  }, {
    key: "getTreeSize",
    value: function (t, e) {
      var i = 1e9,
          n = -1e9,
          o = 1e9,
          r = -1e9;

      for (var s in this.trees) if (this.trees.hasOwnProperty(s) && this.trees[s] === e) {
        var a = t[s];
        i = Math.min(a.x, i), n = Math.max(a.x, n), o = Math.min(a.y, o), r = Math.max(a.y, r);
      }

      return {
        min_x: i,
        max_x: n,
        min_y: o,
        max_y: r
      };
    }
  }, {
    key: "hasSameParent",
    value: function (t, e) {
      var i = this.parentReference[t.id],
          n = this.parentReference[e.id];
      if (void 0 === i || void 0 === n) return !1;

      for (var o = 0; o < i.length; o++) for (var r = 0; r < n.length; r++) if (i[o] == n[r]) return !0;

      return !1;
    }
  }, {
    key: "inSameSubNetwork",
    value: function (t, e) {
      return this.trees[t.id] === this.trees[e.id];
    }
  }, {
    key: "getLevels",
    value: function () {
      return CS(this.distributionOrdering);
    }
  }, {
    key: "addToOrdering",
    value: function (t, e) {
      void 0 === this.distributionOrdering[e] && (this.distributionOrdering[e] = []);
      var i = !1,
          n = this.distributionOrdering[e];

      for (var o in n) if (n[o] === t) {
        i = !0;
        break;
      }

      i || (this.distributionOrdering[e].push(t), this.distributionIndex[t.id] = this.distributionOrdering[e].length - 1);
    }
  }]), t;
}(),
    OT = function () {
  function t(e) {
    oc(this, t), this.body = e, this.initialRandomSeed = Math.round(1e6 * Math.random()), this.randomSeed = this.initialRandomSeed, this.setPhysics = !1, this.options = {}, this.optionsBackup = {
      physics: {}
    }, this.defaultOptions = {
      randomSeed: void 0,
      improvedLayout: !0,
      clusterThreshold: 150,
      hierarchical: {
        enabled: !1,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: !0,
        edgeMinimization: !0,
        parentCentralization: !0,
        direction: "UD",
        sortMethod: "hubsize"
      }
    }, Yr(this.options, this.defaultOptions), this.bindEventListeners();
  }

  return hc(t, [{
    key: "bindEventListeners",
    value: function () {
      var t = this;
      this.body.emitter.on("_dataChanged", function () {
        t.setupHierarchicalLayout();
      }), this.body.emitter.on("_dataLoaded", function () {
        t.layoutNetwork();
      }), this.body.emitter.on("_resetHierarchicalLayout", function () {
        t.setupHierarchicalLayout();
      }), this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function () {
        if (!0 === t.options.hierarchical.enabled) {
          var e = t.direction.curveType();
          t.body.emitter.emit("_forceDisableDynamicCurves", e, !1);
        }
      });
    }
  }, {
    key: "setOptions",
    value: function (t, e) {
      if (void 0 !== t) {
        var i = this.options.hierarchical,
            n = i.enabled;
        if (Wr(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, t), Ds(this.options, t, "hierarchical"), void 0 !== t.randomSeed && (this.initialRandomSeed = t.randomSeed), !0 === i.enabled) return !0 === n && this.body.emitter.emit("refresh", !0), "RL" === i.direction || "DU" === i.direction ? i.levelSeparation > 0 && (i.levelSeparation *= -1) : i.levelSeparation < 0 && (i.levelSeparation *= -1), this.setDirectionStrategy(), this.body.emitter.emit("_resetHierarchicalLayout"), this.adaptAllOptionsForHierarchicalLayout(e);
        if (!0 === n) return this.body.emitter.emit("refresh"), Ur(e, this.optionsBackup);
      }

      return e;
    }
  }, {
    key: "adaptAllOptionsForHierarchicalLayout",
    value: function (t) {
      if (!0 === this.options.hierarchical.enabled) {
        var e = this.optionsBackup.physics;
        void 0 === t.physics || !0 === t.physics ? (t.physics = {
          enabled: void 0 === e.enabled || e.enabled,
          solver: "hierarchicalRepulsion"
        }, e.enabled = void 0 === e.enabled || e.enabled, e.solver = e.solver || "barnesHut") : "object" === aM(t.physics) ? (e.enabled = void 0 === t.physics.enabled || t.physics.enabled, e.solver = t.physics.solver || "barnesHut", t.physics.solver = "hierarchicalRepulsion") : !1 !== t.physics && (e.solver = "barnesHut", t.physics = {
          solver: "hierarchicalRepulsion"
        });
        var i = this.direction.curveType();
        if (void 0 === t.edges) this.optionsBackup.edges = {
          smooth: {
            enabled: !0,
            type: "dynamic"
          }
        }, t.edges = {
          smooth: !1
        };else if (void 0 === t.edges.smooth) this.optionsBackup.edges = {
          smooth: {
            enabled: !0,
            type: "dynamic"
          }
        }, t.edges.smooth = !1;else if ("boolean" == typeof t.edges.smooth) this.optionsBackup.edges = {
          smooth: t.edges.smooth
        }, t.edges.smooth = {
          enabled: t.edges.smooth,
          type: i
        };else {
          var n = t.edges.smooth;
          void 0 !== n.type && "dynamic" !== n.type && (i = n.type), this.optionsBackup.edges = {
            smooth: void 0 === n.enabled || n.enabled,
            type: void 0 === n.type ? "dynamic" : n.type,
            roundness: void 0 === n.roundness ? .5 : n.roundness,
            forceDirection: void 0 !== n.forceDirection && n.forceDirection
          }, t.edges.smooth = {
            enabled: void 0 === n.enabled || n.enabled,
            type: i,
            roundness: void 0 === n.roundness ? .5 : n.roundness,
            forceDirection: void 0 !== n.forceDirection && n.forceDirection
          };
        }
        this.body.emitter.emit("_forceDisableDynamicCurves", i);
      }

      return t;
    }
  }, {
    key: "seededRandom",
    value: function () {
      var t = 1e4 * Math.sin(this.randomSeed++);
      return t - Math.floor(t);
    }
  }, {
    key: "positionInitially",
    value: function (t) {
      if (!0 !== this.options.hierarchical.enabled) {
        this.randomSeed = this.initialRandomSeed;

        for (var e = t.length + 50, i = 0; i < t.length; i++) {
          var n = t[i],
              o = 2 * Math.PI * this.seededRandom();
          void 0 === n.x && (n.x = e * Math.cos(o)), void 0 === n.y && (n.y = e * Math.sin(o));
        }
      }
    }
  }, {
    key: "layoutNetwork",
    value: function () {
      if (!0 !== this.options.hierarchical.enabled && !0 === this.options.improvedLayout) {
        for (var t = this.body.nodeIndices, e = 0, i = 0; i < t.length; i++) {
          !0 === this.body.nodes[t[i]].predefinedPosition && (e += 1);
        }

        if (e < .5 * t.length) {
          var n = 0,
              o = this.options.clusterThreshold,
              r = {
            clusterNodeProperties: {
              shape: "ellipse",
              label: "",
              group: "",
              font: {
                multi: !1
              }
            },
            clusterEdgeProperties: {
              label: "",
              font: {
                multi: !1
              },
              smooth: {
                enabled: !1
              }
            }
          };

          if (t.length > o) {
            for (var s = t.length; t.length > o && n <= 10;) {
              n += 1;
              var a = t.length;
              if (n % 3 == 0 ? this.body.modules.clustering.clusterBridges(r) : this.body.modules.clustering.clusterOutliers(r), a == t.length && n % 3 != 0) return this._declusterAll(), this.body.emitter.emit("_layoutFailed"), void console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
            }

            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * s)
            });
          }

          n > 10 && console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."), this.body.modules.kamadaKawai.solve(t, this.body.edgeIndices, !0), this._shiftToCenter();

          for (var h = 0; h < t.length; h++) {
            var l = this.body.nodes[t[h]];
            !1 === l.predefinedPosition && (l.x += 70 * (.5 - this.seededRandom()), l.y += 70 * (.5 - this.seededRandom()));
          }

          this._declusterAll(), this.body.emitter.emit("_repositionBezierNodes");
        }
      }
    }
  }, {
    key: "_shiftToCenter",
    value: function () {
      for (var t = vD.getRangeCore(this.body.nodes, this.body.nodeIndices), e = vD.findCenter(t), i = 0; i < this.body.nodeIndices.length; i++) {
        var n = this.body.nodes[this.body.nodeIndices[i]];
        n.x -= e.x, n.y -= e.y;
      }
    }
  }, {
    key: "_declusterAll",
    value: function () {
      for (var t = !0; !0 === t;) {
        t = !1;

        for (var e = 0; e < this.body.nodeIndices.length; e++) !0 === this.body.nodes[this.body.nodeIndices[e]].isCluster && (t = !0, this.body.modules.clustering.openCluster(this.body.nodeIndices[e], {}, !1));

        !0 === t && this.body.emitter.emit("_dataChanged");
      }
    }
  }, {
    key: "getSeed",
    value: function () {
      return this.initialRandomSeed;
    }
  }, {
    key: "setupHierarchicalLayout",
    value: function () {
      if (!0 === this.options.hierarchical.enabled && this.body.nodeIndices.length > 0) {
        var t,
            e,
            i = !1,
            n = !1;

        for (e in this.lastNodeOnLevel = {}, this.hierarchical = new xT(), this.body.nodes) this.body.nodes.hasOwnProperty(e) && (void 0 !== (t = this.body.nodes[e]).options.level ? (i = !0, this.hierarchical.levels[e] = t.options.level) : n = !0);

        if (!0 === n && !0 === i) throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");

        if (!0 === n) {
          var o = this.options.hierarchical.sortMethod;
          "hubsize" === o ? this._determineLevelsByHubsize() : "directed" === o ? this._determineLevelsDirected() : "custom" === o && this._determineLevelsCustomCallback();
        }

        for (var r in this.body.nodes) this.body.nodes.hasOwnProperty(r) && this.hierarchical.ensureLevel(r);

        var s = this._getDistribution();

        this._generateMap(), this._placeNodesByHierarchy(s), this._condenseHierarchy(), this._shiftToCenter();
      }
    }
  }, {
    key: "_condenseHierarchy",
    value: function () {
      var t = this,
          e = !1,
          i = {},
          n = function (e, i) {
        var n = t.hierarchical.trees;

        for (var o in n) n.hasOwnProperty(o) && n[o] === e && t.direction.shift(o, i);
      },
          o = function () {
        for (var e = [], i = 0; i < t.hierarchical.numTrees(); i++) e.push(t.direction.getTreeSize(i));

        return e;
      },
          r = function e(i, n) {
        if (!n[i.id] && (n[i.id] = !0, t.hierarchical.childrenReference[i.id])) {
          var o = t.hierarchical.childrenReference[i.id];
          if (o.length > 0) for (var r = 0; r < o.length; r++) e(t.body.nodes[o[r]], n);
        }
      },
          s = function (e) {
        var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e9,
            n = 1e9,
            o = 1e9,
            r = 1e9,
            s = -1e9;

        for (var a in e) if (e.hasOwnProperty(a)) {
          var h = t.body.nodes[a],
              l = t.hierarchical.levels[h.id],
              d = t.direction.getPosition(h),
              u = t._getSpaceAroundNode(h, e),
              c = QS(u, 2),
              f = c[0],
              p = c[1];

          n = Math.min(f, n), o = Math.min(p, o), l <= i && (r = Math.min(d, r), s = Math.max(d, s));
        }

        return [r, s, n, o];
      },
          a = function (e, i) {
        var n = t.hierarchical.getMaxLevel(e.id),
            o = t.hierarchical.getMaxLevel(i.id);
        return Math.min(n, o);
      },
          h = function (e, i, n) {
        for (var o = t.hierarchical, r = 0; r < i.length; r++) {
          var s = i[r],
              a = o.distributionOrdering[s];
          if (a.length > 1) for (var h = 0; h < a.length - 1; h++) {
            var l = a[h],
                d = a[h + 1];
            o.hasSameParent(l, d) && o.inSameSubNetwork(l, d) && e(l, d, n);
          }
        }
      },
          l = function (i, n) {
        var o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            h = t.direction.getPosition(i),
            l = t.direction.getPosition(n),
            d = Math.abs(l - h),
            u = t.options.hierarchical.nodeSpacing;

        if (d > u) {
          var c = {},
              f = {};
          r(i, c), r(n, f);
          var p = a(i, n),
              v = s(c, p),
              y = s(f, p),
              g = v[1],
              m = y[0],
              b = y[2],
              w = Math.abs(g - m);

          if (w > u) {
            var _ = g - m + u;

            _ < -b + u && (_ = -b + u), _ < 0 && (t._shiftBlock(n.id, _), e = !0, !0 === o && t._centerParent(n));
          }
        }
      },
          d = function (n, o) {
        for (var a = o.id, h = o.edges, l = t.hierarchical.levels[o.id], d = t.options.hierarchical.levelSeparation * t.options.hierarchical.levelSeparation, u = {}, c = [], f = 0; f < h.length; f++) {
          var p = h[f];

          if (p.toId != p.fromId) {
            var v = p.toId == a ? p.from : p.to;
            u[h[f].id] = v, t.hierarchical.levels[v.id] < l && c.push(p);
          }
        }

        var y = function (e, i) {
          for (var n = 0, o = 0; o < i.length; o++) if (void 0 !== u[i[o].id]) {
            var r = t.direction.getPosition(u[i[o].id]) - e;
            n += r / Math.sqrt(r * r + d);
          }

          return n;
        },
            g = function (e, i) {
          for (var n = 0, o = 0; o < i.length; o++) if (void 0 !== u[i[o].id]) {
            var r = t.direction.getPosition(u[i[o].id]) - e;
            n -= d * Math.pow(r * r + d, -1.5);
          }

          return n;
        },
            m = function (e, i) {
          for (var n = t.direction.getPosition(o), r = {}, s = 0; s < e; s++) {
            var a = y(n, i),
                h = g(n, i);
            if (void 0 !== r[n -= Math.max(-40, Math.min(40, Math.round(a / h)))]) break;
            r[n] = s;
          }

          return n;
        },
            b = m(n, c);

        !function (n) {
          var a = t.direction.getPosition(o);

          if (void 0 === i[o.id]) {
            var h = {};
            r(o, h), i[o.id] = h;
          }

          var l = s(i[o.id]),
              d = l[2],
              u = l[3],
              c = n - a,
              f = 0;
          c > 0 ? f = Math.min(c, u - t.options.hierarchical.nodeSpacing) : c < 0 && (f = -Math.min(-c, d - t.options.hierarchical.nodeSpacing)), 0 != f && (t._shiftBlock(o.id, f), e = !0);
        }(b), function (i) {
          var n = t.direction.getPosition(o),
              r = t._getSpaceAroundNode(o),
              s = QS(r, 2),
              a = s[0],
              h = s[1],
              l = i - n,
              d = n;

          l > 0 ? d = Math.min(n + (h - t.options.hierarchical.nodeSpacing), i) : l < 0 && (d = Math.max(n - (a - t.options.hierarchical.nodeSpacing), i)), d !== n && (t.direction.setPosition(o, d), e = !0);
        }(b = m(n, h));
      };

      !0 === this.options.hierarchical.blockShifting && (function (i) {
        var n = t.hierarchical.getLevels();
        n = pD(n).call(n);

        for (var o = 0; o < i && (e = !1, h(l, n, !0), !0 === e); o++);
      }(5), function () {
        for (var e in t.body.nodes) t.body.nodes.hasOwnProperty(e) && t._centerParent(t.body.nodes[e]);
      }()), !0 === this.options.hierarchical.edgeMinimization && function (i) {
        var n = t.hierarchical.getLevels();
        n = pD(n).call(n);

        for (var o = 0; o < i; o++) {
          e = !1;

          for (var r = 0; r < n.length; r++) for (var s = n[r], a = t.hierarchical.distributionOrdering[s], h = 0; h < a.length; h++) d(1e3, a[h]);

          if (!0 !== e) break;
        }
      }(20), !0 === this.options.hierarchical.parentCentralization && function () {
        var e = t.hierarchical.getLevels();
        e = pD(e).call(e);

        for (var i = 0; i < e.length; i++) for (var n = e[i], o = t.hierarchical.distributionOrdering[n], r = 0; r < o.length; r++) t._centerParent(o[r]);
      }(), function () {
        for (var e = o(), i = 0, r = 0; r < e.length - 1; r++) {
          i += e[r].max - e[r + 1].min + t.options.hierarchical.treeSpacing, n(r + 1, i);
        }
      }();
    }
  }, {
    key: "_getSpaceAroundNode",
    value: function (t, e) {
      var i = !0;
      void 0 === e && (i = !1);
      var n = this.hierarchical.levels[t.id];

      if (void 0 !== n) {
        var o = this.hierarchical.distributionIndex[t.id],
            r = this.direction.getPosition(t),
            s = this.hierarchical.distributionOrdering[n],
            a = 1e9,
            h = 1e9;

        if (0 !== o) {
          var l = s[o - 1];
          if (!0 === i && void 0 === e[l.id] || !1 === i) a = r - this.direction.getPosition(l);
        }

        if (o != s.length - 1) {
          var d = s[o + 1];

          if (!0 === i && void 0 === e[d.id] || !1 === i) {
            var u = this.direction.getPosition(d);
            h = Math.min(h, u - r);
          }
        }

        return [a, h];
      }

      return [0, 0];
    }
  }, {
    key: "_centerParent",
    value: function (t) {
      if (this.hierarchical.parentReference[t.id]) for (var e = this.hierarchical.parentReference[t.id], i = 0; i < e.length; i++) {
        var n = e[i],
            o = this.body.nodes[n],
            r = this.hierarchical.childrenReference[n];

        if (void 0 !== r) {
          var s = this._getCenterPosition(r),
              a = this.direction.getPosition(o),
              h = this._getSpaceAroundNode(o),
              l = QS(h, 2),
              d = l[0],
              u = l[1],
              c = a - s;

          (c < 0 && Math.abs(c) < u - this.options.hierarchical.nodeSpacing || c > 0 && Math.abs(c) < d - this.options.hierarchical.nodeSpacing) && this.direction.setPosition(o, s);
        }
      }
    }
  }, {
    key: "_placeNodesByHierarchy",
    value: function (t) {
      for (var e in this.positionedNodes = {}, t) if (t.hasOwnProperty(e)) {
        var i,
            n = CS(t[e]);
        n = this._indexArrayToNodes(n), lT(i = this.direction).call(i, n);

        for (var o = 0, r = 0; r < n.length; r++) {
          var s = n[r];

          if (void 0 === this.positionedNodes[s.id]) {
            var a = this.options.hierarchical.nodeSpacing,
                h = a * o;
            o > 0 && (h = this.direction.getPosition(n[r - 1]) + a), this.direction.setPosition(s, h, e), this._validatePositionAndContinue(s, e, h), o++;
          }
        }
      }
    }
  }, {
    key: "_placeBranchNodes",
    value: function (t, e) {
      var i,
          n = this.hierarchical.childrenReference[t];

      if (void 0 !== n) {
        for (var o = [], r = 0; r < n.length; r++) o.push(this.body.nodes[n[r]]);

        lT(i = this.direction).call(i, o);

        for (var s = 0; s < o.length; s++) {
          var a = o[s],
              h = this.hierarchical.levels[a.id];
          if (!(h > e && void 0 === this.positionedNodes[a.id])) return;
          var l = this.options.hierarchical.nodeSpacing,
              d = void 0;
          d = 0 === s ? this.direction.getPosition(this.body.nodes[t]) : this.direction.getPosition(o[s - 1]) + l, this.direction.setPosition(a, d, h), this._validatePositionAndContinue(a, h, d);
        }

        var u = this._getCenterPosition(o);

        this.direction.setPosition(this.body.nodes[t], u, e);
      }
    }
  }, {
    key: "_validatePositionAndContinue",
    value: function (t, e, i) {
      if (this.hierarchical.isTree) {
        if (void 0 !== this.lastNodeOnLevel[e]) {
          var n = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);

          if (i - n < this.options.hierarchical.nodeSpacing) {
            var o = n + this.options.hierarchical.nodeSpacing - i,
                r = this._findCommonParent(this.lastNodeOnLevel[e], t.id);

            this._shiftBlock(r.withChild, o);
          }
        }

        this.lastNodeOnLevel[e] = t.id, this.positionedNodes[t.id] = !0, this._placeBranchNodes(t.id, e);
      }
    }
  }, {
    key: "_indexArrayToNodes",
    value: function (t) {
      for (var e = [], i = 0; i < t.length; i++) e.push(this.body.nodes[t[i]]);

      return e;
    }
  }, {
    key: "_getDistribution",
    value: function () {
      var t,
          e,
          i = {};

      for (t in this.body.nodes) if (this.body.nodes.hasOwnProperty(t)) {
        e = this.body.nodes[t];
        var n = void 0 === this.hierarchical.levels[t] ? 0 : this.hierarchical.levels[t];
        this.direction.fix(e, n), void 0 === i[n] && (i[n] = {}), i[n][t] = e;
      }

      return i;
    }
  }, {
    key: "_getActiveEdges",
    value: function (t) {
      var e = this,
          i = [];
      return es(t.edges, function (t) {
        var n;
        -1 !== el(n = e.body.edgeIndices).call(n, t.id) && i.push(t);
      }), i;
    }
  }, {
    key: "_getHubSizes",
    value: function () {
      var t = this,
          e = {};
      es(this.body.nodeIndices, function (i) {
        var n = t.body.nodes[i],
            o = t._getActiveEdges(n).length;

        e[o] = !0;
      });
      var i = [];
      return es(e, function (t) {
        i.push(Number(t));
      }), lT(uT).call(uT, i, function (t, e) {
        return e - t;
      }), i;
    }
  }, {
    key: "_determineLevelsByHubsize",
    value: function () {
      for (var t = this, e = function (e, i) {
        t.hierarchical.levelDownstream(e, i);
      }, i = this._getHubSizes(), n = function (n) {
        var o = i[n];
        if (0 === o) return "break";
        es(t.body.nodeIndices, function (i) {
          var n = t.body.nodes[i];
          o === t._getActiveEdges(n).length && t._crawlNetwork(e, i);
        });
      }, o = 0; o < i.length; ++o) {
        if ("break" === n(o)) break;
      }
    }
  }, {
    key: "_determineLevelsCustomCallback",
    value: function () {
      var t = this;
      this._crawlNetwork(function (e, i, n) {
        var o = t.hierarchical.levels[e.id];
        void 0 === o && (o = t.hierarchical.levels[e.id] = 1e5);
        var r = (vD.cloneOptions(e, "node"), vD.cloneOptions(i, "node"), void vD.cloneOptions(n, "edge"));
        t.hierarchical.levels[i.id] = o + r;
      }), this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
  }, {
    key: "_determineLevelsDirected",
    value: function () {
      var t,
          e = this,
          i = tT(t = this.body.nodeIndices).call(t, function (t, i) {
        return t.set(i, e.body.nodes[i]), t;
      }, new ZD()),
          n = this.hierarchical.levels;
      "roots" === this.options.hierarchical.shakeTowards ? this.hierarchical.levels = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ol(null);
        return kT(function (e) {
          var i, n;
          return bT(i = UO(n = e.edges).call(n, function (e) {
            return t.has(e.toId);
          })).call(i, function (t) {
            return t.from === e;
          });
        }, function (t, e) {
          return e < t;
        }, "to", t, e);
      }(i, n) : this.hierarchical.levels = function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ol(null);
        return kT(function (e) {
          var i, n;
          return bT(i = UO(n = e.edges).call(n, function (e) {
            return t.has(e.toId);
          })).call(i, function (t) {
            return t.to === e;
          });
        }, function (t, e) {
          return e > t;
        }, "from", t, e);
      }(i, n), this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
  }, {
    key: "_generateMap",
    value: function () {
      var t = this;
      this._crawlNetwork(function (e, i) {
        t.hierarchical.levels[i.id] > t.hierarchical.levels[e.id] && t.hierarchical.addRelation(e.id, i.id);
      }), this.hierarchical.checkIfTree();
    }
  }, {
    key: "_crawlNetwork",
    value: function () {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {},
          i = arguments.length > 1 ? arguments[1] : void 0,
          n = {},
          o = function i(o, r) {
        if (void 0 === n[o.id]) {
          var s;
          t.hierarchical.setTreeIndex(o, r), n[o.id] = !0;

          for (var a = t._getActiveEdges(o), h = 0; h < a.length; h++) {
            var l = a[h];
            !0 === l.connected && (s = l.toId == o.id ? l.from : l.to, o.id != s.id && (e(o, s, l), i(s, r)));
          }
        }
      };

      if (void 0 === i) for (var r = 0, s = 0; s < this.body.nodeIndices.length; s++) {
        var a = this.body.nodeIndices[s];

        if (void 0 === n[a]) {
          var h = this.body.nodes[a];
          o(h, r), r += 1;
        }
      } else {
        var l = this.body.nodes[i];
        if (void 0 === l) return void console.error("Node not found:", i);
        o(l);
      }
    }
  }, {
    key: "_shiftBlock",
    value: function (t, e) {
      var i = this,
          n = {};
      !function t(o) {
        if (!n[o]) {
          n[o] = !0, i.direction.shift(o, e);
          var r = i.hierarchical.childrenReference[o];
          if (void 0 !== r) for (var s = 0; s < r.length; s++) t(r[s]);
        }
      }(t);
    }
  }, {
    key: "_findCommonParent",
    value: function (t, e) {
      var i = this,
          n = {};
      return function t(e, n) {
        var o = i.hierarchical.parentReference[n];
        if (void 0 !== o) for (var r = 0; r < o.length; r++) {
          var s = o[r];
          e[s] = !0, t(e, s);
        }
      }(n, t), function t(e, n) {
        var o = i.hierarchical.parentReference[n];
        if (void 0 !== o) for (var r = 0; r < o.length; r++) {
          var s = o[r];
          if (void 0 !== e[s]) return {
            foundParent: s,
            withChild: n
          };
          var a = t(e, s);
          if (null !== a.foundParent) return a;
        }
        return {
          foundParent: null,
          withChild: n
        };
      }(n, e);
    }
  }, {
    key: "setDirectionStrategy",
    value: function () {
      var t = "UD" === this.options.hierarchical.direction || "DU" === this.options.hierarchical.direction;
      this.direction = t ? new pT(this) : new vT(this);
    }
  }, {
    key: "_getCenterPosition",
    value: function (t) {
      for (var e = 1e9, i = -1e9, n = 0; n < t.length; n++) {
        var o = void 0;
        if (void 0 !== t[n].id) o = t[n];else {
          var r = t[n];
          o = this.body.nodes[r];
        }
        var s = this.direction.getPosition(o);
        e = Math.min(e, s), i = Math.max(i, s);
      }

      return .5 * (e + i);
    }
  }]), t;
}(),
    ST = function () {
  function t(e, i, n, o) {
    var r,
        s,
        a = this;
    oc(this, t), this.body = e, this.canvas = i, this.selectionHandler = n, this.interactionHandler = o, this.editMode = !1, this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0, this.manipulationHammers = [], this.temporaryUIFunctions = {}, this.temporaryEventFunctions = [], this.touchTime = 0, this.temporaryIds = {
      nodes: [],
      edges: []
    }, this.guiEnabled = !1, this.inMode = !1, this.selectedControlNode = void 0, this.options = {}, this.defaultOptions = {
      enabled: !1,
      initiallyActive: !1,
      addNode: !0,
      addEdge: !0,
      editNode: void 0,
      editEdge: !0,
      deleteNode: !0,
      deleteEdge: !0,
      controlNodeStyle: {
        shape: "dot",
        size: 6,
        color: {
          background: "#ff0000",
          border: "#3c3c3c",
          highlight: {
            background: "#07f968",
            border: "#3c3c3c"
          }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    }, Yr(this.options, this.defaultOptions), this.body.emitter.on("destroy", function () {
      a._clean();
    }), this.body.emitter.on("_dataChanged", $(r = this._restore).call(r, this)), this.body.emitter.on("_resetData", $(s = this._restore).call(s, this));
  }

  return hc(t, [{
    key: "_restore",
    value: function () {
      !1 !== this.inMode && (!0 === this.options.initiallyActive ? this.enableEditMode() : this.disableEditMode());
    }
  }, {
    key: "setOptions",
    value: function (t, e, i) {
      void 0 !== e && (void 0 !== e.locale ? this.options.locale = e.locale : this.options.locale = i.locale, void 0 !== e.locales ? this.options.locales = e.locales : this.options.locales = i.locales), void 0 !== t && ("boolean" == typeof t ? this.options.enabled = t : (this.options.enabled = !0, Ur(this.options, t)), !0 === this.options.initiallyActive && (this.editMode = !0), this._setup());
    }
  }, {
    key: "toggleEditMode",
    value: function () {
      !0 === this.editMode ? this.disableEditMode() : this.enableEditMode();
    }
  }, {
    key: "enableEditMode",
    value: function () {
      this.editMode = !0, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = "block", this.closeDiv.style.display = "block", this.editModeDiv.style.display = "none", this.showManipulatorToolbar());
    }
  }, {
    key: "disableEditMode",
    value: function () {
      this.editMode = !1, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = "none", this.closeDiv.style.display = "none", this.editModeDiv.style.display = "block", this._createEditButton());
    }
  }, {
    key: "showManipulatorToolbar",
    value: function () {
      if (this._clean(), this.manipulationDOM = {}, !0 === this.guiEnabled) {
        var t, e;
        this.editMode = !0, this.manipulationDiv.style.display = "block", this.closeDiv.style.display = "block";

        var i = this.selectionHandler._getSelectedNodeCount(),
            n = this.selectionHandler._getSelectedEdgeCount(),
            o = i + n,
            r = this.options.locales[this.options.locale],
            s = !1;

        !1 !== this.options.addNode && (this._createAddNodeButton(r), s = !0), !1 !== this.options.addEdge && (!0 === s ? this._createSeperator(1) : s = !0, this._createAddEdgeButton(r)), 1 === i && "function" == typeof this.options.editNode ? (!0 === s ? this._createSeperator(2) : s = !0, this._createEditNodeButton(r)) : 1 === n && 0 === i && !1 !== this.options.editEdge && (!0 === s ? this._createSeperator(3) : s = !0, this._createEditEdgeButton(r)), 0 !== o && (i > 0 && !1 !== this.options.deleteNode ? (!0 === s && this._createSeperator(4), this._createDeleteButton(r)) : 0 === i && !1 !== this.options.deleteEdge && (!0 === s && this._createSeperator(4), this._createDeleteButton(r))), this._bindHammerToDiv(this.closeDiv, $(t = this.toggleEditMode).call(t, this)), this._temporaryBindEvent("select", $(e = this.showManipulatorToolbar).call(e, this));
      }

      this.body.emitter.emit("_redraw");
    }
  }, {
    key: "addNodeMode",
    value: function () {
      var t;

      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "addNode", !0 === this.guiEnabled) {
        var e,
            i = this.options.locales[this.options.locale];
        this.manipulationDOM = {}, this._createBackButton(i), this._createSeperator(), this._createDescription(i.addDescription || this.options.locales.en.addDescription), this._bindHammerToDiv(this.closeDiv, $(e = this.toggleEditMode).call(e, this));
      }

      this._temporaryBindEvent("click", $(t = this._performAddNode).call(t, this));
    }
  }, {
    key: "editNode",
    value: function () {
      var t = this;
      !0 !== this.editMode && this.enableEditMode(), this._clean();

      var e = this.selectionHandler._getSelectedNode();

      if (void 0 !== e) {
        if (this.inMode = "editNode", "function" != typeof this.options.editNode) throw new Error("No function has been configured to handle the editing of nodes.");

        if (!0 !== e.isCluster) {
          var i = Ur({}, e.options, !1);
          if (i.x = e.x, i.y = e.y, 2 !== this.options.editNode.length) throw new Error("The function for edit does not support two arguments (data, callback)");
          this.options.editNode(i, function (e) {
            null != e && "editNode" === t.inMode && t.body.data.nodes.getDataSet().update(e), t.showManipulatorToolbar();
          });
        } else alert(this.options.locales[this.options.locale].editClusterError || this.options.locales.en.editClusterError);
      } else this.showManipulatorToolbar();
    }
  }, {
    key: "addEdgeMode",
    value: function () {
      var t, e, i, n, o;

      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "addEdge", !0 === this.guiEnabled) {
        var r,
            s = this.options.locales[this.options.locale];
        this.manipulationDOM = {}, this._createBackButton(s), this._createSeperator(), this._createDescription(s.edgeDescription || this.options.locales.en.edgeDescription), this._bindHammerToDiv(this.closeDiv, $(r = this.toggleEditMode).call(r, this));
      }

      this._temporaryBindUI("onTouch", $(t = this._handleConnect).call(t, this)), this._temporaryBindUI("onDragEnd", $(e = this._finishConnect).call(e, this)), this._temporaryBindUI("onDrag", $(i = this._dragControlNode).call(i, this)), this._temporaryBindUI("onRelease", $(n = this._finishConnect).call(n, this)), this._temporaryBindUI("onDragStart", $(o = this._dragStartEdge).call(o, this)), this._temporaryBindUI("onHold", function () {});
    }
  }, {
    key: "editEdgeMode",
    value: function () {
      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "editEdge", "object" !== aM(this.options.editEdge) || "function" != typeof this.options.editEdge.editWithoutDrag || (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 === this.edgeBeingEditedId)) {
        if (!0 === this.guiEnabled) {
          var t,
              e = this.options.locales[this.options.locale];
          this.manipulationDOM = {}, this._createBackButton(e), this._createSeperator(), this._createDescription(e.editEdgeDescription || this.options.locales.en.editEdgeDescription), this._bindHammerToDiv(this.closeDiv, $(t = this.toggleEditMode).call(t, this));
        }

        if (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 !== this.edgeBeingEditedId) {
          var i,
              n,
              o,
              r,
              s = this.body.edges[this.edgeBeingEditedId],
              a = this._getNewTargetNode(s.from.x, s.from.y),
              h = this._getNewTargetNode(s.to.x, s.to.y);

          this.temporaryIds.nodes.push(a.id), this.temporaryIds.nodes.push(h.id), this.body.nodes[a.id] = a, this.body.nodeIndices.push(a.id), this.body.nodes[h.id] = h, this.body.nodeIndices.push(h.id), this._temporaryBindUI("onTouch", $(i = this._controlNodeTouch).call(i, this)), this._temporaryBindUI("onTap", function () {}), this._temporaryBindUI("onHold", function () {}), this._temporaryBindUI("onDragStart", $(n = this._controlNodeDragStart).call(n, this)), this._temporaryBindUI("onDrag", $(o = this._controlNodeDrag).call(o, this)), this._temporaryBindUI("onDragEnd", $(r = this._controlNodeDragEnd).call(r, this)), this._temporaryBindUI("onMouseMove", function () {}), this._temporaryBindEvent("beforeDrawing", function (t) {
            var e = s.edgeType.findBorderPositions(t);
            !1 === a.selected && (a.x = e.from.x, a.y = e.from.y), !1 === h.selected && (h.x = e.to.x, h.y = e.to.y);
          }), this.body.emitter.emit("_redraw");
        } else this.showManipulatorToolbar();
      } else {
        var l = this.body.edges[this.edgeBeingEditedId];

        this._performEditEdge(l.from.id, l.to.id);
      }
    }
  }, {
    key: "deleteSelected",
    value: function () {
      var t = this;
      !0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "delete";
      var e = this.selectionHandler.getSelectedNodes(),
          i = this.selectionHandler.getSelectedEdges(),
          n = void 0;

      if (e.length > 0) {
        for (var o = 0; o < e.length; o++) if (!0 === this.body.nodes[e[o]].isCluster) return void alert(this.options.locales[this.options.locale].deleteClusterError || this.options.locales.en.deleteClusterError);

        "function" == typeof this.options.deleteNode && (n = this.options.deleteNode);
      } else i.length > 0 && "function" == typeof this.options.deleteEdge && (n = this.options.deleteEdge);

      if ("function" == typeof n) {
        var r = {
          nodes: e,
          edges: i
        };
        if (2 !== n.length) throw new Error("The function for delete does not support two arguments (data, callback)");
        n(r, function (e) {
          null != e && "delete" === t.inMode ? (t.body.data.edges.getDataSet().remove(e.edges), t.body.data.nodes.getDataSet().remove(e.nodes), t.body.emitter.emit("startSimulation"), t.showManipulatorToolbar()) : (t.body.emitter.emit("startSimulation"), t.showManipulatorToolbar());
        });
      } else this.body.data.edges.getDataSet().remove(i), this.body.data.nodes.getDataSet().remove(e), this.body.emitter.emit("startSimulation"), this.showManipulatorToolbar();
    }
  }, {
    key: "_setup",
    value: function () {
      !0 === this.options.enabled ? (this.guiEnabled = !0, this._createWrappers(), !1 === this.editMode ? this._createEditButton() : this.showManipulatorToolbar()) : (this._removeManipulationDOM(), this.guiEnabled = !1);
    }
  }, {
    key: "_createWrappers",
    value: function () {
      void 0 === this.manipulationDiv && (this.manipulationDiv = document.createElement("div"), this.manipulationDiv.className = "vis-manipulation", !0 === this.editMode ? this.manipulationDiv.style.display = "block" : this.manipulationDiv.style.display = "none", this.canvas.frame.appendChild(this.manipulationDiv)), void 0 === this.editModeDiv && (this.editModeDiv = document.createElement("div"), this.editModeDiv.className = "vis-edit-mode", !0 === this.editMode ? this.editModeDiv.style.display = "none" : this.editModeDiv.style.display = "block", this.canvas.frame.appendChild(this.editModeDiv)), void 0 === this.closeDiv && (this.closeDiv = document.createElement("div"), this.closeDiv.className = "vis-close", this.closeDiv.style.display = this.manipulationDiv.style.display, this.canvas.frame.appendChild(this.closeDiv));
    }
  }, {
    key: "_getNewTargetNode",
    value: function (t, e) {
      var i = Ur({}, this.options.controlNodeStyle);
      i.id = "targetNode" + Er(), i.hidden = !1, i.physics = !1, i.x = t, i.y = e;
      var n = this.body.functions.createNode(i);
      return n.shape.boundingBox = {
        left: t,
        right: t,
        top: e,
        bottom: e
      }, n;
    }
  }, {
    key: "_createEditButton",
    value: function () {
      var t;
      this._clean(), this.manipulationDOM = {}, Nr(this.editModeDiv);

      var e = this.options.locales[this.options.locale],
          i = this._createButton("editMode", "vis-button vis-edit vis-edit-mode", e.edit || this.options.locales.en.edit);

      this.editModeDiv.appendChild(i), this._bindHammerToDiv(i, $(t = this.toggleEditMode).call(t, this));
    }
  }, {
    key: "_clean",
    value: function () {
      this.inMode = !1, !0 === this.guiEnabled && (Nr(this.editModeDiv), Nr(this.manipulationDiv), this._cleanManipulatorHammers()), this._cleanupTemporaryNodesAndEdges(), this._unbindTemporaryUIs(), this._unbindTemporaryEvents(), this.body.emitter.emit("restorePhysics");
    }
  }, {
    key: "_cleanManipulatorHammers",
    value: function () {
      if (0 != this.manipulationHammers.length) {
        for (var t = 0; t < this.manipulationHammers.length; t++) this.manipulationHammers[t].destroy();

        this.manipulationHammers = [];
      }
    }
  }, {
    key: "_removeManipulationDOM",
    value: function () {
      this._clean(), Nr(this.manipulationDiv), Nr(this.editModeDiv), Nr(this.closeDiv), this.manipulationDiv && this.canvas.frame.removeChild(this.manipulationDiv), this.editModeDiv && this.canvas.frame.removeChild(this.editModeDiv), this.closeDiv && this.canvas.frame.removeChild(this.closeDiv), this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0;
    }
  }, {
    key: "_createSeperator",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
      this.manipulationDOM["seperatorLineDiv" + t] = document.createElement("div"), this.manipulationDOM["seperatorLineDiv" + t].className = "vis-separator-line", this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + t]);
    }
  }, {
    key: "_createAddNodeButton",
    value: function (t) {
      var e,
          i = this._createButton("addNode", "vis-button vis-add", t.addNode || this.options.locales.en.addNode);

      this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, $(e = this.addNodeMode).call(e, this));
    }
  }, {
    key: "_createAddEdgeButton",
    value: function (t) {
      var e,
          i = this._createButton("addEdge", "vis-button vis-connect", t.addEdge || this.options.locales.en.addEdge);

      this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, $(e = this.addEdgeMode).call(e, this));
    }
  }, {
    key: "_createEditNodeButton",
    value: function (t) {
      var e,
          i = this._createButton("editNode", "vis-button vis-edit", t.editNode || this.options.locales.en.editNode);

      this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, $(e = this.editNode).call(e, this));
    }
  }, {
    key: "_createEditEdgeButton",
    value: function (t) {
      var e,
          i = this._createButton("editEdge", "vis-button vis-edit", t.editEdge || this.options.locales.en.editEdge);

      this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, $(e = this.editEdgeMode).call(e, this));
    }
  }, {
    key: "_createDeleteButton",
    value: function (t) {
      var e, i;
      i = this.options.rtl ? "vis-button vis-delete-rtl" : "vis-button vis-delete";

      var n = this._createButton("delete", i, t.del || this.options.locales.en.del);

      this.manipulationDiv.appendChild(n), this._bindHammerToDiv(n, $(e = this.deleteSelected).call(e, this));
    }
  }, {
    key: "_createBackButton",
    value: function (t) {
      var e,
          i = this._createButton("back", "vis-button vis-back", t.back || this.options.locales.en.back);

      this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, $(e = this.showManipulatorToolbar).call(e, this));
    }
  }, {
    key: "_createButton",
    value: function (t, e, i) {
      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "vis-label";
      return this.manipulationDOM[t + "Div"] = document.createElement("div"), this.manipulationDOM[t + "Div"].className = e, this.manipulationDOM[t + "Label"] = document.createElement("div"), this.manipulationDOM[t + "Label"].className = n, this.manipulationDOM[t + "Label"].innerHTML = i, this.manipulationDOM[t + "Div"].appendChild(this.manipulationDOM[t + "Label"]), this.manipulationDOM[t + "Div"];
    }
  }, {
    key: "_createDescription",
    value: function (t) {
      this.manipulationDiv.appendChild(this._createButton("description", "vis-button vis-none", t));
    }
  }, {
    key: "_temporaryBindEvent",
    value: function (t, e) {
      this.temporaryEventFunctions.push({
        event: t,
        boundFunction: e
      }), this.body.emitter.on(t, e);
    }
  }, {
    key: "_temporaryBindUI",
    value: function (t, e) {
      if (void 0 === this.body.eventListeners[t]) throw new Error("This UI function does not exist. Typo? You tried: " + t + " possible are: " + uE(CS(this.body.eventListeners)));
      this.temporaryUIFunctions[t] = this.body.eventListeners[t], this.body.eventListeners[t] = e;
    }
  }, {
    key: "_unbindTemporaryUIs",
    value: function () {
      for (var t in this.temporaryUIFunctions) this.temporaryUIFunctions.hasOwnProperty(t) && (this.body.eventListeners[t] = this.temporaryUIFunctions[t], delete this.temporaryUIFunctions[t]);

      this.temporaryUIFunctions = {};
    }
  }, {
    key: "_unbindTemporaryEvents",
    value: function () {
      for (var t = 0; t < this.temporaryEventFunctions.length; t++) {
        var e = this.temporaryEventFunctions[t].event,
            i = this.temporaryEventFunctions[t].boundFunction;
        this.body.emitter.off(e, i);
      }

      this.temporaryEventFunctions = [];
    }
  }, {
    key: "_bindHammerToDiv",
    value: function (t, e) {
      var i = new Qu(t, {});
      wD.onTouch(i, e), this.manipulationHammers.push(i);
    }
  }, {
    key: "_cleanupTemporaryNodesAndEdges",
    value: function () {
      for (var t = 0; t < this.temporaryIds.edges.length; t++) {
        var e;
        this.body.edges[this.temporaryIds.edges[t]].disconnect(), delete this.body.edges[this.temporaryIds.edges[t]];
        var i,
            n = el(e = this.body.edgeIndices).call(e, this.temporaryIds.edges[t]);
        if (-1 !== n) Rh(i = this.body.edgeIndices).call(i, n, 1);
      }

      for (var o = 0; o < this.temporaryIds.nodes.length; o++) {
        var r;
        delete this.body.nodes[this.temporaryIds.nodes[o]];
        var s,
            a = el(r = this.body.nodeIndices).call(r, this.temporaryIds.nodes[o]);
        if (-1 !== a) Rh(s = this.body.nodeIndices).call(s, a, 1);
      }

      this.temporaryIds = {
        nodes: [],
        edges: []
      };
    }
  }, {
    key: "_controlNodeTouch",
    value: function (t) {
      this.selectionHandler.unselectAll(), this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = Yr({}, this.body.view.translation);
    }
  }, {
    key: "_controlNodeDragStart",
    value: function (t) {
      var e = this.lastTouch,
          i = this.selectionHandler._pointerToPositionObject(e),
          n = this.body.nodes[this.temporaryIds.nodes[0]],
          o = this.body.nodes[this.temporaryIds.nodes[1]],
          r = this.body.edges[this.edgeBeingEditedId];

      this.selectedControlNode = void 0;
      var s = n.isOverlappingWith(i),
          a = o.isOverlappingWith(i);
      !0 === s ? (this.selectedControlNode = n, r.edgeType.from = n) : !0 === a && (this.selectedControlNode = o, r.edgeType.to = o), void 0 !== this.selectedControlNode && this.selectionHandler.selectObject(this.selectedControlNode), this.body.emitter.emit("_redraw");
    }
  }, {
    key: "_controlNodeDrag",
    value: function (t) {
      this.body.emitter.emit("disablePhysics");
      var e = this.body.functions.getPointer(t.center),
          i = this.canvas.DOMtoCanvas(e);
      void 0 !== this.selectedControlNode ? (this.selectedControlNode.x = i.x, this.selectedControlNode.y = i.y) : this.interactionHandler.onDrag(t), this.body.emitter.emit("_redraw");
    }
  }, {
    key: "_controlNodeDragEnd",
    value: function (t) {
      var e = this.body.functions.getPointer(t.center),
          i = this.selectionHandler._pointerToPositionObject(e),
          n = this.body.edges[this.edgeBeingEditedId];

      if (void 0 !== this.selectedControlNode) {
        this.selectionHandler.unselectAll();

        for (var o = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = o.length - 1; s >= 0; s--) if (o[s] !== this.selectedControlNode.id) {
          r = this.body.nodes[o[s]];
          break;
        }

        if (void 0 !== r && void 0 !== this.selectedControlNode) {
          if (!0 === r.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {
            var a = this.body.nodes[this.temporaryIds.nodes[0]];
            this.selectedControlNode.id === a.id ? this._performEditEdge(r.id, n.to.id) : this._performEditEdge(n.from.id, r.id);
          }
        } else n.updateEdgeType(), this.body.emitter.emit("restorePhysics");
        this.body.emitter.emit("_redraw");
      }
    }
  }, {
    key: "_handleConnect",
    value: function (t) {
      if (new Date().valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = Yr({}, this.body.view.translation);
        var e = this.lastTouch,
            i = this.selectionHandler.getNodeAt(e);
        if (void 0 !== i) if (!0 === i.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {
          var n = this._getNewTargetNode(i.x, i.y);

          this.body.nodes[n.id] = n, this.body.nodeIndices.push(n.id);
          var o = this.body.functions.createEdge({
            id: "connectionEdge" + Er(),
            from: i.id,
            to: n.id,
            physics: !1,
            smooth: {
              enabled: !0,
              type: "continuous",
              roundness: .5
            }
          });
          this.body.edges[o.id] = o, this.body.edgeIndices.push(o.id), this.temporaryIds.nodes.push(n.id), this.temporaryIds.edges.push(o.id);
        }
        this.touchTime = new Date().valueOf();
      }
    }
  }, {
    key: "_dragControlNode",
    value: function (t) {
      var e = this.body.functions.getPointer(t.center),
          i = this.selectionHandler._pointerToPositionObject(e),
          n = void 0;

      void 0 !== this.temporaryIds.edges[0] && (n = this.body.edges[this.temporaryIds.edges[0]].fromId);

      for (var o = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = o.length - 1; s >= 0; s--) {
        var a;

        if (-1 === el(a = this.temporaryIds.nodes).call(a, o[s])) {
          r = this.body.nodes[o[s]];
          break;
        }
      }

      if (t.controlEdge = {
        from: n,
        to: r ? r.id : void 0
      }, this.selectionHandler._generateClickEvent("controlNodeDragging", t, e), void 0 !== this.temporaryIds.nodes[0]) {
        var h = this.body.nodes[this.temporaryIds.nodes[0]];
        h.x = this.canvas._XconvertDOMtoCanvas(e.x), h.y = this.canvas._YconvertDOMtoCanvas(e.y), this.body.emitter.emit("_redraw");
      } else this.interactionHandler.onDrag(t);
    }
  }, {
    key: "_finishConnect",
    value: function (t) {
      var e = this.body.functions.getPointer(t.center),
          i = this.selectionHandler._pointerToPositionObject(e),
          n = void 0;

      void 0 !== this.temporaryIds.edges[0] && (n = this.body.edges[this.temporaryIds.edges[0]].fromId);

      for (var o = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = o.length - 1; s >= 0; s--) {
        var a;

        if (-1 === el(a = this.temporaryIds.nodes).call(a, o[s])) {
          r = this.body.nodes[o[s]];
          break;
        }
      }

      this._cleanupTemporaryNodesAndEdges(), void 0 !== r && (!0 === r.isCluster ? alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError) : void 0 !== this.body.nodes[n] && void 0 !== this.body.nodes[r.id] && this._performAddEdge(n, r.id)), t.controlEdge = {
        from: n,
        to: r ? r.id : void 0
      }, this.selectionHandler._generateClickEvent("controlNodeDragEnd", t, e), this.body.emitter.emit("_redraw");
    }
  }, {
    key: "_dragStartEdge",
    value: function (t) {
      var e = this.lastTouch;

      this.selectionHandler._generateClickEvent("dragStart", t, e, void 0, !0);
    }
  }, {
    key: "_performAddNode",
    value: function (t) {
      var e = this,
          i = {
        id: Er(),
        x: t.pointer.canvas.x,
        y: t.pointer.canvas.y,
        label: "new"
      };

      if ("function" == typeof this.options.addNode) {
        if (2 !== this.options.addNode.length) throw this.showManipulatorToolbar(), new Error("The function for add does not support two arguments (data,callback)");
        this.options.addNode(i, function (t) {
          null != t && "addNode" === e.inMode && e.body.data.nodes.getDataSet().add(t), e.showManipulatorToolbar();
        });
      } else this.body.data.nodes.getDataSet().add(i), this.showManipulatorToolbar();
    }
  }, {
    key: "_performAddEdge",
    value: function (t, e) {
      var i = this,
          n = {
        from: t,
        to: e
      };

      if ("function" == typeof this.options.addEdge) {
        if (2 !== this.options.addEdge.length) throw new Error("The function for connect does not support two arguments (data,callback)");
        this.options.addEdge(n, function (t) {
          null != t && "addEdge" === i.inMode && (i.body.data.edges.getDataSet().add(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar());
        });
      } else this.body.data.edges.getDataSet().add(n), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();
    }
  }, {
    key: "_performEditEdge",
    value: function (t, e) {
      var i = this,
          n = {
        id: this.edgeBeingEditedId,
        from: t,
        to: e,
        label: this.body.data.edges.get(this.edgeBeingEditedId).label
      },
          o = this.options.editEdge;

      if ("object" === aM(o) && (o = o.editWithoutDrag), "function" == typeof o) {
        if (2 !== o.length) throw new Error("The function for edit does not support two arguments (data, callback)");
        o(n, function (t) {
          null == t || "editEdge" !== i.inMode ? (i.body.edges[n.id].updateEdgeType(), i.body.emitter.emit("_redraw"), i.showManipulatorToolbar()) : (i.body.data.edges.getDataSet().update(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar());
        });
      } else this.body.data.edges.getDataSet().update(n), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();
    }
  }]), t;
}(),
    MT = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
},
    ET = function () {
  function t() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
    oc(this, t), this.pixelRatio = e, this.generated = !1, this.centerCoordinates = {
      x: 144.5,
      y: 144.5
    }, this.r = 289 * .49, this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    }, this.hueCircle = void 0, this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    }, this.previousColor = void 0, this.applied = !1, this.updateCallback = function () {}, this.closeCallback = function () {}, this._create();
  }

  return hc(t, [{
    key: "insertTo",
    value: function (t) {
      void 0 !== this.hammer && (this.hammer.destroy(), this.hammer = void 0), this.container = t, this.container.appendChild(this.frame), this._bindHammer(), this._setSize();
    }
  }, {
    key: "setUpdateCallback",
    value: function (t) {
      if ("function" != typeof t) throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      this.updateCallback = t;
    }
  }, {
    key: "setCloseCallback",
    value: function (t) {
      if ("function" != typeof t) throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      this.closeCallback = t;
    }
  }, {
    key: "_isColorString",
    value: function (t) {
      if ("string" == typeof t) return MT[t];
    }
  }, {
    key: "setColor",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];

      if ("none" !== t) {
        var i,
            n = this._isColorString(t);

        if (void 0 !== n && (t = n), !0 === jr(t)) {
          if (!0 === xs(t)) {
            var o = t.substr(4).substr(0, t.length - 5).split(",");
            i = {
              r: o[0],
              g: o[1],
              b: o[2],
              a: 1
            };
          } else if (!0 === Os(t)) {
            var r = t.substr(5).substr(0, t.length - 6).split(",");
            i = {
              r: r[0],
              g: r[1],
              b: r[2],
              a: r[3]
            };
          } else if (!0 === ks(t)) {
            var s = us(t);
            i = {
              r: s.r,
              g: s.g,
              b: s.b,
              a: 1
            };
          }
        } else if (t instanceof Object && void 0 !== t.r && void 0 !== t.g && void 0 !== t.b) {
          var a = void 0 !== t.a ? t.a : "1.0";
          i = {
            r: t.r,
            g: t.g,
            b: t.b,
            a: a
          };
        }

        if (void 0 === i) throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + uE(t));

        this._setColor(i, e);
      }
    }
  }, {
    key: "show",
    value: function () {
      void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0), this.applied = !1, this.frame.style.display = "block", this._generateHueCircle();
    }
  }, {
    key: "_hide",
    value: function () {
      var t = this,
          e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      !0 === e && (this.previousColor = Yr({}, this.color)), !0 === this.applied && this.updateCallback(this.initialColor), this.frame.style.display = "none", vc(function () {
        void 0 !== t.closeCallback && (t.closeCallback(), t.closeCallback = void 0);
      }, 0);
    }
  }, {
    key: "_save",
    value: function () {
      this.updateCallback(this.color), this.applied = !1, this._hide();
    }
  }, {
    key: "_apply",
    value: function () {
      this.applied = !0, this.updateCallback(this.color), this._updatePicker(this.color);
    }
  }, {
    key: "_loadLast",
    value: function () {
      void 0 !== this.previousColor ? this.setColor(this.previousColor, !1) : alert("There is no last color to load...");
    }
  }, {
    key: "_setColor",
    value: function (t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      !0 === e && (this.initialColor = Yr({}, t)), this.color = t;
      var i = vs(t.r, t.g, t.b),
          n = 2 * Math.PI,
          o = this.r * i.s,
          r = this.centerCoordinates.x + o * Math.sin(n * i.h),
          s = this.centerCoordinates.y + o * Math.cos(n * i.h);
      this.colorPickerSelector.style.left = r - .5 * this.colorPickerSelector.clientWidth + "px", this.colorPickerSelector.style.top = s - .5 * this.colorPickerSelector.clientHeight + "px", this._updatePicker(t);
    }
  }, {
    key: "_setOpacity",
    value: function (t) {
      this.color.a = t / 100, this._updatePicker(this.color);
    }
  }, {
    key: "_setBrightness",
    value: function (t) {
      var e = vs(this.color.r, this.color.g, this.color.b);
      e.v = t / 100;
      var i = bs(e.h, e.s, e.v);
      i.a = this.color.a, this.color = i, this._updatePicker();
    }
  }, {
    key: "_updatePicker",
    value: function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.color,
          e = vs(t.r, t.g, t.b),
          i = this.colorPickerCanvas.getContext("2d");
      void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (i.webkitBackingStorePixelRatio || i.mozBackingStorePixelRatio || i.msBackingStorePixelRatio || i.oBackingStorePixelRatio || i.backingStorePixelRatio || 1)), i.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      var n = this.colorPickerCanvas.clientWidth,
          o = this.colorPickerCanvas.clientHeight;
      i.clearRect(0, 0, n, o), i.putImageData(this.hueCircle, 0, 0), i.fillStyle = "rgba(0,0,0," + (1 - e.v) + ")", i.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), RM(i).call(i), this.brightnessRange.value = 100 * e.v, this.opacityRange.value = 100 * t.a, this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")", this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }, {
    key: "_setSize",
    value: function () {
      this.colorPickerCanvas.style.width = "100%", this.colorPickerCanvas.style.height = "100%", this.colorPickerCanvas.width = 289 * this.pixelRatio, this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
  }, {
    key: "_create",
    value: function () {
      var t, e, i, n;

      if (this.frame = document.createElement("div"), this.frame.className = "vis-color-picker", this.colorPickerDiv = document.createElement("div"), this.colorPickerSelector = document.createElement("div"), this.colorPickerSelector.className = "vis-selector", this.colorPickerDiv.appendChild(this.colorPickerSelector), this.colorPickerCanvas = document.createElement("canvas"), this.colorPickerDiv.appendChild(this.colorPickerCanvas), this.colorPickerCanvas.getContext) {
        var o = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (o.webkitBackingStorePixelRatio || o.mozBackingStorePixelRatio || o.msBackingStorePixelRatio || o.oBackingStorePixelRatio || o.backingStorePixelRatio || 1), this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      } else {
        var r = document.createElement("DIV");
        r.style.color = "red", r.style.fontWeight = "bold", r.style.padding = "10px", r.innerHTML = "Error: your browser does not support HTML canvas", this.colorPickerCanvas.appendChild(r);
      }

      this.colorPickerDiv.className = "vis-color", this.opacityDiv = document.createElement("div"), this.opacityDiv.className = "vis-opacity", this.brightnessDiv = document.createElement("div"), this.brightnessDiv.className = "vis-brightness", this.arrowDiv = document.createElement("div"), this.arrowDiv.className = "vis-arrow", this.opacityRange = document.createElement("input");

      try {
        this.opacityRange.type = "range", this.opacityRange.min = "0", this.opacityRange.max = "100";
      } catch (t) {}

      this.opacityRange.value = "100", this.opacityRange.className = "vis-range", this.brightnessRange = document.createElement("input");

      try {
        this.brightnessRange.type = "range", this.brightnessRange.min = "0", this.brightnessRange.max = "100";
      } catch (t) {}

      this.brightnessRange.value = "100", this.brightnessRange.className = "vis-range", this.opacityDiv.appendChild(this.opacityRange), this.brightnessDiv.appendChild(this.brightnessRange);
      var s = this;
      this.opacityRange.onchange = function () {
        s._setOpacity(this.value);
      }, this.opacityRange.oninput = function () {
        s._setOpacity(this.value);
      }, this.brightnessRange.onchange = function () {
        s._setBrightness(this.value);
      }, this.brightnessRange.oninput = function () {
        s._setBrightness(this.value);
      }, this.brightnessLabel = document.createElement("div"), this.brightnessLabel.className = "vis-label vis-brightness", this.brightnessLabel.innerHTML = "brightness:", this.opacityLabel = document.createElement("div"), this.opacityLabel.className = "vis-label vis-opacity", this.opacityLabel.innerHTML = "opacity:", this.newColorDiv = document.createElement("div"), this.newColorDiv.className = "vis-new-color", this.newColorDiv.innerHTML = "new", this.initialColorDiv = document.createElement("div"), this.initialColorDiv.className = "vis-initial-color", this.initialColorDiv.innerHTML = "initial", this.cancelButton = document.createElement("div"), this.cancelButton.className = "vis-button vis-cancel", this.cancelButton.innerHTML = "cancel", this.cancelButton.onclick = $(t = this._hide).call(t, this, !1), this.applyButton = document.createElement("div"), this.applyButton.className = "vis-button vis-apply", this.applyButton.innerHTML = "apply", this.applyButton.onclick = $(e = this._apply).call(e, this), this.saveButton = document.createElement("div"), this.saveButton.className = "vis-button vis-save", this.saveButton.innerHTML = "save", this.saveButton.onclick = $(i = this._save).call(i, this), this.loadButton = document.createElement("div"), this.loadButton.className = "vis-button vis-load", this.loadButton.innerHTML = "load last", this.loadButton.onclick = $(n = this._loadLast).call(n, this), this.frame.appendChild(this.colorPickerDiv), this.frame.appendChild(this.arrowDiv), this.frame.appendChild(this.brightnessLabel), this.frame.appendChild(this.brightnessDiv), this.frame.appendChild(this.opacityLabel), this.frame.appendChild(this.opacityDiv), this.frame.appendChild(this.newColorDiv), this.frame.appendChild(this.initialColorDiv), this.frame.appendChild(this.cancelButton), this.frame.appendChild(this.applyButton), this.frame.appendChild(this.saveButton), this.frame.appendChild(this.loadButton);
    }
  }, {
    key: "_bindHammer",
    value: function () {
      var t = this;
      this.drag = {}, this.pinch = {}, this.hammer = new Qu(this.colorPickerCanvas), this.hammer.get("pinch").set({
        enable: !0
      }), wD.onTouch(this.hammer, function (e) {
        t._moveSelector(e);
      }), this.hammer.on("tap", function (e) {
        t._moveSelector(e);
      }), this.hammer.on("panstart", function (e) {
        t._moveSelector(e);
      }), this.hammer.on("panmove", function (e) {
        t._moveSelector(e);
      }), this.hammer.on("panend", function (e) {
        t._moveSelector(e);
      });
    }
  }, {
    key: "_generateHueCircle",
    value: function () {
      if (!1 === this.generated) {
        var t = this.colorPickerCanvas.getContext("2d");
        void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)), t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        var e,
            i,
            n,
            o,
            r = this.colorPickerCanvas.clientWidth,
            s = this.colorPickerCanvas.clientHeight;
        t.clearRect(0, 0, r, s), this.centerCoordinates = {
          x: .5 * r,
          y: .5 * s
        }, this.r = .49 * r;
        var a,
            h = 2 * Math.PI / 360,
            l = 1 / this.r;

        for (n = 0; n < 360; n++) for (o = 0; o < this.r; o++) e = this.centerCoordinates.x + o * Math.sin(h * n), i = this.centerCoordinates.y + o * Math.cos(h * n), a = bs(n * (1 / 360), o * l, 1), t.fillStyle = "rgb(" + a.r + "," + a.g + "," + a.b + ")", t.fillRect(e - .5, i - .5, 2, 2);

        t.strokeStyle = "rgba(0,0,0,1)", t.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), t.stroke(), this.hueCircle = t.getImageData(0, 0, r, s);
      }

      this.generated = !0;
    }
  }, {
    key: "_moveSelector",
    value: function (t) {
      var e = this.colorPickerDiv.getBoundingClientRect(),
          i = t.center.x - e.left,
          n = t.center.y - e.top,
          o = .5 * this.colorPickerDiv.clientHeight,
          r = .5 * this.colorPickerDiv.clientWidth,
          s = i - r,
          a = n - o,
          h = Math.atan2(s, a),
          l = .98 * Math.min(Math.sqrt(s * s + a * a), r),
          d = Math.cos(h) * l + o,
          u = Math.sin(h) * l + r;
      this.colorPickerSelector.style.top = d - .5 * this.colorPickerSelector.clientHeight + "px", this.colorPickerSelector.style.left = u - .5 * this.colorPickerSelector.clientWidth + "px";
      var c = h / (2 * Math.PI);
      c = c < 0 ? c + 1 : c;
      var f = l / this.r,
          p = vs(this.color.r, this.color.g, this.color.b);
      p.h = c, p.s = f;
      var v = bs(p.h, p.s, p.v);
      v.a = this.color.a, this.color = v, this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")", this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }]), t;
}(),
    DT = function () {
  function t(e, i, n) {
    var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    oc(this, t), this.parent = e, this.changedOptions = [], this.container = i, this.allowCreation = !1, this.options = {}, this.initialized = !1, this.popupCounter = 0, this.defaultOptions = {
      enabled: !1,
      filter: !0,
      container: void 0,
      showButton: !0
    }, Yr(this.options, this.defaultOptions), this.configureOptions = n, this.moduleOptions = {}, this.domElements = [], this.popupDiv = {}, this.popupLimit = 5, this.popupHistory = {}, this.colorPicker = new ET(o), this.wrapper = void 0;
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      if (void 0 !== t) {
        this.popupHistory = {}, this._removePopup();
        var e = !0;
        if ("string" == typeof t) this.options.filter = t;else if (t instanceof Array) this.options.filter = t.join();else if ("object" === aM(t)) {
          if (null == t) throw new TypeError("options cannot be null");
          void 0 !== t.container && (this.options.container = t.container), void 0 !== UO(t) && (this.options.filter = UO(t)), void 0 !== t.showButton && (this.options.showButton = t.showButton), void 0 !== t.enabled && (e = t.enabled);
        } else "boolean" == typeof t ? (this.options.filter = !0, e = t) : "function" == typeof t && (this.options.filter = t, e = !0);
        !1 === UO(this.options) && (e = !1), this.options.enabled = e;
      }

      this._clean();
    }
  }, {
    key: "setModuleOptions",
    value: function (t) {
      this.moduleOptions = t, !0 === this.options.enabled && (this._clean(), void 0 !== this.options.container && (this.container = this.options.container), this._create());
    }
  }, {
    key: "_create",
    value: function () {
      this._clean(), this.changedOptions = [];
      var t = UO(this.options),
          e = 0,
          i = !1;

      for (var n in this.configureOptions) this.configureOptions.hasOwnProperty(n) && (this.allowCreation = !1, i = !1, "function" == typeof t ? i = (i = t(n, [])) || this._handleObject(this.configureOptions[n], [n], !0) : !0 !== t && -1 === el(t).call(t, n) || (i = !0), !1 !== i && (this.allowCreation = !0, e > 0 && this._makeItem([]), this._makeHeader(n), this._handleObject(this.configureOptions[n], [n])), e++);

      this._makeButton(), this._push();
    }
  }, {
    key: "_push",
    value: function () {
      this.wrapper = document.createElement("div"), this.wrapper.className = "vis-configuration-wrapper", this.container.appendChild(this.wrapper);

      for (var t = 0; t < this.domElements.length; t++) this.wrapper.appendChild(this.domElements[t]);

      this._showPopupIfNeeded();
    }
  }, {
    key: "_clean",
    value: function () {
      for (var t = 0; t < this.domElements.length; t++) this.wrapper.removeChild(this.domElements[t]);

      void 0 !== this.wrapper && (this.container.removeChild(this.wrapper), this.wrapper = void 0), this.domElements = [], this._removePopup();
    }
  }, {
    key: "_getValue",
    value: function (t) {
      for (var e = this.moduleOptions, i = 0; i < t.length; i++) {
        if (void 0 === e[t[i]]) {
          e = void 0;
          break;
        }

        e = e[t[i]];
      }

      return e;
    }
  }, {
    key: "_makeItem",
    value: function (t) {
      if (!0 === this.allowCreation) {
        var e = document.createElement("div");
        e.className = "vis-configuration vis-config-item vis-config-s" + t.length;

        for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) n[o - 1] = arguments[o];

        return kh(n).call(n, function (t) {
          e.appendChild(t);
        }), this.domElements.push(e), this.domElements.length;
      }

      return 0;
    }
  }, {
    key: "_makeHeader",
    value: function (t) {
      var e = document.createElement("div");
      e.className = "vis-configuration vis-config-header", e.innerHTML = t, this._makeItem([], e);
    }
  }, {
    key: "_makeLabel",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = document.createElement("div");
      return n.className = "vis-configuration vis-config-label vis-config-s" + e.length, n.innerHTML = !0 === i ? "<i><b>" + t + ":</b></i>" : t + ":", n;
    }
  }, {
    key: "_makeDropdown",
    value: function (t, e, i) {
      var n = document.createElement("select");
      n.className = "vis-configuration vis-config-select";
      var o = 0;
      void 0 !== e && -1 !== el(t).call(t, e) && (o = el(t).call(t, e));

      for (var r = 0; r < t.length; r++) {
        var s = document.createElement("option");
        s.value = t[r], r === o && (s.selected = "selected"), s.innerHTML = t[r], n.appendChild(s);
      }

      var a = this;

      n.onchange = function () {
        a._update(this.value, i);
      };

      var h = this._makeLabel(i[i.length - 1], i);

      this._makeItem(i, h, n);
    }
  }, {
    key: "_makeRange",
    value: function (t, e, i) {
      var n = t[0],
          o = t[1],
          r = t[2],
          s = t[3],
          a = document.createElement("input");
      a.className = "vis-configuration vis-config-range";

      try {
        a.type = "range", a.min = o, a.max = r;
      } catch (t) {}

      a.step = s;
      var h = "",
          l = 0;

      if (void 0 !== e) {
        e < 0 && 1.2 * e < o ? (a.min = Math.ceil(1.2 * e), l = a.min, h = "range increased") : e / 1.2 < o && (a.min = Math.ceil(e / 1.2), l = a.min, h = "range increased"), 1.2 * e > r && 1 !== r && (a.max = Math.ceil(1.2 * e), l = a.max, h = "range increased"), a.value = e;
      } else a.value = n;

      var d = document.createElement("input");
      d.className = "vis-configuration vis-config-rangeinput", d.value = a.value;
      var u = this;
      a.onchange = function () {
        d.value = this.value, u._update(Number(this.value), i);
      }, a.oninput = function () {
        d.value = this.value;
      };

      var c = this._makeLabel(i[i.length - 1], i),
          f = this._makeItem(i, c, a, d);

      "" !== h && this.popupHistory[f] !== l && (this.popupHistory[f] = l, this._setupPopup(h, f));
    }
  }, {
    key: "_makeButton",
    value: function () {
      var t = this;

      if (!0 === this.options.showButton) {
        var e = document.createElement("div");
        e.className = "vis-configuration vis-config-button", e.innerHTML = "generate options", e.onclick = function () {
          t._printOptions();
        }, e.onmouseover = function () {
          e.className = "vis-configuration vis-config-button hover";
        }, e.onmouseout = function () {
          e.className = "vis-configuration vis-config-button";
        }, this.optionsContainer = document.createElement("div"), this.optionsContainer.className = "vis-configuration vis-config-option-container", this.domElements.push(this.optionsContainer), this.domElements.push(e);
      }
    }
  }, {
    key: "_setupPopup",
    value: function (t, e) {
      var i = this;

      if (!0 === this.initialized && !0 === this.allowCreation && this.popupCounter < this.popupLimit) {
        var n = document.createElement("div");
        n.id = "vis-configuration-popup", n.className = "vis-configuration-popup", n.innerHTML = t, n.onclick = function () {
          i._removePopup();
        }, this.popupCounter += 1, this.popupDiv = {
          html: n,
          index: e
        };
      }
    }
  }, {
    key: "_removePopup",
    value: function () {
      void 0 !== this.popupDiv.html && (this.popupDiv.html.parentNode.removeChild(this.popupDiv.html), clearTimeout(this.popupDiv.hideTimeout), clearTimeout(this.popupDiv.deleteTimeout), this.popupDiv = {});
    }
  }, {
    key: "_showPopupIfNeeded",
    value: function () {
      var t = this;

      if (void 0 !== this.popupDiv.html) {
        var e = this.domElements[this.popupDiv.index].getBoundingClientRect();
        this.popupDiv.html.style.left = e.left + "px", this.popupDiv.html.style.top = e.top - 30 + "px", document.body.appendChild(this.popupDiv.html), this.popupDiv.hideTimeout = vc(function () {
          t.popupDiv.html.style.opacity = 0;
        }, 1500), this.popupDiv.deleteTimeout = vc(function () {
          t._removePopup();
        }, 1800);
      }
    }
  }, {
    key: "_makeCheckbox",
    value: function (t, e, i) {
      var n = document.createElement("input");
      n.type = "checkbox", n.className = "vis-configuration vis-config-checkbox", n.checked = t, void 0 !== e && (n.checked = e, e !== t && ("object" === aM(t) ? e !== t.enabled && this.changedOptions.push({
        path: i,
        value: e
      }) : this.changedOptions.push({
        path: i,
        value: e
      })));
      var o = this;

      n.onchange = function () {
        o._update(this.checked, i);
      };

      var r = this._makeLabel(i[i.length - 1], i);

      this._makeItem(i, r, n);
    }
  }, {
    key: "_makeTextInput",
    value: function (t, e, i) {
      var n = document.createElement("input");
      n.type = "text", n.className = "vis-configuration vis-config-text", n.value = e, e !== t && this.changedOptions.push({
        path: i,
        value: e
      });
      var o = this;

      n.onchange = function () {
        o._update(this.value, i);
      };

      var r = this._makeLabel(i[i.length - 1], i);

      this._makeItem(i, r, n);
    }
  }, {
    key: "_makeColorField",
    value: function (t, e, i) {
      var n = this,
          o = t[1],
          r = document.createElement("div");
      "none" !== (e = void 0 === e ? o : e) ? (r.className = "vis-configuration vis-config-colorBlock", r.style.backgroundColor = e) : r.className = "vis-configuration vis-config-colorBlock none", e = void 0 === e ? o : e, r.onclick = function () {
        n._showColorPicker(e, r, i);
      };

      var s = this._makeLabel(i[i.length - 1], i);

      this._makeItem(i, s, r);
    }
  }, {
    key: "_showColorPicker",
    value: function (t, e, i) {
      var n = this;
      e.onclick = function () {}, this.colorPicker.insertTo(e), this.colorPicker.show(), this.colorPicker.setColor(t), this.colorPicker.setUpdateCallback(function (t) {
        var o = "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a + ")";
        e.style.backgroundColor = o, n._update(o, i);
      }), this.colorPicker.setCloseCallback(function () {
        e.onclick = function () {
          n._showColorPicker(t, e, i);
        };
      });
    }
  }, {
    key: "_handleObject",
    value: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
          i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = !1,
          o = UO(this.options),
          r = !1;

      for (var s in t) if (t.hasOwnProperty(s)) {
        n = !0;
        var a = t[s],
            h = Xr(e, s);

        if ("function" == typeof o && !1 === (n = o(s, e)) && !(a instanceof Array) && "string" != typeof a && "boolean" != typeof a && a instanceof Object && (this.allowCreation = !1, n = this._handleObject(a, h, !0), this.allowCreation = !1 === i), !1 !== n) {
          r = !0;

          var l = this._getValue(h);

          if (a instanceof Array) this._handleArray(a, l, h);else if ("string" == typeof a) this._makeTextInput(a, l, h);else if ("boolean" == typeof a) this._makeCheckbox(a, l, h);else if (a instanceof Object) {
            var d = !0;
            if (-1 !== el(e).call(e, "physics") && this.moduleOptions.physics.solver !== s && (d = !1), !0 === d) if (void 0 !== a.enabled) {
              var u = Xr(h, "enabled"),
                  c = this._getValue(u);

              if (!0 === c) {
                var f = this._makeLabel(s, h, !0);

                this._makeItem(h, f), r = this._handleObject(a, h) || r;
              } else this._makeCheckbox(a, c, h);
            } else {
              var p = this._makeLabel(s, h, !0);

              this._makeItem(h, p), r = this._handleObject(a, h) || r;
            }
          } else console.error("dont know how to handle", a, s, h);
        }
      }

      return r;
    }
  }, {
    key: "_handleArray",
    value: function (t, e, i) {
      "string" == typeof t[0] && "color" === t[0] ? (this._makeColorField(t, e, i), t[1] !== e && this.changedOptions.push({
        path: i,
        value: e
      })) : "string" == typeof t[0] ? (this._makeDropdown(t, e, i), t[0] !== e && this.changedOptions.push({
        path: i,
        value: e
      })) : "number" == typeof t[0] && (this._makeRange(t, e, i), t[0] !== e && this.changedOptions.push({
        path: i,
        value: Number(e)
      }));
    }
  }, {
    key: "_update",
    value: function (t, e) {
      var i = this._constructOptions(t, e);

      this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit && this.parent.body.emitter.emit("configChange", i), this.initialized = !0, this.parent.setOptions(i);
    }
  }, {
    key: "_constructOptions",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          n = i;
      t = "false" !== (t = "true" === t || t) && t;

      for (var o = 0; o < e.length; o++) "global" !== e[o] && (void 0 === n[e[o]] && (n[e[o]] = {}), o !== e.length - 1 ? n = n[e[o]] : n[e[o]] = t);

      return i;
    }
  }, {
    key: "_printOptions",
    value: function () {
      var t = this.getOptions();
      this.optionsContainer.innerHTML = "<pre>var options = " + uE(t, null, 2) + "</pre>";
    }
  }, {
    key: "getOptions",
    value: function () {
      for (var t = {}, e = 0; e < this.changedOptions.length; e++) this._constructOptions(this.changedOptions[e].value, this.changedOptions[e].path, t);

      return t;
    }
  }]), t;
}(),
    TT = "string",
    CT = "boolean",
    PT = "number",
    AT = "object",
    IT = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"],
    FT = {
  configure: {
    enabled: {
      boolean: CT
    },
    filter: {
      boolean: CT,
      string: TT,
      array: "array",
      function: "function"
    },
    container: {
      dom: "dom"
    },
    showButton: {
      boolean: CT
    },
    __type__: {
      object: AT,
      boolean: CT,
      string: TT,
      array: "array",
      function: "function"
    }
  },
  edges: {
    arrows: {
      to: {
        enabled: {
          boolean: CT
        },
        scaleFactor: {
          number: PT
        },
        type: {
          string: IT
        },
        imageHeight: {
          number: PT
        },
        imageWidth: {
          number: PT
        },
        src: {
          string: TT
        },
        __type__: {
          object: AT,
          boolean: CT
        }
      },
      middle: {
        enabled: {
          boolean: CT
        },
        scaleFactor: {
          number: PT
        },
        type: {
          string: IT
        },
        imageWidth: {
          number: PT
        },
        imageHeight: {
          number: PT
        },
        src: {
          string: TT
        },
        __type__: {
          object: AT,
          boolean: CT
        }
      },
      from: {
        enabled: {
          boolean: CT
        },
        scaleFactor: {
          number: PT
        },
        type: {
          string: IT
        },
        imageWidth: {
          number: PT
        },
        imageHeight: {
          number: PT
        },
        src: {
          string: TT
        },
        __type__: {
          object: AT,
          boolean: CT
        }
      },
      __type__: {
        string: ["from", "to", "middle"],
        object: AT
      }
    },
    arrowStrikethrough: {
      boolean: CT
    },
    background: {
      enabled: {
        boolean: CT
      },
      color: {
        string: TT
      },
      size: {
        number: PT
      },
      dashes: {
        boolean: CT,
        array: "array"
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    chosen: {
      label: {
        boolean: CT,
        function: "function"
      },
      edge: {
        boolean: CT,
        function: "function"
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    color: {
      color: {
        string: TT
      },
      highlight: {
        string: TT
      },
      hover: {
        string: TT
      },
      inherit: {
        string: ["from", "to", "both"],
        boolean: CT
      },
      opacity: {
        number: PT
      },
      __type__: {
        object: AT,
        string: TT
      }
    },
    dashes: {
      boolean: CT,
      array: "array"
    },
    font: {
      color: {
        string: TT
      },
      size: {
        number: PT
      },
      face: {
        string: TT
      },
      background: {
        string: TT
      },
      strokeWidth: {
        number: PT
      },
      strokeColor: {
        string: TT
      },
      align: {
        string: ["horizontal", "top", "middle", "bottom"]
      },
      vadjust: {
        number: PT
      },
      multi: {
        boolean: CT,
        string: TT
      },
      bold: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      boldital: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      ital: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      mono: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      __type__: {
        object: AT,
        string: TT
      }
    },
    hidden: {
      boolean: CT
    },
    hoverWidth: {
      function: "function",
      number: PT
    },
    label: {
      string: TT,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: CT
    },
    length: {
      number: PT,
      undefined: "undefined"
    },
    physics: {
      boolean: CT
    },
    scaling: {
      min: {
        number: PT
      },
      max: {
        number: PT
      },
      label: {
        enabled: {
          boolean: CT
        },
        min: {
          number: PT
        },
        max: {
          number: PT
        },
        maxVisible: {
          number: PT
        },
        drawThreshold: {
          number: PT
        },
        __type__: {
          object: AT,
          boolean: CT
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object: AT
      }
    },
    selectionWidth: {
      function: "function",
      number: PT
    },
    selfReferenceSize: {
      number: PT
    },
    shadow: {
      enabled: {
        boolean: CT
      },
      color: {
        string: TT
      },
      size: {
        number: PT
      },
      x: {
        number: PT
      },
      y: {
        number: PT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    smooth: {
      enabled: {
        boolean: CT
      },
      type: {
        string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
      },
      roundness: {
        number: PT
      },
      forceDirection: {
        string: ["horizontal", "vertical", "none"],
        boolean: CT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    title: {
      string: TT,
      undefined: "undefined"
    },
    width: {
      number: PT
    },
    widthConstraint: {
      maximum: {
        number: PT
      },
      __type__: {
        object: AT,
        boolean: CT,
        number: PT
      }
    },
    value: {
      number: PT,
      undefined: "undefined"
    },
    __type__: {
      object: AT
    }
  },
  groups: {
    useDefaultGroups: {
      boolean: CT
    },
    __any__: "get from nodes, will be overwritten below",
    __type__: {
      object: AT
    }
  },
  interaction: {
    dragNodes: {
      boolean: CT
    },
    dragView: {
      boolean: CT
    },
    hideEdgesOnDrag: {
      boolean: CT
    },
    hideEdgesOnZoom: {
      boolean: CT
    },
    hideNodesOnDrag: {
      boolean: CT
    },
    hover: {
      boolean: CT
    },
    keyboard: {
      enabled: {
        boolean: CT
      },
      speed: {
        x: {
          number: PT
        },
        y: {
          number: PT
        },
        zoom: {
          number: PT
        },
        __type__: {
          object: AT
        }
      },
      bindToWindow: {
        boolean: CT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    multiselect: {
      boolean: CT
    },
    navigationButtons: {
      boolean: CT
    },
    selectable: {
      boolean: CT
    },
    selectConnectedEdges: {
      boolean: CT
    },
    hoverConnectedEdges: {
      boolean: CT
    },
    tooltipDelay: {
      number: PT
    },
    zoomView: {
      boolean: CT
    },
    zoomSpeed: {
      number: PT
    },
    __type__: {
      object: AT
    }
  },
  layout: {
    randomSeed: {
      undefined: "undefined",
      number: PT
    },
    improvedLayout: {
      boolean: CT
    },
    clusterThreshold: {
      number: PT
    },
    hierarchical: {
      enabled: {
        boolean: CT
      },
      levelSeparation: {
        number: PT
      },
      nodeSpacing: {
        number: PT
      },
      treeSpacing: {
        number: PT
      },
      blockShifting: {
        boolean: CT
      },
      edgeMinimization: {
        boolean: CT
      },
      parentCentralization: {
        boolean: CT
      },
      direction: {
        string: ["UD", "DU", "LR", "RL"]
      },
      sortMethod: {
        string: ["hubsize", "directed"]
      },
      shakeTowards: {
        string: ["leaves", "roots"]
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    __type__: {
      object: AT
    }
  },
  manipulation: {
    enabled: {
      boolean: CT
    },
    initiallyActive: {
      boolean: CT
    },
    addNode: {
      boolean: CT,
      function: "function"
    },
    addEdge: {
      boolean: CT,
      function: "function"
    },
    editNode: {
      function: "function"
    },
    editEdge: {
      editWithoutDrag: {
        function: "function"
      },
      __type__: {
        object: AT,
        boolean: CT,
        function: "function"
      }
    },
    deleteNode: {
      boolean: CT,
      function: "function"
    },
    deleteEdge: {
      boolean: CT,
      function: "function"
    },
    controlNodeStyle: "get from nodes, will be overwritten below",
    __type__: {
      object: AT,
      boolean: CT
    }
  },
  nodes: {
    borderWidth: {
      number: PT
    },
    borderWidthSelected: {
      number: PT,
      undefined: "undefined"
    },
    brokenImage: {
      string: TT,
      undefined: "undefined"
    },
    chosen: {
      label: {
        boolean: CT,
        function: "function"
      },
      node: {
        boolean: CT,
        function: "function"
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    color: {
      border: {
        string: TT
      },
      background: {
        string: TT
      },
      highlight: {
        border: {
          string: TT
        },
        background: {
          string: TT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      hover: {
        border: {
          string: TT
        },
        background: {
          string: TT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      __type__: {
        object: AT,
        string: TT
      }
    },
    fixed: {
      x: {
        boolean: CT
      },
      y: {
        boolean: CT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    font: {
      align: {
        string: TT
      },
      color: {
        string: TT
      },
      size: {
        number: PT
      },
      face: {
        string: TT
      },
      background: {
        string: TT
      },
      strokeWidth: {
        number: PT
      },
      strokeColor: {
        string: TT
      },
      vadjust: {
        number: PT
      },
      multi: {
        boolean: CT,
        string: TT
      },
      bold: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      boldital: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      ital: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      mono: {
        color: {
          string: TT
        },
        size: {
          number: PT
        },
        face: {
          string: TT
        },
        mod: {
          string: TT
        },
        vadjust: {
          number: PT
        },
        __type__: {
          object: AT,
          string: TT
        }
      },
      __type__: {
        object: AT,
        string: TT
      }
    },
    group: {
      string: TT,
      number: PT,
      undefined: "undefined"
    },
    heightConstraint: {
      minimum: {
        number: PT
      },
      valign: {
        string: TT
      },
      __type__: {
        object: AT,
        boolean: CT,
        number: PT
      }
    },
    hidden: {
      boolean: CT
    },
    icon: {
      face: {
        string: TT
      },
      code: {
        string: TT
      },
      size: {
        number: PT
      },
      color: {
        string: TT
      },
      weight: {
        string: TT,
        number: PT
      },
      __type__: {
        object: AT
      }
    },
    id: {
      string: TT,
      number: PT
    },
    image: {
      selected: {
        string: TT,
        undefined: "undefined"
      },
      unselected: {
        string: TT,
        undefined: "undefined"
      },
      __type__: {
        object: AT,
        string: TT
      }
    },
    imagePadding: {
      top: {
        number: PT
      },
      right: {
        number: PT
      },
      bottom: {
        number: PT
      },
      left: {
        number: PT
      },
      __type__: {
        object: AT,
        number: PT
      }
    },
    label: {
      string: TT,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: CT
    },
    level: {
      number: PT,
      undefined: "undefined"
    },
    margin: {
      top: {
        number: PT
      },
      right: {
        number: PT
      },
      bottom: {
        number: PT
      },
      left: {
        number: PT
      },
      __type__: {
        object: AT,
        number: PT
      }
    },
    mass: {
      number: PT
    },
    physics: {
      boolean: CT
    },
    scaling: {
      min: {
        number: PT
      },
      max: {
        number: PT
      },
      label: {
        enabled: {
          boolean: CT
        },
        min: {
          number: PT
        },
        max: {
          number: PT
        },
        maxVisible: {
          number: PT
        },
        drawThreshold: {
          number: PT
        },
        __type__: {
          object: AT,
          boolean: CT
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object: AT
      }
    },
    shadow: {
      enabled: {
        boolean: CT
      },
      color: {
        string: TT
      },
      size: {
        number: PT
      },
      x: {
        number: PT
      },
      y: {
        number: PT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    shape: {
      string: ["ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
    },
    shapeProperties: {
      borderDashes: {
        boolean: CT,
        array: "array"
      },
      borderRadius: {
        number: PT
      },
      interpolation: {
        boolean: CT
      },
      useImageSize: {
        boolean: CT
      },
      useBorderWithImage: {
        boolean: CT
      },
      __type__: {
        object: AT
      }
    },
    size: {
      number: PT
    },
    title: {
      string: TT,
      dom: "dom",
      undefined: "undefined"
    },
    value: {
      number: PT,
      undefined: "undefined"
    },
    widthConstraint: {
      minimum: {
        number: PT
      },
      maximum: {
        number: PT
      },
      __type__: {
        object: AT,
        boolean: CT,
        number: PT
      }
    },
    x: {
      number: PT
    },
    y: {
      number: PT
    },
    __type__: {
      object: AT
    }
  },
  physics: {
    enabled: {
      boolean: CT
    },
    barnesHut: {
      gravitationalConstant: {
        number: PT
      },
      centralGravity: {
        number: PT
      },
      springLength: {
        number: PT
      },
      springConstant: {
        number: PT
      },
      damping: {
        number: PT
      },
      avoidOverlap: {
        number: PT
      },
      __type__: {
        object: AT
      }
    },
    forceAtlas2Based: {
      gravitationalConstant: {
        number: PT
      },
      centralGravity: {
        number: PT
      },
      springLength: {
        number: PT
      },
      springConstant: {
        number: PT
      },
      damping: {
        number: PT
      },
      avoidOverlap: {
        number: PT
      },
      __type__: {
        object: AT
      }
    },
    repulsion: {
      centralGravity: {
        number: PT
      },
      springLength: {
        number: PT
      },
      springConstant: {
        number: PT
      },
      nodeDistance: {
        number: PT
      },
      damping: {
        number: PT
      },
      __type__: {
        object: AT
      }
    },
    hierarchicalRepulsion: {
      centralGravity: {
        number: PT
      },
      springLength: {
        number: PT
      },
      springConstant: {
        number: PT
      },
      nodeDistance: {
        number: PT
      },
      damping: {
        number: PT
      },
      avoidOverlap: {
        number: PT
      },
      __type__: {
        object: AT
      }
    },
    maxVelocity: {
      number: PT
    },
    minVelocity: {
      number: PT
    },
    solver: {
      string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
    },
    stabilization: {
      enabled: {
        boolean: CT
      },
      iterations: {
        number: PT
      },
      updateInterval: {
        number: PT
      },
      onlyDynamicEdges: {
        boolean: CT
      },
      fit: {
        boolean: CT
      },
      __type__: {
        object: AT,
        boolean: CT
      }
    },
    timestep: {
      number: PT
    },
    adaptiveTimestep: {
      boolean: CT
    },
    __type__: {
      object: AT,
      boolean: CT
    }
  },
  autoResize: {
    boolean: CT
  },
  clickToUse: {
    boolean: CT
  },
  locale: {
    string: TT
  },
  locales: {
    __any__: {
      any: "any"
    },
    __type__: {
      object: AT
    }
  },
  height: {
    string: TT
  },
  width: {
    string: TT
  },
  __type__: {
    object: AT
  }
};

FT.groups.__any__ = FT.nodes, FT.manipulation.controlNodeStyle = FT.nodes;

var NT = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ["color", "#2B7CE9"],
      background: ["color", "#97C2FC"],
      highlight: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      },
      hover: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      }
    },
    fixed: {
      x: !1,
      y: !1
    },
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [0, 0, 50, 1],
      strokeColor: ["color", "#ffffff"]
    },
    hidden: !1,
    labelHighlightBold: !0,
    physics: !0,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: !1,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: !1,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
    shapeProperties: {
      borderDashes: !1,
      borderRadius: [6, 0, 20, 1],
      interpolation: !0,
      useImageSize: !1
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: {
        enabled: !1,
        scaleFactor: [1, 0, 3, .05],
        type: "arrow"
      },
      middle: {
        enabled: !1,
        scaleFactor: [1, 0, 3, .05],
        type: "arrow"
      },
      from: {
        enabled: !1,
        scaleFactor: [1, 0, 3, .05],
        type: "arrow"
      }
    },
    arrowStrikethrough: !0,
    color: {
      color: ["color", "#848484"],
      highlight: ["color", "#848484"],
      hover: ["color", "#848484"],
      inherit: ["from", "to", "both", !0, !1],
      opacity: [1, 0, 1, .05]
    },
    dashes: !1,
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [2, 0, 50, 1],
      strokeColor: ["color", "#ffffff"],
      align: ["horizontal", "top", "middle", "bottom"]
    },
    hidden: !1,
    hoverWidth: [1.5, 0, 5, .1],
    labelHighlightBold: !0,
    physics: !0,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: !0,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, .1],
    selfReferenceSize: [20, 0, 200, 1],
    shadow: {
      enabled: !1,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: !0,
      type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
      forceDirection: ["horizontal", "vertical", "none"],
      roundness: [.5, 0, 1, .05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    hierarchical: {
      enabled: !1,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: !0,
      edgeMinimization: !0,
      parentCentralization: !0,
      direction: ["UD", "DU", "LR", "RL"],
      sortMethod: ["hubsize", "directed"],
      shakeTowards: ["leaves", "roots"]
    }
  },
  interaction: {
    dragNodes: !0,
    dragView: !0,
    hideEdgesOnDrag: !1,
    hideEdgesOnZoom: !1,
    hideNodesOnDrag: !1,
    hover: !1,
    keyboard: {
      enabled: !1,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [.02, 0, .1, .005]
      },
      bindToWindow: !0
    },
    multiselect: !1,
    navigationButtons: !1,
    selectable: !0,
    selectConnectedEdges: !0,
    hoverConnectedEdges: !0,
    tooltipDelay: [300, 0, 1e3, 25],
    zoomView: !0,
    zoomSpeed: [1, 1, 1, 1]
  },
  manipulation: {
    enabled: !1,
    initiallyActive: !1
  },
  physics: {
    enabled: !0,
    barnesHut: {
      gravitationalConstant: [-2e3, -3e4, 0, 50],
      centralGravity: [.3, 0, 10, .05],
      springLength: [95, 0, 500, 5],
      springConstant: [.04, 0, 1.2, .005],
      damping: [.09, 0, 1, .01],
      avoidOverlap: [0, 0, 1, .01]
    },
    forceAtlas2Based: {
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [.01, 0, 1, .005],
      springLength: [95, 0, 500, 5],
      springConstant: [.08, 0, 1.2, .005],
      damping: [.4, 0, 1, .01],
      avoidOverlap: [0, 0, 1, .01]
    },
    repulsion: {
      centralGravity: [.2, 0, 10, .05],
      springLength: [200, 0, 500, 5],
      springConstant: [.05, 0, 1.2, .005],
      nodeDistance: [100, 0, 500, 5],
      damping: [.09, 0, 1, .01]
    },
    hierarchicalRepulsion: {
      centralGravity: [.2, 0, 10, .05],
      springLength: [100, 0, 500, 5],
      springConstant: [.01, 0, 1.2, .005],
      nodeDistance: [120, 0, 500, 5],
      damping: [.09, 0, 1, .01],
      avoidOverlap: [0, 0, 1, .01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [.1, .01, .5, .01],
    solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
    timestep: [.5, .01, 1, .01]
  }
},
    jT = Object.freeze({
  __proto__: null,
  allOptions: FT,
  configureOptions: NT
}),
    zT = function () {
  function t() {
    oc(this, t);
  }

  return hc(t, [{
    key: "getDistances",
    value: function (t, e, i) {
      for (var n = {}, o = t.edges, r = 0; r < e.length; r++) {
        var s = {};
        n[e[r]] = s;

        for (var a = 0; a < e.length; a++) s[e[a]] = r == a ? 0 : 1e9;
      }

      for (var h = 0; h < i.length; h++) {
        var l = o[i[h]];
        !0 === l.connected && void 0 !== n[l.fromId] && void 0 !== n[l.toId] && (n[l.fromId][l.toId] = 1, n[l.toId][l.fromId] = 1);
      }

      for (var d = e.length, u = 0; u < d; u++) for (var c = e[u], f = n[c], p = 0; p < d - 1; p++) for (var v = e[p], y = n[v], g = p + 1; g < d; g++) {
        var m = e[g],
            b = n[m],
            w = Math.min(y[m], y[c] + f[m]);
        y[m] = w, b[v] = w;
      }

      return n;
    }
  }]), t;
}(),
    LT = function () {
  function t(e, i, n) {
    oc(this, t), this.body = e, this.springLength = i, this.springConstant = n, this.distanceSolver = new zT();
  }

  return hc(t, [{
    key: "setOptions",
    value: function (t) {
      t && (t.springLength && (this.springLength = t.springLength), t.springConstant && (this.springConstant = t.springConstant));
    }
  }, {
    key: "solve",
    value: function (t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = this.distanceSolver.getDistances(this.body, t, e);
      this._createL_matrix(n), this._createK_matrix(n), this._createE_matrix();

      for (var o = .01, r = 1, s = 0, a = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3)), h = 5, l = 1e9, d = 0, u = 0, c = 0, f = 0, p = 0; l > o && s < a;) {
        s += 1;

        var v = this._getHighestEnergyNode(i),
            y = QS(v, 4);

        for (d = y[0], l = y[1], u = y[2], c = y[3], f = l, p = 0; f > r && p < h;) {
          p += 1, this._moveNode(d, u, c);

          var g = this._getEnergy(d),
              m = QS(g, 3);

          f = m[0], u = m[1], c = m[2];
        }
      }
    }
  }, {
    key: "_getHighestEnergyNode",
    value: function (t) {
      for (var e = this.body.nodeIndices, i = this.body.nodes, n = 0, o = e[0], r = 0, s = 0, a = 0; a < e.length; a++) {
        var h = e[a];

        if (!1 === i[h].predefinedPosition || !0 === i[h].isCluster && !0 === t || !0 === i[h].options.fixed.x || !0 === i[h].options.fixed.y) {
          var l = this._getEnergy(h),
              d = QS(l, 3),
              u = d[0],
              c = d[1],
              f = d[2];

          n < u && (n = u, o = h, r = c, s = f);
        }
      }

      return [o, n, r, s];
    }
  }, {
    key: "_getEnergy",
    value: function (t) {
      var e = QS(this.E_sums[t], 2),
          i = e[0],
          n = e[1];
      return [Math.sqrt(Math.pow(i, 2) + Math.pow(n, 2)), i, n];
    }
  }, {
    key: "_moveNode",
    value: function (t, e, i) {
      for (var n = this.body.nodeIndices, o = this.body.nodes, r = 0, s = 0, a = 0, h = o[t].x, l = o[t].y, d = this.K_matrix[t], u = this.L_matrix[t], c = 0; c < n.length; c++) {
        var f = n[c];

        if (f !== t) {
          var p = o[f].x,
              v = o[f].y,
              y = d[f],
              g = u[f],
              m = 1 / Math.pow(Math.pow(h - p, 2) + Math.pow(l - v, 2), 1.5);
          r += y * (1 - g * Math.pow(l - v, 2) * m), s += y * (g * (h - p) * (l - v) * m), a += y * (1 - g * Math.pow(h - p, 2) * m);
        }
      }

      var b = (e / r + i / s) / (s / r - a / s),
          w = -(s * b + e) / r;
      o[t].x += w, o[t].y += b, this._updateE_matrix(t);
    }
  }, {
    key: "_createL_matrix",
    value: function (t) {
      var e = this.body.nodeIndices,
          i = this.springLength;
      this.L_matrix = [];

      for (var n = 0; n < e.length; n++) {
        this.L_matrix[e[n]] = {};

        for (var o = 0; o < e.length; o++) this.L_matrix[e[n]][e[o]] = i * t[e[n]][e[o]];
      }
    }
  }, {
    key: "_createK_matrix",
    value: function (t) {
      var e = this.body.nodeIndices,
          i = this.springConstant;
      this.K_matrix = [];

      for (var n = 0; n < e.length; n++) {
        this.K_matrix[e[n]] = {};

        for (var o = 0; o < e.length; o++) this.K_matrix[e[n]][e[o]] = i * Math.pow(t[e[n]][e[o]], -2);
      }
    }
  }, {
    key: "_createE_matrix",
    value: function () {
      var t = this.body.nodeIndices,
          e = this.body.nodes;
      this.E_matrix = {}, this.E_sums = {};

      for (var i = 0; i < t.length; i++) this.E_matrix[t[i]] = [];

      for (var n = 0; n < t.length; n++) {
        for (var o = t[n], r = e[o].x, s = e[o].y, a = 0, h = 0, l = n; l < t.length; l++) {
          var d = t[l];

          if (d !== o) {
            var u = e[d].x,
                c = e[d].y,
                f = 1 / Math.sqrt(Math.pow(r - u, 2) + Math.pow(s - c, 2));
            this.E_matrix[o][l] = [this.K_matrix[o][d] * (r - u - this.L_matrix[o][d] * (r - u) * f), this.K_matrix[o][d] * (s - c - this.L_matrix[o][d] * (s - c) * f)], this.E_matrix[d][n] = this.E_matrix[o][l], a += this.E_matrix[o][l][0], h += this.E_matrix[o][l][1];
          }
        }

        this.E_sums[o] = [a, h];
      }
    }
  }, {
    key: "_updateE_matrix",
    value: function (t) {
      for (var e = this.body.nodeIndices, i = this.body.nodes, n = this.E_matrix[t], o = this.K_matrix[t], r = this.L_matrix[t], s = i[t].x, a = i[t].y, h = 0, l = 0, d = 0; d < e.length; d++) {
        var u = e[d];

        if (u !== t) {
          var c = n[d],
              f = c[0],
              p = c[1],
              v = i[u].x,
              y = i[u].y,
              g = 1 / Math.sqrt(Math.pow(s - v, 2) + Math.pow(a - y, 2)),
              m = o[u] * (s - v - r[u] * (s - v) * g),
              b = o[u] * (a - y - r[u] * (a - y) * g);
          n[d] = [m, b], h += m, l += b;
          var w = this.E_sums[u];
          w[0] += m - f, w[1] += b - p;
        }
      }

      this.E_sums[t] = [h, l];
    }
  }]), t;
}();

function RT(t, e, i) {
  var n,
      o,
      r,
      s,
      a = this;
  if (!(this instanceof RT)) throw new SyntaxError("Constructor must be called with the new operator");
  this.options = {}, this.defaultOptions = {
    locale: "en",
    locales: nc,
    clickToUse: !1
  }, Yr(this.options, this.defaultOptions), this.body = {
    container: t,
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: $(n = this.on).call(n, this),
      off: $(o = this.off).call(o, this),
      emit: $(r = this.emit).call(r, this),
      once: $(s = this.once).call(s, this)
    },
    eventListeners: {
      onTap: function () {},
      onTouch: function () {},
      onDoubleTap: function () {},
      onHold: function () {},
      onDragStart: function () {},
      onDrag: function () {},
      onDragEnd: function () {},
      onMouseWheel: function () {},
      onPinch: function () {},
      onMouseMove: function () {},
      onRelease: function () {},
      onContext: function () {}
    },
    data: {
      nodes: null,
      edges: null
    },
    functions: {
      createNode: function () {},
      createEdge: function () {},
      getPointer: function () {}
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    }
  }, this.bindEventListeners(), this.images = new dc(function () {
    return a.body.emitter.emit("_requestRedraw");
  }), this.groups = new uc(), this.canvas = new _D(this.body), this.selectionHandler = new TD(this.body, this.canvas), this.interactionHandler = new DD(this.body, this.canvas, this.selectionHandler), this.view = new SD(this.body, this.canvas), this.renderer = new mD(this.body, this.canvas), this.physics = new lD(this.body), this.layoutEngine = new OT(this.body), this.clustering = new gD(this.body), this.manipulation = new ST(this.body, this.canvas, this.selectionHandler, this.interactionHandler), this.nodesHandler = new gE(this.body, this.images, this.groups, this.layoutEngine), this.edgesHandler = new JE(this.body, this.images, this.groups), this.body.modules.kamadaKawai = new LT(this.body, 150, .05), this.body.modules.clustering = this.clustering, this.canvas._create(), this.setOptions(i), this.setData(e);
}

ot(RT.prototype), RT.prototype.setOptions = function (t) {
  var e = this;

  if (null === t && (t = void 0), void 0 !== t) {
    !0 === pE.validate(t, FT) && console.log("%cErrors have been found in the supplied options object.", fE);

    if (Wr(["locale", "locales", "clickToUse"], this.options, t), t = this.layoutEngine.setOptions(t.layout, t), this.canvas.setOptions(t), this.groups.setOptions(t.groups), this.nodesHandler.setOptions(t.nodes), this.edgesHandler.setOptions(t.edges), this.physics.setOptions(t.physics), this.manipulation.setOptions(t.manipulation, t, this.options), this.interactionHandler.setOptions(t.interaction), this.renderer.setOptions(t.interaction), this.selectionHandler.setOptions(t.interaction), void 0 !== t.groups && this.body.emitter.emit("refreshNodes"), "configure" in t && (this.configurator || (this.configurator = new DT(this, this.body.container, NT, this.canvas.pixelRatio)), this.configurator.setOptions(t.configure)), this.configurator && !0 === this.configurator.options.enabled) {
      var i = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      Ur(i.nodes, this.nodesHandler.options), Ur(i.edges, this.edgesHandler.options), Ur(i.layout, this.layoutEngine.options), Ur(i.interaction, this.selectionHandler.options), Ur(i.interaction, this.renderer.options), Ur(i.interaction, this.interactionHandler.options), Ur(i.manipulation, this.manipulation.options), Ur(i.physics, this.physics.options), Ur(i.global, this.canvas.options), Ur(i.global, this.options), this.configurator.setModuleOptions(i);
    }

    void 0 !== t.clickToUse ? !0 === t.clickToUse ? void 0 === this.activator && (this.activator = new ic(this.canvas.frame), this.activator.on("change", function () {
      e.body.emitter.emit("activate");
    })) : (void 0 !== this.activator && (this.activator.destroy(), delete this.activator), this.body.emitter.emit("activate")) : this.body.emitter.emit("activate"), this.canvas.setSize(), this.body.emitter.emit("startSimulation");
  }
}, RT.prototype._updateVisibleIndices = function () {
  var t = this.body.nodes,
      e = this.body.edges;

  for (var i in this.body.nodeIndices = [], this.body.edgeIndices = [], t) t.hasOwnProperty(i) && (this.clustering._isClusteredNode(i) || !1 !== t[i].options.hidden || this.body.nodeIndices.push(t[i].id));

  for (var n in e) if (e.hasOwnProperty(n)) {
    var o = e[n],
        r = t[o.fromId],
        s = t[o.toId],
        a = void 0 !== r && void 0 !== s;
    !this.clustering._isClusteredEdge(n) && !1 === o.options.hidden && a && !1 === r.options.hidden && !1 === s.options.hidden && this.body.edgeIndices.push(o.id);
  }
}, RT.prototype.bindEventListeners = function () {
  var t = this;
  this.body.emitter.on("_dataChanged", function () {
    t.edgesHandler._updateState(), t.body.emitter.emit("_dataUpdated");
  }), this.body.emitter.on("_dataUpdated", function () {
    t.clustering._updateState(), t._updateVisibleIndices(), t._updateValueRange(t.body.nodes), t._updateValueRange(t.body.edges), t.body.emitter.emit("startSimulation"), t.body.emitter.emit("_requestRedraw");
  });
}, RT.prototype.setData = function (t) {
  if (this.body.emitter.emit("resetPhysics"), this.body.emitter.emit("_resetData"), this.selectionHandler.unselectAll(), t && t.dot && (t.nodes || t.edges)) throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');

  if (this.setOptions(t && t.options), t && t.dot) {
    console.log("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
    var e = jl.DOTToGraph(t.dot);
    this.setData(e);
  } else if (t && t.gephi) {
    console.log("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
    var i = Hl(t.gephi);
    this.setData(i);
  } else this.nodesHandler.setData(t && t.nodes, !0), this.edgesHandler.setData(t && t.edges, !0), this.body.emitter.emit("_dataChanged"), this.body.emitter.emit("_dataLoaded"), this.body.emitter.emit("initPhysics");
}, RT.prototype.destroy = function () {
  for (var t in this.body.emitter.emit("destroy"), this.body.emitter.off(), this.off(), delete this.groups, delete this.canvas, delete this.selectionHandler, delete this.interactionHandler, delete this.view, delete this.renderer, delete this.physics, delete this.layoutEngine, delete this.clustering, delete this.manipulation, delete this.nodesHandler, delete this.edgesHandler, delete this.configurator, delete this.images, this.body.nodes) this.body.nodes.hasOwnProperty(t) && delete this.body.nodes[t];

  for (var e in this.body.edges) this.body.edges.hasOwnProperty(e) && delete this.body.edges[e];

  Nr(this.body.container);
}, RT.prototype._updateValueRange = function (t) {
  var e,
      i = void 0,
      n = void 0,
      o = 0;

  for (e in t) if (t.hasOwnProperty(e)) {
    var r = t[e].getValue();
    void 0 !== r && (i = void 0 === i ? r : Math.min(r, i), n = void 0 === n ? r : Math.max(r, n), o += r);
  }

  if (void 0 !== i && void 0 !== n) for (e in t) t.hasOwnProperty(e) && t[e].setValueRange(i, n, o);
}, RT.prototype.isActive = function () {
  return !this.activator || this.activator.active;
}, RT.prototype.setSize = function () {
  return this.canvas.setSize.apply(this.canvas, arguments);
}, RT.prototype.canvasToDOM = function () {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
}, RT.prototype.DOMtoCanvas = function () {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
}, RT.prototype.findNode = function () {
  return this.clustering.findNode.apply(this.clustering, arguments);
}, RT.prototype.isCluster = function () {
  return this.clustering.isCluster.apply(this.clustering, arguments);
}, RT.prototype.openCluster = function () {
  return this.clustering.openCluster.apply(this.clustering, arguments);
}, RT.prototype.cluster = function () {
  return this.clustering.cluster.apply(this.clustering, arguments);
}, RT.prototype.getNodesInCluster = function () {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
}, RT.prototype.clusterByConnection = function () {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
}, RT.prototype.clusterByHubsize = function () {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
}, RT.prototype.clusterOutliers = function () {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
}, RT.prototype.getSeed = function () {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
}, RT.prototype.enableEditMode = function () {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
}, RT.prototype.disableEditMode = function () {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
}, RT.prototype.addNodeMode = function () {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
}, RT.prototype.editNode = function () {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
}, RT.prototype.editNodeMode = function () {
  return console.log("Deprecated: Please use editNode instead of editNodeMode."), this.manipulation.editNode.apply(this.manipulation, arguments);
}, RT.prototype.addEdgeMode = function () {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
}, RT.prototype.editEdgeMode = function () {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
}, RT.prototype.deleteSelected = function () {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
}, RT.prototype.getPositions = function () {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
}, RT.prototype.storePositions = function () {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
}, RT.prototype.moveNode = function () {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
}, RT.prototype.getBoundingBox = function () {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
}, RT.prototype.getConnectedNodes = function (t) {
  return void 0 !== this.body.nodes[t] ? this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments) : this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
}, RT.prototype.getConnectedEdges = function () {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
}, RT.prototype.startSimulation = function () {
  return this.physics.startSimulation.apply(this.physics, arguments);
}, RT.prototype.stopSimulation = function () {
  return this.physics.stopSimulation.apply(this.physics, arguments);
}, RT.prototype.stabilize = function () {
  return this.physics.stabilize.apply(this.physics, arguments);
}, RT.prototype.getSelection = function () {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
}, RT.prototype.setSelection = function () {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
}, RT.prototype.getSelectedNodes = function () {
  return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
}, RT.prototype.getSelectedEdges = function () {
  return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
}, RT.prototype.getNodeAt = function () {
  var t = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
  return void 0 !== t && void 0 !== t.id ? t.id : t;
}, RT.prototype.getEdgeAt = function () {
  var t = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
  return void 0 !== t && void 0 !== t.id ? t.id : t;
}, RT.prototype.selectNodes = function () {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
}, RT.prototype.selectEdges = function () {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
}, RT.prototype.unselectAll = function () {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments), this.redraw();
}, RT.prototype.redraw = function () {
  return this.renderer.redraw.apply(this.renderer, arguments);
}, RT.prototype.getScale = function () {
  return this.view.getScale.apply(this.view, arguments);
}, RT.prototype.getViewPosition = function () {
  return this.view.getViewPosition.apply(this.view, arguments);
}, RT.prototype.fit = function () {
  return this.view.fit.apply(this.view, arguments);
}, RT.prototype.moveTo = function () {
  return this.view.moveTo.apply(this.view, arguments);
}, RT.prototype.focus = function () {
  return this.view.focus.apply(this.view, arguments);
}, RT.prototype.releaseNode = function () {
  return this.view.releaseNode.apply(this.view, arguments);
}, RT.prototype.getOptionsFromConfigurator = function () {
  var t = {};
  return this.configurator && (t = this.configurator.getOptions.apply(this.configurator)), t;
};
var BT = i(function (t, e) {
  e.prepareElements = function (t) {
    for (var e in t) t.hasOwnProperty(e) && (t[e].redundant = t[e].used, t[e].used = []);
  }, e.cleanupElements = function (t) {
    for (var e in t) if (t.hasOwnProperty(e) && t[e].redundant) {
      for (var i = 0; i < t[e].redundant.length; i++) t[e].redundant[i].parentNode.removeChild(t[e].redundant[i]);

      t[e].redundant = [];
    }
  }, e.resetElements = function (t) {
    e.prepareElements(t), e.cleanupElements(t), e.prepareElements(t);
  }, e.getSVGElement = function (t, e, i) {
    var n;
    return e.hasOwnProperty(t) ? e[t].redundant.length > 0 ? (n = e[t].redundant[0], e[t].redundant.shift()) : (n = document.createElementNS("http://www.w3.org/2000/svg", t), i.appendChild(n)) : (n = document.createElementNS("http://www.w3.org/2000/svg", t), e[t] = {
      used: [],
      redundant: []
    }, i.appendChild(n)), e[t].used.push(n), n;
  }, e.getDOMElement = function (t, e, i, n) {
    var o;
    return e.hasOwnProperty(t) ? e[t].redundant.length > 0 ? (o = e[t].redundant[0], e[t].redundant.shift()) : (o = document.createElement(t), void 0 !== n ? i.insertBefore(o, n) : i.appendChild(o)) : (o = document.createElement(t), e[t] = {
      used: [],
      redundant: []
    }, void 0 !== n ? i.insertBefore(o, n) : i.appendChild(o)), e[t].used.push(o), o;
  }, e.drawPoint = function (t, i, n, o, r, s) {
    var a;

    if ("circle" == n.style ? ((a = e.getSVGElement("circle", o, r)).setAttributeNS(null, "cx", t), a.setAttributeNS(null, "cy", i), a.setAttributeNS(null, "r", .5 * n.size)) : ((a = e.getSVGElement("rect", o, r)).setAttributeNS(null, "x", t - .5 * n.size), a.setAttributeNS(null, "y", i - .5 * n.size), a.setAttributeNS(null, "width", n.size), a.setAttributeNS(null, "height", n.size)), void 0 !== n.styles && a.setAttributeNS(null, "style", n.styles), a.setAttributeNS(null, "class", n.className + " vis-point"), s) {
      var h = e.getSVGElement("text", o, r);
      s.xOffset && (t += s.xOffset), s.yOffset && (i += s.yOffset), s.content && (h.textContent = s.content), s.className && h.setAttributeNS(null, "class", s.className + " vis-label"), h.setAttributeNS(null, "x", t), h.setAttributeNS(null, "y", i);
    }

    return a;
  }, e.drawBar = function (t, i, n, o, r, s, a, h) {
    if (0 != o) {
      o < 0 && (i -= o *= -1);
      var l = e.getSVGElement("rect", s, a);
      l.setAttributeNS(null, "x", t - .5 * n), l.setAttributeNS(null, "y", i), l.setAttributeNS(null, "width", n), l.setAttributeNS(null, "height", o), l.setAttributeNS(null, "class", r), h && l.setAttributeNS(null, "style", h);
    }
  };
}),
    YT = BT.prepareElements,
    HT = BT.cleanupElements,
    WT = BT.resetElements,
    VT = BT.getSVGElement,
    UT = BT.getDOMElement,
    GT = BT.drawPoint,
    qT = BT.drawBar,
    XT = Object.freeze({
  __proto__: null,
  default: BT,
  __moduleExports: BT,
  prepareElements: YT,
  cleanupElements: HT,
  resetElements: WT,
  getSVGElement: VT,
  getDOMElement: UT,
  drawPoint: GT,
  drawBar: qT
}),
    ZT = i(function (t, i) {
  t.exports = function () {
    var i, n;

    function o() {
      return i.apply(null, arguments);
    }

    function r(t) {
      return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t);
    }

    function s(t) {
      return null != t && "[object Object]" === Object.prototype.toString.call(t);
    }

    function a(t) {
      return void 0 === t;
    }

    function h(t) {
      return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t);
    }

    function l(t) {
      return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t);
    }

    function d(t, e) {
      var i,
          n = [];

      for (i = 0; i < t.length; ++i) n.push(e(t[i], i));

      return n;
    }

    function u(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }

    function c(t, e) {
      for (var i in e) u(e, i) && (t[i] = e[i]);

      return u(e, "toString") && (t.toString = e.toString), u(e, "valueOf") && (t.valueOf = e.valueOf), t;
    }

    function f(t, e, i, n) {
      return Ie(t, e, i, n, !0).utc();
    }

    function p(t) {
      return null == t._pf && (t._pf = {
        empty: !1,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: !1,
        invalidMonth: null,
        invalidFormat: !1,
        userInvalidated: !1,
        iso: !1,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: !1,
        weekdayMismatch: !1
      }), t._pf;
    }

    function v(t) {
      if (null == t._isValid) {
        var e = p(t),
            i = n.call(e.parsedDateParts, function (t) {
          return null != t;
        }),
            o = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && i);
        if (t._strict && (o = o && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return o;
        t._isValid = o;
      }

      return t._isValid;
    }

    function y(t) {
      var e = f(NaN);
      return null != t ? c(p(e), t) : p(e).userInvalidated = !0, e;
    }

    n = Array.prototype.some ? Array.prototype.some : function (t) {
      for (var e = Object(this), i = e.length >>> 0, n = 0; n < i; n++) if (n in e && t.call(this, e[n], n, e)) return !0;

      return !1;
    };
    var g = o.momentProperties = [];

    function m(t, e) {
      var i, n, o;
      if (a(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), a(e._i) || (t._i = e._i), a(e._f) || (t._f = e._f), a(e._l) || (t._l = e._l), a(e._strict) || (t._strict = e._strict), a(e._tzm) || (t._tzm = e._tzm), a(e._isUTC) || (t._isUTC = e._isUTC), a(e._offset) || (t._offset = e._offset), a(e._pf) || (t._pf = p(e)), a(e._locale) || (t._locale = e._locale), g.length > 0) for (i = 0; i < g.length; i++) a(o = e[n = g[i]]) || (t[n] = o);
      return t;
    }

    var b = !1;

    function w(t) {
      m(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === b && (b = !0, o.updateOffset(this), b = !1);
    }

    function _(t) {
      return t instanceof w || null != t && null != t._isAMomentObject;
    }

    function k(t) {
      return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
    }

    function x(t) {
      var e = +t,
          i = 0;
      return 0 !== e && isFinite(e) && (i = k(e)), i;
    }

    function O(t, e, i) {
      var n,
          o = Math.min(t.length, e.length),
          r = Math.abs(t.length - e.length),
          s = 0;

      for (n = 0; n < o; n++) (i && t[n] !== e[n] || !i && x(t[n]) !== x(e[n])) && s++;

      return s + r;
    }

    function S(t) {
      !1 === o.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t);
    }

    function M(t, e) {
      var i = !0;
      return c(function () {
        if (null != o.deprecationHandler && o.deprecationHandler(null, t), i) {
          for (var n, r = [], s = 0; s < arguments.length; s++) {
            if (n = "", "object" == typeof arguments[s]) {
              for (var a in n += "\n[" + s + "] ", arguments[0]) n += a + ": " + arguments[0][a] + ", ";

              n = n.slice(0, -2);
            } else n = arguments[s];

            r.push(n);
          }

          S(t + "\nArguments: " + Array.prototype.slice.call(r).join("") + "\n" + new Error().stack), i = !1;
        }

        return e.apply(this, arguments);
      }, e);
    }

    var E,
        D = {};

    function T(t, e) {
      null != o.deprecationHandler && o.deprecationHandler(t, e), D[t] || (S(e), D[t] = !0);
    }

    function C(t) {
      return t instanceof Function || "[object Function]" === Object.prototype.toString.call(t);
    }

    function P(t, e) {
      var i,
          n = c({}, t);

      for (i in e) u(e, i) && (s(t[i]) && s(e[i]) ? (n[i] = {}, c(n[i], t[i]), c(n[i], e[i])) : null != e[i] ? n[i] = e[i] : delete n[i]);

      for (i in t) u(t, i) && !u(e, i) && s(t[i]) && (n[i] = c({}, n[i]));

      return n;
    }

    function A(t) {
      null != t && this.set(t);
    }

    o.suppressDeprecationWarnings = !1, o.deprecationHandler = null, E = Object.keys ? Object.keys : function (t) {
      var e,
          i = [];

      for (e in t) u(t, e) && i.push(e);

      return i;
    };
    var I = {};

    function F(t, e) {
      var i = t.toLowerCase();
      I[i] = I[i + "s"] = I[e] = t;
    }

    function N(t) {
      return "string" == typeof t ? I[t] || I[t.toLowerCase()] : void 0;
    }

    function j(t) {
      var e,
          i,
          n = {};

      for (i in t) u(t, i) && (e = N(i)) && (n[e] = t[i]);

      return n;
    }

    var z = {};

    function L(t, e) {
      z[t] = e;
    }

    function R(t, e, i) {
      var n = "" + Math.abs(t),
          o = e - n.length;
      return (t >= 0 ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, o)).toString().substr(1) + n;
    }

    var B = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        Y = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        H = {},
        W = {};

    function V(t, e, i, n) {
      var o = n;
      "string" == typeof n && (o = function () {
        return this[n]();
      }), t && (W[t] = o), e && (W[e[0]] = function () {
        return R(o.apply(this, arguments), e[1], e[2]);
      }), i && (W[i] = function () {
        return this.localeData().ordinal(o.apply(this, arguments), t);
      });
    }

    function U(t, e) {
      return t.isValid() ? (e = G(e, t.localeData()), H[e] = H[e] || function (t) {
        var e,
            i,
            n,
            o = t.match(B);

        for (e = 0, i = o.length; e < i; e++) W[o[e]] ? o[e] = W[o[e]] : o[e] = (n = o[e]).match(/\[[\s\S]/) ? n.replace(/^\[|\]$/g, "") : n.replace(/\\/g, "");

        return function (e) {
          var n,
              r = "";

          for (n = 0; n < i; n++) r += C(o[n]) ? o[n].call(e, t) : o[n];

          return r;
        };
      }(e), H[e](t)) : t.localeData().invalidDate();
    }

    function G(t, e) {
      var i = 5;

      function n(t) {
        return e.longDateFormat(t) || t;
      }

      for (Y.lastIndex = 0; i >= 0 && Y.test(t);) t = t.replace(Y, n), Y.lastIndex = 0, i -= 1;

      return t;
    }

    var q = /\d/,
        X = /\d\d/,
        Z = /\d{3}/,
        K = /\d{4}/,
        $ = /[+-]?\d{6}/,
        J = /\d\d?/,
        Q = /\d\d\d\d?/,
        tt = /\d\d\d\d\d\d?/,
        et = /\d{1,3}/,
        it = /\d{1,4}/,
        nt = /[+-]?\d{1,6}/,
        ot = /\d+/,
        rt = /[+-]?\d+/,
        st = /Z|[+-]\d\d:?\d\d/gi,
        at = /Z|[+-]\d\d(?::?\d\d)?/gi,
        ht = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        lt = {};

    function dt(t, e, i) {
      lt[t] = C(e) ? e : function (t, n) {
        return t && i ? i : e;
      };
    }

    function ut(t, e) {
      return u(lt, t) ? lt[t](e._strict, e._locale) : new RegExp(ct(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, o) {
        return e || i || n || o;
      })));
    }

    function ct(t) {
      return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }

    var ft = {};

    function pt(t, e) {
      var i,
          n = e;

      for ("string" == typeof t && (t = [t]), h(e) && (n = function (t, i) {
        i[e] = x(t);
      }), i = 0; i < t.length; i++) ft[t[i]] = n;
    }

    function vt(t, e) {
      pt(t, function (t, i, n, o) {
        n._w = n._w || {}, e(t, n._w, n, o);
      });
    }

    function yt(t, e, i) {
      null != e && u(ft, t) && ft[t](e, i._a, i, t);
    }

    var gt = 0,
        mt = 1,
        bt = 2,
        wt = 3,
        _t = 4,
        kt = 5,
        xt = 6,
        Ot = 7,
        St = 8;

    function Mt(t) {
      return Et(t) ? 366 : 365;
    }

    function Et(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    }

    V("Y", 0, 0, function () {
      var t = this.year();
      return t <= 9999 ? "" + t : "+" + t;
    }), V(0, ["YY", 2], 0, function () {
      return this.year() % 100;
    }), V(0, ["YYYY", 4], 0, "year"), V(0, ["YYYYY", 5], 0, "year"), V(0, ["YYYYYY", 6, !0], 0, "year"), F("year", "y"), L("year", 1), dt("Y", rt), dt("YY", J, X), dt("YYYY", it, K), dt("YYYYY", nt, $), dt("YYYYYY", nt, $), pt(["YYYYY", "YYYYYY"], gt), pt("YYYY", function (t, e) {
      e[gt] = 2 === t.length ? o.parseTwoDigitYear(t) : x(t);
    }), pt("YY", function (t, e) {
      e[gt] = o.parseTwoDigitYear(t);
    }), pt("Y", function (t, e) {
      e[gt] = parseInt(t, 10);
    }), o.parseTwoDigitYear = function (t) {
      return x(t) + (x(t) > 68 ? 1900 : 2e3);
    };
    var Dt,
        Tt = Ct("FullYear", !0);

    function Ct(t, e) {
      return function (i) {
        return null != i ? (At(this, t, i), o.updateOffset(this, e), this) : Pt(this, t);
      };
    }

    function Pt(t, e) {
      return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN;
    }

    function At(t, e, i) {
      t.isValid() && !isNaN(i) && ("FullYear" === e && Et(t.year()) && 1 === t.month() && 29 === t.date() ? t._d["set" + (t._isUTC ? "UTC" : "") + e](i, t.month(), It(i, t.month())) : t._d["set" + (t._isUTC ? "UTC" : "") + e](i));
    }

    function It(t, e) {
      if (isNaN(t) || isNaN(e)) return NaN;

      var i = function (t, e) {
        return (t % e + e) % e;
      }(e, 12);

      return t += (e - i) / 12, 1 === i ? Et(t) ? 29 : 28 : 31 - i % 7 % 2;
    }

    Dt = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) {
      var e;

      for (e = 0; e < this.length; ++e) if (this[e] === t) return e;

      return -1;
    }, V("M", ["MM", 2], "Mo", function () {
      return this.month() + 1;
    }), V("MMM", 0, 0, function (t) {
      return this.localeData().monthsShort(this, t);
    }), V("MMMM", 0, 0, function (t) {
      return this.localeData().months(this, t);
    }), F("month", "M"), L("month", 8), dt("M", J), dt("MM", J, X), dt("MMM", function (t, e) {
      return e.monthsShortRegex(t);
    }), dt("MMMM", function (t, e) {
      return e.monthsRegex(t);
    }), pt(["M", "MM"], function (t, e) {
      e[mt] = x(t) - 1;
    }), pt(["MMM", "MMMM"], function (t, e, i, n) {
      var o = i._locale.monthsParse(t, n, i._strict);

      null != o ? e[mt] = o : p(i).invalidMonth = t;
    });
    var Ft = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        Nt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        jt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

    function zt(t, e, i) {
      var n,
          o,
          r,
          s = t.toLocaleLowerCase();
      if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n) r = f([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[n] = this.months(r, "").toLocaleLowerCase();
      return i ? "MMM" === e ? -1 !== (o = Dt.call(this._shortMonthsParse, s)) ? o : null : -1 !== (o = Dt.call(this._longMonthsParse, s)) ? o : null : "MMM" === e ? -1 !== (o = Dt.call(this._shortMonthsParse, s)) ? o : -1 !== (o = Dt.call(this._longMonthsParse, s)) ? o : null : -1 !== (o = Dt.call(this._longMonthsParse, s)) ? o : -1 !== (o = Dt.call(this._shortMonthsParse, s)) ? o : null;
    }

    function Lt(t, e) {
      var i;
      if (!t.isValid()) return t;
      if ("string" == typeof e) if (/^\d+$/.test(e)) e = x(e);else if (!h(e = t.localeData().monthsParse(e))) return t;
      return i = Math.min(t.date(), It(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i), t;
    }

    function Rt(t) {
      return null != t ? (Lt(this, t), o.updateOffset(this, !0), this) : Pt(this, "Month");
    }

    var Bt = ht,
        Yt = ht;

    function Ht() {
      function t(t, e) {
        return e.length - t.length;
      }

      var e,
          i,
          n = [],
          o = [],
          r = [];

      for (e = 0; e < 12; e++) i = f([2e3, e]), n.push(this.monthsShort(i, "")), o.push(this.months(i, "")), r.push(this.months(i, "")), r.push(this.monthsShort(i, ""));

      for (n.sort(t), o.sort(t), r.sort(t), e = 0; e < 12; e++) n[e] = ct(n[e]), o[e] = ct(o[e]);

      for (e = 0; e < 24; e++) r[e] = ct(r[e]);

      this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i");
    }

    function Wt(t, e, i, n, o, r, s) {
      var a;
      return t < 100 && t >= 0 ? (a = new Date(t + 400, e, i, n, o, r, s), isFinite(a.getFullYear()) && a.setFullYear(t)) : a = new Date(t, e, i, n, o, r, s), a;
    }

    function Vt(t) {
      var e;

      if (t < 100 && t >= 0) {
        var i = Array.prototype.slice.call(arguments);
        i[0] = t + 400, e = new Date(Date.UTC.apply(null, i)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t);
      } else e = new Date(Date.UTC.apply(null, arguments));

      return e;
    }

    function Ut(t, e, i) {
      var n = 7 + e - i;
      return -(7 + Vt(t, 0, n).getUTCDay() - e) % 7 + n - 1;
    }

    function Gt(t, e, i, n, o) {
      var r,
          s,
          a = 1 + 7 * (e - 1) + (7 + i - n) % 7 + Ut(t, n, o);
      return a <= 0 ? s = Mt(r = t - 1) + a : a > Mt(t) ? (r = t + 1, s = a - Mt(t)) : (r = t, s = a), {
        year: r,
        dayOfYear: s
      };
    }

    function qt(t, e, i) {
      var n,
          o,
          r = Ut(t.year(), e, i),
          s = Math.floor((t.dayOfYear() - r - 1) / 7) + 1;
      return s < 1 ? n = s + Xt(o = t.year() - 1, e, i) : s > Xt(t.year(), e, i) ? (n = s - Xt(t.year(), e, i), o = t.year() + 1) : (o = t.year(), n = s), {
        week: n,
        year: o
      };
    }

    function Xt(t, e, i) {
      var n = Ut(t, e, i),
          o = Ut(t + 1, e, i);
      return (Mt(t) - n + o) / 7;
    }

    function Zt(t, e) {
      return t.slice(e, 7).concat(t.slice(0, e));
    }

    V("w", ["ww", 2], "wo", "week"), V("W", ["WW", 2], "Wo", "isoWeek"), F("week", "w"), F("isoWeek", "W"), L("week", 5), L("isoWeek", 5), dt("w", J), dt("ww", J, X), dt("W", J), dt("WW", J, X), vt(["w", "ww", "W", "WW"], function (t, e, i, n) {
      e[n.substr(0, 1)] = x(t);
    }), V("d", 0, "do", "day"), V("dd", 0, 0, function (t) {
      return this.localeData().weekdaysMin(this, t);
    }), V("ddd", 0, 0, function (t) {
      return this.localeData().weekdaysShort(this, t);
    }), V("dddd", 0, 0, function (t) {
      return this.localeData().weekdays(this, t);
    }), V("e", 0, 0, "weekday"), V("E", 0, 0, "isoWeekday"), F("day", "d"), F("weekday", "e"), F("isoWeekday", "E"), L("day", 11), L("weekday", 11), L("isoWeekday", 11), dt("d", J), dt("e", J), dt("E", J), dt("dd", function (t, e) {
      return e.weekdaysMinRegex(t);
    }), dt("ddd", function (t, e) {
      return e.weekdaysShortRegex(t);
    }), dt("dddd", function (t, e) {
      return e.weekdaysRegex(t);
    }), vt(["dd", "ddd", "dddd"], function (t, e, i, n) {
      var o = i._locale.weekdaysParse(t, n, i._strict);

      null != o ? e.d = o : p(i).invalidWeekday = t;
    }), vt(["d", "e", "E"], function (t, e, i, n) {
      e[n] = x(t);
    });
    var Kt = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        $t = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        Jt = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

    function Qt(t, e, i) {
      var n,
          o,
          r,
          s = t.toLocaleLowerCase();
      if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n) r = f([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(r, "").toLocaleLowerCase();
      return i ? "dddd" === e ? -1 !== (o = Dt.call(this._weekdaysParse, s)) ? o : null : "ddd" === e ? -1 !== (o = Dt.call(this._shortWeekdaysParse, s)) ? o : null : -1 !== (o = Dt.call(this._minWeekdaysParse, s)) ? o : null : "dddd" === e ? -1 !== (o = Dt.call(this._weekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._shortWeekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._minWeekdaysParse, s)) ? o : null : "ddd" === e ? -1 !== (o = Dt.call(this._shortWeekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._weekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._minWeekdaysParse, s)) ? o : null : -1 !== (o = Dt.call(this._minWeekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._weekdaysParse, s)) ? o : -1 !== (o = Dt.call(this._shortWeekdaysParse, s)) ? o : null;
    }

    var te = ht,
        ee = ht,
        ie = ht;

    function ne() {
      function t(t, e) {
        return e.length - t.length;
      }

      var e,
          i,
          n,
          o,
          r,
          s = [],
          a = [],
          h = [],
          l = [];

      for (e = 0; e < 7; e++) i = f([2e3, 1]).day(e), n = this.weekdaysMin(i, ""), o = this.weekdaysShort(i, ""), r = this.weekdays(i, ""), s.push(n), a.push(o), h.push(r), l.push(n), l.push(o), l.push(r);

      for (s.sort(t), a.sort(t), h.sort(t), l.sort(t), e = 0; e < 7; e++) a[e] = ct(a[e]), h[e] = ct(h[e]), l[e] = ct(l[e]);

      this._weekdaysRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + s.join("|") + ")", "i");
    }

    function oe() {
      return this.hours() % 12 || 12;
    }

    function re(t, e) {
      V(t, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), e);
      });
    }

    function se(t, e) {
      return e._meridiemParse;
    }

    V("H", ["HH", 2], 0, "hour"), V("h", ["hh", 2], 0, oe), V("k", ["kk", 2], 0, function () {
      return this.hours() || 24;
    }), V("hmm", 0, 0, function () {
      return "" + oe.apply(this) + R(this.minutes(), 2);
    }), V("hmmss", 0, 0, function () {
      return "" + oe.apply(this) + R(this.minutes(), 2) + R(this.seconds(), 2);
    }), V("Hmm", 0, 0, function () {
      return "" + this.hours() + R(this.minutes(), 2);
    }), V("Hmmss", 0, 0, function () {
      return "" + this.hours() + R(this.minutes(), 2) + R(this.seconds(), 2);
    }), re("a", !0), re("A", !1), F("hour", "h"), L("hour", 13), dt("a", se), dt("A", se), dt("H", J), dt("h", J), dt("k", J), dt("HH", J, X), dt("hh", J, X), dt("kk", J, X), dt("hmm", Q), dt("hmmss", tt), dt("Hmm", Q), dt("Hmmss", tt), pt(["H", "HH"], wt), pt(["k", "kk"], function (t, e, i) {
      var n = x(t);
      e[wt] = 24 === n ? 0 : n;
    }), pt(["a", "A"], function (t, e, i) {
      i._isPm = i._locale.isPM(t), i._meridiem = t;
    }), pt(["h", "hh"], function (t, e, i) {
      e[wt] = x(t), p(i).bigHour = !0;
    }), pt("hmm", function (t, e, i) {
      var n = t.length - 2;
      e[wt] = x(t.substr(0, n)), e[_t] = x(t.substr(n)), p(i).bigHour = !0;
    }), pt("hmmss", function (t, e, i) {
      var n = t.length - 4,
          o = t.length - 2;
      e[wt] = x(t.substr(0, n)), e[_t] = x(t.substr(n, 2)), e[kt] = x(t.substr(o)), p(i).bigHour = !0;
    }), pt("Hmm", function (t, e, i) {
      var n = t.length - 2;
      e[wt] = x(t.substr(0, n)), e[_t] = x(t.substr(n));
    }), pt("Hmmss", function (t, e, i) {
      var n = t.length - 4,
          o = t.length - 2;
      e[wt] = x(t.substr(0, n)), e[_t] = x(t.substr(n, 2)), e[kt] = x(t.substr(o));
    });
    var ae,
        he = Ct("Hours", !0),
        le = {
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      longDateFormat: {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      invalidDate: "Invalid date",
      ordinal: "%d",
      dayOfMonthOrdinalParse: /\d{1,2}/,
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      months: Nt,
      monthsShort: jt,
      week: {
        dow: 0,
        doy: 6
      },
      weekdays: Kt,
      weekdaysMin: Jt,
      weekdaysShort: $t,
      meridiemParse: /[ap]\.?m?\.?/i
    },
        de = {},
        ue = {};

    function ce(t) {
      return t ? t.toLowerCase().replace("_", "-") : t;
    }

    function fe(i) {
      var n = null;
      if (!de[i] && t && t.exports) try {
        n = ae._abbr, e(), pe(n);
      } catch (t) {}
      return de[i];
    }

    function pe(t, e) {
      var i;
      return t && ((i = a(e) ? ye(t) : ve(t, e)) ? ae = i : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), ae._abbr;
    }

    function ve(t, e) {
      if (null !== e) {
        var i,
            n = le;
        if (e.abbr = t, null != de[t]) T("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = de[t]._config;else if (null != e.parentLocale) if (null != de[e.parentLocale]) n = de[e.parentLocale]._config;else {
          if (null == (i = fe(e.parentLocale))) return ue[e.parentLocale] || (ue[e.parentLocale] = []), ue[e.parentLocale].push({
            name: t,
            config: e
          }), null;
          n = i._config;
        }
        return de[t] = new A(P(n, e)), ue[t] && ue[t].forEach(function (t) {
          ve(t.name, t.config);
        }), pe(t), de[t];
      }

      return delete de[t], null;
    }

    function ye(t) {
      var e;
      if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return ae;

      if (!r(t)) {
        if (e = fe(t)) return e;
        t = [t];
      }

      return function (t) {
        for (var e, i, n, o, r = 0; r < t.length;) {
          for (e = (o = ce(t[r]).split("-")).length, i = (i = ce(t[r + 1])) ? i.split("-") : null; e > 0;) {
            if (n = fe(o.slice(0, e).join("-"))) return n;
            if (i && i.length >= e && O(o, i, !0) >= e - 1) break;
            e--;
          }

          r++;
        }

        return ae;
      }(t);
    }

    function ge(t) {
      var e,
          i = t._a;
      return i && -2 === p(t).overflow && (e = i[mt] < 0 || i[mt] > 11 ? mt : i[bt] < 1 || i[bt] > It(i[gt], i[mt]) ? bt : i[wt] < 0 || i[wt] > 24 || 24 === i[wt] && (0 !== i[_t] || 0 !== i[kt] || 0 !== i[xt]) ? wt : i[_t] < 0 || i[_t] > 59 ? _t : i[kt] < 0 || i[kt] > 59 ? kt : i[xt] < 0 || i[xt] > 999 ? xt : -1, p(t)._overflowDayOfYear && (e < gt || e > bt) && (e = bt), p(t)._overflowWeeks && -1 === e && (e = Ot), p(t)._overflowWeekday && -1 === e && (e = St), p(t).overflow = e), t;
    }

    function me(t, e, i) {
      return null != t ? t : null != e ? e : i;
    }

    function be(t) {
      var e,
          i,
          n,
          r,
          s,
          a = [];

      if (!t._d) {
        for (n = function (t) {
          var e = new Date(o.now());
          return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()];
        }(t), t._w && null == t._a[bt] && null == t._a[mt] && function (t) {
          var e, i, n, o, r, s, a, h;
          if (null != (e = t._w).GG || null != e.W || null != e.E) r = 1, s = 4, i = me(e.GG, t._a[gt], qt(Fe(), 1, 4).year), n = me(e.W, 1), ((o = me(e.E, 1)) < 1 || o > 7) && (h = !0);else {
            r = t._locale._week.dow, s = t._locale._week.doy;
            var l = qt(Fe(), r, s);
            i = me(e.gg, t._a[gt], l.year), n = me(e.w, l.week), null != e.d ? ((o = e.d) < 0 || o > 6) && (h = !0) : null != e.e ? (o = e.e + r, (e.e < 0 || e.e > 6) && (h = !0)) : o = r;
          }
          n < 1 || n > Xt(i, r, s) ? p(t)._overflowWeeks = !0 : null != h ? p(t)._overflowWeekday = !0 : (a = Gt(i, n, o, r, s), t._a[gt] = a.year, t._dayOfYear = a.dayOfYear);
        }(t), null != t._dayOfYear && (s = me(t._a[gt], n[gt]), (t._dayOfYear > Mt(s) || 0 === t._dayOfYear) && (p(t)._overflowDayOfYear = !0), i = Vt(s, 0, t._dayOfYear), t._a[mt] = i.getUTCMonth(), t._a[bt] = i.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e) t._a[e] = a[e] = n[e];

        for (; e < 7; e++) t._a[e] = a[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];

        24 === t._a[wt] && 0 === t._a[_t] && 0 === t._a[kt] && 0 === t._a[xt] && (t._nextDay = !0, t._a[wt] = 0), t._d = (t._useUTC ? Vt : Wt).apply(null, a), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[wt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (p(t).weekdayMismatch = !0);
      }
    }

    var we = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        _e = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        ke = /Z|[+-]\d\d(?::?\d\d)?/,
        xe = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]],
        Oe = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
        Se = /^\/?Date\((\-?\d+)/i;

    function Me(t) {
      var e,
          i,
          n,
          o,
          r,
          s,
          a = t._i,
          h = we.exec(a) || _e.exec(a);

      if (h) {
        for (p(t).iso = !0, e = 0, i = xe.length; e < i; e++) if (xe[e][1].exec(h[1])) {
          o = xe[e][0], n = !1 !== xe[e][2];
          break;
        }

        if (null == o) return void (t._isValid = !1);

        if (h[3]) {
          for (e = 0, i = Oe.length; e < i; e++) if (Oe[e][1].exec(h[3])) {
            r = (h[2] || " ") + Oe[e][0];
            break;
          }

          if (null == r) return void (t._isValid = !1);
        }

        if (!n && null != r) return void (t._isValid = !1);

        if (h[4]) {
          if (!ke.exec(h[4])) return void (t._isValid = !1);
          s = "Z";
        }

        t._f = o + (r || "") + (s || ""), Pe(t);
      } else t._isValid = !1;
    }

    var Ee = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function De(t) {
      var e = parseInt(t, 10);
      return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
    }

    var Te = {
      UT: 0,
      GMT: 0,
      EDT: -240,
      EST: -300,
      CDT: -300,
      CST: -360,
      MDT: -360,
      MST: -420,
      PDT: -420,
      PST: -480
    };

    function Ce(t) {
      var e,
          i,
          n,
          o,
          r,
          s,
          a,
          h = Ee.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));

      if (h) {
        var l = (e = h[4], i = h[3], n = h[2], o = h[5], r = h[6], s = h[7], a = [De(e), jt.indexOf(i), parseInt(n, 10), parseInt(o, 10), parseInt(r, 10)], s && a.push(parseInt(s, 10)), a);
        if (!function (t, e, i) {
          return !t || $t.indexOf(t) === new Date(e[0], e[1], e[2]).getDay() || (p(i).weekdayMismatch = !0, i._isValid = !1, !1);
        }(h[1], l, t)) return;
        t._a = l, t._tzm = function (t, e, i) {
          if (t) return Te[t];
          if (e) return 0;
          var n = parseInt(i, 10),
              o = n % 100;
          return (n - o) / 100 * 60 + o;
        }(h[8], h[9], h[10]), t._d = Vt.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), p(t).rfc2822 = !0;
      } else t._isValid = !1;
    }

    function Pe(t) {
      if (t._f !== o.ISO_8601) {
        if (t._f !== o.RFC_2822) {
          t._a = [], p(t).empty = !0;
          var e,
              i,
              n,
              r,
              s,
              a = "" + t._i,
              h = a.length,
              l = 0;

          for (n = G(t._f, t._locale).match(B) || [], e = 0; e < n.length; e++) r = n[e], (i = (a.match(ut(r, t)) || [])[0]) && ((s = a.substr(0, a.indexOf(i))).length > 0 && p(t).unusedInput.push(s), a = a.slice(a.indexOf(i) + i.length), l += i.length), W[r] ? (i ? p(t).empty = !1 : p(t).unusedTokens.push(r), yt(r, i, t)) : t._strict && !i && p(t).unusedTokens.push(r);

          p(t).charsLeftOver = h - l, a.length > 0 && p(t).unusedInput.push(a), t._a[wt] <= 12 && !0 === p(t).bigHour && t._a[wt] > 0 && (p(t).bigHour = void 0), p(t).parsedDateParts = t._a.slice(0), p(t).meridiem = t._meridiem, t._a[wt] = function (t, e, i) {
            var n;
            return null == i ? e : null != t.meridiemHour ? t.meridiemHour(e, i) : null != t.isPM ? ((n = t.isPM(i)) && e < 12 && (e += 12), n || 12 !== e || (e = 0), e) : e;
          }(t._locale, t._a[wt], t._meridiem), be(t), ge(t);
        } else Ce(t);
      } else Me(t);
    }

    function Ae(t) {
      var e = t._i,
          i = t._f;
      return t._locale = t._locale || ye(t._l), null === e || void 0 === i && "" === e ? y({
        nullInput: !0
      }) : ("string" == typeof e && (t._i = e = t._locale.preparse(e)), _(e) ? new w(ge(e)) : (l(e) ? t._d = e : r(i) ? function (t) {
        var e, i, n, o, r;
        if (0 === t._f.length) return p(t).invalidFormat = !0, void (t._d = new Date(NaN));

        for (o = 0; o < t._f.length; o++) r = 0, e = m({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[o], Pe(e), v(e) && (r += p(e).charsLeftOver, r += 10 * p(e).unusedTokens.length, p(e).score = r, (null == n || r < n) && (n = r, i = e));

        c(t, i || e);
      }(t) : i ? Pe(t) : function (t) {
        var e = t._i;
        a(e) ? t._d = new Date(o.now()) : l(e) ? t._d = new Date(e.valueOf()) : "string" == typeof e ? function (t) {
          var e = Se.exec(t._i);
          null === e ? (Me(t), !1 === t._isValid && (delete t._isValid, Ce(t), !1 === t._isValid && (delete t._isValid, o.createFromInputFallback(t)))) : t._d = new Date(+e[1]);
        }(t) : r(e) ? (t._a = d(e.slice(0), function (t) {
          return parseInt(t, 10);
        }), be(t)) : s(e) ? function (t) {
          if (!t._d) {
            var e = j(t._i);
            t._a = d([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], function (t) {
              return t && parseInt(t, 10);
            }), be(t);
          }
        }(t) : h(e) ? t._d = new Date(e) : o.createFromInputFallback(t);
      }(t), v(t) || (t._d = null), t));
    }

    function Ie(t, e, i, n, o) {
      var a,
          h = {};
      return !0 !== i && !1 !== i || (n = i, i = void 0), (s(t) && function (t) {
        if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(t).length;
        var e;

        for (e in t) if (t.hasOwnProperty(e)) return !1;

        return !0;
      }(t) || r(t) && 0 === t.length) && (t = void 0), h._isAMomentObject = !0, h._useUTC = h._isUTC = o, h._l = i, h._i = t, h._f = e, h._strict = n, (a = new w(ge(Ae(h))))._nextDay && (a.add(1, "d"), a._nextDay = void 0), a;
    }

    function Fe(t, e, i, n) {
      return Ie(t, e, i, n, !1);
    }

    o.createFromInputFallback = M("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (t) {
      t._d = new Date(t._i + (t._useUTC ? " UTC" : ""));
    }), o.ISO_8601 = function () {}, o.RFC_2822 = function () {};
    var Ne = M("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
      var t = Fe.apply(null, arguments);
      return this.isValid() && t.isValid() ? t < this ? this : t : y();
    }),
        je = M("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
      var t = Fe.apply(null, arguments);
      return this.isValid() && t.isValid() ? t > this ? this : t : y();
    });

    function ze(t, e) {
      var i, n;
      if (1 === e.length && r(e[0]) && (e = e[0]), !e.length) return Fe();

      for (i = e[0], n = 1; n < e.length; ++n) e[n].isValid() && !e[n][t](i) || (i = e[n]);

      return i;
    }

    var Le = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

    function Re(t) {
      var e = j(t),
          i = e.year || 0,
          n = e.quarter || 0,
          o = e.month || 0,
          r = e.week || e.isoWeek || 0,
          s = e.day || 0,
          a = e.hour || 0,
          h = e.minute || 0,
          l = e.second || 0,
          d = e.millisecond || 0;
      this._isValid = function (t) {
        for (var e in t) if (-1 === Dt.call(Le, e) || null != t[e] && isNaN(t[e])) return !1;

        for (var i = !1, n = 0; n < Le.length; ++n) if (t[Le[n]]) {
          if (i) return !1;
          parseFloat(t[Le[n]]) !== x(t[Le[n]]) && (i = !0);
        }

        return !0;
      }(e), this._milliseconds = +d + 1e3 * l + 6e4 * h + 1e3 * a * 60 * 60, this._days = +s + 7 * r, this._months = +o + 3 * n + 12 * i, this._data = {}, this._locale = ye(), this._bubble();
    }

    function Be(t) {
      return t instanceof Re;
    }

    function Ye(t) {
      return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t);
    }

    function He(t, e) {
      V(t, 0, 0, function () {
        var t = this.utcOffset(),
            i = "+";
        return t < 0 && (t = -t, i = "-"), i + R(~~(t / 60), 2) + e + R(~~t % 60, 2);
      });
    }

    He("Z", ":"), He("ZZ", ""), dt("Z", at), dt("ZZ", at), pt(["Z", "ZZ"], function (t, e, i) {
      i._useUTC = !0, i._tzm = Ve(at, t);
    });
    var We = /([\+\-]|\d\d)/gi;

    function Ve(t, e) {
      var i = (e || "").match(t);
      if (null === i) return null;
      var n = ((i[i.length - 1] || []) + "").match(We) || ["-", 0, 0],
          o = 60 * n[1] + x(n[2]);
      return 0 === o ? 0 : "+" === n[0] ? o : -o;
    }

    function Ue(t, e) {
      var i, n;
      return e._isUTC ? (i = e.clone(), n = (_(t) || l(t) ? t.valueOf() : Fe(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), o.updateOffset(i, !1), i) : Fe(t).local();
    }

    function Ge(t) {
      return 15 * -Math.round(t._d.getTimezoneOffset() / 15);
    }

    function qe() {
      return !!this.isValid() && this._isUTC && 0 === this._offset;
    }

    o.updateOffset = function () {};

    var Xe = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
        Ze = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function Ke(t, e) {
      var i,
          n,
          o,
          r,
          s,
          a,
          l = t,
          d = null;
      return Be(t) ? l = {
        ms: t._milliseconds,
        d: t._days,
        M: t._months
      } : h(t) ? (l = {}, e ? l[e] = t : l.milliseconds = t) : (d = Xe.exec(t)) ? (i = "-" === d[1] ? -1 : 1, l = {
        y: 0,
        d: x(d[bt]) * i,
        h: x(d[wt]) * i,
        m: x(d[_t]) * i,
        s: x(d[kt]) * i,
        ms: x(Ye(1e3 * d[xt])) * i
      }) : (d = Ze.exec(t)) ? (i = "-" === d[1] ? -1 : 1, l = {
        y: $e(d[2], i),
        M: $e(d[3], i),
        w: $e(d[4], i),
        d: $e(d[5], i),
        h: $e(d[6], i),
        m: $e(d[7], i),
        s: $e(d[8], i)
      }) : null == l ? l = {} : "object" == typeof l && ("from" in l || "to" in l) && (r = Fe(l.from), s = Fe(l.to), o = r.isValid() && s.isValid() ? (s = Ue(s, r), r.isBefore(s) ? a = Je(r, s) : ((a = Je(s, r)).milliseconds = -a.milliseconds, a.months = -a.months), a) : {
        milliseconds: 0,
        months: 0
      }, (l = {}).ms = o.milliseconds, l.M = o.months), n = new Re(l), Be(t) && u(t, "_locale") && (n._locale = t._locale), n;
    }

    function $e(t, e) {
      var i = t && parseFloat(t.replace(",", "."));
      return (isNaN(i) ? 0 : i) * e;
    }

    function Je(t, e) {
      var i = {};
      return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i;
    }

    function Qe(t, e) {
      return function (i, n) {
        var o;
        return null === n || isNaN(+n) || (T(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), o = i, i = n, n = o), ti(this, Ke(i = "string" == typeof i ? +i : i, n), t), this;
      };
    }

    function ti(t, e, i, n) {
      var r = e._milliseconds,
          s = Ye(e._days),
          a = Ye(e._months);
      t.isValid() && (n = null == n || n, a && Lt(t, Pt(t, "Month") + a * i), s && At(t, "Date", Pt(t, "Date") + s * i), r && t._d.setTime(t._d.valueOf() + r * i), n && o.updateOffset(t, s || a));
    }

    Ke.fn = Re.prototype, Ke.invalid = function () {
      return Ke(NaN);
    };
    var ei = Qe(1, "add"),
        ii = Qe(-1, "subtract");

    function ni(t, e) {
      var i = 12 * (e.year() - t.year()) + (e.month() - t.month()),
          n = t.clone().add(i, "months");
      return -(i + (e - n < 0 ? (e - n) / (n - t.clone().add(i - 1, "months")) : (e - n) / (t.clone().add(i + 1, "months") - n))) || 0;
    }

    function oi(t) {
      var e;
      return void 0 === t ? this._locale._abbr : (null != (e = ye(t)) && (this._locale = e), this);
    }

    o.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", o.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var ri = M("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
      return void 0 === t ? this.localeData() : this.locale(t);
    });

    function si() {
      return this._locale;
    }

    var ai = 1e3,
        hi = 60 * ai,
        li = 60 * hi,
        di = 3506328 * li;

    function ui(t, e) {
      return (t % e + e) % e;
    }

    function ci(t, e, i) {
      return t < 100 && t >= 0 ? new Date(t + 400, e, i) - di : new Date(t, e, i).valueOf();
    }

    function fi(t, e, i) {
      return t < 100 && t >= 0 ? Date.UTC(t + 400, e, i) - di : Date.UTC(t, e, i);
    }

    function pi(t, e) {
      V(0, [t, t.length], 0, e);
    }

    function vi(t, e, i, n, o) {
      var r;
      return null == t ? qt(this, n, o).year : (e > (r = Xt(t, n, o)) && (e = r), yi.call(this, t, e, i, n, o));
    }

    function yi(t, e, i, n, o) {
      var r = Gt(t, e, i, n, o),
          s = Vt(r.year, 0, r.dayOfYear);
      return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this;
    }

    V(0, ["gg", 2], 0, function () {
      return this.weekYear() % 100;
    }), V(0, ["GG", 2], 0, function () {
      return this.isoWeekYear() % 100;
    }), pi("gggg", "weekYear"), pi("ggggg", "weekYear"), pi("GGGG", "isoWeekYear"), pi("GGGGG", "isoWeekYear"), F("weekYear", "gg"), F("isoWeekYear", "GG"), L("weekYear", 1), L("isoWeekYear", 1), dt("G", rt), dt("g", rt), dt("GG", J, X), dt("gg", J, X), dt("GGGG", it, K), dt("gggg", it, K), dt("GGGGG", nt, $), dt("ggggg", nt, $), vt(["gggg", "ggggg", "GGGG", "GGGGG"], function (t, e, i, n) {
      e[n.substr(0, 2)] = x(t);
    }), vt(["gg", "GG"], function (t, e, i, n) {
      e[n] = o.parseTwoDigitYear(t);
    }), V("Q", 0, "Qo", "quarter"), F("quarter", "Q"), L("quarter", 7), dt("Q", q), pt("Q", function (t, e) {
      e[mt] = 3 * (x(t) - 1);
    }), V("D", ["DD", 2], "Do", "date"), F("date", "D"), L("date", 9), dt("D", J), dt("DD", J, X), dt("Do", function (t, e) {
      return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
    }), pt(["D", "DD"], bt), pt("Do", function (t, e) {
      e[bt] = x(t.match(J)[0]);
    });
    var gi = Ct("Date", !0);
    V("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), F("dayOfYear", "DDD"), L("dayOfYear", 4), dt("DDD", et), dt("DDDD", Z), pt(["DDD", "DDDD"], function (t, e, i) {
      i._dayOfYear = x(t);
    }), V("m", ["mm", 2], 0, "minute"), F("minute", "m"), L("minute", 14), dt("m", J), dt("mm", J, X), pt(["m", "mm"], _t);
    var mi = Ct("Minutes", !1);
    V("s", ["ss", 2], 0, "second"), F("second", "s"), L("second", 15), dt("s", J), dt("ss", J, X), pt(["s", "ss"], kt);
    var bi,
        wi = Ct("Seconds", !1);

    for (V("S", 0, 0, function () {
      return ~~(this.millisecond() / 100);
    }), V(0, ["SS", 2], 0, function () {
      return ~~(this.millisecond() / 10);
    }), V(0, ["SSS", 3], 0, "millisecond"), V(0, ["SSSS", 4], 0, function () {
      return 10 * this.millisecond();
    }), V(0, ["SSSSS", 5], 0, function () {
      return 100 * this.millisecond();
    }), V(0, ["SSSSSS", 6], 0, function () {
      return 1e3 * this.millisecond();
    }), V(0, ["SSSSSSS", 7], 0, function () {
      return 1e4 * this.millisecond();
    }), V(0, ["SSSSSSSS", 8], 0, function () {
      return 1e5 * this.millisecond();
    }), V(0, ["SSSSSSSSS", 9], 0, function () {
      return 1e6 * this.millisecond();
    }), F("millisecond", "ms"), L("millisecond", 16), dt("S", et, q), dt("SS", et, X), dt("SSS", et, Z), bi = "SSSS"; bi.length <= 9; bi += "S") dt(bi, ot);

    function _i(t, e) {
      e[xt] = x(1e3 * ("0." + t));
    }

    for (bi = "S"; bi.length <= 9; bi += "S") pt(bi, _i);

    var ki = Ct("Milliseconds", !1);
    V("z", 0, 0, "zoneAbbr"), V("zz", 0, 0, "zoneName");
    var xi = w.prototype;

    function Oi(t) {
      return t;
    }

    xi.add = ei, xi.calendar = function (t, e) {
      var i = t || Fe(),
          n = Ue(i, this).startOf("day"),
          r = o.calendarFormat(this, n) || "sameElse",
          s = e && (C(e[r]) ? e[r].call(this, i) : e[r]);
      return this.format(s || this.localeData().calendar(r, this, Fe(i)));
    }, xi.clone = function () {
      return new w(this);
    }, xi.diff = function (t, e, i) {
      var n, o, r;
      if (!this.isValid()) return NaN;
      if (!(n = Ue(t, this)).isValid()) return NaN;

      switch (o = 6e4 * (n.utcOffset() - this.utcOffset()), e = N(e)) {
        case "year":
          r = ni(this, n) / 12;
          break;

        case "month":
          r = ni(this, n);
          break;

        case "quarter":
          r = ni(this, n) / 3;
          break;

        case "second":
          r = (this - n) / 1e3;
          break;

        case "minute":
          r = (this - n) / 6e4;
          break;

        case "hour":
          r = (this - n) / 36e5;
          break;

        case "day":
          r = (this - n - o) / 864e5;
          break;

        case "week":
          r = (this - n - o) / 6048e5;
          break;

        default:
          r = this - n;
      }

      return i ? r : k(r);
    }, xi.endOf = function (t) {
      var e;
      if (void 0 === (t = N(t)) || "millisecond" === t || !this.isValid()) return this;
      var i = this._isUTC ? fi : ci;

      switch (t) {
        case "year":
          e = i(this.year() + 1, 0, 1) - 1;
          break;

        case "quarter":
          e = i(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case "month":
          e = i(this.year(), this.month() + 1, 1) - 1;
          break;

        case "week":
          e = i(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case "isoWeek":
          e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case "day":
        case "date":
          e = i(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case "hour":
          e = this._d.valueOf(), e += li - ui(e + (this._isUTC ? 0 : this.utcOffset() * hi), li) - 1;
          break;

        case "minute":
          e = this._d.valueOf(), e += hi - ui(e, hi) - 1;
          break;

        case "second":
          e = this._d.valueOf(), e += ai - ui(e, ai) - 1;
      }

      return this._d.setTime(e), o.updateOffset(this, !0), this;
    }, xi.format = function (t) {
      t || (t = this.isUtc() ? o.defaultFormatUtc : o.defaultFormat);
      var e = U(this, t);
      return this.localeData().postformat(e);
    }, xi.from = function (t, e) {
      return this.isValid() && (_(t) && t.isValid() || Fe(t).isValid()) ? Ke({
        to: this,
        from: t
      }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
    }, xi.fromNow = function (t) {
      return this.from(Fe(), t);
    }, xi.to = function (t, e) {
      return this.isValid() && (_(t) && t.isValid() || Fe(t).isValid()) ? Ke({
        from: this,
        to: t
      }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
    }, xi.toNow = function (t) {
      return this.to(Fe(), t);
    }, xi.get = function (t) {
      return C(this[t = N(t)]) ? this[t]() : this;
    }, xi.invalidAt = function () {
      return p(this).overflow;
    }, xi.isAfter = function (t, e) {
      var i = _(t) ? t : Fe(t);
      return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = N(e) || "millisecond") ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf());
    }, xi.isBefore = function (t, e) {
      var i = _(t) ? t : Fe(t);
      return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = N(e) || "millisecond") ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf());
    }, xi.isBetween = function (t, e, i, n) {
      var o = _(t) ? t : Fe(t),
          r = _(e) ? e : Fe(e);
      return !!(this.isValid() && o.isValid() && r.isValid()) && ("(" === (n = n || "()")[0] ? this.isAfter(o, i) : !this.isBefore(o, i)) && (")" === n[1] ? this.isBefore(r, i) : !this.isAfter(r, i));
    }, xi.isSame = function (t, e) {
      var i,
          n = _(t) ? t : Fe(t);
      return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = N(e) || "millisecond") ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf()));
    }, xi.isSameOrAfter = function (t, e) {
      return this.isSame(t, e) || this.isAfter(t, e);
    }, xi.isSameOrBefore = function (t, e) {
      return this.isSame(t, e) || this.isBefore(t, e);
    }, xi.isValid = function () {
      return v(this);
    }, xi.lang = ri, xi.locale = oi, xi.localeData = si, xi.max = je, xi.min = Ne, xi.parsingFlags = function () {
      return c({}, p(this));
    }, xi.set = function (t, e) {
      if ("object" == typeof t) for (var i = function (t) {
        var e = [];

        for (var i in t) e.push({
          unit: i,
          priority: z[i]
        });

        return e.sort(function (t, e) {
          return t.priority - e.priority;
        }), e;
      }(t = j(t)), n = 0; n < i.length; n++) this[i[n].unit](t[i[n].unit]);else if (C(this[t = N(t)])) return this[t](e);
      return this;
    }, xi.startOf = function (t) {
      var e;
      if (void 0 === (t = N(t)) || "millisecond" === t || !this.isValid()) return this;
      var i = this._isUTC ? fi : ci;

      switch (t) {
        case "year":
          e = i(this.year(), 0, 1);
          break;

        case "quarter":
          e = i(this.year(), this.month() - this.month() % 3, 1);
          break;

        case "month":
          e = i(this.year(), this.month(), 1);
          break;

        case "week":
          e = i(this.year(), this.month(), this.date() - this.weekday());
          break;

        case "isoWeek":
          e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case "day":
        case "date":
          e = i(this.year(), this.month(), this.date());
          break;

        case "hour":
          e = this._d.valueOf(), e -= ui(e + (this._isUTC ? 0 : this.utcOffset() * hi), li);
          break;

        case "minute":
          e = this._d.valueOf(), e -= ui(e, hi);
          break;

        case "second":
          e = this._d.valueOf(), e -= ui(e, ai);
      }

      return this._d.setTime(e), o.updateOffset(this, !0), this;
    }, xi.subtract = ii, xi.toArray = function () {
      var t = this;
      return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()];
    }, xi.toObject = function () {
      var t = this;
      return {
        years: t.year(),
        months: t.month(),
        date: t.date(),
        hours: t.hours(),
        minutes: t.minutes(),
        seconds: t.seconds(),
        milliseconds: t.milliseconds()
      };
    }, xi.toDate = function () {
      return new Date(this.valueOf());
    }, xi.toISOString = function (t) {
      if (!this.isValid()) return null;
      var e = !0 !== t,
          i = e ? this.clone().utc() : this;
      return i.year() < 0 || i.year() > 9999 ? U(i, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : C(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", U(i, "Z")) : U(i, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }, xi.inspect = function () {
      if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
      var t = "moment",
          e = "";
      this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
      var i = "[" + t + '("]',
          n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
          o = e + '[")]';
      return this.format(i + n + "-MM-DD[T]HH:mm:ss.SSS" + o);
    }, xi.toJSON = function () {
      return this.isValid() ? this.toISOString() : null;
    }, xi.toString = function () {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }, xi.unix = function () {
      return Math.floor(this.valueOf() / 1e3);
    }, xi.valueOf = function () {
      return this._d.valueOf() - 6e4 * (this._offset || 0);
    }, xi.creationData = function () {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }, xi.year = Tt, xi.isLeapYear = function () {
      return Et(this.year());
    }, xi.weekYear = function (t) {
      return vi.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }, xi.isoWeekYear = function (t) {
      return vi.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4);
    }, xi.quarter = xi.quarters = function (t) {
      return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3);
    }, xi.month = Rt, xi.daysInMonth = function () {
      return It(this.year(), this.month());
    }, xi.week = xi.weeks = function (t) {
      var e = this.localeData().week(this);
      return null == t ? e : this.add(7 * (t - e), "d");
    }, xi.isoWeek = xi.isoWeeks = function (t) {
      var e = qt(this, 1, 4).week;
      return null == t ? e : this.add(7 * (t - e), "d");
    }, xi.weeksInYear = function () {
      var t = this.localeData()._week;

      return Xt(this.year(), t.dow, t.doy);
    }, xi.isoWeeksInYear = function () {
      return Xt(this.year(), 1, 4);
    }, xi.date = gi, xi.day = xi.days = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;
      var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      return null != t ? (t = function (t, e) {
        return "string" != typeof t ? t : isNaN(t) ? "number" == typeof (t = e.weekdaysParse(t)) ? t : null : parseInt(t, 10);
      }(t, this.localeData()), this.add(t - e, "d")) : e;
    }, xi.weekday = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;
      var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return null == t ? e : this.add(t - e, "d");
    }, xi.isoWeekday = function (t) {
      if (!this.isValid()) return null != t ? this : NaN;

      if (null != t) {
        var e = function (t, e) {
          return "string" == typeof t ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t;
        }(t, this.localeData());

        return this.day(this.day() % 7 ? e : e - 7);
      }

      return this.day() || 7;
    }, xi.dayOfYear = function (t) {
      var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
      return null == t ? e : this.add(t - e, "d");
    }, xi.hour = xi.hours = he, xi.minute = xi.minutes = mi, xi.second = xi.seconds = wi, xi.millisecond = xi.milliseconds = ki, xi.utcOffset = function (t, e, i) {
      var n,
          r = this._offset || 0;
      if (!this.isValid()) return null != t ? this : NaN;

      if (null != t) {
        if ("string" == typeof t) {
          if (null === (t = Ve(at, t))) return this;
        } else Math.abs(t) < 16 && !i && (t *= 60);

        return !this._isUTC && e && (n = Ge(this)), this._offset = t, this._isUTC = !0, null != n && this.add(n, "m"), r !== t && (!e || this._changeInProgress ? ti(this, Ke(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, o.updateOffset(this, !0), this._changeInProgress = null)), this;
      }

      return this._isUTC ? r : Ge(this);
    }, xi.utc = function (t) {
      return this.utcOffset(0, t);
    }, xi.local = function (t) {
      return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Ge(this), "m")), this;
    }, xi.parseZone = function () {
      if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);else if ("string" == typeof this._i) {
        var t = Ve(st, this._i);
        null != t ? this.utcOffset(t) : this.utcOffset(0, !0);
      }
      return this;
    }, xi.hasAlignedHourOffset = function (t) {
      return !!this.isValid() && (t = t ? Fe(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0);
    }, xi.isDST = function () {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }, xi.isLocal = function () {
      return !!this.isValid() && !this._isUTC;
    }, xi.isUtcOffset = function () {
      return !!this.isValid() && this._isUTC;
    }, xi.isUtc = qe, xi.isUTC = qe, xi.zoneAbbr = function () {
      return this._isUTC ? "UTC" : "";
    }, xi.zoneName = function () {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }, xi.dates = M("dates accessor is deprecated. Use date instead.", gi), xi.months = M("months accessor is deprecated. Use month instead", Rt), xi.years = M("years accessor is deprecated. Use year instead", Tt), xi.zone = M("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (t, e) {
      return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset();
    }), xi.isDSTShifted = M("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
      if (!a(this._isDSTShifted)) return this._isDSTShifted;
      var t = {};

      if (m(t, this), (t = Ae(t))._a) {
        var e = t._isUTC ? f(t._a) : Fe(t._a);
        this._isDSTShifted = this.isValid() && O(t._a, e.toArray()) > 0;
      } else this._isDSTShifted = !1;

      return this._isDSTShifted;
    });
    var Si = A.prototype;

    function Mi(t, e, i, n) {
      var o = ye(),
          r = f().set(n, e);
      return o[i](r, t);
    }

    function Ei(t, e, i) {
      if (h(t) && (e = t, t = void 0), t = t || "", null != e) return Mi(t, e, i, "month");
      var n,
          o = [];

      for (n = 0; n < 12; n++) o[n] = Mi(t, n, i, "month");

      return o;
    }

    function Di(t, e, i, n) {
      "boolean" == typeof t ? (h(e) && (i = e, e = void 0), e = e || "") : (i = e = t, t = !1, h(e) && (i = e, e = void 0), e = e || "");
      var o,
          r = ye(),
          s = t ? r._week.dow : 0;
      if (null != i) return Mi(e, (i + s) % 7, n, "day");
      var a = [];

      for (o = 0; o < 7; o++) a[o] = Mi(e, (o + s) % 7, n, "day");

      return a;
    }

    Si.calendar = function (t, e, i) {
      var n = this._calendar[t] || this._calendar.sameElse;
      return C(n) ? n.call(e, i) : n;
    }, Si.longDateFormat = function (t) {
      var e = this._longDateFormat[t],
          i = this._longDateFormat[t.toUpperCase()];

      return e || !i ? e : (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, function (t) {
        return t.slice(1);
      }), this._longDateFormat[t]);
    }, Si.invalidDate = function () {
      return this._invalidDate;
    }, Si.ordinal = function (t) {
      return this._ordinal.replace("%d", t);
    }, Si.preparse = Oi, Si.postformat = Oi, Si.relativeTime = function (t, e, i, n) {
      var o = this._relativeTime[i];
      return C(o) ? o(t, e, i, n) : o.replace(/%d/i, t);
    }, Si.pastFuture = function (t, e) {
      var i = this._relativeTime[t > 0 ? "future" : "past"];
      return C(i) ? i(e) : i.replace(/%s/i, e);
    }, Si.set = function (t) {
      var e, i;

      for (i in t) C(e = t[i]) ? this[i] = e : this["_" + i] = e;

      this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }, Si.months = function (t, e) {
      return t ? r(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || Ft).test(e) ? "format" : "standalone"][t.month()] : r(this._months) ? this._months : this._months.standalone;
    }, Si.monthsShort = function (t, e) {
      return t ? r(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[Ft.test(e) ? "format" : "standalone"][t.month()] : r(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }, Si.monthsParse = function (t, e, i) {
      var n, o, r;
      if (this._monthsParseExact) return zt.call(this, t, e, i);

      for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
        if (o = f([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp("^" + this.months(o, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(o, "").replace(".", "") + "$", "i")), i || this._monthsParse[n] || (r = "^" + this.months(o, "") + "|^" + this.monthsShort(o, ""), this._monthsParse[n] = new RegExp(r.replace(".", ""), "i")), i && "MMMM" === e && this._longMonthsParse[n].test(t)) return n;
        if (i && "MMM" === e && this._shortMonthsParse[n].test(t)) return n;
        if (!i && this._monthsParse[n].test(t)) return n;
      }
    }, Si.monthsRegex = function (t) {
      return this._monthsParseExact ? (u(this, "_monthsRegex") || Ht.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (u(this, "_monthsRegex") || (this._monthsRegex = Yt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex);
    }, Si.monthsShortRegex = function (t) {
      return this._monthsParseExact ? (u(this, "_monthsRegex") || Ht.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (u(this, "_monthsShortRegex") || (this._monthsShortRegex = Bt), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }, Si.week = function (t) {
      return qt(t, this._week.dow, this._week.doy).week;
    }, Si.firstDayOfYear = function () {
      return this._week.doy;
    }, Si.firstDayOfWeek = function () {
      return this._week.dow;
    }, Si.weekdays = function (t, e) {
      var i = r(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
      return !0 === t ? Zt(i, this._week.dow) : t ? i[t.day()] : i;
    }, Si.weekdaysMin = function (t) {
      return !0 === t ? Zt(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin;
    }, Si.weekdaysShort = function (t) {
      return !0 === t ? Zt(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort;
    }, Si.weekdaysParse = function (t, e, i) {
      var n, o, r;
      if (this._weekdaysParseExact) return Qt.call(this, t, e, i);

      for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
        if (o = f([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp("^" + this.weekdays(o, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[n] = new RegExp("^" + this.weekdaysShort(o, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[n] = new RegExp("^" + this.weekdaysMin(o, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[n] || (r = "^" + this.weekdays(o, "") + "|^" + this.weekdaysShort(o, "") + "|^" + this.weekdaysMin(o, ""), this._weekdaysParse[n] = new RegExp(r.replace(".", ""), "i")), i && "dddd" === e && this._fullWeekdaysParse[n].test(t)) return n;
        if (i && "ddd" === e && this._shortWeekdaysParse[n].test(t)) return n;
        if (i && "dd" === e && this._minWeekdaysParse[n].test(t)) return n;
        if (!i && this._weekdaysParse[n].test(t)) return n;
      }
    }, Si.weekdaysRegex = function (t) {
      return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || ne.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (u(this, "_weekdaysRegex") || (this._weekdaysRegex = te), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }, Si.weekdaysShortRegex = function (t) {
      return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || ne.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (u(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ee), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }, Si.weekdaysMinRegex = function (t) {
      return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || ne.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (u(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = ie), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }, Si.isPM = function (t) {
      return "p" === (t + "").toLowerCase().charAt(0);
    }, Si.meridiem = function (t, e, i) {
      return t > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
    }, pe("en", {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (t) {
        var e = t % 10;
        return t + (1 === x(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th");
      }
    }), o.lang = M("moment.lang is deprecated. Use moment.locale instead.", pe), o.langData = M("moment.langData is deprecated. Use moment.localeData instead.", ye);
    var Ti = Math.abs;

    function Ci(t, e, i, n) {
      var o = Ke(e, i);
      return t._milliseconds += n * o._milliseconds, t._days += n * o._days, t._months += n * o._months, t._bubble();
    }

    function Pi(t) {
      return t < 0 ? Math.floor(t) : Math.ceil(t);
    }

    function Ai(t) {
      return 4800 * t / 146097;
    }

    function Ii(t) {
      return 146097 * t / 4800;
    }

    function Fi(t) {
      return function () {
        return this.as(t);
      };
    }

    var Ni = Fi("ms"),
        ji = Fi("s"),
        zi = Fi("m"),
        Li = Fi("h"),
        Ri = Fi("d"),
        Bi = Fi("w"),
        Yi = Fi("M"),
        Hi = Fi("Q"),
        Wi = Fi("y");

    function Vi(t) {
      return function () {
        return this.isValid() ? this._data[t] : NaN;
      };
    }

    var Ui = Vi("milliseconds"),
        Gi = Vi("seconds"),
        qi = Vi("minutes"),
        Xi = Vi("hours"),
        Zi = Vi("days"),
        Ki = Vi("months"),
        $i = Vi("years"),
        Ji = Math.round,
        Qi = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };

    function tn(t, e, i, n, o) {
      return o.relativeTime(e || 1, !!i, t, n);
    }

    var en = Math.abs;

    function nn(t) {
      return (t > 0) - (t < 0) || +t;
    }

    function on() {
      if (!this.isValid()) return this.localeData().invalidDate();
      var t,
          e,
          i = en(this._milliseconds) / 1e3,
          n = en(this._days),
          o = en(this._months);
      t = k(i / 60), e = k(t / 60), i %= 60, t %= 60;
      var r = k(o / 12),
          s = o %= 12,
          a = n,
          h = e,
          l = t,
          d = i ? i.toFixed(3).replace(/\.?0+$/, "") : "",
          u = this.asSeconds();
      if (!u) return "P0D";
      var c = u < 0 ? "-" : "",
          f = nn(this._months) !== nn(u) ? "-" : "",
          p = nn(this._days) !== nn(u) ? "-" : "",
          v = nn(this._milliseconds) !== nn(u) ? "-" : "";
      return c + "P" + (r ? f + r + "Y" : "") + (s ? f + s + "M" : "") + (a ? p + a + "D" : "") + (h || l || d ? "T" : "") + (h ? v + h + "H" : "") + (l ? v + l + "M" : "") + (d ? v + d + "S" : "");
    }

    var rn = Re.prototype;
    return rn.isValid = function () {
      return this._isValid;
    }, rn.abs = function () {
      var t = this._data;
      return this._milliseconds = Ti(this._milliseconds), this._days = Ti(this._days), this._months = Ti(this._months), t.milliseconds = Ti(t.milliseconds), t.seconds = Ti(t.seconds), t.minutes = Ti(t.minutes), t.hours = Ti(t.hours), t.months = Ti(t.months), t.years = Ti(t.years), this;
    }, rn.add = function (t, e) {
      return Ci(this, t, e, 1);
    }, rn.subtract = function (t, e) {
      return Ci(this, t, e, -1);
    }, rn.as = function (t) {
      if (!this.isValid()) return NaN;
      var e,
          i,
          n = this._milliseconds;
      if ("month" === (t = N(t)) || "quarter" === t || "year" === t) switch (e = this._days + n / 864e5, i = this._months + Ai(e), t) {
        case "month":
          return i;

        case "quarter":
          return i / 3;

        case "year":
          return i / 12;
      } else switch (e = this._days + Math.round(Ii(this._months)), t) {
        case "week":
          return e / 7 + n / 6048e5;

        case "day":
          return e + n / 864e5;

        case "hour":
          return 24 * e + n / 36e5;

        case "minute":
          return 1440 * e + n / 6e4;

        case "second":
          return 86400 * e + n / 1e3;

        case "millisecond":
          return Math.floor(864e5 * e) + n;

        default:
          throw new Error("Unknown unit " + t);
      }
    }, rn.asMilliseconds = Ni, rn.asSeconds = ji, rn.asMinutes = zi, rn.asHours = Li, rn.asDays = Ri, rn.asWeeks = Bi, rn.asMonths = Yi, rn.asQuarters = Hi, rn.asYears = Wi, rn.valueOf = function () {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * x(this._months / 12) : NaN;
    }, rn._bubble = function () {
      var t,
          e,
          i,
          n,
          o,
          r = this._milliseconds,
          s = this._days,
          a = this._months,
          h = this._data;
      return r >= 0 && s >= 0 && a >= 0 || r <= 0 && s <= 0 && a <= 0 || (r += 864e5 * Pi(Ii(a) + s), s = 0, a = 0), h.milliseconds = r % 1e3, t = k(r / 1e3), h.seconds = t % 60, e = k(t / 60), h.minutes = e % 60, i = k(e / 60), h.hours = i % 24, s += k(i / 24), o = k(Ai(s)), a += o, s -= Pi(Ii(o)), n = k(a / 12), a %= 12, h.days = s, h.months = a, h.years = n, this;
    }, rn.clone = function () {
      return Ke(this);
    }, rn.get = function (t) {
      return t = N(t), this.isValid() ? this[t + "s"]() : NaN;
    }, rn.milliseconds = Ui, rn.seconds = Gi, rn.minutes = qi, rn.hours = Xi, rn.days = Zi, rn.weeks = function () {
      return k(this.days() / 7);
    }, rn.months = Ki, rn.years = $i, rn.humanize = function (t) {
      if (!this.isValid()) return this.localeData().invalidDate();

      var e = this.localeData(),
          i = function (t, e, i) {
        var n = Ke(t).abs(),
            o = Ji(n.as("s")),
            r = Ji(n.as("m")),
            s = Ji(n.as("h")),
            a = Ji(n.as("d")),
            h = Ji(n.as("M")),
            l = Ji(n.as("y")),
            d = o <= Qi.ss && ["s", o] || o < Qi.s && ["ss", o] || r <= 1 && ["m"] || r < Qi.m && ["mm", r] || s <= 1 && ["h"] || s < Qi.h && ["hh", s] || a <= 1 && ["d"] || a < Qi.d && ["dd", a] || h <= 1 && ["M"] || h < Qi.M && ["MM", h] || l <= 1 && ["y"] || ["yy", l];
        return d[2] = e, d[3] = +t > 0, d[4] = i, tn.apply(null, d);
      }(this, !t, e);

      return t && (i = e.pastFuture(+this, i)), e.postformat(i);
    }, rn.toISOString = on, rn.toString = on, rn.toJSON = on, rn.locale = oi, rn.localeData = si, rn.toIsoString = M("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", on), rn.lang = ri, V("X", 0, 0, "unix"), V("x", 0, 0, "valueOf"), dt("x", rt), dt("X", /[+-]?\d+(\.\d{1,3})?/), pt("X", function (t, e, i) {
      i._d = new Date(1e3 * parseFloat(t, 10));
    }), pt("x", function (t, e, i) {
      i._d = new Date(x(t));
    }), o.version = "2.24.0", i = Fe, o.fn = xi, o.min = function () {
      return ze("isBefore", [].slice.call(arguments, 0));
    }, o.max = function () {
      return ze("isAfter", [].slice.call(arguments, 0));
    }, o.now = function () {
      return Date.now ? Date.now() : +new Date();
    }, o.utc = f, o.unix = function (t) {
      return Fe(1e3 * t);
    }, o.months = function (t, e) {
      return Ei(t, e, "months");
    }, o.isDate = l, o.locale = pe, o.invalid = y, o.duration = Ke, o.isMoment = _, o.weekdays = function (t, e, i) {
      return Di(t, e, i, "weekdays");
    }, o.parseZone = function () {
      return Fe.apply(null, arguments).parseZone();
    }, o.localeData = ye, o.isDuration = Be, o.monthsShort = function (t, e) {
      return Ei(t, e, "monthsShort");
    }, o.weekdaysMin = function (t, e, i) {
      return Di(t, e, i, "weekdaysMin");
    }, o.defineLocale = ve, o.updateLocale = function (t, e) {
      if (null != e) {
        var i,
            n,
            o = le;
        null != (n = fe(t)) && (o = n._config), e = P(o, e), (i = new A(e)).parentLocale = de[t], de[t] = i, pe(t);
      } else null != de[t] && (null != de[t].parentLocale ? de[t] = de[t].parentLocale : null != de[t] && delete de[t]);

      return de[t];
    }, o.locales = function () {
      return E(de);
    }, o.weekdaysShort = function (t, e, i) {
      return Di(t, e, i, "weekdaysShort");
    }, o.normalizeUnits = N, o.relativeTimeRounding = function (t) {
      return void 0 === t ? Ji : "function" == typeof t && (Ji = t, !0);
    }, o.relativeTimeThreshold = function (t, e) {
      return void 0 !== Qi[t] && (void 0 === e ? Qi[t] : (Qi[t] = e, "s" === t && (Qi.ss = e - 1), !0));
    }, o.calendarFormat = function (t, e) {
      var i = t.diff(e, "days", !0);
      return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
    }, o.prototype = xi, o.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    }, o;
  }();
}),
    KT = "undefined" != typeof window && window.moment || ZT,
    $T = Object.freeze({
  __proto__: null,
  default: KT,
  __moduleExports: KT
}),
    JT = {
  Images: dc,
  dotparser: zl,
  gephiParser: Wl,
  allOptions: jT,
  convertDot: Nl,
  convertGephi: Hl
},
    QT = Object.freeze({
  __proto__: null,
  network: JT,
  DOMutil: XT,
  util: Ls,
  data: CO,
  moment: $T,
  Hammer: tc,
  keycharm: Gl,
  DataSet: EO,
  DataView: DO,
  Queue: gO,
  Network: RT
});
exports.network = JT;
exports.moment = $T;
exports.DOMutil = XT;
var _default = QT;
exports.default = _default;
},{}],"w89l":[function(require,module,exports) {
var global = arguments[3];
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Graph2d = Graph2d;
exports.util = exports.timeline = exports.moment = exports.keycharm = exports.Timeline = exports.Queue = exports.Hammer = exports.DataView = exports.DataSet = exports.DOMutil = exports.default = void 0;

/**
 * vis-timeline - timeline-graph2d
 * https://github.com/visjs/vis-timeline
 *
 * Create a fully customizable, interactive timeline with items and ranges.
 *
 * @version 6.2.10
 * @date    2019-12-08T21:10:57Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2018-2019 visjs contributors, https://github.com/visjs
 *
 * @license 
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire() {
  throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var O = 'object';

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global_1 = // eslint-disable-next-line no-undef
check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof commonjsGlobal == O && commonjsGlobal) || // eslint-disable-next-line no-new-func
Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
}; // Thank's IE8 for his funny defineProperty


var descriptors = !fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object; // `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
}; // toObject with fallback for non-array-like ES3 strings


var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
}; // `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$1.createElement(it) : {};
}; // Thank's IE8 for his funny defineProperty


var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$1
};

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f$2
};
var hide = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    hide(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }

  return value;
};

var shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || setGlobal(SHARED, {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.2.1',
    mode: 'global',
    copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
  });
});
var functionToString = shared('native-function-to-string', Function.toString);
var WeakMap = global_1.WeakMap;
var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));
var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};
var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (nativeWeakMap) {
  var store = new WeakMap$1();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;

  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };

  get = function (it) {
    return wmget.call(store, it) || {};
  };

  has$1 = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function (it, metadata) {
    hide(it, STATE, metadata);
    return metadata;
  };

  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };

  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};
var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(functionToString).split('toString');
  shared('inspectSource', function (it) {
    return functionToString.call(it);
  });
  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;

    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }

    if (O === global_1) {
      if (simple) O[key] = value;else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }

    if (simple) O[key] = value;else hide(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);
  });
});
var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).

var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
}; // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};
var indexOf = arrayIncludes.indexOf;

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }

  return result;
}; // IE8- don't enum bug keys


var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3
};
var f$4 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$4
}; // all object keys, includes non-enumerable and symbols

var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
var isForced_1 = isForced;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      hide(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
}); // `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray

var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
}; // `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject


var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
}; // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys


var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
}; // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);

  return O;
};
var html = getBuiltIn('document', 'documentElement');
var IE_PROTO = sharedKey('IE_PROTO');
var PROTOTYPE = 'prototype';

var Empty = function () {
  /* empty */
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];

  return createDict();
}; // `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create


var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

hiddenKeys[IE_PROTO] = true;
var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
var toString$1 = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
  f: f$5
};
var Symbol$1 = global_1.Symbol;
var store$1 = shared('wks');

var wellKnownSymbol = function (name) {
  return store$1[name] || (store$1[name] = nativeSymbol && Symbol$1[name] || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));
};

var f$6 = wellKnownSymbol;
var wrappedWellKnownSymbol = {
  f: f$6
};
var defineProperty = objectDefineProperty.f;

var defineWellKnownSymbol = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbol.f(NAME)
  });
};

var defineProperty$1 = objectDefineProperty.f;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty$1(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
}; // optional / simple context binding


var bindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate = function (originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

var createMethod$1 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = bindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);

      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return value;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              push.call(target, value);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6)
};
var $forEach = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var JSON$1 = global_1.JSON;
var nativeJSONStringify = JSON$1 && JSON$1.stringify;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function () {
      return nativeDefineProperty$1(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = nativeSymbol && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);

  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor


if (!nativeSymbol) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);

    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }

  wrappedWellKnownSymbol.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

_export({
  global: true,
  wrap: true,
  forced: !nativeSymbol,
  sham: !nativeSymbol
}, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

_export({
  target: SYMBOL,
  stat: true,
  forced: !nativeSymbol
}, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol,
  sham: !descriptors
}, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443


_export({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    objectGetOwnPropertySymbols.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify


JSON$1 && _export({
  target: 'JSON',
  stat: true,
  forced: !nativeSymbol || fails(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return nativeJSONStringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
  })
}, {
  stringify: function stringify(it) {
    var args = [it];
    var index = 1;
    var replacer, $replacer;

    while (arguments.length > index) args.push(arguments[index++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON$1, args);
  }
}); // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive

if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf); // `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag

setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;
var defineProperty$2 = objectDefineProperty.f;
var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty$2(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  _export({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
} // `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator


defineWellKnownSymbol('iterator');

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

var SPECIES$1 = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
  return !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES$1] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var IS_CONCAT_SPREADABLE_SUPPORT = !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

_export({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var $filter = arrayIteration.filter; // `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('filter')
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var sloppyArrayMethod = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

var $forEach$1 = arrayIteration.forEach; // `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach; // `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

_export({
  target: 'Array',
  proto: true,
  forced: [].forEach != arrayForEach
}, {
  forEach: arrayForEach
}); // call something on iterator step with safe closing on error


var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterators = {};
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var ITERATOR$1 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$1] || it['@@iterator'] || iterators[classof(it)];
}; // `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from


var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var index = 0;
  var iteratorMethod = getIteratorMethod(O);
  var length, result, step, iterator;
  if (mapping) mapfn = bindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    result = new C();

    for (; !(step = iterator.next()).done; index++) {
      createProperty(result, index, mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);

    for (; length > index; index++) {
      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
    }
  }

  result.length = index;
  return result;
};

var ITERATOR$2 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from

_export({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: arrayFrom
});

var $indexOf = arrayIncludes.indexOf;
var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof

_export({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || SLOPPY_METHOD
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype$1 = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
  hide(ArrayPrototype$1, UNSCOPABLES, objectCreate(null));
} // add a key to Array.prototype[@@unscopables]


var addToUnscopables = function (key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};

var correctPrototypeGetter = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype$1 : null;
};
var ITERATOR$3 = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if (!has(IteratorPrototype, ITERATOR$3)) hide(IteratorPrototype, ITERATOR$3, returnThis);
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

var returnThis$1 = function () {
  return this;
};

var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
}; // `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */


var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);
var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function () {
  return this;
};

var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
          hide(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
    hide(IterablePrototype, ITERATOR$4, defaultIterator);
  }

  iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator

var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
var nativeJoin = [].join;
var ES3_STRINGS = indexedObject != Object;
var SLOPPY_METHOD$1 = sloppyArrayMethod('join', ','); // `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join

_export({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || SLOPPY_METHOD$1
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

var $map = arrayIteration.map; // `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('map')
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var SPECIES$2 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('slice')
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$2];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);

    result.length = n;
    return result;
  }
});

var $some = arrayIteration.some; // `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some

_export({
  target: 'Array',
  proto: true,
  forced: sloppyArrayMethod('some')
}, {
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var nativeSort = [].sort;
var test = [1, 2, 3]; // IE8-

var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails(function () {
  test.sort(null);
}); // Old WebKit

var SLOPPY_METHOD$2 = sloppyArrayMethod('sort');
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$2; // `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort

_export({
  target: 'Array',
  proto: true,
  forced: FORCED$1
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
  }
});

var defineProperty$3 = objectDefineProperty.f;
var DataView = global_1.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array$1 = global_1.Int8Array;
var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
var Uint8ClampedArray = global_1.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype$2 = Object.prototype;
var isPrototypeOf = ObjectPrototype$2.isPrototypeOf;
var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var NATIVE_ARRAY_BUFFER = !!(global_1.ArrayBuffer && DataView); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (objectSetPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  }

  throw TypeError('Target is not a typed array constructor');
};

var exportProto = function (KEY, property, forced) {
  if (!descriptors) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }

  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportStatic = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!descriptors) return;

  if (objectSetPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }

    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
      } catch (error) {
        /* empty */
      }
    } else return;
  }

  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
} // WebKit bug - typed arrays constructors prototype is Object.prototype


if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };

  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
  }
} // WebKit bug - one more object in Uint8ClampedArray prototype chain


if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$2)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty$3(TypedArrayPrototype, TO_STRING_TAG$2, {
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });

  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
    hide(global_1[NAME], TYPED_ARRAY_TAG, NAME);
  }
} // WebKit bug - the same parent prototype for typed arrays and data view


if (NATIVE_ARRAY_BUFFER && objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype) !== ObjectPrototype$2) {
  objectSetPrototypeOf(DataViewPrototype, ObjectPrototype$2);
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportProto: exportProto,
  exportStatic: exportStatic,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);

  return target;
};

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
}; // `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex


var toIndex = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
}; // `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill


var arrayFill = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

var arrayBuffer = createCommonjsModule(function (module, exports) {
  var NATIVE_ARRAY_BUFFER = arrayBufferViewCore.NATIVE_ARRAY_BUFFER;
  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var defineProperty = objectDefineProperty.f;
  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE = 'prototype';
  var WRONG_LENGTH = 'Wrong length';
  var WRONG_INDEX = 'Wrong index';
  var NativeArrayBuffer = global_1[ARRAY_BUFFER];
  var $ArrayBuffer = NativeArrayBuffer;
  var $DataView = global_1[DATA_VIEW];
  var Math = global_1.Math;
  var RangeError = global_1.RangeError; // eslint-disable-next-line no-shadow-restricted-names

  var Infinity = 1 / 0;
  var abs = Math.abs;
  var pow = Math.pow;
  var floor = Math.floor;
  var log = Math.log;
  var LN2 = Math.LN2; // IEEE754 conversions based on https://github.com/feross/ieee754

  var packIEEE754 = function (number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number); // eslint-disable-next-line no-self-compare

    if (number != number || number === Infinity) {
      // eslint-disable-next-line no-self-compare
      mantissa = number != number ? 1 : 0;
      exponent = eMax;
    } else {
      exponent = floor(log(number) / LN2);

      if (number * (c = pow(2, -exponent)) < 1) {
        exponent--;
        c *= 2;
      }

      if (exponent + eBias >= 1) {
        number += rt / c;
      } else {
        number += rt * pow(2, 1 - eBias);
      }

      if (number * c >= 2) {
        exponent++;
        c /= 2;
      }

      if (exponent + eBias >= eMax) {
        mantissa = 0;
        exponent = eMax;
      } else if (exponent + eBias >= 1) {
        mantissa = (number * c - 1) * pow(2, mantissaLength);
        exponent = exponent + eBias;
      } else {
        mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
        exponent = 0;
      }
    }

    for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);

    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;

    for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);

    buffer[--index] |= sign * 128;
    return buffer;
  };

  var unpackIEEE754 = function (buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;

    for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);

    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;

    for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);

    if (exponent === 0) {
      exponent = 1 - eBias;
    } else if (exponent === eMax) {
      return mantissa ? NaN : sign ? -Infinity : Infinity;
    } else {
      mantissa = mantissa + pow(2, mantissaLength);
      exponent = exponent - eBias;
    }

    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
  };

  var unpackInt32 = function (buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
  };

  var packInt8 = function (number) {
    return [number & 0xFF];
  };

  var packInt16 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF];
  };

  var packInt32 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
  };

  var packFloat32 = function (number) {
    return packIEEE754(number, 23, 4);
  };

  var packFloat64 = function (number) {
    return packIEEE754(number, 52, 8);
  };

  var addGetter = function (Constructor, key) {
    defineProperty(Constructor[PROTOTYPE], key, {
      get: function () {
        return getInternalState(this)[key];
      }
    });
  };

  var get = function (view, count, index, isLittleEndian) {
    var numIndex = +index;
    var intIndex = toIndex(numIndex);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = bytes.slice(start, start + count);
    return isLittleEndian ? pack : pack.reverse();
  };

  var set = function (view, count, index, conversion, value, isLittleEndian) {
    var numIndex = +index;
    var intIndex = toIndex(numIndex);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);

    for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
  };

  if (!NATIVE_ARRAY_BUFFER) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
      var byteLength = toIndex(length);
      setInternalState(this, {
        bytes: arrayFill.call(new Array(byteLength), 0),
        byteLength: byteLength
      });
      if (!descriptors) this.byteLength = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      anInstance(this, $DataView, DATA_VIEW);
      anInstance(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = getInternalState(buffer).byteLength;
      var offset = toInteger(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
      setInternalState(this, {
        buffer: buffer,
        byteLength: byteLength,
        byteOffset: offset
      });

      if (!descriptors) {
        this.buffer = buffer;
        this.byteLength = byteLength;
        this.byteOffset = offset;
      }
    };

    if (descriptors) {
      addGetter($ArrayBuffer, 'byteLength');
      addGetter($DataView, 'buffer');
      addGetter($DataView, 'byteLength');
      addGetter($DataView, 'byteOffset');
    }

    redefineAll($DataView[PROTOTYPE], {
      getInt8: function getInt8(byteOffset) {
        return get(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset
      /* , littleEndian */
      ) {
        var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset
      /* , littleEndian */
      ) {
        var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset
      /* , littleEndian */
      ) {
        return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
      },
      getUint32: function getUint32(byteOffset
      /* , littleEndian */
      ) {
        return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset
      /* , littleEndian */
      ) {
        return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
      },
      getFloat64: function getFloat64(byteOffset
      /* , littleEndian */
      ) {
        return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
      },
      setInt8: function setInt8(byteOffset, value) {
        set(this, 1, byteOffset, packInt8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set(this, 1, byteOffset, packInt8, value);
      },
      setInt16: function setInt16(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint16: function setUint16(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setInt32: function setInt32(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint32: function setUint32(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat32: function setFloat32(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat64: function setFloat64(byteOffset, value
      /* , littleEndian */
      ) {
        set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
      }
    });
  } else {
    if (!fails(function () {
      NativeArrayBuffer(1);
    }) || !fails(function () {
      new NativeArrayBuffer(-1); // eslint-disable-line no-new
    }) || fails(function () {
      new NativeArrayBuffer(); // eslint-disable-line no-new

      new NativeArrayBuffer(1.5); // eslint-disable-line no-new

      new NativeArrayBuffer(NaN); // eslint-disable-line no-new

      return NativeArrayBuffer.name != ARRAY_BUFFER;
    })) {
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, $ArrayBuffer);
        return new NativeArrayBuffer(toIndex(length));
      };

      var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];

      for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
        if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, NativeArrayBuffer[key]);
      }

      ArrayBufferPrototype.constructor = $ArrayBuffer;
    } // iOS Safari 7.x bug


    var testView = new $DataView(new $ArrayBuffer(2));
    var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
      setInt8: function setInt8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      }
    }, {
      unsafe: true
    });
  }

  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  setToStringTag($DataView, DATA_VIEW);
  exports[ARRAY_BUFFER] = $ArrayBuffer;
  exports[DATA_VIEW] = $DataView;
});
var SPECIES$3 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor

var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$3]) == undefined ? defaultConstructor : aFunction$1(S);
};

var ArrayBuffer = arrayBuffer.ArrayBuffer;
var DataView$1 = arrayBuffer.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;
var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
}); // `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

_export({
  target: 'ArrayBuffer',
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }

    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView$1(this);
    var viewTarget = new DataView$1(result);
    var index = 0;

    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }

    return result;
  }
}); // `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat


var stringRepeat = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;

  return result;
}; // https://github.com/tc39/proposal-string-pad-start-end


var ceil$1 = Math.ceil; // `String.prototype.{ padStart, padEnd }` methods implementation

var createMethod$2 = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
  start: createMethod$2(false),
  // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
  end: createMethod$2(true)
};
var padStart = stringPad.start;
var abs = Math.abs;
var DatePrototype = Date.prototype;
var getTime = DatePrototype.getTime;
var nativeDateToISOString = DatePrototype.toISOString; // `Date.prototype.toISOString` method implementation
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:

var dateToIsoString = fails(function () {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  nativeDateToISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = date.getUTCFullYear();
  var milliseconds = date.getUTCMilliseconds();
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
} : nativeDateToISOString; // `Date.prototype.toISOString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations

_export({
  target: 'Date',
  proto: true,
  forced: Date.prototype.toISOString !== dateToIsoString
}, {
  toISOString: dateToIsoString
});

var FORCED$2 = fails(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}); // `Date.prototype.toJSON` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tojson

_export({
  target: 'Date',
  proto: true,
  forced: FORCED$2
}, {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

var DatePrototype$1 = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype$1[TO_STRING];
var getTime$1 = DatePrototype$1.getTime; // `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype$1, TO_STRING, function toString() {
    var value = getTime$1.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

var defineProperty$4 = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME$1 = 'name'; // Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name

if (descriptors && !(NAME$1 in FunctionPrototype)) {
  defineProperty$4(FunctionPrototype, NAME$1, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
} // makes subclassing work correct for wrapped built-ins


var inheritIfRequired = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
}; // a string of all valid unicode whitespaces
// eslint-disable-next-line max-len


var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$3 = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};
var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$5 = objectDefineProperty.f;
var trim = stringTrim.trim;
var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor


if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
} // `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue


var thisNumberValue = function (value) {
  if (typeof value != 'number' && classofRaw(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }

  return +value;
};

var nativeToFixed = 1.0.toFixed;
var floor$1 = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

var FORCED$3 = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
}); // `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed

_export({
  target: 'Number',
  proto: true,
  forced: FORCED$3
}, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;

      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor$1(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;

      while (--index >= 0) {
        c += data[index];
        data[index] = floor$1(c / n);
        c = c % n * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';

      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
        }
      }

      return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare

    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);

    if (number < 0) {
      sign = '-';
      number = -number;
    }

    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = fractDigits;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + stringRepeat.call('0', fractDigits);
      }
    }

    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits ? '0.' + stringRepeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    }

    return result;
  }
});

var nativeAssign = Object.assign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
// should work with symbols and should have deterministic property order (V8 bug)

var objectAssign = !nativeAssign || fails(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign

_export({
  target: 'Object',
  stat: true,
  forced: Object.assign !== objectAssign
}, {
  assign: objectAssign
}); // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperties: objectDefineProperties
}); // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperty: objectDefineProperty.f
});

var freezing = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});
var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;
  var METADATA = uid('meta');
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function (it) {
    defineProperty(it, METADATA, {
      value: {
        objectID: 'O' + ++id,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey = function (it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function (it) {
    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
  };

  var meta = module.exports = {
    REQUIRED: false,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;
});
var internalMetadata_1 = internalMetadata.REQUIRED;
var internalMetadata_2 = internalMetadata.fastKey;
var internalMetadata_3 = internalMetadata.getWeakData;
var internalMetadata_4 = internalMetadata.onFreeze;
var onFreeze = internalMetadata.onFreeze;
var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeFreeze(1);
}); // `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !freezing
}, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});

var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var FAILS_ON_PRIMITIVES$1 = fails(function () {
  nativeGetOwnPropertyDescriptor$2(1);
});
var FORCED$4 = !descriptors || FAILS_ON_PRIMITIVES$1; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

_export({
  target: 'Object',
  stat: true,
  forced: FORCED$4,
  sham: !descriptors
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
  }
}); // `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors


_export({
  target: 'Object',
  stat: true,
  sham: !descriptors
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }

    return result;
  }
});

var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES$2 = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$2
}, {
  getOwnPropertyNames: nativeGetOwnPropertyNames$2
});

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES$3 = fails(function () {
  nativeIsFrozen(1);
}); // `Object.isFrozen` method
// https://tc39.github.io/ecma262/#sec-object.isfrozen

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$3
}, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});

var FAILS_ON_PRIMITIVES$4 = fails(function () {
  objectKeys(1);
}); // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$4
}, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
});

var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var test$1 = {};
test$1[TO_STRING_TAG$3] = 'z'; // `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

var objectToString = String(test$1) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test$1.toString;
var ObjectPrototype$3 = Object.prototype; // `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

if (objectToString !== ObjectPrototype$3.toString) {
  redefine(ObjectPrototype$3, 'toString', objectToString, {
    unsafe: true
  });
}

var propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation

var createMethod$4 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!descriptors || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod$4(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod$4(false)
};
var $values = objectToArray.values; // `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values

_export({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

var trim$1 = stringTrim.trim;
var nativeParseFloat = global_1.parseFloat;
var FORCED$5 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string

var _parseFloat = FORCED$5 ? function parseFloat(string) {
  var trimmedString = trim$1(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string


_export({
  global: true,
  forced: parseFloat != _parseFloat
}, {
  parseFloat: _parseFloat
});

var trim$2 = stringTrim.trim;
var nativeParseInt = global_1.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED$6 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix

var _parseInt = FORCED$6 ? function parseInt(string, radix) {
  var S = trim$2(String(string));
  return nativeParseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : nativeParseInt; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix


_export({
  global: true,
  forced: parseInt != _parseInt
}, {
  parseInt: _parseInt
});

var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp

var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
}; // `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


var regexpFlags = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var SPECIES$4 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$4]) {
    defineProperty(Constructor, SPECIES$4, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty$6 = objectDefineProperty.f;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var MATCH$1 = wellKnownSymbol('match');
var NativeRegExp = global_1.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" should create a new object, old webkit bug

var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var FORCED$7 = descriptors && isForced_1('RegExp', !CORRECT_NEW || fails(function () {
  re2[MATCH$1] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})); // `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor

if (FORCED$7) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegexp(pattern);
    var flagsAreUndefined = flags === undefined;
    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern : inheritIfRequired(CORRECT_NEW ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags) : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper) ? pattern.source : pattern, patternIsRegExp && flagsAreUndefined ? regexpFlags.call(pattern) : flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
  };

  var proxy = function (key) {
    key in RegExpWrapper || defineProperty$6(RegExpWrapper, key, {
      configurable: true,
      get: function () {
        return NativeRegExp[key];
      },
      set: function (it) {
        NativeRegExp[key] = it;
      }
    });
  };

  var keys$2 = getOwnPropertyNames$1(NativeRegExp);
  var index = 0;

  while (keys$2.length > index) proxy(keys$2[index++]);

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global_1, 'RegExp', RegExpWrapper);
} // https://tc39.github.io/ecma262/#sec-get-regexp-@@species


setSpecies('RegExp');
var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== regexpExec
}, {
  exec: regexpExec
});

var TO_STRING$1 = 'toString';
var RegExpPrototype$1 = RegExp.prototype;
var nativeToString = RegExpPrototype$1[TO_STRING$1];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
}); // FF44- RegExp#toString has a wrong name

var INCORRECT_NAME = nativeToString.name != TO_STRING$1; // `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING$1, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$1) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
} // `String.prototype.{ codePointAt, at }` methods implementation


var createMethod$5 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$5(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$5(true)
};
var charAt = stringMultibyte.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$2 = internalState.set;
var getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState$2(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});
var SPECIES$5 = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES$5] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
    if (sham) hide(RegExp.prototype[SYMBOL], 'sham', true);
  }
};

var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex

var advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
}; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec


var regexpExecAbstract = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
}; // @@match logic


fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regexpExecAbstract(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regexpExecAbstract(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});
var max$2 = Math.max;
var min$2 = Math.min;
var floor$2 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regexpExecAbstract(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max$2(min$2(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor$2(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});
var arrayPush = [].push;
var min$3 = Math.min;
var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  return !RegExp(MAX_UINT32, 'y');
}); // @@split logic

fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;

  if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

      if (!isRegexp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }

      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }

        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }

      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output.length > lim ? output.slice(0, lim) : output;
    }; // Chakra, V8

  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = requireObjectCoercible(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
}, !SUPPORTS_Y);
var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
// of whitespaces and has a correct name

var forcedStringTrimMethod = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $trim = stringTrim.trim; // `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim

_export({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});
/* eslint-disable no-new */


var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$1 = global_1.ArrayBuffer;
var Int8Array$2 = global_1.Int8Array;
var typedArraysConstructorsRequiresWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
  Int8Array$2(1);
}) || !fails(function () {
  new Int8Array$2(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$2();
  new Int8Array$2(null);
  new Int8Array$2(1.5);
  new Int8Array$2(iterable);
}, true) || fails(function () {
  // Safari 11 bug
  return new Int8Array$2(new ArrayBuffer$1(2), 1, undefined).length !== 1;
});

var toOffset = function (it, BYTES) {
  var offset = toInteger(it);
  if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source
/* , mapfn, thisArg */
) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator;

  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    O = [];

    while (!(step = iterator.next()).done) {
      O.push(step.value);
    }
  }

  if (mapping && argumentsLength > 2) {
    mapfn = bindContext(mapfn, arguments[2], 2);
  }

  length = toLength(O.length);
  result = new (aTypedArrayConstructor$1(this))(length);

  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }

  return result;
};

var typedArrayConstructor = createCommonjsModule(function (module) {
  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var forEach = arrayIteration.forEach;
  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global_1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, {
      get: function () {
        return getInternalState(this)[key];
      }
    });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
      target[key] = descriptor.value;
      return target;
    }

    return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({
      target: 'Object',
      stat: true,
      forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    }); // eslint-disable-next-line max-statements


    module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function (that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function (that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function (that, index) {
        nativeDefineProperty(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;

          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;

            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }

            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }

          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer)
          });

          while (index < length) addElement(that, index++);
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArraysConstructorsRequiresWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) hide(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        hide(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      if (TYPED_ARRAY_TAG) hide(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

      _export({
        global: true,
        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
        sham: !NATIVE_ARRAY_BUFFER_VIEWS
      }, exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        hide(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        hide(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () {
    /* empty */
  };
}); // `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});
var min$4 = Math.min; // `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

var arrayCopyWithin = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min$4((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

var aTypedArray$1 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

arrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start
/* , end */
) {
  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});
var $every = arrayIteration.every;
var aTypedArray$2 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

arrayBufferViewCore.exportProto('every', function every(callbackfn
/* , thisArg */
) {
  return $every(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});
var aTypedArray$3 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars

arrayBufferViewCore.exportProto('fill', function fill(value
/* , start, end */
) {
  return arrayFill.apply(aTypedArray$3(this), arguments);
});
var $filter$1 = arrayIteration.filter;
var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor; // `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

arrayBufferViewCore.exportProto('filter', function filter(callbackfn
/* , thisArg */
) {
  var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$2(C))(length);

  while (length > index) result[index] = list[index++];

  return result;
});
var $find = arrayIteration.find;
var aTypedArray$5 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

arrayBufferViewCore.exportProto('find', function find(predicate
/* , thisArg */
) {
  return $find(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});
var $findIndex = arrayIteration.findIndex;
var aTypedArray$6 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

arrayBufferViewCore.exportProto('findIndex', function findIndex(predicate
/* , thisArg */
) {
  return $findIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});
var $forEach$2 = arrayIteration.forEach;
var aTypedArray$7 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

arrayBufferViewCore.exportProto('forEach', function forEach(callbackfn
/* , thisArg */
) {
  $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});
var $includes = arrayIncludes.includes;
var aTypedArray$8 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

arrayBufferViewCore.exportProto('includes', function includes(searchElement
/* , fromIndex */
) {
  return $includes(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});
var $indexOf$1 = arrayIncludes.indexOf;
var aTypedArray$9 = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

arrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement
/* , fromIndex */
) {
  return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});
var ITERATOR$5 = wellKnownSymbol('iterator');
var Uint8Array$1 = global_1.Uint8Array;
var arrayValues = es_array_iterator.values;
var arrayKeys = es_array_iterator.keys;
var arrayEntries = es_array_iterator.entries;
var aTypedArray$a = arrayBufferViewCore.aTypedArray;
var exportProto$1 = arrayBufferViewCore.exportProto;
var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$5];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray$a(this));
}; // `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


exportProto$1('entries', function entries() {
  return arrayEntries.call(aTypedArray$a(this));
}); // `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

exportProto$1('keys', function keys() {
  return arrayKeys.call(aTypedArray$a(this));
}); // `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

exportProto$1('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

exportProto$1(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);
var aTypedArray$b = arrayBufferViewCore.aTypedArray;
var $join = [].join; // `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars

arrayBufferViewCore.exportProto('join', function join(separator) {
  return $join.apply(aTypedArray$b(this), arguments);
});
var min$5 = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var SLOPPY_METHOD$3 = sloppyArrayMethod('lastIndexOf'); // `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

var arrayLastIndexOf = NEGATIVE_ZERO$1 || SLOPPY_METHOD$3 ? function lastIndexOf(searchElement
/* , fromIndex = @[*-1] */
) {
  // convert -0 to +0
  if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min$5(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;

  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;

  return -1;
} : nativeLastIndexOf;
var aTypedArray$c = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars

arrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement
/* , fromIndex */
) {
  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
});
var $map$1 = arrayIteration.map;
var aTypedArray$d = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor; // `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

arrayBufferViewCore.exportProto('map', function map(mapfn
/* , thisArg */
) {
  return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
  });
}); // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod$6 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$6(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$6(true)
};
var $reduce = arrayReduce.left;
var aTypedArray$e = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

arrayBufferViewCore.exportProto('reduce', function reduce(callbackfn
/* , initialValue */
) {
  return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});
var $reduceRight = arrayReduce.right;
var aTypedArray$f = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

arrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn
/* , initialValue */
) {
  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});
var aTypedArray$g = arrayBufferViewCore.aTypedArray;
var floor$3 = Math.floor; // `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

arrayBufferViewCore.exportProto('reverse', function reverse() {
  var that = this;
  var length = aTypedArray$g(that).length;
  var middle = floor$3(length / 2);
  var index = 0;
  var value;

  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }

  return that;
});
var aTypedArray$h = arrayBufferViewCore.aTypedArray;
var FORCED$8 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
}); // `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

arrayBufferViewCore.exportProto('set', function set(arrayLike
/* , offset */
) {
  aTypedArray$h(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');

  while (index < len) this[offset + index] = src[index++];
}, FORCED$8);
var aTypedArray$i = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
var $slice = [].slice;
var FORCED$9 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
}); // `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

arrayBufferViewCore.exportProto('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray$i(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$4(C))(length);

  while (length > index) result[index] = list[index++];

  return result;
}, FORCED$9);
var $some$1 = arrayIteration.some;
var aTypedArray$j = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

arrayBufferViewCore.exportProto('some', function some(callbackfn
/* , thisArg */
) {
  return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});
var aTypedArray$k = arrayBufferViewCore.aTypedArray;
var $sort = [].sort; // `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

arrayBufferViewCore.exportProto('sort', function sort(comparefn) {
  return $sort.call(aTypedArray$k(this), comparefn);
});
var aTypedArray$l = arrayBufferViewCore.aTypedArray; // `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

arrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {
  var O = aTypedArray$l(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});
var Int8Array$3 = global_1.Int8Array;
var aTypedArray$m = arrayBufferViewCore.aTypedArray;
var $toLocaleString = [].toLocaleString;
var $slice$1 = [].slice; // iOS Safari 6.x fails here

var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
  $toLocaleString.call(new Int8Array$3(1));
});
var FORCED$a = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array$3.prototype.toLocaleString.call([1, 2]);
}); // `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

arrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
}, FORCED$a);
var Uint8Array$2 = global_1.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype;
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () {
  arrayToString.call({});
})) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
} // `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring


arrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString); // iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
    hide(CollectionPrototype, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype.forEach = arrayForEach;
  }
}

var ITERATOR$6 = wellKnownSymbol('iterator');
var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;

  if (CollectionPrototype$1) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype$1[ITERATOR$6] !== ArrayValues) try {
      hide(CollectionPrototype$1, ITERATOR$6, ArrayValues);
    } catch (error) {
      CollectionPrototype$1[ITERATOR$6] = ArrayValues;
    }
    if (!CollectionPrototype$1[TO_STRING_TAG$4]) hide(CollectionPrototype$1, TO_STRING_TAG$4, COLLECTION_NAME$1);
    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        hide(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
} // `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson


_export({
  target: 'URL',
  proto: true,
  enumerable: true
}, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty$7 = _defineProperty$1;

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles$1;

function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray$1;

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread$1;

function _toConsumableArray$1(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray$1;
var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire$1() {
  throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule$1(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule$1(function (module) {
  function _typeof2(obj) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      _typeof2 = function _typeof2(obj) {
        return _typeof(obj);
      };
    } else {
      _typeof2 = function _typeof2(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
      };
    }

    return _typeof2(obj);
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      module.exports = _typeof$1 = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      module.exports = _typeof$1 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof$1(obj);
  }

  module.exports = _typeof$1;
});

var moment = createCommonjsModule$1(function (module, exports) {
  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal$1, function () {
    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function some(fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (_typeof(arguments[i]) === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function keys(obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function func() {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function func(input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (_typeof(units) === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function indexOf(o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire$1;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function now() {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function ordinal(number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
}); // Maps for number <-> hex string conversion

var byteToHex = [];

for (var i = 0; i < 256; i++) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}
/**
 * Represent binary UUID into it's string representation.
 *
 * @param buf - Buffer containing UUID bytes.
 * @param offset - Offset from the start of the buffer where the UUID is saved (not needed if the buffer starts with the UUID).
 *
 * @returns String representation of the UUID.
 */


function stringifyUUID(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}
/**
 * Generate 16 random bytes to be used as a base for UUID.
 *
 * @ignore
 */


var random = function () {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);

    return function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  } // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().
  // It's fast, but is of unspecified quality.


  var _rnds = new Array(16);

  return function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) {
        r = Math.random() * 0x100000000;
      }

      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  }; //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php
  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  // return require('./rng');
}();

var byteToHex$1 = [];

for (var i$1 = 0; i$1 < 256; i$1++) {
  byteToHex$1[i$1] = (i$1 + 0x100).toString(16).substr(1);
} // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
// random #'s we need to init node and clockseq


var seedBytes = random(); // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)

var defaultNodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]]; // Per 4.2.2, randomize (14 bit) clockseq

var defaultClockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff; // Previous uuid creation time

/**
 * UUIDv4 options.
 */

/**
 * Generate UUIDv4
 *
 * @param options - Options to be used instead of default generated values.
 * String 'binary' is a shorthand for uuid4({}, new Array(16)).
 * @param buf - If present the buffer will be filled with the generated UUID.
 * @param offset - Offset of the UUID from the start of the buffer.
 *
 * @returns UUIDv4
 */

function uuid4() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var buf = arguments.length > 1 ? arguments[1] : undefined;
  var offset = arguments.length > 2 ? arguments[2] : undefined; // Deprecated - 'format' argument, as supported in v1.2

  var i = buf && offset || 0;

  if (typeof options === 'string') {
    buf = options === 'binary' ? new Array(16) : undefined;
    options = {};
  }

  var rnds = options.random || (options.rng || random)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || stringifyUUID(rnds);
} // Rollup will complain about mixing default and named exports in UMD build,


function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(source, true).forEach(function (key) {
        defineProperty$7(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/


var ASPDateRegex = /^\/?Date\((-?\d+)/i; // Hex color

var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
/**
 * Hue, Saturation, Value.
 */

/**
 * Test whether given object is a number
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if number, false otherwise.
 */

function isNumber(value) {
  return value instanceof Number || typeof value === 'number';
}
/**
 * Remove everything in the DOM object
 *
 * @param DOMobject - Node whose child nodes will be recursively deleted.
 */


function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;

      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
/**
 * Test whether given object is a string
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if string, false otherwise.
 */


function isString(value) {
  return value instanceof String || typeof value === 'string';
}
/**
 * Test whether given object is a object (not primitive or null).
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if not null object, false otherwise.
 */


function isObject$1(value) {
  return _typeof_1(value) === 'object' && value !== null;
}
/**
 * Test whether given object is a Date, or a String containing a Date
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if Date instance or string date representation, false otherwise.
 */


function isDate(value) {
  if (value instanceof Date) {
    return true;
  } else if (isString(value)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(value);

    if (match) {
      return true;
    } else if (!isNaN(Date.parse(value))) {
      return true;
    }
  }

  return false;
}
/**
 * Test whether given object is a Moment date.
 * @TODO: This is basically a workaround, if Moment was imported property it wouldn't necessary as moment.isMoment is a TS type guard.
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if Moment instance, false otherwise.
 */


function isMoment(value) {
  return moment.isMoment(value);
}
/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param prop - Name of property to copy from b to a.
 * @param allowDeletion  if true, delete property in a if explicitly set to null in b
 */


function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;

  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== undefined;
  }

  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop]; // Remember, this is a reference copy!
  }
}
/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param a - The object that will have it's properties updated.
 * @param b - The object with property updates.
 * @param allowDeletion - if true, delete properties in a that are explicitly set to null in b
 */


function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // NOTE: iteration of properties of a
  // NOTE: prototype properties iterated over as well

  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (b[prop] === null || _typeof_1(b[prop]) !== 'object') {
        // Note: typeof null === 'object'
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        var aProp = a[prop];
        var bProp = b[prop];

        if (isObject$1(aProp) && isObject$1(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
/**
 * Copy the values of all of the enumerable own properties from one or more source objects to a
 * target object. Returns the target object.
 *
 * @param target - The target object to copy to.
 * @param source - The source object from which to copy properties.
 *
 * @return The target object.
 */


var extend = Object.assign;
/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 *
 * @param props - Properties to be copied to a.
 * @param a - The target.
 * @param others - The sources.
 *
 * @returns Argument a.
 */

function selectiveExtend(props, a) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var _len = arguments.length, others = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    others[_key - 2] = arguments[_key];
  }

  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];

      if (other && Object.prototype.hasOwnProperty.call(other, prop)) {
        a[prop] = other[prop];
      }
    }
  }

  return a;
}
/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * **Note:** Previous version of this routine implied that multiple source objects
 *           could be used; however, the implementation was **wrong**.
 *           Since multiple (>1) sources weren't used anywhere in the `vis.js` code,
 *           this has been removed
 *
 * @param props - Names of first-level properties to copy over.
 * @param a - Target object.
 * @param b - Source object.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 *
 * @returns Argument a.
 */


function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // TODO: add support for Arrays to deepExtend

  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var p = 0; p < props.length; p++) {
    var prop = props[p];

    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }

        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Extend object `a` with properties of object `b`, ignoring properties which are explicitly
 * specified to be excluded.
 *
 * The properties of `b` are considered for copying.
 * Properties which are themselves objects are are also extended.
 * Only properties with defined values are copied
 *
 * @param propsToExclude - Names of properties which should *not* be copied.
 * @param a - Object to extend.
 * @param b - Object to take properties from for extension.
 * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.
 *
 * @returns Argument a.
 */


function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // TODO: add support for Arrays to deepExtend
  // NOTE: array properties have an else-below; apparently, there is a problem here.

  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    } // Handle local properties only


    if (propsToExclude.indexOf(prop) !== -1) {
      continue;
    } // In exclusion list, skip


    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === undefined) {
        a[prop] = {};
      }

      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (Array.isArray(b[prop])) {
      a[prop] = [];

      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }

  return a;
}
/**
 * Deep extend an object a with the properties of object b
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param protoExtend - If true, the prototype values will also be extended
 * (ie. the options objects that inherit from others will also get the inherited options).
 * @param allowDeletion - If true, the values of fields that are null will be deleted.
 *
 * @returns Argument a.
 */


function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }

        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];

        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Test whether all elements in two arrays are equal.
 *
 * @param a - First array.
 * @param b - Second array.
 *
 * @returns True if both arrays have the same length and same elements (1 = '1').
 */


function equalArray(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Convert an object into another type
 *
 * @param object - Value of unknown type.
 * @param type - Name of the desired type.
 *
 * @returns Object in the desired type.
 * @throws Error
 */


function convert(object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }

  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }

  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  } //noinspection FallthroughInSwitchStatementJS


  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      if (isString(object) && !isNaN(Date.parse(object))) {
        return moment(object).valueOf();
      } else {
        // @TODO: I don't think that Number and String constructors are a good idea.
        // This could also fail if the object doesn't have valueOf method or if it's redefined.
        // For example: Object.create(null) or { valueOf: 7 }.
        return Number(object.valueOf());
      }

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (isNumber(object)) {
        return new Date(object);
      }

      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (isMoment(object)) {
        return new Date(object.valueOf());
      }

      if (isString(object)) {
        match = ASPDateRegex.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
          return moment(new Date(object)).toDate(); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType(object) + ' to type Date');
      }

    case 'Moment':
      if (isNumber(object)) {
        return moment(object);
      }

      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (isMoment(object)) {
        return moment(object);
      }

      if (isString(object)) {
        match = ASPDateRegex.exec(object);

        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
          return moment(object); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType(object) + ' to type Date');
      }

    case 'ISODate':
      if (isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (isMoment(object)) {
        return object.toDate().toISOString();
      } else if (isString(object)) {
        match = ASPDateRegex.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
          return moment(object).format(); // ISO 8601
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType(object) + ' to type ISODate');
      }

    case 'ASPDate':
      if (isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date || isMoment(object)) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (isString(object)) {
        match = ASPDateRegex.exec(object);

        var _value;

        if (match) {
          // object is an ASP date
          _value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
          _value = new Date(object).valueOf(); // parse string
        }

        return '/Date(' + _value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + getType(object) + ' to type ASPDate');
      }

    default:
      var never = type;
      throw new Error("Unknown type ".concat(never));
  }
}
/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 *
 * @param object - Input value of unknown type.
 *
 * @returns Detected type.
 */


function getType(object) {
  var type = _typeof_1(object);

  if (type === 'object') {
    if (object === null) {
      return 'null';
    }

    if (object instanceof Boolean) {
      return 'Boolean';
    }

    if (object instanceof Number) {
      return 'Number';
    }

    if (object instanceof String) {
      return 'String';
    }

    if (Array.isArray(object)) {
      return 'Array';
    }

    if (object instanceof Date) {
      return 'Date';
    }

    return 'Object';
  }

  if (type === 'number') {
    return 'Number';
  }

  if (type === 'boolean') {
    return 'Boolean';
  }

  if (type === 'string') {
    return 'String';
  }

  if (type === undefined) {
    return 'undefined';
  }

  return type;
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - First part.
 * @param newValue - The value to be aadded into the array.
 *
 * @returns A new array with all items from arr and newValue (which is last).
 */


function copyAndExtendArray(arr, newValue) {
  return [].concat(toConsumableArray(arr), [newValue]);
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - The array to be copied.
 *
 * @returns Shallow copy of arr.
 */


function copyArray(arr) {
  return arr.slice();
}
/**
 * Retrieve the absolute left value of a DOM element
 *
 * @param elem - A dom element, for example a div.
 *
 * @returns The absolute left position of this element in the browser page.
 */


function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
/**
 * Retrieve the absolute right value of a DOM element
 *
 * @param elem - A dom element, for example a div.
 *
 * @returns The absolute right position of this element in the browser page.
 */


function getAbsoluteRight(elem) {
  return elem.getBoundingClientRect().right;
}
/**
 * Retrieve the absolute top value of a DOM element
 *
 * @param elem - A dom element, for example a div.
 *
 * @returns The absolute top position of this element in the browser page.
 */


function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
/**
 * Add a className to the given elements style.
 *
 * @param elem - The element to which the classes will be added.
 * @param classNames - Space separated list of classes.
 */


function addClassName(elem, classNames) {
  var classes = elem.className.split(' ');
  var newClasses = classNames.split(' ');
  classes = classes.concat(newClasses.filter(function (className) {
    return classes.indexOf(className) < 0;
  }));
  elem.className = classes.join(' ');
}
/**
 * Remove a className from the given elements style.
 *
 * @param elem - The element from which the classes will be removed.
 * @param classNames - Space separated list of classes.
 */


function removeClassName(elem, classNames) {
  var classes = elem.className.split(' ');
  var oldClasses = classNames.split(' ');
  classes = classes.filter(function (className) {
    return oldClasses.indexOf(className) < 0;
  });
  elem.className = classes.join(' ');
}
/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).
 * In case of an Object, the method loops over all properties of the object.
 *
 * @param object - An Object or Array to be iterated over.
 * @param callback - Array.forEach-like callback.
 */


function forEach(object, callback) {
  if (Array.isArray(object)) {
    // array
    var len = object.length;

    for (var i = 0; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (var _key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, _key2)) {
        callback(object[_key2], _key2, object);
      }
    }
  }
}
/**
 * Convert an object into an array: all objects properties are put into the array. The resulting array is unordered.
 *
 * @param o - Object that contains the properties and methods.
 *
 * @returns An array of unordered values.
 */


var toArray = Object.values;
/**
 * Update a property in an object
 *
 * @param object - The object whose property will be updated.
 * @param key - Name of the property to be updated.
 * @param value - The new value to be assigned.
 *
 * @returns Whether the value was updated (true) or already strictly the same in the original object (false).
 */

function updateProperty(object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
}
/**
 * Throttle the given function to be only executed once per animation frame.
 *
 * @param fn - The original function.
 *
 * @returns The throttled function.
 */


function throttle(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      requestAnimationFrame(function () {
        scheduled = false;
        fn();
      });
    }
  };
}
/**
 * Add and event listener. Works for all browsers.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.addEventListener(action, , ).
 * @param listener - Same as Element.addEventListener(, listener, ).
 * @param useCapture - Same as Element.addEventListener(, , useCapture).
 */


function addEventListener(element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {
      action = 'DOMMouseScroll'; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent('on' + action, listener); // IE browsers
  }
}
/**
 * Remove an event listener from an element
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.removeEventListener(action, , ).
 * @param listener - Same as Element.removeEventListener(, listener, ).
 * @param useCapture - Same as Element.removeEventListener(, , useCapture).
 */


function removeEventListener(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {
      action = 'DOMMouseScroll'; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    element.detachEvent('on' + action, listener); // IE browsers
  }
}
/**
 * Cancels the event's default action if it is cancelable, without stopping further propagation of the event.
 *
 * @param event - The event whose default action should be prevented.
 */


function preventDefault(event) {
  if (!event) {
    event = window.event;
  }

  if (!event) ;else if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
    event.returnValue = false; // IE browsers
  }
}
/**
 * Get HTML element which is the target of the event.
 *
 * @param event - The event.
 *
 * @returns The element or null if not obtainable.
 */


function getTarget() {
  var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event; // code from http://www.quirksmode.org/js/events_properties.html
  // @TODO: EventTarget can be almost anything, is it okay to return only Elements?

  var target = null;
  if (!event) ;else if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (!(target instanceof Element)) {
    return null;
  }

  if (target.nodeType != null && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;

    if (!(target instanceof Element)) {
      return null;
    }
  }

  return target;
}
/**
 * Check if given element contains given parent somewhere in the DOM tree
 *
 * @param element - The element to be tested.
 * @param parent - The ancestor (not necessarily parent) of the element.
 *
 * @returns True if parent is an ancestor of the element, false otherwise.
 */


function hasParent(element, parent) {
  var elem = element;

  while (elem) {
    if (elem === parent) {
      return true;
    } else if (elem.parentNode) {
      elem = elem.parentNode;
    } else {
      return false;
    }
  }

  return false;
}

var option = {
  /**
   * Convert a value into a boolean.
   *
   * @param value - Value to be converted intoboolean, a function will be executed as (() => unknown).
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   *
   * @returns Corresponding boolean value, if none then the default value, if none then null.
   */
  asBoolean: function asBoolean(value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return value != false;
    }

    return defaultValue || null;
  },

  /**
   * Convert a value into a number.
   *
   * @param value - Value to be converted intonumber, a function will be executed as (() => unknown).
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   *
   * @returns Corresponding **boxed** number value, if none then the default value, if none then null.
   */
  asNumber: function asNumber(value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return Number(value) || defaultValue || null;
    }

    return defaultValue || null;
  },

  /**
   * Convert a value into a string.
   *
   * @param value - Value to be converted intostring, a function will be executed as (() => unknown).
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   *
   * @returns Corresponding **boxed** string value, if none then the default value, if none then null.
   */
  asString: function asString(value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return String(value);
    }

    return defaultValue || null;
  },

  /**
   * Convert a value into a size.
   *
   * @param value - Value to be converted intosize, a function will be executed as (() => unknown).
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   *
   * @returns Corresponding string value (number + 'px'), if none then the default value, if none then null.
   */
  asSize: function asSize(value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (isString(value)) {
      return value;
    } else if (isNumber(value)) {
      return value + 'px';
    } else {
      return defaultValue || null;
    }
  },

  /**
   * Convert a value into a DOM Element.
   *
   * @param value - Value to be converted into DOM Element, a function will be executed as (() => unknown).
   * @param defaultValue - If the value or the return value of the function == null then this will be returned.
   *
   * @returns The DOM Element, if none then the default value, if none then null.
   */
  asElement: function asElement(value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    return value || defaultValue || null;
  }
};
/**
 * Convert hex color string into RGB color object.
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param hex - Hex color string (3 or 6 digits, with or without #).
 *
 * @returns RGB color object.
 */

function hexToRGB(hex) {
  var result;

  switch (hex.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex);
      return result ? {
        r: parseInt(result[1] + result[1], 16),
        g: parseInt(result[2] + result[2], 16),
        b: parseInt(result[3] + result[3], 16)
      } : null;

    case 6:
    case 7:
      result = fullHexRE.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;

    default:
      return null;
  }
}
/**
 * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.
 *
 * @param color - The color string (hex, RGB, RGBA).
 * @param opacity - The new opacity.
 *
 * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.
 */


function overrideOpacity(color, opacity) {
  if (color.indexOf('rgba') !== -1) {
    return color;
  } else if (color.indexOf('rgb') !== -1) {
    var rgb = color.substr(color.indexOf('(') + 1).replace(')', '').split(',');
    return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + opacity + ')';
  } else {
    var _rgb = hexToRGB(color);

    if (_rgb == null) {
      return color;
    } else {
      return 'rgba(' + _rgb.r + ',' + _rgb.g + ',' + _rgb.b + ',' + opacity + ')';
    }
  }
}
/**
 * Convert RGB <0, 255> into hex color string.
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 *
 * @returns Hex color string (for example: '#0acdc0').
 */


function RGBToHex(red, green, blue) {
  return '#' + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
}
/**
 * Parse a color property into an object with border, background, and highlight colors
 *
 * @param inputColor - Shorthand color string or input color object.
 * @param defaultColor - Full color object to fill in missing values in inputColor.
 *
 * @returns Color object.
 */


function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;

    if (isValidRGB(colorStr)) {
      var rgb = colorStr.substr(4).substr(0, colorStr.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }

    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      var _color = {
        background: inputColor.background || undefined,
        border: inputColor.border || undefined,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || undefined,
          border: inputColor.highlight && inputColor.highlight.border || undefined
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || undefined,
          background: inputColor.hover && inputColor.hover.background || undefined
        }
      };
      return _color;
    }
  }
}
/**
 * Convert RGB <0, 255> into HSV object.
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 *
 * @returns HSV color object.
 */


function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue)); // Black-gray-white

  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  } // Colors other than black-gray-white:


  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};
    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');

        var _key3 = parts[0].trim();

        var _value2 = parts[1].trim();

        styles[_key3] = _value2;
      }
    });
    return styles;
  },
  // build a css text string from an object with key/values
  join: function join(styles) {
    return Object.keys(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }
};
/**
 * Append a string with css styles to an element
 *
 * @param element - The element that will receive new styles.
 * @param cssText - The styles to be appended.
 */

function addCssText(element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);

  var styles = _objectSpread({}, currentStyles, {}, newStyles);

  element.style.cssText = cssUtil.join(styles);
}
/**
 * Remove a string with css styles from an element
 *
 * @param element - The element from which styles should be removed.
 * @param cssText - The styles to be removed.
 */


function removeCssText(element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var _key4 in removeStyles) {
    if (Object.prototype.hasOwnProperty.call(removeStyles, _key4)) {
      delete styles[_key4];
    }
  }

  element.style.cssText = cssUtil.join(styles);
}
/**
 * Convert HSV <0, 1> into RGB color object.
 * https://gist.github.com/mjijackson/5311256
 *
 * @param h - Hue
 * @param s - Saturation
 * @param v - Value
 *
 * @returns RGB color object.
 */


function HSVToRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
/**
 * Convert HSV <0, 1> into hex color string.
 *
 * @param h - Hue
 * @param s - Saturation
 * @param v - Value
 *
 * @returns Hex color string.
 */


function HSVToHex(h, s, v) {
  var rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
/**
 * Convert hex color string into HSV <0, 1>.
 *
 * @param hex - Hex color string.
 *
 * @returns HSV color object.
 */


function hexToHSV(hex) {
  var rgb = hexToRGB(hex);

  if (!rgb) {
    throw new TypeError("'".concat(hex, "' is not a valid color."));
  }

  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
/**
 * Validate hex color string.
 *
 * @param hex - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */


function isValidHex(hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
}
/**
 * Validate RGB color string.
 *
 * @param rgb - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGB(rgb) {
  rgb = rgb.replace(' ', '');
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
}
/**
 * Validate RGBA color string.
 *
 * @param rgba - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGBA(rgba) {
  rgba = rgba.replace(' ', '');
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(0?.{1,3})\)/i.test(rgba);
  return isOk;
}
/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param fields - Names of properties to be bridged.
 * @param referenceObject - The original object.
 *
 * @returns A new object inheriting from the referenceObject.
 */


function selectiveBridgeObject(fields, referenceObject) {
  if (referenceObject !== null && _typeof_1(referenceObject) === 'object') {
    // !!! typeof null === 'object'
    var objectTo = Object.create(referenceObject);

    for (var i = 0; i < fields.length; i++) {
      if (Object.prototype.hasOwnProperty.call(referenceObject, fields[i])) {
        if (_typeof_1(referenceObject[fields[i]]) == 'object') {
          objectTo[fields[i]] = bridgeObject(referenceObject[fields[i]]);
        }
      }
    }

    return objectTo;
  } else {
    return null;
  }
}
/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param referenceObject - The original object.
 *
 * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.
 */


function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof_1(referenceObject) !== 'object') {
    return null;
  }

  if (referenceObject instanceof Element) {
    // Avoid bridging DOM objects
    return referenceObject;
  }

  var objectTo = Object.create(referenceObject);

  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof_1(referenceObject[i]) == 'object') {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }

  return objectTo;
}
/**
 * This method provides a stable sort implementation, very fast for presorted data.
 *
 * @param a - The array to be sorted (in-place).
 * @param compare - An order comparator.
 *
 * @returns The argument a.
 */


function insertSort(a, compare) {
  for (var i = 0; i < a.length; i++) {
    var k = a[i];
    var j = void 0;

    for (j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
      a[j] = a[j - 1];
    }

    a[j] = k;
  }

  return a;
}
/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 * @param mergeTarget - Either this.options or the options used for the groups.
 * @param options - Options.
 * @param option - Option key in the options argument.
 * @param globalOptions - Global options, passed in to determine value of option 'enabled'.
 */


function mergeOptions(mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}; // Local helpers

  var isPresent = function isPresent(obj) {
    return obj !== null && obj !== undefined;
  };

  var isObject = function isObject(obj) {
    return obj !== null && _typeof_1(obj) === 'object';
  }; // https://stackoverflow.com/a/34491287/1223531


  var isEmpty = function isEmpty(obj) {
    for (var x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }

    return true;
  }; // Guards


  if (!isObject(mergeTarget)) {
    throw new Error('Parameter mergeTarget must be an object');
  }

  if (!isObject(options)) {
    throw new Error('Parameter options must be an object');
  }

  if (!isPresent(option)) {
    throw new Error('Parameter option must have a value');
  }

  if (!isObject(globalOptions)) {
    throw new Error('Parameter globalOptions must be an object');
  } //
  // Actual merge routine, separated from main logic
  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
  //


  var doMerge = function doMerge(target, options, option) {
    if (!isObject(target[option])) {
      target[option] = {};
    }

    var src = options[option];
    var dst = target[option];

    for (var prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  }; // Local initialization


  var srcOption = options[option];
  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : undefined;
  var globalEnabled = globalOption ? globalOption.enabled : undefined; /////////////////////////////////////////
  // Main routine
  /////////////////////////////////////////

  if (srcOption === undefined) {
    return; // Nothing to do
  }

  if (typeof srcOption === 'boolean') {
    if (!isObject(mergeTarget[option])) {
      mergeTarget[option] = {};
    }

    mergeTarget[option].enabled = srcOption;
    return;
  }

  if (srcOption === null && !isObject(mergeTarget[option])) {
    // If possible, explicit copy from globals
    if (isPresent(globalOption)) {
      mergeTarget[option] = Object.create(globalOption);
    } else {
      return; // Nothing to do
    }
  }

  if (!isObject(srcOption)) {
    return;
  } //
  // Ensure that 'enabled' is properly set. It is required internally
  // Note that the value from options will always overwrite the existing value
  //


  var enabled = true; // default value

  if (srcOption.enabled !== undefined) {
    enabled = srcOption.enabled;
  } else {
    // Take from globals, if present
    if (globalEnabled !== undefined) {
      enabled = globalOption.enabled;
    }
  }

  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
}
/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param orderedItems - Items ordered by start
 * @param comparator - -1 is lower, 0 is equal, 1 is higher
 * @param field - Property name on an item (i.e. item[field]).
 * @param field2 - Second property name on an item (i.e. item[field][field2]).
 *
 * @returns Index of the found item or -1 if nothing was found.
 */


function binarySearchCustom(orderedItems, comparator, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);
    var item = orderedItems[middle];

    var _value3 = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = comparator(_value3);

    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
}
/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param orderedItems - Sorted array.
 * @param target - The searched value.
 * @param field - Name of the property in items to be searched.
 * @param sidePreference - If the target is between two values, should the index of the before or the after be returned?
 * @param comparator - An optional comparator, returning -1, 0, 1 for <, ===, >.
 *
 * @returns The index of found value or -1 if nothing was found.
 */


function binarySearchValue(orderedItems, target, field, sidePreference, comparator) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue;
  var value;
  var nextValue;
  var middle;
  comparator = comparator != undefined ? comparator : function (a, b) {
    return a == b ? 0 : a < b ? -1 : 1;
  };

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (comparator(value, target) == 0) {
      // we found the target
      return middle;
    } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (comparator(value, target) < 0) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }

    iteration++;
  } // didnt find anything. Return -1.


  return -1;
}
/*
 * Easing Functions.
 * Only considering the t value for the range [0, 1] => [0, 1].
 *
 * Inspiration: from http://gizma.com/easing/
 * https://gist.github.com/gre/1650294
 */


var easingFunctions = {
  /**
   * no easing, no acceleration
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  linear: function linear(t) {
    return t;
  },

  /**
   * accelerating from zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },

  /**
   * decelerating to zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },

  /**
   * acceleration until halfway, then deceleration
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },

  /**
   * accelerating from zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },

  /**
   * decelerating to zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },

  /**
   * acceleration until halfway, then deceleration
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },

  /**
   * accelerating from zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },

  /**
   * decelerating to zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },

  /**
   * acceleration until halfway, then deceleration
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },

  /**
   * accelerating from zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },

  /**
   * decelerating to zero velocity
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },

  /**
   * acceleration until halfway, then deceleration
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
/**
 * Experimentaly compute the width of the scrollbar for this browser.
 *
 * @returns The width in pixels.
 */

function getScrollBarWidth() {
  var inner = document.createElement('p');
  inner.style.width = '100%';
  inner.style.height = '200px';
  var outer = document.createElement('div');
  outer.style.position = 'absolute';
  outer.style.top = '0px';
  outer.style.left = '0px';
  outer.style.visibility = 'hidden';
  outer.style.width = '200px';
  outer.style.height = '150px';
  outer.style.overflow = 'hidden';
  outer.appendChild(inner);
  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;

  if (w1 == w2) {
    w2 = outer.clientWidth;
  }

  document.body.removeChild(outer);
  return w1 - w2;
} // @TODO: This doesn't work properly.
// It works only for single property objects,
// otherwise it combines all of the types in a union.
// export function topMost<K1 extends string, V1> (
//   pile: Record<K1, undefined | V1>[],
//   accessors: K1 | [K1]
// ): undefined | V1
// export function topMost<K1 extends string, K2 extends string, V1, V2> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],
//   accessors: [K1, K2]
// ): undefined | V1 | V2
// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],
//   accessors: [K1, K2, K3]
// ): undefined | V1 | V2 | V3

/**
 * Get the top most property value from a pile of objects.
 *
 * @param pile - Array of objects, no required format.
 * @param accessors - Array of property names (e.g. object['foo']['bar']  ['foo', 'bar']).
 *
 * @returns Value of the property with given accessors path from the first pile item where it's not undefined.
 */


function topMost(pile, accessors) {
  var candidate;

  if (!Array.isArray(accessors)) {
    accessors = [accessors];
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pile[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var member = _step.value;

      if (member) {
        candidate = member[accessors[0]];

        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }

        if (typeof candidate !== 'undefined') {
          break;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return candidate;
}

var util =
/*#__PURE__*/
Object.freeze({
  isNumber: isNumber,
  recursiveDOMDelete: recursiveDOMDelete,
  isString: isString,
  isObject: isObject$1,
  isDate: isDate,
  isMoment: isMoment,
  fillIfDefined: fillIfDefined,
  extend: extend,
  selectiveExtend: selectiveExtend,
  selectiveDeepExtend: selectiveDeepExtend,
  selectiveNotDeepExtend: selectiveNotDeepExtend,
  deepExtend: deepExtend,
  equalArray: equalArray,
  convert: convert,
  getType: getType,
  copyAndExtendArray: copyAndExtendArray,
  copyArray: copyArray,
  getAbsoluteLeft: getAbsoluteLeft,
  getAbsoluteRight: getAbsoluteRight,
  getAbsoluteTop: getAbsoluteTop,
  addClassName: addClassName,
  removeClassName: removeClassName,
  forEach: forEach,
  toArray: toArray,
  updateProperty: updateProperty,
  throttle: throttle,
  addEventListener: addEventListener,
  removeEventListener: removeEventListener,
  preventDefault: preventDefault,
  getTarget: getTarget,
  hasParent: hasParent,
  option: option,
  hexToRGB: hexToRGB,
  overrideOpacity: overrideOpacity,
  RGBToHex: RGBToHex,
  parseColor: parseColor,
  RGBToHSV: RGBToHSV,
  addCssText: addCssText,
  removeCssText: removeCssText,
  HSVToRGB: HSVToRGB,
  HSVToHex: HSVToHex,
  hexToHSV: hexToHSV,
  isValidHex: isValidHex,
  isValidRGB: isValidRGB,
  isValidRGBA: isValidRGBA,
  selectiveBridgeObject: selectiveBridgeObject,
  bridgeObject: bridgeObject,
  insertSort: insertSort,
  mergeOptions: mergeOptions,
  binarySearchCustom: binarySearchCustom,
  binarySearchValue: binarySearchValue,
  easingFunctions: easingFunctions,
  getScrollBarWidth: getScrollBarWidth,
  topMost: topMost,
  randomUUID: uuid4
}); // New API (tree shakeable).

exports.util = util;
var util$1 =
/*#__PURE__*/
Object.freeze({
  'default': util,
  HSVToHex: HSVToHex,
  HSVToRGB: HSVToRGB,
  RGBToHSV: RGBToHSV,
  RGBToHex: RGBToHex,
  addClassName: addClassName,
  addCssText: addCssText,
  addEventListener: addEventListener,
  binarySearchCustom: binarySearchCustom,
  binarySearchValue: binarySearchValue,
  bridgeObject: bridgeObject,
  convert: convert,
  copyAndExtendArray: copyAndExtendArray,
  copyArray: copyArray,
  deepExtend: deepExtend,
  easingFunctions: easingFunctions,
  equalArray: equalArray,
  extend: extend,
  fillIfDefined: fillIfDefined,
  forEach: forEach,
  getAbsoluteLeft: getAbsoluteLeft,
  getAbsoluteRight: getAbsoluteRight,
  getAbsoluteTop: getAbsoluteTop,
  getScrollBarWidth: getScrollBarWidth,
  getTarget: getTarget,
  getType: getType,
  hasParent: hasParent,
  hexToHSV: hexToHSV,
  hexToRGB: hexToRGB,
  insertSort: insertSort,
  isDate: isDate,
  isMoment: isMoment,
  isNumber: isNumber,
  isObject: isObject$1,
  isString: isString,
  isValidHex: isValidHex,
  isValidRGB: isValidRGB,
  isValidRGBA: isValidRGBA,
  mergeOptions: mergeOptions,
  option: option,
  overrideOpacity: overrideOpacity,
  parseColor: parseColor,
  preventDefault: preventDefault,
  randomUUID: uuid4,
  recursiveDOMDelete: recursiveDOMDelete,
  removeClassName: removeClassName,
  removeCssText: removeCssText,
  removeEventListener: removeEventListener,
  selectiveBridgeObject: selectiveBridgeObject,
  selectiveDeepExtend: selectiveDeepExtend,
  selectiveExtend: selectiveExtend,
  selectiveNotDeepExtend: selectiveNotDeepExtend,
  throttle: throttle,
  toArray: toArray,
  topMost: topMost,
  updateProperty: updateProperty
}); // DOM utility methods

/**
 * this prepares the JSON container for allocating SVG elements
 * @param {Object} JSONcontainer
 * @private
 */

function prepareElements(JSONcontainer) {
  // cleanup the redundant svgElements;
  for (var elementType in JSONcontainer) {
    if (JSONcontainer.hasOwnProperty(elementType)) {
      JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
      JSONcontainer[elementType].used = [];
    }
  }
}
/**
 * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from
 * which to remove the redundant elements.
 *
 * @param {Object} JSONcontainer
 * @private
 */


function cleanupElements(JSONcontainer) {
  // cleanup the redundant svgElements;
  for (var elementType in JSONcontainer) {
    if (JSONcontainer.hasOwnProperty(elementType)) {
      if (JSONcontainer[elementType].redundant) {
        for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
          JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
        }

        JSONcontainer[elementType].redundant = [];
      }
    }
  }
}
/**
 * Ensures that all elements are removed first up so they can be recreated cleanly
 * @param {Object} JSONcontainer
 */


function resetElements(JSONcontainer) {
  prepareElements(JSONcontainer);
  cleanupElements(JSONcontainer);
  prepareElements(JSONcontainer);
}
/**
 * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
 * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
 *
 * @param {string} elementType
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @returns {Element}
 * @private
 */


function getSVGElement(elementType, JSONcontainer, svgContainer) {
  var element; // allocate SVG element, if it doesnt yet exist, create one.

  if (JSONcontainer.hasOwnProperty(elementType)) {
    // this element has been created before
    // check if there is an redundant element
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      // create a new element and add it to the SVG
      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
      svgContainer.appendChild(element);
    }
  } else {
    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
    element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
    JSONcontainer[elementType] = {
      used: [],
      redundant: []
    };
    svgContainer.appendChild(element);
  }

  JSONcontainer[elementType].used.push(element);
  return element;
}
/**
 * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
 * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
 *
 * @param {string} elementType
 * @param {Object} JSONcontainer
 * @param {Element} DOMContainer
 * @param {Element} insertBefore
 * @returns {*}
 */


function getDOMElement(elementType, JSONcontainer, DOMContainer, insertBefore) {
  var element; // allocate DOM element, if it doesnt yet exist, create one.

  if (JSONcontainer.hasOwnProperty(elementType)) {
    // this element has been created before
    // check if there is an redundant element
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      // create a new element and add it to the SVG
      element = document.createElement(elementType);

      if (insertBefore !== undefined) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
  } else {
    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
    element = document.createElement(elementType);
    JSONcontainer[elementType] = {
      used: [],
      redundant: []
    };

    if (insertBefore !== undefined) {
      DOMContainer.insertBefore(element, insertBefore);
    } else {
      DOMContainer.appendChild(element);
    }
  }

  JSONcontainer[elementType].used.push(element);
  return element;
}
/**
 * Draw a point object. This is a separate function because it can also be called by the legend.
 * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions
 * as well.
 *
 * @param {number} x
 * @param {number} y
 * @param {Object} groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @param {Object} labelObj
 * @returns {vis.PointItem}
 */


function drawPoint(x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
  var point;

  if (groupTemplate.style == 'circle') {
    point = getSVGElement('circle', JSONcontainer, svgContainer);
    point.setAttributeNS(null, "cx", x);
    point.setAttributeNS(null, "cy", y);
    point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
  } else {
    point = getSVGElement('rect', JSONcontainer, svgContainer);
    point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, "width", groupTemplate.size);
    point.setAttributeNS(null, "height", groupTemplate.size);
  }

  if (groupTemplate.styles !== undefined) {
    point.setAttributeNS(null, "style", groupTemplate.styles);
  }

  point.setAttributeNS(null, "class", groupTemplate.className + " vis-point"); //handle label

  if (labelObj) {
    var label = getSVGElement('text', JSONcontainer, svgContainer);

    if (labelObj.xOffset) {
      x = x + labelObj.xOffset;
    }

    if (labelObj.yOffset) {
      y = y + labelObj.yOffset;
    }

    if (labelObj.content) {
      label.textContent = labelObj.content;
    }

    if (labelObj.className) {
      label.setAttributeNS(null, "class", labelObj.className + " vis-label");
    }

    label.setAttributeNS(null, "x", x);
    label.setAttributeNS(null, "y", y);
  }

  return point;
}
/**
 * draw a bar SVG element centered on the X coordinate
 *
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {string} className
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @param {string} style
 */


function drawBar(x, y, width, height, className, JSONcontainer, svgContainer, style) {
  if (height != 0) {
    if (height < 0) {
      height *= -1;
      y -= height;
    }

    var rect = getSVGElement('rect', JSONcontainer, svgContainer);
    rect.setAttributeNS(null, "x", x - 0.5 * width);
    rect.setAttributeNS(null, "y", y);
    rect.setAttributeNS(null, "width", width);
    rect.setAttributeNS(null, "height", height);
    rect.setAttributeNS(null, "class", className);

    if (style) {
      rect.setAttributeNS(null, "style", style);
    }
  }
}
/**
 * get default language
 * @returns {string}
 */


function getNavigatorLanguage() {
  if (navigator.languages && navigator.languages.length) {
    return navigator.languages;
  } else {
    return navigator.userLanguage || navigator.language || navigator.browserLanguage || 'en';
  }
}

var DOMutil =
/*#__PURE__*/
Object.freeze({
  prepareElements: prepareElements,
  cleanupElements: cleanupElements,
  resetElements: resetElements,
  getSVGElement: getSVGElement,
  getDOMElement: getDOMElement,
  drawPoint: drawPoint,
  drawBar: drawBar,
  getNavigatorLanguage: getNavigatorLanguage
});
exports.DOMutil = DOMutil;
var $reduce$1 = arrayReduce.left; // `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce

_export({
  target: 'Array',
  proto: true,
  forced: sloppyArrayMethod('reduce')
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var max$3 = Math.max;
var min$6 = Math.min;
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('splice')
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$6(max$3(toInteger(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var FAILS_ON_PRIMITIVES$5 = fails(function () {
  objectGetPrototypeOf(1);
}); // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$5,
  sham: !correctPrototypeGetter
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return objectGetPrototypeOf(toObject(it));
  }
}); // `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof


_export({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: objectSetPrototypeOf
});
/** 
 * vis-data - data
 * http://visjs.org/
 * 
 * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.
 * 
 * @version 6.1.0
 * @date    2019-07-16T13:37:00Z
 * 
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2018-2019 visjs contributors, https://github.com/visjs
 * 
 * @license 
 * vis.js is dual licensed under both
 * 
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 *   and
 * 
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 * 
 * vis.js may be distributed under either license.
 */


function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty$8 = _defineProperty$2;

function createCommonjsModule$2(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var _typeof_1$1 = createCommonjsModule$2(function (module) {
  function _typeof2(obj) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      _typeof2 = function _typeof2(obj) {
        return _typeof(obj);
      };
    } else {
      _typeof2 = function _typeof2(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
      };
    }

    return _typeof2(obj);
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      module.exports = _typeof$1 = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      module.exports = _typeof$1 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof$1(obj);
  }

  module.exports = _typeof$1;
});

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck$1;

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass$1;

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized$1;

function _possibleConstructorReturn$1(self, call) {
  if (call && (_typeof_1$1(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

var possibleConstructorReturn = _possibleConstructorReturn$1;
var getPrototypeOf = createCommonjsModule$2(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
});
var setPrototypeOf = createCommonjsModule$2(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
});

function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

var inherits = _inherits$1; // Maps for number <-> hex string conversion

var byteToHex$2 = [];

for (var i$2 = 0; i$2 < 256; i$2++) {
  byteToHex$2[i$2] = (i$2 + 0x100).toString(16).substr(1);
}
/**
 * Represent binary UUID into it's string representation.
 *
 * @param buf - Buffer containing UUID bytes.
 * @param offset - Offset from the start of the buffer where the UUID is saved (not needed if the buffer starts with the UUID).
 *
 * @returns String representation of the UUID.
 */


function stringifyUUID$1(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex$2;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}
/**
 * Generate 16 random bytes to be used as a base for UUID.
 *
 * @ignore
 */


var random$1 = function () {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);

    return function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  } // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().
  // It's fast, but is of unspecified quality.


  var _rnds = new Array(16);

  return function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) {
        r = Math.random() * 0x100000000;
      }

      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  }; //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php
  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  // return require('./rng');
}();

var byteToHex$1$1 = [];

for (var i$1$1 = 0; i$1$1 < 256; i$1$1++) {
  byteToHex$1$1[i$1$1] = (i$1$1 + 0x100).toString(16).substr(1);
} // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
// random #'s we need to init node and clockseq


var seedBytes$1 = random$1(); // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)

var defaultNodeId$1 = [seedBytes$1[0] | 0x01, seedBytes$1[1], seedBytes$1[2], seedBytes$1[3], seedBytes$1[4], seedBytes$1[5]]; // Per 4.2.2, randomize (14 bit) clockseq

var defaultClockseq$1 = (seedBytes$1[6] << 8 | seedBytes$1[7]) & 0x3fff; // Previous uuid creation time

/**
 * UUIDv4 options.
 */

/**
 * Generate UUIDv4
 *
 * @param options - Options to be used instead of default generated values.
 * String 'binary' is a shorthand for uuid4({}, new Array(16)).
 * @param buf - If present the buffer will be filled with the generated UUID.
 * @param offset - Offset of the UUID from the start of the buffer.
 *
 * @returns UUIDv4
 */

function uuid4$1() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var buf = arguments.length > 1 ? arguments[1] : undefined;
  var offset = arguments.length > 2 ? arguments[2] : undefined; // Deprecated - 'format' argument, as supported in v1.2

  var i = buf && offset || 0;

  if (typeof options === 'string') {
    buf = options === 'binary' ? new Array(16) : undefined;
    options = {};
  }

  var rnds = options.random || (options.rng || random$1)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || stringifyUUID$1(rnds);
} // Rollup will complain about mixing default and named exports in UMD build,


function _typeof$1(obj) {
  if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
    _typeof$1 = function _typeof$1(obj) {
      return _typeof(obj);
    };
  } else {
    _typeof$1 = function _typeof$1(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
    };
  }

  return _typeof$1(obj);
}

var commonjsGlobal$2 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire$2() {
  throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule$1$1(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var moment$1 = createCommonjsModule$1$1(function (module, exports) {
  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal$2, function () {
    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function some(fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (_typeof(arguments[i]) === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function keys(obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function func() {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function func(input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (_typeof(units) === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function indexOf(o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire$2;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function now() {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function ordinal(number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
}); // Maps for number <-> hex string conversion

var byteToHex$2$1 = [];

for (var i$2$1 = 0; i$2$1 < 256; i$2$1++) {
  byteToHex$2$1[i$2$1] = (i$2$1 + 0x100).toString(16).substr(1);
}
/**
 * Generate 16 random bytes to be used as a base for UUID.
 *
 * @ignore
 */


var random$1$1 = function () {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);

    return function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  } // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().
  // It's fast, but is of unspecified quality.


  var _rnds = new Array(16);

  return function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) {
        r = Math.random() * 0x100000000;
      }

      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  }; //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php
  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  // return require('./rng');
}();

var byteToHex$1$1$1 = [];

for (var i$1$1$1 = 0; i$1$1$1 < 256; i$1$1$1++) {
  byteToHex$1$1$1[i$1$1$1] = (i$1$1$1 + 0x100).toString(16).substr(1);
} // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
// random #'s we need to init node and clockseq


var seedBytes$1$1 = random$1$1(); // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)

var defaultNodeId$1$1 = [seedBytes$1$1[0] | 0x01, seedBytes$1$1[1], seedBytes$1$1[2], seedBytes$1$1[3], seedBytes$1$1[4], seedBytes$1$1[5]]; // Per 4.2.2, randomize (14 bit) clockseq

var defaultClockseq$1$1 = (seedBytes$1$1[6] << 8 | seedBytes$1$1[7]) & 0x3fff; // Previous uuid creation time
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/

var ASPDateRegex$1 = /^\/?Date\((-?\d+)/i; // Hex color

/**
 * Hue, Saturation, Value.
 */

/**
 * Test whether given object is a number
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if number, false otherwise.
 */

function isNumber$1(value) {
  return value instanceof Number || typeof value === 'number';
}
/**
 * Test whether given object is a string
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if string, false otherwise.
 */


function isString$1(value) {
  return value instanceof String || typeof value === 'string';
}
/**
 * Test whether given object is a Moment date.
 * @TODO: This is basically a workaround, if Moment was imported property it wouldn't necessary as moment.isMoment is a TS type guard.
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if Moment instance, false otherwise.
 */


function isMoment$1(value) {
  return moment$1.isMoment(value);
}
/**
 * Convert an object into another type
 *
 * @param object - Value of unknown type.
 * @param type - Name of the desired type.
 *
 * @returns Object in the desired type.
 * @throws Error
 */


function convert$1(object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }

  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }

  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  } //noinspection FallthroughInSwitchStatementJS


  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      if (isString$1(object) && !isNaN(Date.parse(object))) {
        return moment$1(object).valueOf();
      } else {
        // @TODO: I don't think that Number and String constructors are a good idea.
        // This could also fail if the object doesn't have valueOf method or if it's redefined.
        // For example: Object.create(null) or { valueOf: 7 }.
        return Number(object.valueOf());
      }

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (isNumber$1(object)) {
        return new Date(object);
      }

      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (isMoment$1(object)) {
        return new Date(object.valueOf());
      }

      if (isString$1(object)) {
        match = ASPDateRegex$1.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
          return moment$1(new Date(object)).toDate(); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType$1(object) + ' to type Date');
      }

    case 'Moment':
      if (isNumber$1(object)) {
        return moment$1(object);
      }

      if (object instanceof Date) {
        return moment$1(object.valueOf());
      } else if (isMoment$1(object)) {
        return moment$1(object);
      }

      if (isString$1(object)) {
        match = ASPDateRegex$1.exec(object);

        if (match) {
          // object is an ASP date
          return moment$1(Number(match[1])); // parse number
        } else {
          return moment$1(object); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType$1(object) + ' to type Date');
      }

    case 'ISODate':
      if (isNumber$1(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (isMoment$1(object)) {
        return object.toDate().toISOString();
      } else if (isString$1(object)) {
        match = ASPDateRegex$1.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
          return moment$1(object).format(); // ISO 8601
        }
      } else {
        throw new Error('Cannot convert object of type ' + getType$1(object) + ' to type ISODate');
      }

    case 'ASPDate':
      if (isNumber$1(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (isString$1(object)) {
        match = ASPDateRegex$1.exec(object);

        var _value;

        if (match) {
          // object is an ASP date
          _value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
          _value = new Date(object).valueOf(); // parse string
        }

        return '/Date(' + _value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + getType$1(object) + ' to type ASPDate');
      }

    default:
      var never = type;
      throw new Error("Unknown type ".concat(never));
  }
}
/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 *
 * @param object - Input value of unknown type.
 *
 * @returns Detected type.
 */


function getType$1(object) {
  var type = _typeof$1(object);

  if (type === 'object') {
    if (object === null) {
      return 'null';
    }

    if (object instanceof Boolean) {
      return 'Boolean';
    }

    if (object instanceof Number) {
      return 'Number';
    }

    if (object instanceof String) {
      return 'String';
    }

    if (Array.isArray(object)) {
      return 'Array';
    }

    if (object instanceof Date) {
      return 'Date';
    }

    return 'Object';
  }

  if (type === 'number') {
    return 'Number';
  }

  if (type === 'boolean') {
    return 'Boolean';
  }

  if (type === 'string') {
    return 'String';
  }

  if (type === undefined) {
    return 'undefined';
  }

  return type;
}
/**
 * Determine whether a value can be used as an id.
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if the value is valid id, false otherwise.
 */


function isId(value) {
  return typeof value === 'string' || typeof value === 'number';
}
/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */


var Queue =
/*#__PURE__*/
function () {
  /**
   * Construct a new Queue.
   *
   * @param options - Queue configuration.
   */
  function Queue(options) {
    classCallCheck(this, Queue);
    this._queue = [];
    this._timeout = null;
    this._extended = null; // options

    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  /**
   * Update the configuration of the queue.
   *
   * @param options - Queue configuration.
   */


  createClass(Queue, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && typeof options.delay !== 'undefined') {
        this.delay = options.delay;
      }

      if (options && typeof options.max !== 'undefined') {
        this.max = options.max;
      }

      this._flushIfNeeded();
    }
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     *
     * @returns The created queue.
     */

  }, {
    key: "destroy",

    /**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */
    value: function destroy() {
      this.flush();

      if (this._extended) {
        var object = this._extended.object;
        var methods = this._extended.methods;

        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];

          if (method.original) {
            object[method.name] = method.original;
          } else {
            // @TODO: better solution?
            delete object[method.name];
          }
        }

        this._extended = null;
      }
    }
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */

  }, {
    key: "replace",
    value: function replace(object, method) {
      var me = this;
      var original = object[method];

      if (!original) {
        throw new Error('Method ' + method + ' undefined');
      }

      object[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        } // add this call to the queue


        me.queue({
          args: args,
          fn: original,
          context: this
        });
      };
    }
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */

  }, {
    key: "queue",
    value: function queue(entry) {
      if (typeof entry === 'function') {
        this._queue.push({
          fn: entry
        });
      } else {
        this._queue.push(entry);
      }

      this._flushIfNeeded();
    }
    /**
     * Check whether the queue needs to be flushed.
     */

  }, {
    key: "_flushIfNeeded",
    value: function _flushIfNeeded() {
      var _this = this; // flush when the maximum is exceeded.


      if (this._queue.length > this.max) {
        this.flush();
      } // flush after a period of inactivity when a delay is configured


      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }

      if (this.queue.length > 0 && typeof this.delay === 'number') {
        this._timeout = setTimeout(function () {
          _this.flush();
        }, this.delay);
      }
    }
    /**
     * Flush all queued calls
     */

  }, {
    key: "flush",
    value: function flush() {
      this._queue.splice(0).forEach(function (entry) {
        entry.fn.apply(entry.context || entry.fn, entry.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function extend(object, options) {
      var queue = new Queue(options);

      if (object.flush !== undefined) {
        throw new Error('Target object already has a property flush');
      }

      object.flush = function () {
        queue.flush();
      };

      var methods = [{
        name: 'flush',
        original: undefined
      }];

      if (options && options.replace) {
        for (var i = 0; i < options.replace.length; i++) {
          var name = options.replace[i];
          methods.push({
            name: name,
            // @TODO: better solution?
            original: object[name]
          }); // @TODO: better solution?

          queue.replace(object, name);
        }
      }

      queue._extended = {
        object: object,
        methods: methods
      };
      return queue;
    }
  }]);
  return Queue;
}();

exports.Queue = Queue;

function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles$1 = _arrayWithoutHoles$2;

function _iterableToArray$2(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray$1 = _iterableToArray$2;

function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread$1 = _nonIterableSpread$2;

function _toConsumableArray$2(arr) {
  return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || nonIterableSpread$1();
}

var toConsumableArray$1 = _toConsumableArray$2;
/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */

var DataSetPart =
/*#__PURE__*/
function () {
  function DataSetPart() {
    classCallCheck(this, DataSetPart);
    this._subscribers = {
      '*': [],
      add: [],
      remove: [],
      update: []
    };
    /**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */

    this.subscribe = DataSetPart.prototype.on;
    /**
     * @deprecated Use off instead (PS: DataView.unsubscribe === DataView.off).
     */

    this.unsubscribe = DataSetPart.prototype.off;
  }
  /**
   * Trigger an event
   *
   * @param event - Event name.
   * @param payload - Event payload.
   * @param senderId - Id of the sender.
   */


  createClass(DataSetPart, [{
    key: "_trigger",
    value: function _trigger(event, payload, senderId) {
      if (event === '*') {
        throw new Error('Cannot trigger event *');
      }

      var subscribers = [].concat(toConsumableArray$1(this._subscribers[event]), toConsumableArray$1(this._subscribers['*']));

      for (var i = 0, len = subscribers.length; i < len; i++) {
        var subscriber = subscribers[i];

        if (subscriber.callback) {
          subscriber.callback(event, payload, senderId != null ? senderId : null);
        }
      }
    }
    /**
     * Subscribe to an event, add an event listener.
     *
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "on",
    value: function on(event, callback) {
      this._subscribers[event].push({
        callback: callback
      });
    }
    /**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     *
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "off",
    value: function off(event, callback) {
      this._subscribers[event] = this._subscribers[event].filter(function (listener) {
        return listener.callback !== callback;
      });
    }
  }]);
  return DataSetPart;
}();

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(source, true).forEach(function (key) {
        defineProperty$8(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}
/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and manipulate unstructured data and listen for changes in the data. The DataSet is key/value based. Data items can be added, updated and removed from the DataSet, and one can subscribe to changes in the DataSet. The data in the DataSet can be filtered and ordered, and fields (like dates) can be converted to a specific type. Data can be normalized when appending it to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 *
 * // retrieve formatted items
 * var items = data.get({
 *   fields: ['id', 'date'],
 *   type: {
 *     date: 'ISODate'
 *   }
 * });
 * console.log('formatted items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSet =
/*#__PURE__*/
function (_DataSetPart) {
  inherits(DataSet, _DataSetPart);
  /**
   * Construct a new DataSet.
   *
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */

  function DataSet(data, options) {
    var _this;

    classCallCheck(this, DataSet);
    _this = possibleConstructorReturn(this, getPrototypeOf(DataSet).call(this)); // correctly read optional arguments

    if (data && !Array.isArray(data)) {
      options = data;
      data = [];
    }

    _this._options = options || {};
    _this._data = Object.create({}); // map with data indexed by id

    _this.length = 0; // number of items in the DataSet

    _this._idProp = _this._options.fieldId || 'id'; // name of the field containing id

    _this._type = {}; // internal field types (NOTE: this can differ from this._options.type)
    // all variants of a Date are internally stored as Date, so we can convert
    // from everything to everything (also from ISODate to Number for example)

    if (_this._options.type) {
      var fields = Object.keys(_this._options.type);

      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var value = _this._options.type[field];

        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          _this._type[field] = 'Date';
        } else {
          _this._type[field] = value;
        }
      }
    } // add initial data when provided


    if (data && data.length) {
      _this.add(data);
    }

    _this.setOptions(options);

    return _this;
  }
  /**
   * Set new options.
   *
   * @param options - The new options.
   */


  createClass(DataSet, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && options.queue !== undefined) {
        if (options.queue === false) {
          // delete queue if loaded
          if (this._queue) {
            this._queue.destroy();

            delete this._queue;
          }
        } else {
          // create queue and update its options
          if (!this._queue) {
            this._queue = Queue.extend(this, {
              replace: ['add', 'update', 'remove']
            });
          }

          if (options.queue && _typeof_1$1(options.queue) === 'object') {
            this._queue.setOptions(options.queue);
          }
        }
      }
    }
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     *
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     *
     * @throws When an item with the same id as any of the added items already exists.
     */

  }, {
    key: "add",
    value: function add(data, senderId) {
      var addedIds = [];
      var id;

      if (Array.isArray(data)) {
        // Array
        for (var i = 0, len = data.length; i < len; i++) {
          id = this._addItem(data[i]);
          addedIds.push(id);
        }
      } else if (data && _typeof_1$1(data) === 'object') {
        // Single item
        id = this._addItem(data);
        addedIds.push(id);
      } else {
        throw new Error('Unknown dataType');
      }

      if (addedIds.length) {
        this._trigger('add', {
          items: addedIds
        }, senderId);
      }

      return addedIds;
    }
    /**
     * Update existing items. When an item does not exist, it will be created
     *
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     *
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     *
     * @throws When the supplied data is neither an item nor an array of items.
     */

  }, {
    key: "update",
    value: function update(data, senderId) {
      var _this2 = this;

      var addedIds = [];
      var updatedIds = [];
      var oldData = [];
      var updatedData = [];
      var idProp = this._idProp;

      var addOrUpdate = function addOrUpdate(item) {
        var origId = item[idProp];

        if (origId != null && _this2._data[origId]) {
          var fullItem = item; // it has an id, therefore it is a fullitem

          var oldItem = Object.assign({}, _this2._data[origId]); // update item

          var id = _this2._updateItem(fullItem);

          updatedIds.push(id);
          updatedData.push(fullItem);
          oldData.push(oldItem);
        } else {
          // add new item
          var _id = _this2._addItem(item);

          addedIds.push(_id);
        }
      };

      if (Array.isArray(data)) {
        // Array
        for (var i = 0, len = data.length; i < len; i++) {
          if (data[i] && _typeof_1$1(data[i]) === 'object') {
            addOrUpdate(data[i]);
          } else {
            console.warn('Ignoring input item, which is not an object at index ' + i);
          }
        }
      } else if (data && _typeof_1$1(data) === 'object') {
        // Single item
        addOrUpdate(data);
      } else {
        throw new Error('Unknown dataType');
      }

      if (addedIds.length) {
        this._trigger('add', {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        var props = {
          items: updatedIds,
          oldData: oldData,
          data: updatedData
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger('update', props, senderId);
      }

      return addedIds.concat(updatedIds);
    }
    /** @inheritdoc */

  }, {
    key: "get",
    value: function get(first, second) {
      // @TODO: Woudn't it be better to split this into multiple methods?
      // parse the arguments
      var id = undefined;
      var ids = undefined;
      var options = undefined;

      if (isId(first)) {
        // get(id [, options])
        id = first;
        options = second;
      } else if (Array.isArray(first)) {
        // get(ids [, options])
        ids = first;
        options = second;
      } else {
        // get([, options])
        options = first;
      } // determine the return type


      var returnType = options && options.returnType === 'Object' ? 'Object' : 'Array'; // @TODO: WTF is this? Or am I missing something?
      // var returnType
      // if (options && options.returnType) {
      //   var allowedValues = ['Array', 'Object']
      //   returnType =
      //     allowedValues.indexOf(options.returnType) == -1
      //       ? 'Array'
      //       : options.returnType
      // } else {
      //   returnType = 'Array'
      // }
      // build options

      var type = options && options.type || this._options.type;
      var filter = options && options.filter;
      var items = [];
      var item = null;
      var itemIds = null;
      var itemId = null; // convert items

      if (id != null) {
        // return a single item
        item = this._getItem(id, type);

        if (item && filter && !filter(item)) {
          item = null;
        }
      } else if (ids != null) {
        // return a subset of items
        for (var i = 0, len = ids.length; i < len; i++) {
          item = this._getItem(ids[i], type);

          if (item != null && (!filter || filter(item))) {
            items.push(item);
          }
        }
      } else {
        // return all items
        itemIds = Object.keys(this._data);

        for (var _i = 0, _len = itemIds.length; _i < _len; _i++) {
          itemId = itemIds[_i];
          item = this._getItem(itemId, type);

          if (item != null && (!filter || filter(item))) {
            items.push(item);
          }
        }
      } // order the results


      if (options && options.order && id == undefined) {
        this._sort(items, options.order);
      } // filter fields of the items


      if (options && options.fields) {
        var fields = options.fields;

        if (id != undefined && item != null) {
          item = this._filterFields(item, fields);
        } else {
          for (var _i2 = 0, _len2 = items.length; _i2 < _len2; _i2++) {
            items[_i2] = this._filterFields(items[_i2], fields);
          }
        }
      } // return the results


      if (returnType == 'Object') {
        var result = {};

        for (var _i3 = 0, _len3 = items.length; _i3 < _len3; _i3++) {
          var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
          // result[resultant.id] = resultant

          var _id2 = resultant[this._idProp];
          result[_id2] = resultant;
        }

        return result;
      } else {
        if (id != null) {
          // a single item
          return item;
        } else {
          // just return our array
          return items;
        }
      }
    }
    /** @inheritdoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      var data = this._data;
      var filter = options && options.filter;
      var order = options && options.order;
      var type = options && options.type || this._options.type;
      var itemIds = Object.keys(data);
      var ids = [];
      var item;
      var items;

      if (filter) {
        // get filtered items
        if (order) {
          // create ordered list
          items = [];

          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id = itemIds[i];
            item = this._getItem(id, type);

            if (filter(item)) {
              items.push(item);
            }
          }

          this._sort(items, order);

          for (var _i4 = 0, _len4 = items.length; _i4 < _len4; _i4++) {
            ids.push(items[_i4][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i5 = 0, _len5 = itemIds.length; _i5 < _len5; _i5++) {
            var _id3 = itemIds[_i5];
            item = this._getItem(_id3, type);

            if (filter(item)) {
              ids.push(item[this._idProp]);
            }
          }
        }
      } else {
        // get all items
        if (order) {
          // create an ordered list
          items = [];

          for (var _i6 = 0, _len6 = itemIds.length; _i6 < _len6; _i6++) {
            var _id4 = itemIds[_i6];
            items.push(data[_id4]);
          }

          this._sort(items, order);

          for (var _i7 = 0, _len7 = items.length; _i7 < _len7; _i7++) {
            ids.push(items[_i7][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i8 = 0, _len8 = itemIds.length; _i8 < _len8; _i8++) {
            var _id5 = itemIds[_i8];
            item = data[_id5];
            ids.push(item[this._idProp]);
          }
        }
      }

      return ids;
    }
    /** @inheritdoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this;
    }
    /** @inheritdoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      var filter = options && options.filter;
      var type = options && options.type || this._options.type;
      var data = this._data;
      var itemIds = Object.keys(data);

      if (options && options.order) {
        // execute forEach on ordered list
        var items = this.get(options);

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var id = item[this._idProp];
          callback(item, id);
        }
      } else {
        // unordered
        for (var _i9 = 0, _len9 = itemIds.length; _i9 < _len9; _i9++) {
          var _id6 = itemIds[_i9];

          var _item = this._getItem(_id6, type);

          if (!filter || filter(_item)) {
            callback(_item, _id6);
          }
        }
      }
    }
    /** @inheritdoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      var filter = options && options.filter;
      var type = options && options.type || this._options.type;
      var mappedItems = [];
      var data = this._data;
      var itemIds = Object.keys(data); // convert and filter items

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];

        var item = this._getItem(id, type);

        if (!filter || filter(item)) {
          mappedItems.push(callback(item, id));
        }
      } // order items


      if (options && options.order) {
        this._sort(mappedItems, options.order);
      }

      return mappedItems;
    }
    /**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     *
     * @typeParam K - Field name type.
     *
     * @returns The item without any additional fields.
     */

  }, {
    key: "_filterFields",
    value: function _filterFields(item, fields) {
      if (!item) {
        // item is null
        return item;
      }

      return (Array.isArray(fields) ? // Use the supplied array
      fields : // Use the keys of the supplied object
      Object.keys(fields)).reduce(function (filteredItem, field) {
        filteredItem[field] = item[field];
        return filteredItem;
      }, {});
    }
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     *
     * @typeParam T - The type of the items in the items array.
     */

  }, {
    key: "_sort",
    value: function _sort(items, order) {
      if (typeof order === 'string') {
        // order by provided field name
        var name = order; // field name

        items.sort(function (a, b) {
          // @TODO: How to treat missing properties?
          var av = a[name];
          var bv = b[name];
          return av > bv ? 1 : av < bv ? -1 : 0;
        });
      } else if (typeof order === 'function') {
        // order by sort function
        items.sort(order);
      } else {
        // TODO: extend order by an Object {field:string, direction:string}
        //       where direction can be 'asc' or 'desc'
        throw new TypeError('Order must be a function or a string');
      }
    }
    /**
     * Remove an item or multiple items by reference (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     *
     * @returns The ids of the removed items.
     */

  }, {
    key: "remove",
    value: function remove(id, senderId) {
      var removedIds = [];
      var removedItems = []; // force everything to be an array for simplicity

      var ids = Array.isArray(id) ? id : [id];

      for (var i = 0, len = ids.length; i < len; i++) {
        var item = this._remove(ids[i]);

        if (item) {
          var itemId = item[this._idProp];

          if (itemId != null) {
            removedIds.push(itemId);
            removedItems.push(item);
          }
        }
      }

      if (removedIds.length) {
        this._trigger('remove', {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }

      return removedIds;
    }
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     *
     * @returns The removed item if removed, null otherwise.
     */

  }, {
    key: "_remove",
    value: function _remove(id) {
      // @TODO: It origianlly returned the item although the docs say id.
      // The code expects the item, so probably an error in the docs.
      var ident; // confirm the id to use based on the args type

      if (isId(id)) {
        ident = id;
      } else if (id && _typeof_1$1(id) === 'object') {
        ident = id[this._idProp]; // look for the identifier field using ._idProp
      } // do the removing if the item is found


      if (ident != null && this._data[ident]) {
        var item = this._data[ident];
        delete this._data[ident];
        --this.length;
        return item;
      }

      return null;
    }
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     *
     * @returns removedIds - The ids of all removed items.
     */

  }, {
    key: "clear",
    value: function clear(senderId) {
      var ids = Object.keys(this._data);
      var items = [];

      for (var i = 0, len = ids.length; i < len; i++) {
        items.push(this._data[ids[i]]);
      }

      this._data = {};
      this.length = 0;

      this._trigger('remove', {
        items: ids,
        oldData: items
      }, senderId);

      return ids;
    }
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     *
     * @returns Item containing max value, or null if no items.
     */

  }, {
    key: "max",
    value: function max(field) {
      var data = this._data;
      var itemIds = Object.keys(data);
      var max = null;
      var maxField = null;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data[id];
        var itemField = item[field];

        if (itemField != null && (maxField == null || itemField > maxField)) {
          max = item;
          maxField = itemField;
        }
      }

      return max;
    }
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     *
     * @returns Item containing min value, or null if no items.
     */

  }, {
    key: "min",
    value: function min(field) {
      var data = this._data;
      var itemIds = Object.keys(data);
      var min = null;
      var minField = null;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data[id];
        var itemField = item[field];

        if (itemField != null && (minField == null || itemField < minField)) {
          min = item;
          minField = itemField;
        }
      }

      return min;
    }
    /**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     *
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */

  }, {
    key: "distinct",
    value: function distinct(prop) {
      var data = this._data;
      var itemIds = Object.keys(data);
      var values = [];
      var fieldType = this._options.type && this._options.type[prop] || null;
      var count = 0;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data[id];
        var value = item[prop];
        var exists = false;

        for (var j = 0; j < count; j++) {
          if (values[j] == value) {
            exists = true;
            break;
          }
        }

        if (!exists && value !== undefined) {
          values[count] = value;
          count++;
        }
      }

      if (fieldType) {
        for (var _i10 = 0, _len10 = values.length; _i10 < _len10; _i10++) {
          values[_i10] = convert$1(values[_i10], fieldType);
        }
      }

      return values;
    }
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     *
     * @returns Added item's id. An id is generated when it is not present in the item.
     */

  }, {
    key: "_addItem",
    value: function _addItem(item) {
      var id = item[this._idProp];

      if (id != null) {
        // check whether this id is already taken
        if (this._data[id]) {
          // item already exists
          throw new Error('Cannot add item: item with id ' + id + ' already exists');
        }
      } else {
        // generate an id
        id = uuid4$1();
        item[this._idProp] = id;
      }

      var d = {};
      var fields = Object.keys(item);

      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var fieldType = this._type[field]; // type may be undefined

        d[field] = convert$1(item[field], fieldType);
      }

      this._data[id] = d;
      this.length++;
      return id;
    }
    /**
     * Get an item. Fields can be converted to a specific type
     *
     * @param id - Id of the requested item.
     * @param types - Property name to type name object map of type converstions.
     *
     * @returns The item, optionally after type conversion.
     */

  }, {
    key: "_getItem",
    value: function _getItem(id, types) {
      // @TODO: I have no idea how to type this.
      // get the item from the dataset
      var raw = this._data[id];

      if (!raw) {
        return null;
      } // convert the items field types


      var converted;
      var fields = Object.keys(raw);

      if (types) {
        converted = {};

        for (var i = 0, len = fields.length; i < len; i++) {
          var field = fields[i];
          var value = raw[field];
          converted[field] = convert$1(value, types[field]);
        }
      } else {
        // no field types specified, no converting needed
        converted = _objectSpread$1({}, raw);
      }

      if (converted[this._idProp] == null) {
        converted[this._idProp] = raw.id;
      }

      return converted;
    }
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param item - The new item
     *
     * @returns The id of the updated item.
     */

  }, {
    key: "_updateItem",
    value: function _updateItem(item) {
      var id = item[this._idProp];

      if (id == null) {
        throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
      }

      var d = this._data[id];

      if (!d) {
        // item doesn't exist
        throw new Error('Cannot update item: no item with id ' + id + ' found');
      } // merge with current item


      var fields = Object.keys(item);

      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var fieldType = this._type[field] // type may be undefined
        ;
        d[field] = convert$1(item[field], fieldType);
      }

      return id;
    }
  }]);
  return DataSet;
}(DataSetPart);
/**
 * DataView
 *
 * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
 *
 * ## Example
 * ```javascript
 * // create a DataSet
 * var data = new vis.DataSet();
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // create a DataView
 * // the view will only contain items having a property group with value 1,
 * // and will only output fields id, text, and date.
 * var view = new vis.DataView(data, {
 *   filter: function (item) {
 *     return (item.group == 1);
 *   },
 *   fields: ['id', 'text', 'date']
 * });
 *
 * // subscribe to any change in the DataView
 * view.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an item in the data set
 * data.update({id: 2, group: 1});
 *
 * // get all ids in the view
 * var ids = view.getIds();
 * console.log('ids', ids); // will output [1, 2]
 *
 * // get all items in the view
 * var items = view.get();
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


exports.DataSet = DataSet;

var DataView$2 =
/*#__PURE__*/
function (_DataSetPart) {
  inherits(DataView, _DataSetPart);
  /**
   * Create a DataView.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */

  function DataView(data, options) {
    var _this;

    classCallCheck(this, DataView);
    _this = possibleConstructorReturn(this, getPrototypeOf(DataView).call(this));
    /** @inheritdoc */

    _this.length = 0;
    _this._ids = {}; // ids of the items currently in memory (just contains a boolean true)

    _this._options = options || {};
    _this.listener = _this._onEvent.bind(assertThisInitialized(_this));

    _this.setData(data);

    return _this;
  } // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view.
   *
   * @param data - The instance containing data (directly or indirectly).
   */


  createClass(DataView, [{
    key: "setData",
    value: function setData(data) {
      if (this._data) {
        // unsubscribe from current dataset
        if (this._data.off) {
          this._data.off('*', this.listener);
        } // trigger a remove of all items in memory


        var ids = this._data.getIds({
          filter: this._options.filter
        });

        var items = this._data.get(ids);

        this._ids = {};
        this.length = 0;

        this._trigger('remove', {
          items: ids,
          oldData: items
        });
      }

      if (data != null) {
        this._data = data; // trigger an add of all added items

        var _ids = this._data.getIds({
          filter: this._options.filter
        });

        for (var i = 0, len = _ids.length; i < len; i++) {
          var id = _ids[i];
          this._ids[id] = true;
        }

        this.length = _ids.length;

        this._trigger('add', {
          items: _ids
        });
      } else {
        this._data = new DataSet();
      } // subscribe to new dataset


      if (this._data.on) {
        this._data.on('*', this.listener);
      }
    }
    /**
     * Refresh the DataView.
     * Useful when the DataView has a filter function containing a variable parameter.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var ids = this._data.getIds({
        filter: this._options.filter
      });

      var oldIds = Object.keys(this._ids);
      var newIds = {};
      var addedIds = [];
      var removedIds = [];
      var removedItems = []; // check for additions

      for (var i = 0, len = ids.length; i < len; i++) {
        var id = ids[i];
        newIds[id] = true;

        if (!this._ids[id]) {
          addedIds.push(id);
          this._ids[id] = true;
        }
      } // check for removals


      for (var _i = 0, _len = oldIds.length; _i < _len; _i++) {
        var _id = oldIds[_i];

        var item = this._data.get(_id);

        if (item == null) {
          // @TODO: Investigate.
          // Doesn't happen during tests or examples.
          // Is it really impossible or could it eventually happen?
          // How to handle it if it does? The types guarantee non-nullable items.
          console.error('If you see this, report it please.');
        } else if (!newIds[_id]) {
          removedIds.push(_id);
          removedItems.push(item);
          delete this._ids[_id];
        }
      }

      this.length += addedIds.length - removedIds.length; // trigger events

      if (addedIds.length) {
        this._trigger('add', {
          items: addedIds
        });
      }

      if (removedIds.length) {
        this._trigger('remove', {
          items: removedIds,
          oldData: removedItems
        });
      }
    }
    /** @inheritdoc */

  }, {
    key: "get",
    value: function get(first, second) {
      if (this._data == null) {
        return null;
      } // parse the arguments


      var ids = null;
      var options;

      if (isId(first) || Array.isArray(first)) {
        ids = first;
        options = second;
      } else {
        options = first;
      } // extend the options with the default options and provided options


      var viewOptions = Object.assign({}, this._options, options); // create a combined filter method when needed

      var thisFilter = this._options.filter;
      var optionsFilter = options && options.filter;

      if (thisFilter && optionsFilter) {
        viewOptions.filter = function (item) {
          return thisFilter(item) && optionsFilter(item);
        };
      }

      if (ids == null) {
        return this._data.get(viewOptions);
      } else {
        return this._data.get(ids, viewOptions);
      }
    }
    /** @inheritdoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      if (this._data.length) {
        var defaultFilter = this._options.filter;
        var optionsFilter = options != null ? options.filter : null;
        var filter;

        if (optionsFilter) {
          if (defaultFilter) {
            filter = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter = optionsFilter;
          }
        } else {
          filter = defaultFilter;
        }

        return this._data.getIds({
          filter: filter,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritdoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      if (this._data) {
        var defaultFilter = this._options.filter;
        var optionsFilter = options && options.filter;
        var filter;

        if (optionsFilter) {
          if (defaultFilter) {
            filter = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter = optionsFilter;
          }
        } else {
          filter = defaultFilter;
        }

        this._data.forEach(callback, {
          filter: filter,
          order: options && options.order
        });
      }
    }
    /** @inheritdoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      if (this._data) {
        var defaultFilter = this._options.filter;
        var optionsFilter = options && options.filter;
        var filter;

        if (optionsFilter) {
          if (defaultFilter) {
            filter = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter = optionsFilter;
          }
        } else {
          filter = defaultFilter;
        }

        return this._data.map(callback, {
          filter: filter,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritdoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this._data.getDataSet();
    }
    /**
     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
     *
     * @param event - The name of the event.
     * @param params - Parameters of the event.
     * @param senderId - Id supplied by the sender.
     */

  }, {
    key: "_onEvent",
    value: function _onEvent(event, params, senderId) {
      if (!params || !params.items || !this._data) {
        return;
      }

      var ids = params.items;
      var addedIds = [];
      var updatedIds = [];
      var removedIds = [];
      var oldItems = [];
      var updatedItems = [];
      var removedItems = [];

      switch (event) {
        case 'add':
          // filter the ids of the added items
          for (var i = 0, len = ids.length; i < len; i++) {
            var id = ids[i];
            var item = this.get(id);

            if (item) {
              this._ids[id] = true;
              addedIds.push(id);
            }
          }

          break;

        case 'update':
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (var _i2 = 0, _len2 = ids.length; _i2 < _len2; _i2++) {
            var _id2 = ids[_i2];

            var _item = this.get(_id2);

            if (_item) {
              if (this._ids[_id2]) {
                updatedIds.push(_id2);
                updatedItems.push(params.data[_i2]);
                oldItems.push(params.oldData[_i2]);
              } else {
                this._ids[_id2] = true;
                addedIds.push(_id2);
              }
            } else {
              if (this._ids[_id2]) {
                delete this._ids[_id2];
                removedIds.push(_id2);
                removedItems.push(params.oldData[_i2]);
              }
            }
          }

          break;

        case 'remove':
          // filter the ids of the removed items
          for (var _i3 = 0, _len3 = ids.length; _i3 < _len3; _i3++) {
            var _id3 = ids[_i3];

            if (this._ids[_id3]) {
              delete this._ids[_id3];
              removedIds.push(_id3);
              removedItems.push(params.oldData[_i3]);
            }
          }

          break;
      }

      this.length += addedIds.length - removedIds.length;

      if (addedIds.length) {
        this._trigger('add', {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        this._trigger('update', {
          items: updatedIds,
          oldData: oldItems,
          data: updatedItems
        }, senderId);
      }

      if (removedIds.length) {
        this._trigger('remove', {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }
    }
  }]);
  return DataView;
}(DataSetPart);

exports.DataView = DataView$2;
var moment$2 = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {
    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function some(fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (_typeof(arguments[i]) === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function keys(obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function func() {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function func(input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (_typeof(units) === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function indexOf(o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function now() {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function ordinal(number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
}); // use this instance. Else, load via commonjs.

var moment$3 = typeof window !== 'undefined' && window['moment'] || moment$2; // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/

exports.moment = moment$3;
var ASPDateRegex$2 = /^\/?Date\((-?\d+)/i;
/**
 * Convert an object into another type
 *
 * @param object - Value of unknown type.
 * @param type - Name of the desired type.
 *
 * @returns Object in the desired type.
 * @throws Error
 */

function convert$2(object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }

  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }

  if (!(typeof type === "string") && !(type instanceof String)) {
    throw new Error("Type must be a string");
  } //noinspection FallthroughInSwitchStatementJS


  switch (type) {
    case "boolean":
    case "Boolean":
      return Boolean(object);

    case "number":
    case "Number":
      if (isString(object) && !isNaN(Date.parse(object))) {
        return moment$2(object).valueOf();
      } else {
        // @TODO: I don't think that Number and String constructors are a good idea.
        // This could also fail if the object doesn't have valueOf method or if it's redefined.
        // For example: Object.create(null) or { valueOf: 7 }.
        return Number(object.valueOf());
      }

    case "string":
    case "String":
      return String(object);

    case "Date":
      if (isNumber(object)) {
        return new Date(object);
      }

      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment$2.isMoment(object)) {
        return new Date(object.valueOf());
      }

      if (isString(object)) {
        match = ASPDateRegex$2.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
          return moment$2(new Date(object)).toDate(); // parse string
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object) + " to type Date");
      }

    case "Moment":
      if (isNumber(object)) {
        return moment$2(object);
      }

      if (object instanceof Date) {
        return moment$2(object.valueOf());
      } else if (moment$2.isMoment(object)) {
        return moment$2(object);
      }

      if (isString(object)) {
        match = ASPDateRegex$2.exec(object);

        if (match) {
          // object is an ASP date
          return moment$2(Number(match[1])); // parse number
        } else {
          return moment$2(object); // parse string
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object) + " to type Date");
      }

    case "ISODate":
      if (isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment$2.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (isString(object)) {
        match = ASPDateRegex$2.exec(object);

        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
          return moment$2(object).format(); // ISO 8601
        }
      } else {
        throw new Error("Cannot convert object of type " + getType(object) + " to type ISODate");
      }

    case "ASPDate":
      if (isNumber(object)) {
        return "/Date(" + object + ")/";
      } else if (object instanceof Date || moment$2.isMoment(object)) {
        return "/Date(" + object.valueOf() + ")/";
      } else if (isString(object)) {
        match = ASPDateRegex$2.exec(object);
        var value;

        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
          value = new Date(object).valueOf(); // parse string
        }

        return "/Date(" + value + ")/";
      } else {
        throw new Error("Cannot convert object of type " + getType(object) + " to type ASPDate");
      }

    default:
      throw new Error("Unknown type ".concat(type));
  }
}

var util$2 = _objectSpread2({}, util$1, {
  convert: convert$2
});
/** Prototype for visual components */


var Component =
/*#__PURE__*/
function () {
  /**
  * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
  * @param {Object} [options]
  */
  function Component(body, options) {
    _classCallCheck(this, Component); // eslint-disable-line no-unused-vars


    this.options = null;
    this.props = null;
  }
  /**
   * Set options for the component. The new options will be merged into the
   * current options.
   * @param {Object} options
   */


  _createClass(Component, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        util$2.extend(this.options, options);
      }
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      // should be implemented by the component
      return false;
    }
    /**
     * Destroy the component. Cleanup DOM and event listeners
     */

  }, {
    key: "destroy",
    value: function destroy() {} // should be implemented by the component

    /**
     * Test whether the component is resized since the last time _isResized() was
     * called.
     * @return {Boolean} Returns true if the component is resized
     * @protected
     */

  }, {
    key: "_isResized",
    value: function _isResized() {
      var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;
      this.props._previousWidth = this.props.width;
      this.props._previousHeight = this.props.height;
      return resized;
    }
  }]);

  return Component;
}(); // `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat


_export({
  target: 'String',
  proto: true
}, {
  repeat: stringRepeat
});
/**
 * used in Core to convert the options into a volatile variable
 * 
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 * @returns {number}
 */


function convertHiddenOptions(moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return convertHiddenOptions(moment, body, [hiddenDates]);
  }

  body.hiddenDates = [];

  if (hiddenDates) {
    if (Array.isArray(hiddenDates) == true) {
      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat === undefined) {
          var dateItem = {};
          dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }

      body.hiddenDates.sort(function (a, b) {
        return a.start - b.start;
      }); // sort by start time
    }
  }
}
/**
 * create new entrees for the repeating hidden dates
 *
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 * @returns {null}
 */


function updateHiddenDates(moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return updateHiddenDates(moment, body, [hiddenDates]);
  }

  if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
    convertHiddenOptions(moment, body, hiddenDates);
    var start = moment(body.range.start);
    var end = moment(body.range.end);
    var totalRange = body.range.end - body.range.start;
    var pixelTime = totalRange / body.domProps.centerContainer.width;

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].repeat !== undefined) {
        var startDate = moment(hiddenDates[i].start);
        var endDate = moment(hiddenDates[i].end);

        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: ".concat(hiddenDates[i].start));
        }

        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: ".concat(hiddenDates[i].end));
        }

        var duration = endDate - startDate;

        if (duration >= 4 * pixelTime) {
          var offset = 0;
          var runUntil = end.clone();

          switch (hiddenDates[i].repeat) {
            case "daily":
              // case of time
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }

              startDate.dayOfYear(start.dayOfYear());
              startDate.year(start.year());
              startDate.subtract(7, 'days');
              endDate.dayOfYear(start.dayOfYear());
              endDate.year(start.year());
              endDate.subtract(7 - offset, 'days');
              runUntil.add(1, 'weeks');
              break;

            case "weekly":
              {
                var dayOffset = endDate.diff(startDate, 'days');
                var day = startDate.day(); // set the start date to the range.start

                startDate.date(start.date());
                startDate.month(start.month());
                startDate.year(start.year());
                endDate = startDate.clone(); // force

                startDate.day(day);
                endDate.day(day);
                endDate.add(dayOffset, 'days');
                startDate.subtract(1, 'weeks');
                endDate.subtract(1, 'weeks');
                runUntil.add(1, 'weeks');
                break;
              }

            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }

              startDate.month(start.month());
              startDate.year(start.year());
              startDate.subtract(1, 'months');
              endDate.month(start.month());
              endDate.year(start.year());
              endDate.subtract(1, 'months');
              endDate.add(offset, 'months');
              runUntil.add(1, 'months');
              break;

            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }

              startDate.year(start.year());
              startDate.subtract(1, 'years');
              endDate.year(start.year());
              endDate.subtract(1, 'years');
              endDate.add(offset, 'years');
              runUntil.add(1, 'years');
              break;

            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
              return;
          }

          while (startDate < runUntil) {
            body.hiddenDates.push({
              start: startDate.valueOf(),
              end: endDate.valueOf()
            });

            switch (hiddenDates[i].repeat) {
              case "daily":
                startDate.add(1, 'days');
                endDate.add(1, 'days');
                break;

              case "weekly":
                startDate.add(1, 'weeks');
                endDate.add(1, 'weeks');
                break;

              case "monthly":
                startDate.add(1, 'months');
                endDate.add(1, 'months');
                break;

              case "yearly":
                startDate.add(1, 'y');
                endDate.add(1, 'y');
                break;

              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
          }

          body.hiddenDates.push({
            start: startDate.valueOf(),
            end: endDate.valueOf()
          });
        }
      }
    } // remove duplicates, merge where possible


    removeDuplicates(body); // ensure the new positions are not on hidden dates

    var startHidden = getIsHidden(body.range.start, body.hiddenDates);
    var endHidden = getIsHidden(body.range.end, body.hiddenDates);
    var rangeStart = body.range.start;
    var rangeEnd = body.range.end;

    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }

    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }

    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
}
/**
 * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
 * Scales with N^2
 *
 * @param {Object} body
 */


function removeDuplicates(body) {
  var hiddenDates = body.hiddenDates;
  var safeDates = [];

  for (var i = 0; i < hiddenDates.length; i++) {
    for (var j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        // j inside i
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        } // j start inside i
        else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
            hiddenDates[i].end = hiddenDates[j].end;
            hiddenDates[j].remove = true;
          } // j end inside i
          else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
              hiddenDates[i].start = hiddenDates[j].start;
              hiddenDates[j].remove = true;
            }
      }
    }
  }

  for (i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }

  body.hiddenDates = safeDates;
  body.hiddenDates.sort(function (a, b) {
    return a.start - b.start;
  }); // sort by start time
}
/**
 * Prints dates to console
 * @param {array} dates
 */


function printDates(dates) {
  for (var i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
}
/**
 * Used in TimeStep to avoid the hidden times.
 * @param {function} moment
 * @param {TimeStep} timeStep
 * @param {Date} previousTime
 */


function stepOverHiddenDates(moment, timeStep, previousTime) {
  var stepInHidden = false;
  var currentValue = timeStep.current.valueOf();

  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
    var startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;

    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }

  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    var prevValue = moment(previousTime);
    var newValue = moment(endDate); //check if the next step should be major

    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }

    timeStep.current = newValue;
  }
} ///**
// * Used in TimeStep to avoid the hidden times.
// * @param timeStep
// * @param previousTime
// */
//checkFirstStep = function(timeStep) {
//  var stepInHidden = false;
//  var currentValue = timeStep.current.valueOf();
//  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
//    var startDate = timeStep.hiddenDates[i].start;
//    var endDate = timeStep.hiddenDates[i].end;
//    if (currentValue >= startDate && currentValue < endDate) {
//      stepInHidden = true;
//      break;
//    }
//  }
//
//  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
//    var newValue = moment(endDate);
//    timeStep.current = newValue.toDate();
//  }
//};

/**
 * replaces the Core toScreen methods
 *
 * @param {timeline.Core} Core
 * @param {Date} time
 * @param {number} width
 * @returns {number}
 */


function toScreen(Core, time, width) {
  var conversion;

  if (Core.body.hiddenDates.length == 0) {
    conversion = Core.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    var hidden = getIsHidden(time, Core.body.hiddenDates);

    if (hidden.hidden == true) {
      time = hidden.startDate;
    }

    var duration = getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);

    if (time < Core.range.start) {
      conversion = Core.range.conversion(width, duration);
      var hiddenBeforeStart = getHiddenDurationBeforeStart(Core.body.hiddenDates, time, conversion.offset);
      time = Core.options.moment(time).toDate().valueOf();
      time = time + hiddenBeforeStart;
      return -(conversion.offset - time.valueOf()) * conversion.scale;
    } else if (time > Core.range.end) {
      var rangeAfterEnd = {
        start: Core.range.start,
        end: time
      };
      time = correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, rangeAfterEnd, time);
      conversion = Core.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    } else {
      time = correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);
      conversion = Core.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    }
  }
}
/**
 * Replaces the core toTime methods
 *
 * @param {timeline.Core} Core
 * @param {number} x
 * @param {number} width
 * @returns {Date}
 */


function toTime(Core, x, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    var hiddenDuration = getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
    var partialDuration = totalDuration * x / width;
    var accumulatedHiddenDuration = getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);
    return new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
  }
}
/**
 * Support function
 *
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {number} start
 * @param {number} end
 * @returns {number}
 */


function getHiddenDurationBetween(hiddenDates, start, end) {
  var duration = 0;

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end; // if time after the cutout, and the

    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }

  return duration;
}
/**
 * Support function
 *
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {number} start
 * @param {number} end
 * @returns {number}
 */


function getHiddenDurationBeforeStart(hiddenDates, start, end) {
  var duration = 0;

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (startDate >= start && endDate <= end) {
      duration += endDate - startDate;
    }
  }

  return duration;
}
/**
 * Support function
 * @param {function} moment
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {{start: number, end: number}} range
 * @param {Date} time
 * @returns {number}
 */


function correctTimeForHidden(moment, hiddenDates, range, time) {
  time = moment(time).toDate().valueOf();
  time -= getHiddenDurationBefore(moment, hiddenDates, range, time);
  return time;
}
/**
 * Support function
 * @param {function} moment
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {{start: number, end: number}} range
 * @param {Date} time
 * @returns {number}
 */


function getHiddenDurationBefore(moment, hiddenDates, range, time) {
  var timeOffset = 0;
  time = moment(time).toDate().valueOf();

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end; // if time after the cutout, and the

    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }

  return timeOffset;
}
/**
 * sum the duration from start to finish, including the hidden duration,
 * until the required amount has been reached, return the accumulated hidden duration
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {{start: number, end: number}} range
 * @param {number} [requiredDuration=0]
 * @returns {number}
 */


function getAccumulatedHiddenDuration(hiddenDates, range, requiredDuration) {
  var hiddenDuration = 0;
  var duration = 0;
  var previousPoint = range.start; //printDates(hiddenDates)

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end; // if time after the cutout, and the

    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;

      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }

  return hiddenDuration;
}
/**
 * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @param {Date} time
 * @param {number} direction
 * @param {boolean} correctionEnabled
 * @returns {Date|number}
 */


function snapAwayFromHidden(hiddenDates, time, direction, correctionEnabled) {
  var isHidden = getIsHidden(time, hiddenDates);

  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
}
/**
 * Check if a time is hidden
 *
 * @param {Date} time
 * @param {Array.<{start: Window.start, end: *}>} hiddenDates
 * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
 */


function getIsHidden(time, hiddenDates) {
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (time >= startDate && time < endDate) {
      // if the start is entering a hidden zone
      return {
        hidden: true,
        startDate: startDate,
        endDate: endDate
      };
    }
  }

  return {
    hidden: false,
    startDate: startDate,
    endDate: endDate
  };
}

var DateUtil =
/*#__PURE__*/
Object.freeze({
  convertHiddenOptions: convertHiddenOptions,
  updateHiddenDates: updateHiddenDates,
  removeDuplicates: removeDuplicates,
  printDates: printDates,
  stepOverHiddenDates: stepOverHiddenDates,
  toScreen: toScreen,
  toTime: toTime,
  getHiddenDurationBetween: getHiddenDurationBetween,
  getHiddenDurationBeforeStart: getHiddenDurationBeforeStart,
  correctTimeForHidden: correctTimeForHidden,
  getHiddenDurationBefore: getHiddenDurationBefore,
  getAccumulatedHiddenDuration: getAccumulatedHiddenDuration,
  snapAwayFromHidden: snapAwayFromHidden,
  getIsHidden: getIsHidden
});
/**
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 */

var Range =
/*#__PURE__*/
function (_Component) {
  _inherits(Range, _Component);
  /**
  * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
  * @param {Object} [options]    See description at Range.setOptions
  * @constructor Range
  * @extends Component
  */


  function Range(body, options) {
    var _this;

    _classCallCheck(this, Range);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Range).call(this));
    var now = moment$3().hours(0).minutes(0).seconds(0).milliseconds(0);
    var start = now.clone().add(-3, 'days').valueOf();
    var end = now.clone().add(3, 'days').valueOf();
    _this.millisecondsPerPixelCache = undefined;

    if (options === undefined) {
      _this.start = start;
      _this.end = end;
    } else {
      _this.start = options.start || start;
      _this.end = options.end || end;
    }

    _this.rolling = false;
    _this.body = body;
    _this.deltaDifference = 0;
    _this.scaleOffset = 0;
    _this.startToFront = false;
    _this.endToFront = true; // default options

    _this.defaultOptions = {
      rtl: false,
      start: null,
      end: null,
      moment: moment$3,
      direction: 'horizontal',
      // 'horizontal' or 'vertical'
      moveable: true,
      zoomable: true,
      min: null,
      max: null,
      zoomMin: 10,
      // milliseconds
      zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000,
      // milliseconds
      rollingMode: {
        follow: false,
        offset: 0.5
      }
    };
    _this.options = util$2.extend({}, _this.defaultOptions);
    _this.props = {
      touch: {}
    };
    _this.animationTimer = null; // drag listeners for dragging

    _this.body.emitter.on('panstart', _this._onDragStart.bind(_assertThisInitialized(_this)));

    _this.body.emitter.on('panmove', _this._onDrag.bind(_assertThisInitialized(_this)));

    _this.body.emitter.on('panend', _this._onDragEnd.bind(_assertThisInitialized(_this))); // mouse wheel for zooming


    _this.body.emitter.on('mousewheel', _this._onMouseWheel.bind(_assertThisInitialized(_this))); // pinch to zoom


    _this.body.emitter.on('touch', _this._onTouch.bind(_assertThisInitialized(_this)));

    _this.body.emitter.on('pinch', _this._onPinch.bind(_assertThisInitialized(_this))); // on click of rolling mode button


    _this.body.dom.rollingModeBtn.addEventListener('click', _this.startRolling.bind(_assertThisInitialized(_this)));

    _this.setOptions(options);

    return _this;
  }
  /**
   * Set options for the range controller
   * @param {Object} options      Available options:
   *                              {number | Date | String} start  Start date for the range
   *                              {number | Date | String} end    End date for the range
   *                              {number} min    Minimum value for start
   *                              {number} max    Maximum value for end
   *                              {number} zoomMin    Set a minimum value for
   *                                                  (end - start).
   *                              {number} zoomMax    Set a maximum value for
   *                                                  (end - start).
   *                              {boolean} moveable Enable moving of the range
   *                                                 by dragging. True by default
   *                              {boolean} zoomable Enable zooming of the range
   *                                                 by pinching/scrolling. True by default
   */


  _createClass(Range, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        // copy the options that we know
        var fields = ['animation', 'direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey', 'zoomFriction', 'rtl', 'showCurrentTime', 'rollingMode', 'horizontalScroll'];
        util$2.selectiveExtend(fields, this.options, options);

        if (options.rollingMode && options.rollingMode.follow) {
          this.startRolling();
        }

        if ('start' in options || 'end' in options) {
          // apply a new range. both start and end are optional
          this.setRange(options.start, options.end);
        }
      }
    }
    /**
     * Start auto refreshing the current time bar
     */

  }, {
    key: "startRolling",
    value: function startRolling() {
      var me = this;
      /**
       *  Updates the current time.
       */

      function update() {
        me.stopRolling();
        me.rolling = true;
        var interval = me.end - me.start;
        var t = util$2.convert(new Date(), 'Date').valueOf();
        var rollingModeOffset = me.options.rollingMode && me.options.rollingMode.offset || 0.5;
        var start = t - interval * rollingModeOffset;
        var end = t + interval * (1 - rollingModeOffset);
        var options = {
          animation: false
        };
        me.setRange(start, end, options); // determine interval to refresh

        var scale = me.conversion(me.body.domProps.center.width).scale;
        interval = 1 / scale / 10;
        if (interval < 30) interval = 30;
        if (interval > 1000) interval = 1000;
        me.body.dom.rollingModeBtn.style.visibility = "hidden"; // start a renderTimer to adjust for the new time

        me.currentTimeTimer = setTimeout(update, interval);
      }

      update();
    }
    /**
     * Stop auto refreshing the current time bar
     */

  }, {
    key: "stopRolling",
    value: function stopRolling() {
      if (this.currentTimeTimer !== undefined) {
        clearTimeout(this.currentTimeTimer);
        this.rolling = false;
        this.body.dom.rollingModeBtn.style.visibility = "visible";
      }
    }
    /**
     * Set a new start and end range
     * @param {Date | number | string} start
     * @param {Date | number | string} end
     * @param {Object} options      Available options:
     *                              {boolean | {duration: number, easingFunction: string}} [animation=false]
     *                                    If true, the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     *                              {boolean} [byUser=false]
     *                              {Event}  event  Mouse event
     * @param {Function} callback     a callback function to be executed at the end of this function  
     * @param {Function} frameCallback    a callback function executed each frame of the range animation.
     *                                    The callback will be passed three parameters:
     *                                    {number} easeCoefficient    an easing coefficent
     *                                    {boolean} willDraw          If true the caller will redraw after the callback completes
     *                                    {boolean} done              If true then animation is ending after the current frame
     * @return {void}
     */

  }, {
    key: "setRange",
    value: function setRange(start, end, options, callback, frameCallback) {
      if (!options) {
        options = {};
      }

      if (options.byUser !== true) {
        options.byUser = false;
      }

      var me = this;
      var finalStart = start != undefined ? util$2.convert(start, 'Date').valueOf() : null;
      var finalEnd = end != undefined ? util$2.convert(end, 'Date').valueOf() : null;

      this._cancelAnimation();

      this.millisecondsPerPixelCache = undefined;

      if (options.animation) {
        // true or an Object
        var initStart = this.start;
        var initEnd = this.end;
        var duration = _typeof(options.animation) === 'object' && 'duration' in options.animation ? options.animation.duration : 500;
        var easingName = _typeof(options.animation) === 'object' && 'easingFunction' in options.animation ? options.animation.easingFunction : 'easeInOutQuad';
        var easingFunction = util$2.easingFunctions[easingName];

        if (!easingFunction) {
          throw new Error("Unknown easing function ".concat(JSON.stringify(easingName), ". Choose from: ").concat(Object.keys(util$2.easingFunctions).join(', ')));
        }

        var initTime = Date.now();
        var anyChanged = false;

        var next = function next() {
          if (!me.props.touch.dragging) {
            var now = Date.now();
            var time = now - initTime;
            var ease = easingFunction(time / duration);
            var done = time > duration;
            var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
            var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;
            changed = me._applyRange(s, e);
            updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
            anyChanged = anyChanged || changed;
            var params = {
              start: new Date(me.start),
              end: new Date(me.end),
              byUser: options.byUser,
              event: options.event
            };

            if (frameCallback) {
              frameCallback(ease, changed, done);
            }

            if (changed) {
              me.body.emitter.emit('rangechange', params);
            }

            if (done) {
              if (anyChanged) {
                me.body.emitter.emit('rangechanged', params);

                if (callback) {
                  return callback();
                }
              }
            } else {
              // animate with as high as possible frame rate, leave 20 ms in between
              // each to prevent the browser from blocking
              me.animationTimer = setTimeout(next, 20);
            }
          }
        };

        return next();
      } else {
        var changed = this._applyRange(finalStart, finalEnd);

        updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

        if (changed) {
          var params = {
            start: new Date(this.start),
            end: new Date(this.end),
            byUser: options.byUser,
            event: options.event
          };
          this.body.emitter.emit('rangechange', params);
          clearTimeout(me.timeoutID);
          me.timeoutID = setTimeout(function () {
            me.body.emitter.emit('rangechanged', params);
          }, 200);

          if (callback) {
            return callback();
          }
        }
      }
    }
    /**
     * Get the number of milliseconds per pixel.
     *
     * @returns {undefined|number}
     */

  }, {
    key: "getMillisecondsPerPixel",
    value: function getMillisecondsPerPixel() {
      if (this.millisecondsPerPixelCache === undefined) {
        this.millisecondsPerPixelCache = (this.end - this.start) / this.body.dom.center.clientWidth;
      }

      return this.millisecondsPerPixelCache;
    }
    /**
     * Stop an animation
     * @private
     */

  }, {
    key: "_cancelAnimation",
    value: function _cancelAnimation() {
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
        this.animationTimer = null;
      }
    }
    /**
     * Set a new start and end range. This method is the same as setRange, but
     * does not trigger a range change and range changed event, and it returns
     * true when the range is changed
     * @param {number} [start]
     * @param {number} [end]
     * @return {boolean} changed
     * @private
     */

  }, {
    key: "_applyRange",
    value: function _applyRange(start, end) {
      var newStart = start != null ? util$2.convert(start, 'Date').valueOf() : this.start;
      var newEnd = end != null ? util$2.convert(end, 'Date').valueOf() : this.end;
      var max = this.options.max != null ? util$2.convert(this.options.max, 'Date').valueOf() : null;
      var min = this.options.min != null ? util$2.convert(this.options.min, 'Date').valueOf() : null;
      var diff; // check for valid number

      if (isNaN(newStart) || newStart === null) {
        throw new Error("Invalid start \"".concat(start, "\""));
      }

      if (isNaN(newEnd) || newEnd === null) {
        throw new Error("Invalid end \"".concat(end, "\""));
      } // prevent end < start


      if (newEnd < newStart) {
        newEnd = newStart;
      } // prevent start < min


      if (min !== null) {
        if (newStart < min) {
          diff = min - newStart;
          newStart += diff;
          newEnd += diff; // prevent end > max

          if (max != null) {
            if (newEnd > max) {
              newEnd = max;
            }
          }
        }
      } // prevent end > max


      if (max !== null) {
        if (newEnd > max) {
          diff = newEnd - max;
          newStart -= diff;
          newEnd -= diff; // prevent start < min

          if (min != null) {
            if (newStart < min) {
              newStart = min;
            }
          }
        }
      } // prevent (end-start) < zoomMin


      if (this.options.zoomMin !== null) {
        var zoomMin = parseFloat(this.options.zoomMin);

        if (zoomMin < 0) {
          zoomMin = 0;
        }

        if (newEnd - newStart < zoomMin) {
          // compensate for a scale of 0.5 ms
          var compensation = 0.5;

          if (this.end - this.start === zoomMin && newStart >= this.start - compensation && newEnd <= this.end) {
            // ignore this action, we are already zoomed to the minimum
            newStart = this.start;
            newEnd = this.end;
          } else {
            // zoom to the minimum
            diff = zoomMin - (newEnd - newStart);
            newStart -= diff / 2;
            newEnd += diff / 2;
          }
        }
      } // prevent (end-start) > zoomMax


      if (this.options.zoomMax !== null) {
        var zoomMax = parseFloat(this.options.zoomMax);

        if (zoomMax < 0) {
          zoomMax = 0;
        }

        if (newEnd - newStart > zoomMax) {
          if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
            // ignore this action, we are already zoomed to the maximum
            newStart = this.start;
            newEnd = this.end;
          } else {
            // zoom to the maximum
            diff = newEnd - newStart - zoomMax;
            newStart += diff / 2;
            newEnd -= diff / 2;
          }
        }
      }

      var changed = this.start != newStart || this.end != newEnd; // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)

      if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
        this.body.emitter.emit('checkRangedItems');
      }

      this.start = newStart;
      this.end = newEnd;
      return changed;
    }
    /**
     * Retrieve the current range.
     * @return {Object} An object with start and end properties
     */

  }, {
    key: "getRange",
    value: function getRange() {
      return {
        start: this.start,
        end: this.end
      };
    }
    /**
     * Calculate the conversion offset and scale for current range, based on
     * the provided width
     * @param {number} width
     * @param {number} [totalHidden=0]
     * @returns {{offset: number, scale: number}} conversion
     */

  }, {
    key: "conversion",
    value: function conversion(width, totalHidden) {
      return Range.conversion(this.start, this.end, width, totalHidden);
    }
    /**
     * Static method to calculate the conversion offset and scale for a range,
     * based on the provided start, end, and width
     * @param {number} start
     * @param {number} end
     * @param {number} width
     * @param {number} [totalHidden=0]
     * @returns {{offset: number, scale: number}} conversion
     */

  }, {
    key: "_onDragStart",

    /**
     * Start dragging horizontally or vertically
     * @param {Event} event
     * @private
     */
    value: function _onDragStart(event) {
      this.deltaDifference = 0;
      this.previousDelta = 0; // only allow dragging when configured as movable

      if (!this.options.moveable) return; // only start dragging when the mouse is inside the current range

      if (!this._isInsideRange(event)) return; // refuse to drag when we where pinching to prevent the timeline make a jump
      // when releasing the fingers in opposite order from the touch screen

      if (!this.props.touch.allowDragging) return;
      this.stopRolling();
      this.props.touch.start = this.start;
      this.props.touch.end = this.end;
      this.props.touch.dragging = true;

      if (this.body.dom.root) {
        this.body.dom.root.style.cursor = 'move';
      }
    }
    /**
     * Perform dragging operation
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDrag",
    value: function _onDrag(event) {
      if (!event) return;
      if (!this.props.touch.dragging) return; // only allow dragging when configured as movable

      if (!this.options.moveable) return; // TODO: this may be redundant in hammerjs2
      // refuse to drag when we where pinching to prevent the timeline make a jump
      // when releasing the fingers in opposite order from the touch screen

      if (!this.props.touch.allowDragging) return;
      var direction = this.options.direction;
      validateDirection(direction);
      var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
      delta -= this.deltaDifference;
      var interval = this.props.touch.end - this.props.touch.start; // normalize dragging speed if cutout is in between.

      var duration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
      interval -= duration;
      var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;
      var diffRange;

      if (this.options.rtl) {
        diffRange = delta / width * interval;
      } else {
        diffRange = -delta / width * interval;
      }

      var newStart = this.props.touch.start + diffRange;
      var newEnd = this.props.touch.end + diffRange; // snapping times away from hidden zones

      var safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
      var safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);

      if (safeStart != newStart || safeEnd != newEnd) {
        this.deltaDifference += delta;
        this.props.touch.start = safeStart;
        this.props.touch.end = safeEnd;

        this._onDrag(event);

        return;
      }

      this.previousDelta = delta;

      this._applyRange(newStart, newEnd);

      var startDate = new Date(this.start);
      var endDate = new Date(this.end); // fire a rangechange event

      this.body.emitter.emit('rangechange', {
        start: startDate,
        end: endDate,
        byUser: true,
        event: event
      }); // fire a panmove event

      this.body.emitter.emit('panmove');
    }
    /**
     * Stop dragging operation
     * @param {event} event
     * @private
     */

  }, {
    key: "_onDragEnd",
    value: function _onDragEnd(event) {
      if (!this.props.touch.dragging) return; // only allow dragging when configured as movable

      if (!this.options.moveable) return; // TODO: this may be redundant in hammerjs2
      // refuse to drag when we where pinching to prevent the timeline make a jump
      // when releasing the fingers in opposite order from the touch screen

      if (!this.props.touch.allowDragging) return;
      this.props.touch.dragging = false;

      if (this.body.dom.root) {
        this.body.dom.root.style.cursor = 'auto';
      } // fire a rangechanged event


      this.body.emitter.emit('rangechanged', {
        start: new Date(this.start),
        end: new Date(this.end),
        byUser: true,
        event: event
      });
    }
    /**
     * Event handler for mouse wheel event, used to zoom
     * Code from http://adomas.org/javascript-mouse-wheel/
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onMouseWheel",
    value: function _onMouseWheel(event) {
      // retrieve delta
      var delta = 0;

      if (event.wheelDelta) {
        /* IE/Opera. */
        delta = event.wheelDelta / 120;
      } else if (event.detail) {
        /* Mozilla case. */
        // In Mozilla, sign of delta is different than in IE.
        // Also, delta is multiple of 3.
        delta = -event.detail / 3;
      } else if (event.deltaY) {
        delta = -event.deltaY / 3;
      } // don't allow zoom when the according key is pressed and the zoomKey option or not zoomable but movable


      if (this.options.zoomKey && !event[this.options.zoomKey] && this.options.zoomable || !this.options.zoomable && this.options.moveable) {
        return;
      } // only allow zooming when configured as zoomable and moveable


      if (!(this.options.zoomable && this.options.moveable)) return; // only zoom when the mouse is inside the current range

      if (!this._isInsideRange(event)) return; // If delta is nonzero, handle it.
      // Basically, delta is now positive if wheel was scrolled up,
      // and negative, if wheel was scrolled down.

      if (delta) {
        // perform the zoom action. Delta is normally 1 or -1
        // adjust a negative delta such that zooming in with delta 0.1
        // equals zooming out with a delta -0.1
        var zoomFriction = this.options.zoomFriction || 5;
        var scale;

        if (delta < 0) {
          scale = 1 - delta / zoomFriction;
        } else {
          scale = 1 / (1 + delta / zoomFriction);
        } // calculate center, the date to zoom around


        var pointerDate;

        if (this.rolling) {
          var rollingModeOffset = this.options.rollingMode && this.options.rollingMode.offset || 0.5;
          pointerDate = this.start + (this.end - this.start) * rollingModeOffset;
        } else {
          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          }, this.body.dom.center);
          pointerDate = this._pointerToDate(pointer);
        }

        this.zoom(scale, pointerDate, delta, event); // Prevent default actions caused by mouse wheel
        // (else the page and timeline both scroll)

        event.preventDefault();
      }
    }
    /**
     * Start of a touch gesture
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onTouch",
    value: function _onTouch(event) {
      // eslint-disable-line no-unused-vars
      this.props.touch.start = this.start;
      this.props.touch.end = this.end;
      this.props.touch.allowDragging = true;
      this.props.touch.center = null;
      this.scaleOffset = 0;
      this.deltaDifference = 0; // Disable the browser default handling of this event.

      util$2.preventDefault(event);
    }
    /**
     * Handle pinch event
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onPinch",
    value: function _onPinch(event) {
      // only allow zooming when configured as zoomable and moveable
      if (!(this.options.zoomable && this.options.moveable)) return; // Disable the browser default handling of this event.

      util$2.preventDefault(event);
      this.props.touch.allowDragging = false;

      if (!this.props.touch.center) {
        this.props.touch.center = this.getPointer(event.center, this.body.dom.center);
      }

      this.stopRolling();
      var scale = 1 / (event.scale + this.scaleOffset);

      var centerDate = this._pointerToDate(this.props.touch.center);

      var hiddenDuration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
      var hiddenDurationBefore = getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
      var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore; // calculate new start and end

      var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
      var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale; // snapping times away from hidden zones

      this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times

      this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

      var safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
      var safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);

      if (safeStart != newStart || safeEnd != newEnd) {
        this.props.touch.start = safeStart;
        this.props.touch.end = safeEnd;
        this.scaleOffset = 1 - event.scale;
        newStart = safeStart;
        newEnd = safeEnd;
      }

      var options = {
        animation: false,
        byUser: true,
        event: event
      };
      this.setRange(newStart, newEnd, options);
      this.startToFront = false; // revert to default

      this.endToFront = true; // revert to default
    }
    /**
     * Test whether the mouse from a mouse event is inside the visible window,
     * between the current start and end date
     * @param {Object} event
     * @return {boolean} Returns true when inside the visible window
     * @private
     */

  }, {
    key: "_isInsideRange",
    value: function _isInsideRange(event) {
      // calculate the time where the mouse is, check whether inside
      // and no scroll action should happen.
      var clientX = event.center ? event.center.x : event.clientX;
      var centerContainerRect = this.body.dom.centerContainer.getBoundingClientRect();
      var x = this.options.rtl ? clientX - centerContainerRect.left : centerContainerRect.right - clientX;
      var time = this.body.util.toTime(x);
      return time >= this.start && time <= this.end;
    }
    /**
     * Helper function to calculate the center date for zooming
     * @param {{x: number, y: number}} pointer
     * @return {number} date
     * @private
     */

  }, {
    key: "_pointerToDate",
    value: function _pointerToDate(pointer) {
      var conversion;
      var direction = this.options.direction;
      validateDirection(direction);

      if (direction == 'horizontal') {
        return this.body.util.toTime(pointer.x).valueOf();
      } else {
        var height = this.body.domProps.center.height;
        conversion = this.conversion(height);
        return pointer.y / conversion.scale + conversion.offset;
      }
    }
    /**
     * Get the pointer location relative to the location of the dom element
     * @param {{x: number, y: number}} touch
     * @param {Element} element   HTML DOM element
     * @return {{x: number, y: number}} pointer
     * @private
     */

  }, {
    key: "getPointer",
    value: function getPointer(touch, element) {
      var elementRect = element.getBoundingClientRect();

      if (this.options.rtl) {
        return {
          x: elementRect.right - touch.x,
          y: touch.y - elementRect.top
        };
      } else {
        return {
          x: touch.x - elementRect.left,
          y: touch.y - elementRect.top
        };
      }
    }
    /**
     * Zoom the range the given scale in or out. Start and end date will
     * be adjusted, and the timeline will be redrawn. You can optionally give a
     * date around which to zoom.
     * For example, try scale = 0.9 or 1.1
     * @param {number} scale      Scaling factor. Values above 1 will zoom out,
     *                            values below 1 will zoom in.
     * @param {number} [center]   Value representing a date around which will
     *                            be zoomed.
     * @param {number} delta
     * @param {Event} event
     */

  }, {
    key: "zoom",
    value: function zoom(scale, center, delta, event) {
      // if centerDate is not provided, take it half between start Date and end Date
      if (center == null) {
        center = (this.start + this.end) / 2;
      }

      var hiddenDuration = getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
      var hiddenDurationBefore = getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
      var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore; // calculate new start and end

      var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
      var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale; // snapping times away from hidden zones

      this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times

      this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times

      var safeStart = snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
      var safeEnd = snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);

      if (safeStart != newStart || safeEnd != newEnd) {
        newStart = safeStart;
        newEnd = safeEnd;
      }

      var options = {
        animation: false,
        byUser: true,
        event: event
      };
      this.setRange(newStart, newEnd, options);
      this.startToFront = false; // revert to default

      this.endToFront = true; // revert to default
    }
    /**
     * Move the range with a given delta to the left or right. Start and end
     * value will be adjusted. For example, try delta = 0.1 or -0.1
     * @param {number}  delta     Moving amount. Positive value will move right,
     *                            negative value will move left
     */

  }, {
    key: "move",
    value: function move(delta) {
      // zoom start Date and end Date relative to the centerDate
      var diff = this.end - this.start; // apply new values

      var newStart = this.start + diff * delta;
      var newEnd = this.end + diff * delta; // TODO: reckon with min and max range

      this.start = newStart;
      this.end = newEnd;
    }
    /**
     * Move the range to a new center point
     * @param {number} moveTo      New center point of the range
     */

  }, {
    key: "moveTo",
    value: function moveTo(_moveTo) {
      var center = (this.start + this.end) / 2;
      var diff = center - _moveTo; // calculate new start and end

      var newStart = this.start - diff;
      var newEnd = this.end - diff;
      var options = {
        animation: false,
        byUser: true,
        event: null
      };
      this.setRange(newStart, newEnd, options);
    }
  }], [{
    key: "conversion",
    value: function conversion(start, end, width, totalHidden) {
      if (totalHidden === undefined) {
        totalHidden = 0;
      }

      if (width != 0 && end - start != 0) {
        return {
          offset: start,
          scale: width / (end - start - totalHidden)
        };
      } else {
        return {
          offset: 0,
          scale: 1
        };
      }
    }
  }]);

  return Range;
}(Component);

function validateDirection(direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError("Unknown direction \"".concat(direction, "\". Choose \"horizontal\" or \"vertical\"."));
  }
}
/**
 * Expose `Emitter`.
 */


var emitterComponent = Emitter;
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks[event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

var propagating = createCommonjsModule(function (module, exports) {
  (function (factory) {
    {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    }
  })(function () {
    var _firstTarget = null; // singleton, will contain the target element where the touch event started

    /**
     * Extend an Hammer.js instance with event propagation.
     *
     * Features:
     * - Events emitted by hammer will propagate in order from child to parent
     *   elements.
     * - Events are extended with a function `event.stopPropagation()` to stop
     *   propagation to parent elements.
     * - An option `preventDefault` to stop all default browser behavior.
     *
     * Usage:
     *   var hammer = propagatingHammer(new Hammer(element));
     *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
     *
     * @param {Hammer.Manager} hammer   An hammer instance.
     * @param {Object} [options]        Available options:
     *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
     *                                    Enforce preventing the default browser behavior.
     *                                    Cannot be set to `false`.
     * @return {Hammer.Manager} Returns the same hammer instance with extended
     *                          functionality
     */

    return function propagating(hammer, options) {
      var _options = options || {
        preventDefault: false
      };

      if (hammer.Manager) {
        // This looks like the Hammer constructor.
        // Overload the constructors with our own.
        var Hammer = hammer;

        var PropagatingHammer = function PropagatingHammer(element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer(element, o), o);
        };

        Hammer.assign(PropagatingHammer, Hammer);

        PropagatingHammer.Manager = function (element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer.Manager(element, o), o);
        };

        return PropagatingHammer;
      } // create a wrapper object which will override the functions
      // `on`, `off`, `destroy`, and `emit` of the hammer instance


      var wrapper = Object.create(hammer); // attach to DOM element

      var element = hammer.element;
      if (!element.hammer) element.hammer = [];
      element.hammer.push(wrapper); // register an event to catch the start of a gesture and store the
      // target in a singleton

      hammer.on('hammer.input', function (event) {
        if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {
          event.preventDefault();
        }

        if (event.isFirst) {
          _firstTarget = event.target;
        }
      });
      /** @type {Object.<String, Array.<function>>} */

      wrapper._handlers = {};
      /**
       * Register a handler for one or multiple events
       * @param {String} events    A space separated string with events
       * @param {function} handler A callback function, called as handler(event)
       * @returns {Hammer.Manager} Returns the hammer instance
       */

      wrapper.on = function (events, handler) {
        // register the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];

          if (!_handlers) {
            wrapper._handlers[event] = _handlers = []; // register the static, propagated handler

            hammer.on(event, propagatedHandler);
          }

          _handlers.push(handler);
        });
        return wrapper;
      };
      /**
       * Unregister a handler for one or multiple events
       * @param {String} events      A space separated string with events
       * @param {function} [handler] Optional. The registered handler. If not
       *                             provided, all handlers for given events
       *                             are removed.
       * @returns {Hammer.Manager}   Returns the hammer instance
       */


      wrapper.off = function (events, handler) {
        // unregister the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];

          if (_handlers) {
            _handlers = handler ? _handlers.filter(function (h) {
              return h !== handler;
            }) : [];

            if (_handlers.length > 0) {
              wrapper._handlers[event] = _handlers;
            } else {
              // remove static, propagated handler
              hammer.off(event, propagatedHandler);
              delete wrapper._handlers[event];
            }
          }
        });
        return wrapper;
      };
      /**
       * Emit to the event listeners
       * @param {string} eventType
       * @param {Event} event
       */


      wrapper.emit = function (eventType, event) {
        _firstTarget = event.target;
        hammer.emit(eventType, event);
      };

      wrapper.destroy = function () {
        // Detach from DOM element
        var hammers = hammer.element.hammer;
        var idx = hammers.indexOf(wrapper);
        if (idx !== -1) hammers.splice(idx, 1);
        if (!hammers.length) delete hammer.element.hammer; // clear all handlers

        wrapper._handlers = {}; // call original hammer destroy

        hammer.destroy();
      }; // split a string with space separated words


      function split(events) {
        return events.match(/[^ ]+/g);
      }
      /**
       * A static event handler, applying event propagation.
       * @param {Object} event
       */


      function propagatedHandler(event) {
        // let only a single hammer instance handle this event
        if (event.type !== 'hammer.input') {
          // it is possible that the same srcEvent is used with multiple hammer events,
          // we keep track on which events are handled in an object _handled
          if (!event.srcEvent._handled) {
            event.srcEvent._handled = {};
          }

          if (event.srcEvent._handled[event.type]) {
            return;
          } else {
            event.srcEvent._handled[event.type] = true;
          }
        } // attach a stopPropagation function to the event


        var stopped = false;

        event.stopPropagation = function () {
          stopped = true;
        }; //wrap the srcEvent's stopPropagation to also stop hammer propagation:


        var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);

        if (typeof srcStop == "function") {
          event.srcEvent.stopPropagation = function () {
            srcStop();
            event.stopPropagation();
          };
        } // attach firstTarget property to the event


        event.firstTarget = _firstTarget; // propagate over all elements (until stopped)

        var elem = _firstTarget;

        while (elem && !stopped) {
          var elemHammer = elem.hammer;

          if (elemHammer) {
            var _handlers;

            for (var k = 0; k < elemHammer.length; k++) {
              _handlers = elemHammer[k]._handlers[event.type];
              if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
                _handlers[i](event);
              }
            }
          }

          elem = elem.parentNode;
        }
      }

      return wrapper;
    };
  });
});
/*! Hammer.JS - v2.0.16 - 2019-11-11
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */


var assign;

if (typeof Object.assign !== 'function') {
  assign = function assign(target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
} else {
  assign = Object.assign;
}

var assign$1 = assign;
var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement('div');
var TYPE_FUNCTION = 'function';
var round = Math.round,
    abs$1 = Math.abs;
var now = Date.now;
/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */

function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;

  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;

    if (prop in obj) {
      return prop;
    }

    i++;
  }

  return undefined;
}
/* eslint-disable no-new-func, no-nested-ternary */


var win;

if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {};
} else {
  win = window;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }

  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
    // If css.supports is not supported but there is native touch-action assume it supports
    // all values. This is the case for IE 10 and 11.
    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
  });
  return touchMap;
}

var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = 'ontouchstart' in win;
var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */

function each(obj, iterator, context) {
  var i;

  if (!obj) {
    return;
  }

  if (obj.forEach) {
    obj.forEach(iterator, context);
  } else if (obj.length !== undefined) {
    i = 0;

    while (i < obj.length) {
      iterator.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
  }
}
/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */


function boolOrFn(val, args) {
  if (_typeof(val) === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || undefined : undefined, args);
  }

  return val;
}
/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */


function inStr(str, find) {
  return str.indexOf(find) > -1;
}
/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */


function cleanTouchActions(actions) {
  // none
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }

  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning

  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  } // pan-x OR pan-y


  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  } // manipulation


  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }

  return TOUCH_ACTION_AUTO;
}
/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */


var TouchAction =
/*#__PURE__*/
function () {
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  var _proto = TouchAction.prototype;

  _proto.set = function set(value) {
    // find out the touch-action by the event handlers
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }

    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }

    this.actions = value.toLowerCase().trim();
  };
  /**
   * @private
   * just re-set the touchAction value
   */


  _proto.update = function update() {
    this.set(this.manager.options.touchAction);
  };
  /**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */


  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function (recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(' '));
  };
  /**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */


  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection; // if the touch action did prevented once this session

    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }

    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

    if (hasNone) {
      // do not prevent defaults if this is a tap gesture
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;

      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }

    if (hasPanX && hasPanY) {
      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
      return;
    }

    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  /**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */


  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };

  return TouchAction;
}();
/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */


function hasParent$1(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */


function getCenter(pointers) {
  var pointersLength = pointers.length; // no need to loop when only one touch

  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }

  var x = 0;
  var y = 0;
  var i = 0;

  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }

  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */


function simpleCloneInputData(input) {
  // make a simple copy of the pointers because we will get a reference if we don't
  // we only need clientXY for the calculations
  var pointers = [];
  var i = 0;

  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }

  return {
    timeStamp: now(),
    pointers: pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */


function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */


function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */


function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }

  if (abs$1(x) >= abs$1(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }

  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

function computeDeltaXY(session, input) {
  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
  // jscs throwing error on defalut destructured values and without defaults tests fail

  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};

  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }

  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */


function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */


function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */


function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */


function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;

  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    // use latest velocity info if it doesn't overtake a minimum period
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }

  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */


function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length; // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  } // to compute scale and rotation we need to store the multiple touches


  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  var firstInput = session.firstInput,
      firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input); // find the correct target

  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;

  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = target;
  }

  if (hasParent$1(srcEventTarget, target)) {
    target = srcEventTarget;
  }

  input.target = target;
}
/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */


function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;

  if (isFirst) {
    manager.session = {};
  } // source event is the normalized value of the domEvents
  // like 'touchstart, mouseup, pointerdown'


  input.eventType = eventType; // compute scale, rotation etc

  computeInputData(manager, input); // emit secret event

  manager.emit('hammer.input', input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */


function splitStr(str) {
  return str.trim().split(/\s+/g);
}
/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function addEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.addEventListener(type, handler, false);
  });
}
/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function removeEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.removeEventListener(type, handler, false);
  });
}
/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */


function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */


var Input =
/*#__PURE__*/
function () {
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }
  /**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */


  var _proto = Input.prototype;

  _proto.handler = function handler() {};
  /**
   * @private
   * bind the events
   */


  _proto.init = function init() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  /**
   * @private
   * unbind the events
   */


  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };

  return Input;
}();
/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */


function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;

    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        // do not use === here, test fails
        return i;
      }

      i++;
    }

    return -1;
  }
}

var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
}; // in IE10 the pointer types is defined as an enum

var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

};
var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = 'MSPointerDown';
  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}
/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */


var PointerEventInput =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(PointerEventInput, _Input);

  function PointerEventInput() {
    var _this;

    var proto = PointerEventInput.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = PointerEventInput.prototype;

  _proto.handler = function handler(ev) {
    var store = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    } // it not found, so the pointer hasn't been down (so it's probably a hover)


    if (storeIndex < 0) {
      return;
    } // update the event in the store


    store[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store,
      changedPointers: [ev],
      pointerType: pointerType,
      srcEvent: ev
    });

    if (removePointer) {
      // remove from the store
      store.splice(storeIndex, 1);
    }
  };

  return PointerEventInput;
}(Input);
/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */


function toArray$1(obj) {
  return Array.prototype.slice.call(obj, 0);
}
/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */


function uniqueArray(src, key, sort) {
  var results = [];
  var values = [];
  var i = 0;

  while (i < src.length) {
    var val = key ? src[i][key] : src[i];

    if (inArray(values, val) < 0) {
      results.push(src[i]);
    }

    values[i] = val;
    i++;
  }

  if (sort) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function (a, b) {
        return a[key] > b[key];
      });
    }
  }

  return results;
}

var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

var TouchInput =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(TouchInput, _Input);

  function TouchInput() {
    var _this;

    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

    return _this;
  }

  var _proto = TouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);

    if (!touches) {
      return;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return TouchInput;
}(Input);

function getTouches(ev, type) {
  var allTouches = toArray$1(ev.touches);
  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  var i;
  var targetTouches;
  var changedTouches = toArray$1(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target; // get target touches from touches

  targetTouches = allTouches.filter(function (touch) {
    return hasParent$1(touch.target, target);
  }); // collect touches

  if (type === INPUT_START) {
    i = 0;

    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  } // filter changed touches to only contain touches that exist in the collected target ids


  i = 0;

  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    } // cleanup removed touches


    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }

    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}

var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */

var MouseInput =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(MouseInput, _Input);

  function MouseInput() {
    var _this;

    var proto = MouseInput.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false; // mousedown state

    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = MouseInput.prototype;

  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    } // mouse must be down


    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };

  return MouseInput;
}(Input);
/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */


var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers,
      touch = _eventData$changedPoi[0];

  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);

    var removeLastTouch = function removeLastTouch() {
      var i = lts.indexOf(lastTouch);

      if (i > -1) {
        lts.splice(i, 1);
      }
    };

    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}

function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}

function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;

  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);

    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }

  return false;
}

var TouchMouseInput =
/*#__PURE__*/
function () {
  var TouchMouseInput =
  /*#__PURE__*/
  function (_Input) {
    _inheritsLoose(TouchMouseInput, _Input);

    function TouchMouseInput(_manager, callback) {
      var _this;

      _this = _Input.call(this, _manager, callback) || this;

      _this.handler = function (manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


        if (isTouch) {
          recordTouches.call(_assertThisInitialized$2(_assertThisInitialized$2(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$2(_assertThisInitialized$2(_this)), inputData)) {
          return;
        }

        _this.callback(manager, inputEvent, inputData);
      };

      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    /**
     * @private
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */


    var _proto = TouchMouseInput.prototype;
    /**
     * @private
     * remove the event listeners
     */

    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };

    return TouchMouseInput;
  }(Input);

  return TouchMouseInput;
}();
/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */


function createInputInstance(manager) {
  var Type; // let inputClass = manager.options.inputClass;

  var inputClass = manager.options.inputClass;

  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }

  return new Type(manager, inputHandler);
}
/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */


function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }

  return false;
}

var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */

var _uniqueId = 1;

function uniqueId() {
  return _uniqueId++;
}
/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */


function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;

  if (manager) {
    return manager.get(otherRecognizer);
  }

  return otherRecognizer;
}
/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */


function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return 'cancel';
  } else if (state & STATE_ENDED) {
    return 'end';
  } else if (state & STATE_CHANGED) {
    return 'move';
  } else if (state & STATE_BEGAN) {
    return 'start';
  }

  return '';
}
/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */

/**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */


var Recognizer =
/*#__PURE__*/
function () {
  function Recognizer(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */


  var _proto = Recognizer.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

    this.manager && this.manager.touchAction.update();
    return this;
  };
  /**
   * @private
   * recognize simultaneous with an other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
      return this;
    }

    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }

    return this;
  };
  /**
   * @private
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  /**
   * @private
   * recognizer can only run when an other is failing
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
      return this;
    }

    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }

    return this;
  };
  /**
   * @private
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index = inArray(this.requireFail, otherRecognizer);

    if (index > -1) {
      this.requireFail.splice(index, 1);
    }

    return this;
  };
  /**
   * @private
   * has require failures boolean
   * @returns {boolean}
   */


  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  /**
   * @private
   * if the recognizer can recognize simultaneous with an other recognizer
   * @param {Recognizer} otherRecognizer
   * @returns {Boolean}
   */


  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  /**
   * @private
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   * @param {Object} input
   */


  _proto.emit = function emit(input) {
    var self = this;
    var state = this.state;

    function emit(event) {
      self.manager.emit(event, input);
    } // 'panstart' and 'panmove'


    if (state < STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }

    emit(self.options.event); // simple 'eventName' events

    if (input.additionalEvent) {
      // additional event(panleft, panright, pinchin, pinchout...)
      emit(input.additionalEvent);
    } // panend and pancancel


    if (state >= STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }
  };
  /**
   * @private
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   * @param {Object} input
   */


  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    } // it's failing anyway


    this.state = STATE_FAILED;
  };
  /**
   * @private
   * can we emit?
   * @returns {boolean}
   */


  _proto.canEmit = function canEmit() {
    var i = 0;

    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }

      i++;
    }

    return true;
  };
  /**
   * @private
   * update the recognizer
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    // make a new copy of the inputData
    // so we can change the inputData without messing up the other recognizers
    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    } // reset when we've reached the end


    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }

    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
    // so trigger an event

    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  /**
   * @private
   * return the state of the recognizer
   * the actual recognizing happens in this method
   * @virtual
   * @param {Object} inputData
   * @returns {constant} STATE
   */

  /* jshint ignore:start */


  _proto.process = function process(inputData) {};
  /* jshint ignore:end */

  /**
   * @private
   * return the preferred touch-action
   * @virtual
   * @returns {Array}
   */


  _proto.getTouchAction = function getTouchAction() {};
  /**
   * @private
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   * @virtual
   */


  _proto.reset = function reset() {};

  return Recognizer;
}();

var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,

  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,

  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,

  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,

  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,

  /**
   * @private
   * Default recognizer setup when calling `Hammer()`
   * When creating a new Manager these will be skipped.
   * @type {Array}
   */
  preset: [],

  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",

    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",

    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",

    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",

    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",

    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
var STOP = 1;
var FORCED_STOP = 2;
/**
 * @private
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */

function toggleCssProps(manager, add) {
  var element = manager.element;

  if (!element.style) {
    return;
  }

  var prop;
  each(manager.options.cssProps, function (value, name) {
    prop = prefixed(element.style, name);

    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });

  if (!add) {
    manager.oldCssProps = {};
  }
}
/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */


function triggerDomEvent(event, data) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}
/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Manager =
/*#__PURE__*/
function () {
  function Manager(element, options) {
    var _this = this;

    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = _this.add(new item[0](item[1]));

      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */


  var _proto = Manager.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // Options that need a little more setup

    if (options.touchAction) {
      this.touchAction.update();
    }

    if (options.inputTarget) {
      // Clean up existing event listeners and reinitialize
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }

    return this;
  };
  /**
   * @private
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   * @param {Boolean} [force]
   */


  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  /**
   * @private
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    var session = this.session;

    if (session.stopped) {
      return;
    } // run the touch-action polyfill


    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
    // if no recognizer is detecting a thing, it is set to `null`

    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
    // or when we're in a new session

    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }

    var i = 0;

    while (i < recognizers.length) {
      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
      // 1.   allow if the session is NOT forced stopped (see the .stop() method)
      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
      //      that is being recognized.
      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
      //      this can be setup with the `recognizeWith()` method on the recognizer.

      if (session.stopped !== FORCED_STOP && ( // 1
      !curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        // 3
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
      // current active recognizer. but only if we don't already have an active recognizer


      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }

      i++;
    }
  };
  /**
   * @private
   * get a recognizer by its event name.
   * @param {Recognizer|String} recognizer
   * @returns {Recognizer|Null}
   */


  _proto.get = function get(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }

    var recognizers = this.recognizers;

    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }

    return null;
  };
  /**
   * @private add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   * @param {Recognizer} recognizer
   * @returns {Recognizer|Manager}
   */


  _proto.add = function add(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    } // remove existing


    var existing = this.get(recognizer.options.event);

    if (existing) {
      this.remove(existing);
    }

    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  /**
   * @private
   * remove a recognizer by name or instance
   * @param {Recognizer|String} recognizer
   * @returns {Manager}
   */


  _proto.remove = function remove(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }

    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

    if (recognizer) {
      var recognizers = this.recognizers;
      var index = inArray(recognizers, targetRecognizer);

      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }

    return this;
  };
  /**
   * @private
   * bind event
   * @param {String} events
   * @param {Function} handler
   * @returns {EventEmitter} this
   */


  _proto.on = function on(events, handler) {
    if (events === undefined || handler === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    });
    return this;
  };
  /**
   * @private unbind event, leave emit blank to remove all handlers
   * @param {String} events
   * @param {Function} [handler]
   * @returns {EventEmitter} this
   */


  _proto.off = function off(events, handler) {
    if (events === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      if (!handler) {
        delete handlers[event];
      } else {
        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
      }
    });
    return this;
  };
  /**
   * @private emit event to the listeners
   * @param {String} event
   * @param {Object} data
   */


  _proto.emit = function emit(event, data) {
    // we also want to trigger dom events
    if (this.options.domEvents) {
      triggerDomEvent(event, data);
    } // no handlers, so skip it all


    var handlers = this.handlers[event] && this.handlers[event].slice();

    if (!handlers || !handlers.length) {
      return;
    }

    data.type = event;

    data.preventDefault = function () {
      data.srcEvent.preventDefault();
    };

    var i = 0;

    while (i < handlers.length) {
      handlers[i](data);
      i++;
    }
  };
  /**
   * @private
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */


  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };

  return Manager;
}();

var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */

var SingleTouchInput =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(SingleTouchInput, _Input);

  function SingleTouchInput() {
    var _this;

    var proto = SingleTouchInput.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }

  var _proto = SingleTouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

    if (type === INPUT_START) {
      this.started = true;
    }

    if (!this.started) {
      return;
    }

    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return SingleTouchInput;
}(Input);

function normalizeSingleTouches(ev, type) {
  var all = toArray$1(ev.touches);
  var changed = toArray$1(ev.changedTouches);

  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), 'identifier', true);
  }

  return [all, changed];
}
/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */


var AttrRecognizer =
/*#__PURE__*/
function (_Recognizer) {
  _inheritsLoose(AttrRecognizer, _Recognizer);

  function AttrRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  /**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */


  var _proto = AttrRecognizer.prototype;

  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  /**
   * @private
   * Process the input and return the state for the recognizer
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {*} State
   */


  _proto.process = function process(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }

      return state | STATE_CHANGED;
    }

    return STATE_FAILED;
  };

  return AttrRecognizer;
}(Recognizer);
/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */


var TapRecognizer =
/*#__PURE__*/
function (_Recognizer) {
  _inheritsLoose(TapRecognizer, _Recognizer);

  function TapRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this; // previous time and center,
    // used for tap counting

    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }

  var _proto = TapRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();

    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    } // we only allow little movement
    // and we've reached an end event, so a tap is possible


    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }

      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;

      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }

      this._input = input; // if tap count matches we have recognized it,
      // else it has began recognizing...

      var tapCount = this.count % options.taps;

      if (tapCount === 0) {
        // no failing requirements, immediately trigger the tap event
        // or wait as long as the multitap interval to trigger
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function () {
            _this2.state = STATE_RECOGNIZED;

            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }

    return STATE_FAILED;
  };

  _proto.failTimeout = function failTimeout() {
    var _this3 = this;

    this._timer = setTimeout(function () {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };

  return TapRecognizer;
}(Recognizer);
/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */


function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return 'down';
  } else if (direction === DIRECTION_UP) {
    return 'up';
  } else if (direction === DIRECTION_LEFT) {
    return 'left';
  } else if (direction === DIRECTION_RIGHT) {
    return 'right';
  }

  return '';
}
/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var PanRecognizer =
/*#__PURE__*/
function (_AttrRecognizer) {
  _inheritsLoose(PanRecognizer, _AttrRecognizer);

  function PanRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _AttrRecognizer.call(this, _extends({
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }

  var _proto = PanRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];

    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }

    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }

    return actions;
  };

  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x = input.deltaX;
    var y = input.deltaY; // lock to axis?

    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }

    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };

  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };

  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);

    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PanRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var SwipeRecognizer =
/*#__PURE__*/
function (_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

  function SwipeRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }

  var _proto = SwipeRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };

  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;

    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }

    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };

  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);

    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }

    this.manager.emit(this.options.event, input);
  };

  return SwipeRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */


var PinchRecognizer =
/*#__PURE__*/
function (_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer, _AttrRecognizer);

  function PinchRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'pinch',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };

  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? 'in' : 'out';
      input.additionalEvent = this.options.event + inOut;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PinchRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */


var RotateRecognizer =
/*#__PURE__*/
function (_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer, _AttrRecognizer);

  function RotateRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'rotate',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = RotateRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };

  return RotateRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */


var PressRecognizer =
/*#__PURE__*/
function (_Recognizer) {
  _inheritsLoose(PressRecognizer, _Recognizer);

  function PressRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }

  var _proto = PressRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input; // we only allow little movement
    // and we've reached an end event, so a tap is possible

    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function () {
        _this2.state = STATE_RECOGNIZED;

        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }

    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }

    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now();
      this.manager.emit(this.options.event, this._input);
    }
  };

  return PressRecognizer;
}(Recognizer);
/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */


function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function () {
    var e = new Error('get-stack-trace');
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
    var log = window.console && (window.console.warn || window.console.log);

    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }

    return method.apply(this, arguments);
  };
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */


var extend$1 = deprecate(function (dest, src, merge) {
  var keys = Object.keys(src);
  var i = 0;

  while (i < keys.length) {
    if (!merge || merge && dest[keys[i]] === undefined) {
      dest[keys[i]] = src[keys[i]];
    }

    i++;
  }

  return dest;
}, 'extend', 'Use `assign`.');
/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */

var merge = deprecate(function (dest, src) {
  return extend$1(dest, src, true);
}, 'merge', 'Use `assign`.');
/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */

function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;

  if (properties) {
    assign$1(childP, properties);
  }
}
/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */


function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Hammer =
/*#__PURE__*/
function () {
  var Hammer =
  /**
    * @private
    * @const {string}
    */
  function Hammer(element, options) {
    if (options === void 0) {
      options = {};
    }

    return new Manager(element, _extends({
      recognizers: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
      [RotateRecognizer, {
        enable: false
      }], [PinchRecognizer, {
        enable: false
      }, ['rotate']], [SwipeRecognizer, {
        direction: DIRECTION_HORIZONTAL
      }], [PanRecognizer, {
        direction: DIRECTION_HORIZONTAL
      }, ['swipe']], [TapRecognizer], [TapRecognizer, {
        event: 'doubletap',
        taps: 2
      }, ['tap']], [PressRecognizer]]
    }, options));
  };

  Hammer.VERSION = "2.0.16";
  Hammer.DIRECTION_ALL = DIRECTION_ALL;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer.DIRECTION_UP = DIRECTION_UP;
  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer.DIRECTION_NONE = DIRECTION_NONE;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.INPUT_START = INPUT_START;
  Hammer.INPUT_MOVE = INPUT_MOVE;
  Hammer.INPUT_END = INPUT_END;
  Hammer.INPUT_CANCEL = INPUT_CANCEL;
  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer.STATE_BEGAN = STATE_BEGAN;
  Hammer.STATE_CHANGED = STATE_CHANGED;
  Hammer.STATE_ENDED = STATE_ENDED;
  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer.STATE_CANCELLED = STATE_CANCELLED;
  Hammer.STATE_FAILED = STATE_FAILED;
  Hammer.Manager = Manager;
  Hammer.Input = Input;
  Hammer.TouchAction = TouchAction;
  Hammer.TouchInput = TouchInput;
  Hammer.MouseInput = MouseInput;
  Hammer.PointerEventInput = PointerEventInput;
  Hammer.TouchMouseInput = TouchMouseInput;
  Hammer.SingleTouchInput = SingleTouchInput;
  Hammer.Recognizer = Recognizer;
  Hammer.AttrRecognizer = AttrRecognizer;
  Hammer.Tap = TapRecognizer;
  Hammer.Pan = PanRecognizer;
  Hammer.Swipe = SwipeRecognizer;
  Hammer.Pinch = PinchRecognizer;
  Hammer.Rotate = RotateRecognizer;
  Hammer.Press = PressRecognizer;
  Hammer.on = addEventListeners;
  Hammer.off = removeEventListeners;
  Hammer.each = each;
  Hammer.merge = merge;
  Hammer.extend = extend$1;
  Hammer.bindFn = bindFn;
  Hammer.assign = assign$1;
  Hammer.inherit = inherit;
  Hammer.bindFn = bindFn;
  Hammer.prefixed = prefixed;
  Hammer.toArray = toArray$1;
  Hammer.inArray = inArray;
  Hammer.uniqueArray = uniqueArray;
  Hammer.splitStr = splitStr;
  Hammer.boolOrFn = boolOrFn;
  Hammer.hasParent = hasParent$1;
  Hammer.addEventListeners = addEventListeners;
  Hammer.removeEventListeners = removeEventListeners;
  Hammer.defaults = defaults;
  return Hammer;
}();
/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */


function hammerMock() {
  var noop = function noop() {};

  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get: function get(m) {
      //eslint-disable-line no-unused-vars
      return {
        set: noop
      };
    }
  };
}

var modifiedHammer;

if (typeof window !== 'undefined') {
  var OurHammer = window['Hammer'] || Hammer;
  modifiedHammer = propagating(OurHammer, {
    preventDefault: 'mouse'
  });
} else {
  modifiedHammer = function modifiedHammer() {
    return (// hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
      hammerMock()
    );
  };
}

var Hammer$1 = modifiedHammer;
/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */

exports.Hammer = Hammer$1;

function onTouch(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst) {
      callback(event);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
}
/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 * @returns {*}
 */


function onRelease(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal) {
      callback(event);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
}
/**
 * Hack the PinchRecognizer such that it doesn't prevent default behavior
 * for vertical panning.
 *
 * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932
 *
 * @param {Hammer.Pinch} pinchRecognizer
 * @return {Hammer.Pinch} returns the pinchRecognizer
 */


function disablePreventDefaultVertically(pinchRecognizer) {
  var TOUCH_ACTION_PAN_Y = 'pan-y';

  pinchRecognizer.getTouchAction = function () {
    // default method returns [TOUCH_ACTION_NONE]
    return [TOUCH_ACTION_PAN_Y];
  };

  return pinchRecognizer;
}
/**
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 */


var TimeStep =
/*#__PURE__*/
function () {
  /**
    * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
    *                               or new Date(2010, 9, 21, 23, 45, 00)
    * @param {Date} [end]           The end date
    * @param {number} [minimumStep] Optional. Minimum step size in milliseconds
    * @param {Date|Array.<Date>} [hiddenDates] Optional.
    * @param {{showMajorLabels: boolean}} [options] Optional.
    * @constructor  TimeStep
    */
  function TimeStep(start, end, minimumStep, hiddenDates, options) {
    _classCallCheck(this, TimeStep);

    this.moment = moment$3; // variables

    this.current = this.moment();
    this._start = this.moment();
    this._end = this.moment();
    this.autoScale = true;
    this.scale = 'day';
    this.step = 1; // initialize the range

    this.setRange(start, end, minimumStep); // hidden Dates options

    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;

    if (Array.isArray(hiddenDates)) {
      this.hiddenDates = hiddenDates;
    } else if (hiddenDates != undefined) {
      this.hiddenDates = [hiddenDates];
    } else {
      this.hiddenDates = [];
    }

    this.format = TimeStep.FORMAT; // default formatting

    this.options = options ? options : {};
  }
  /**
   * Set custom constructor function for moment. Can be used to set dates
   * to UTC or to set a utcOffset.
   * @param {function} moment
   */


  _createClass(TimeStep, [{
    key: "setMoment",
    value: function setMoment(moment) {
      this.moment = moment; // update the date properties, can have a new utcOffset

      this.current = this.moment(this.current.valueOf());
      this._start = this.moment(this._start.valueOf());
      this._end = this.moment(this._end.valueOf());
    }
    /**
     * Set custom formatting for the minor an major labels of the TimeStep.
     * Both `minorLabels` and `majorLabels` are an Object with properties:
     * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'.
     * @param {{minorLabels: Object, majorLabels: Object}} format
     */

  }, {
    key: "setFormat",
    value: function setFormat(format) {
      var defaultFormat = util$2.deepExtend({}, TimeStep.FORMAT);
      this.format = util$2.deepExtend(defaultFormat, format);
    }
    /**
     * Set a new range
     * If minimumStep is provided, the step size is chosen as close as possible
     * to the minimumStep but larger than minimumStep. If minimumStep is not
     * provided, the scale is set to 1 DAY.
     * The minimumStep should correspond with the onscreen size of about 6 characters
     * @param {Date} [start]      The start date and time.
     * @param {Date} [end]        The end date and time.
     * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
     */

  }, {
    key: "setRange",
    value: function setRange(start, end, minimumStep) {
      if (!(start instanceof Date) || !(end instanceof Date)) {
        throw "No legal start or end date in method setRange";
      }

      this._start = start != undefined ? this.moment(start.valueOf()) : Date.now();
      this._end = end != undefined ? this.moment(end.valueOf()) : Date.now();

      if (this.autoScale) {
        this.setMinimumStep(minimumStep);
      }
    }
    /**
     * Set the range iterator to the start date.
     */

  }, {
    key: "start",
    value: function start() {
      this.current = this._start.clone();
      this.roundToMinor();
    }
    /**
     * Round the current date to the first minor date value
     * This must be executed once when the current date is set to start Date
     */

  }, {
    key: "roundToMinor",
    value: function roundToMinor() {
      // round to floor
      // to prevent year & month scales rounding down to the first day of week we perform this separately
      if (this.scale == 'week') {
        this.current.weekday(0);
      } // IMPORTANT: we have no breaks in this switch! (this is no bug)
      // noinspection FallThroughInSwitchStatementJS


      switch (this.scale) {
        case 'year':
          this.current.year(this.step * Math.floor(this.current.year() / this.step));
          this.current.month(0);

        case 'month':
          this.current.date(1);
        // eslint-disable-line no-fallthrough

        case 'week': // eslint-disable-line no-fallthrough

        case 'day': // eslint-disable-line no-fallthrough

        case 'weekday':
          this.current.hours(0);
        // eslint-disable-line no-fallthrough

        case 'hour':
          this.current.minutes(0);
        // eslint-disable-line no-fallthrough

        case 'minute':
          this.current.seconds(0);
        // eslint-disable-line no-fallthrough

        case 'second':
          this.current.milliseconds(0);
        // eslint-disable-line no-fallthrough
        //case 'millisecond': // nothing to do for milliseconds
      }

      if (this.step != 1) {
        // round down to the first minor value that is a multiple of the current step size
        var priorCurrent = this.current.clone();

        switch (this.scale) {
          case 'millisecond':
            this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');
            break;

          case 'second':
            this.current.subtract(this.current.seconds() % this.step, 'seconds');
            break;

          case 'minute':
            this.current.subtract(this.current.minutes() % this.step, 'minutes');
            break;

          case 'hour':
            this.current.subtract(this.current.hours() % this.step, 'hours');
            break;

          case 'weekday': // intentional fall through

          case 'day':
            this.current.subtract((this.current.date() - 1) % this.step, 'day');
            break;

          case 'week':
            this.current.subtract(this.current.week() % this.step, 'week');
            break;

          case 'month':
            this.current.subtract(this.current.month() % this.step, 'month');
            break;

          case 'year':
            this.current.subtract(this.current.year() % this.step, 'year');
            break;

          default:
            break;
        }

        if (!priorCurrent.isSame(this.current)) {
          this.current = moment$3(snapAwayFromHidden(this.hiddenDates, this.current.valueOf(), -1, true));
        }
      }
    }
    /**
     * Check if the there is a next step
     * @return {boolean}  true if the current date has not passed the end date
     */

  }, {
    key: "hasNext",
    value: function hasNext() {
      return this.current.valueOf() <= this._end.valueOf();
    }
    /**
     * Do the next step
     */

  }, {
    key: "next",
    value: function next() {
      var prev = this.current.valueOf(); // Two cases, needed to prevent issues with switching daylight savings
      // (end of March and end of October)

      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');
          break;

        case 'second':
          this.current.add(this.step, 'second');
          break;

        case 'minute':
          this.current.add(this.step, 'minute');
          break;

        case 'hour':
          this.current.add(this.step, 'hour');

          if (this.current.month() < 6) {
            this.current.subtract(this.current.hours() % this.step, 'hour');
          } else {
            if (this.current.hours() % this.step !== 0) {
              this.current.add(this.step - this.current.hours() % this.step, 'hour');
            }
          }

          break;

        case 'weekday': // intentional fall through

        case 'day':
          this.current.add(this.step, 'day');
          break;

        case 'week':
          if (this.current.weekday() !== 0) {
            // we had a month break not correlating with a week's start before
            this.current.weekday(0); // switch back to week cycles

            this.current.add(this.step, 'week');
          } else if (this.options.showMajorLabels === false) {
            this.current.add(this.step, 'week'); // the default case
          } else {
            // first day of the week
            var nextWeek = this.current.clone();
            nextWeek.add(1, 'week');

            if (nextWeek.isSame(this.current, 'month')) {
              // is the first day of the next week in the same month?
              this.current.add(this.step, 'week'); // the default case
            } else {
              // inject a step at each first day of the month
              this.current.add(this.step, 'week');
              this.current.date(1);
            }
          }

          break;

        case 'month':
          this.current.add(this.step, 'month');
          break;

        case 'year':
          this.current.add(this.step, 'year');
          break;

        default:
          break;
      }

      if (this.step != 1) {
        // round down to the correct major value
        switch (this.scale) {
          case 'millisecond':
            if (this.current.milliseconds() > 0 && this.current.milliseconds() < this.step) this.current.milliseconds(0);
            break;

          case 'second':
            if (this.current.seconds() > 0 && this.current.seconds() < this.step) this.current.seconds(0);
            break;

          case 'minute':
            if (this.current.minutes() > 0 && this.current.minutes() < this.step) this.current.minutes(0);
            break;

          case 'hour':
            if (this.current.hours() > 0 && this.current.hours() < this.step) this.current.hours(0);
            break;

          case 'weekday': // intentional fall through

          case 'day':
            if (this.current.date() < this.step + 1) this.current.date(1);
            break;

          case 'week':
            if (this.current.week() < this.step) this.current.week(1);
            break;
          // week numbering starts at 1, not 0

          case 'month':
            if (this.current.month() < this.step) this.current.month(0);
            break;

          case 'year':
            break;
          // nothing to do for year

          default:
            break;
        }
      } // safety mechanism: if current time is still unchanged, move to the end


      if (this.current.valueOf() == prev) {
        this.current = this._end.clone();
      } // Reset switches for year, month and day. Will get set to true where appropriate in DateUtil.stepOverHiddenDates


      this.switchedDay = false;
      this.switchedMonth = false;
      this.switchedYear = false;
      stepOverHiddenDates(this.moment, this, prev);
    }
    /**
     * Get the current datetime
     * @return {Moment}  current The current date
     */

  }, {
    key: "getCurrent",
    value: function getCurrent() {
      return this.current.clone();
    }
    /**
     * Set a custom scale. Autoscaling will be disabled.
     * For example setScale('minute', 5) will result
     * in minor steps of 5 minutes, and major steps of an hour.
     *
     * @param {{scale: string, step: number}} params
     *                               An object containing two properties:
     *                               - A string 'scale'. Choose from 'millisecond', 'second',
     *                                 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'.
     *                               - A number 'step'. A step size, by default 1.
     *                                 Choose for example 1, 2, 5, or 10.
     */

  }, {
    key: "setScale",
    value: function setScale(params) {
      if (params && typeof params.scale == 'string') {
        this.scale = params.scale;
        this.step = params.step > 0 ? params.step : 1;
        this.autoScale = false;
      }
    }
    /**
     * Enable or disable autoscaling
     * @param {boolean} enable  If true, autoascaling is set true
     */

  }, {
    key: "setAutoScale",
    value: function setAutoScale(enable) {
      this.autoScale = enable;
    }
    /**
     * Automatically determine the scale that bests fits the provided minimum step
     * @param {number} [minimumStep]  The minimum step size in milliseconds
     */

  }, {
    key: "setMinimumStep",
    value: function setMinimumStep(minimumStep) {
      if (minimumStep == undefined) {
        return;
      } //var b = asc + ds;


      var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
      var stepMonth = 1000 * 60 * 60 * 24 * 30;
      var stepDay = 1000 * 60 * 60 * 24;
      var stepHour = 1000 * 60 * 60;
      var stepMinute = 1000 * 60;
      var stepSecond = 1000;
      var stepMillisecond = 1; // find the smallest step that is larger than the provided minimumStep

      if (stepYear * 1000 > minimumStep) {
        this.scale = 'year';
        this.step = 1000;
      }

      if (stepYear * 500 > minimumStep) {
        this.scale = 'year';
        this.step = 500;
      }

      if (stepYear * 100 > minimumStep) {
        this.scale = 'year';
        this.step = 100;
      }

      if (stepYear * 50 > minimumStep) {
        this.scale = 'year';
        this.step = 50;
      }

      if (stepYear * 10 > minimumStep) {
        this.scale = 'year';
        this.step = 10;
      }

      if (stepYear * 5 > minimumStep) {
        this.scale = 'year';
        this.step = 5;
      }

      if (stepYear > minimumStep) {
        this.scale = 'year';
        this.step = 1;
      }

      if (stepMonth * 3 > minimumStep) {
        this.scale = 'month';
        this.step = 3;
      }

      if (stepMonth > minimumStep) {
        this.scale = 'month';
        this.step = 1;
      }

      if (stepDay * 7 > minimumStep) {
        this.scale = 'week';
        this.step = 1;
      }

      if (stepDay * 2 > minimumStep) {
        this.scale = 'day';
        this.step = 2;
      }

      if (stepDay > minimumStep) {
        this.scale = 'day';
        this.step = 1;
      }

      if (stepDay / 2 > minimumStep) {
        this.scale = 'weekday';
        this.step = 1;
      }

      if (stepHour * 4 > minimumStep) {
        this.scale = 'hour';
        this.step = 4;
      }

      if (stepHour > minimumStep) {
        this.scale = 'hour';
        this.step = 1;
      }

      if (stepMinute * 15 > minimumStep) {
        this.scale = 'minute';
        this.step = 15;
      }

      if (stepMinute * 10 > minimumStep) {
        this.scale = 'minute';
        this.step = 10;
      }

      if (stepMinute * 5 > minimumStep) {
        this.scale = 'minute';
        this.step = 5;
      }

      if (stepMinute > minimumStep) {
        this.scale = 'minute';
        this.step = 1;
      }

      if (stepSecond * 15 > minimumStep) {
        this.scale = 'second';
        this.step = 15;
      }

      if (stepSecond * 10 > minimumStep) {
        this.scale = 'second';
        this.step = 10;
      }

      if (stepSecond * 5 > minimumStep) {
        this.scale = 'second';
        this.step = 5;
      }

      if (stepSecond > minimumStep) {
        this.scale = 'second';
        this.step = 1;
      }

      if (stepMillisecond * 200 > minimumStep) {
        this.scale = 'millisecond';
        this.step = 200;
      }

      if (stepMillisecond * 100 > minimumStep) {
        this.scale = 'millisecond';
        this.step = 100;
      }

      if (stepMillisecond * 50 > minimumStep) {
        this.scale = 'millisecond';
        this.step = 50;
      }

      if (stepMillisecond * 10 > minimumStep) {
        this.scale = 'millisecond';
        this.step = 10;
      }

      if (stepMillisecond * 5 > minimumStep) {
        this.scale = 'millisecond';
        this.step = 5;
      }

      if (stepMillisecond > minimumStep) {
        this.scale = 'millisecond';
        this.step = 1;
      }
    }
    /**
     * Snap a date to a rounded value.
     * The snap intervals are dependent on the current scale and step.
     * Static function
     * @param {Date} date    the date to be snapped.
     * @param {string} scale Current scale, can be 'millisecond', 'second',
     *                       'minute', 'hour', 'weekday, 'day', 'week', 'month', 'year'.
     * @param {number} step  Current step (1, 2, 4, 5, ...
     * @return {Date} snappedDate
     */

  }, {
    key: "isMajor",

    /**
     * Check if the current value is a major value (for example when the step
     * is DAY, a major value is each first day of the MONTH)
     * @return {boolean} true if current date is major, else false.
     */
    value: function isMajor() {
      if (this.switchedYear == true) {
        switch (this.scale) {
          case 'year':
          case 'month':
          case 'week':
          case 'weekday':
          case 'day':
          case 'hour':
          case 'minute':
          case 'second':
          case 'millisecond':
            return true;

          default:
            return false;
        }
      } else if (this.switchedMonth == true) {
        switch (this.scale) {
          case 'week':
          case 'weekday':
          case 'day':
          case 'hour':
          case 'minute':
          case 'second':
          case 'millisecond':
            return true;

          default:
            return false;
        }
      } else if (this.switchedDay == true) {
        switch (this.scale) {
          case 'millisecond':
          case 'second':
          case 'minute':
          case 'hour':
            return true;

          default:
            return false;
        }
      }

      var date = this.moment(this.current);

      switch (this.scale) {
        case 'millisecond':
          return date.milliseconds() == 0;

        case 'second':
          return date.seconds() == 0;

        case 'minute':
          return date.hours() == 0 && date.minutes() == 0;

        case 'hour':
          return date.hours() == 0;

        case 'weekday': // intentional fall through

        case 'day':
          return date.date() == 1;

        case 'week':
          return date.date() == 1;

        case 'month':
          return date.month() == 0;

        case 'year':
          return false;

        default:
          return false;
      }
    }
    /**
     * Returns formatted text for the minor axislabel, depending on the current
     * date and the scale. For example when scale is MINUTE, the current time is
     * formatted as "hh:mm".
     * @param {Date} [date=this.current] custom date. if not provided, current date is taken
     * @returns {String}
     */

  }, {
    key: "getLabelMinor",
    value: function getLabelMinor(date) {
      if (date == undefined) {
        date = this.current;
      }

      if (date instanceof Date) {
        date = this.moment(date);
      }

      if (typeof this.format.minorLabels === "function") {
        return this.format.minorLabels(date, this.scale, this.step);
      }

      var format = this.format.minorLabels[this.scale]; // noinspection FallThroughInSwitchStatementJS

      switch (this.scale) {
        case 'week':
          // Don't draw the minor label if this date is the first day of a month AND if it's NOT the start of the week.
          // The 'date' variable may actually be the 'next' step when called from TimeAxis' _repaintLabels.
          if (date.date() === 1 && date.weekday() !== 0) {
            return "";
          }

        default:
          // eslint-disable-line no-fallthrough
          return format && format.length > 0 ? this.moment(date).format(format) : '';
      }
    }
    /**
     * Returns formatted text for the major axis label, depending on the current
     * date and the scale. For example when scale is MINUTE, the major scale is
     * hours, and the hour will be formatted as "hh".
     * @param {Date} [date=this.current] custom date. if not provided, current date is taken
     * @returns {String}
     */

  }, {
    key: "getLabelMajor",
    value: function getLabelMajor(date) {
      if (date == undefined) {
        date = this.current;
      }

      if (date instanceof Date) {
        date = this.moment(date);
      }

      if (typeof this.format.majorLabels === "function") {
        return this.format.majorLabels(date, this.scale, this.step);
      }

      var format = this.format.majorLabels[this.scale];
      return format && format.length > 0 ? this.moment(date).format(format) : '';
    }
    /**
     * get class name
     * @return {string} class name
     */

  }, {
    key: "getClassName",
    value: function getClassName() {
      var _moment = this.moment;
      var m = this.moment(this.current);
      var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function

      var step = this.step;
      var classNames = [];
      /**
       *
       * @param {number} value
       * @returns {String}
       */

      function even(value) {
        return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
      }
      /**
       *
       * @param {Date} date
       * @returns {String}
       */


      function today(date) {
        if (date.isSame(Date.now(), 'day')) {
          return ' vis-today';
        }

        if (date.isSame(_moment().add(1, 'day'), 'day')) {
          return ' vis-tomorrow';
        }

        if (date.isSame(_moment().add(-1, 'day'), 'day')) {
          return ' vis-yesterday';
        }

        return '';
      }
      /**
       *
       * @param {Date} date
       * @returns {String}
       */


      function currentWeek(date) {
        return date.isSame(Date.now(), 'week') ? ' vis-current-week' : '';
      }
      /**
       *
       * @param {Date} date
       * @returns {String}
       */


      function currentMonth(date) {
        return date.isSame(Date.now(), 'month') ? ' vis-current-month' : '';
      }
      /**
       *
       * @param {Date} date
       * @returns {String}
       */


      function currentYear(date) {
        return date.isSame(Date.now(), 'year') ? ' vis-current-year' : '';
      }

      switch (this.scale) {
        case 'millisecond':
          classNames.push(today(current));
          classNames.push(even(current.milliseconds()));
          break;

        case 'second':
          classNames.push(today(current));
          classNames.push(even(current.seconds()));
          break;

        case 'minute':
          classNames.push(today(current));
          classNames.push(even(current.minutes()));
          break;

        case 'hour':
          classNames.push("vis-h".concat(current.hours()).concat(this.step == 4 ? '-h' + (current.hours() + 4) : ''));
          classNames.push(today(current));
          classNames.push(even(current.hours()));
          break;

        case 'weekday':
          classNames.push("vis-".concat(current.format('dddd').toLowerCase()));
          classNames.push(today(current));
          classNames.push(currentWeek(current));
          classNames.push(even(current.date()));
          break;

        case 'day':
          classNames.push("vis-day".concat(current.date()));
          classNames.push("vis-".concat(current.format('MMMM').toLowerCase()));
          classNames.push(today(current));
          classNames.push(currentMonth(current));
          classNames.push(this.step <= 2 ? today(current) : '');
          classNames.push(this.step <= 2 ? "vis-".concat(current.format('dddd').toLowerCase()) : '');
          classNames.push(even(current.date() - 1));
          break;

        case 'week':
          classNames.push("vis-week".concat(current.format('w')));
          classNames.push(currentWeek(current));
          classNames.push(even(current.week()));
          break;

        case 'month':
          classNames.push("vis-".concat(current.format('MMMM').toLowerCase()));
          classNames.push(currentMonth(current));
          classNames.push(even(current.month()));
          break;

        case 'year':
          classNames.push("vis-year".concat(current.year()));
          classNames.push(currentYear(current));
          classNames.push(even(current.year()));
          break;
      }

      return classNames.filter(String).join(" ");
    }
  }], [{
    key: "snap",
    value: function snap(date, scale, step) {
      var clone = moment$3(date);

      if (scale == 'year') {
        var year = clone.year() + Math.round(clone.month() / 12);
        clone.year(Math.round(year / step) * step);
        clone.month(0);
        clone.date(0);
        clone.hours(0);
        clone.minutes(0);
        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'month') {
        if (clone.date() > 15) {
          clone.date(1);
          clone.add(1, 'month'); // important: first set Date to 1, after that change the month.
        } else {
          clone.date(1);
        }

        clone.hours(0);
        clone.minutes(0);
        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'week') {
        if (clone.weekday() > 2) {
          // doing it the momentjs locale aware way
          clone.weekday(0);
          clone.add(1, 'week');
        } else {
          clone.weekday(0);
        }

        clone.hours(0);
        clone.minutes(0);
        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'day') {
        //noinspection FallthroughInSwitchStatementJS
        switch (step) {
          case 5:
          case 2:
            clone.hours(Math.round(clone.hours() / 24) * 24);
            break;

          default:
            clone.hours(Math.round(clone.hours() / 12) * 12);
            break;
        }

        clone.minutes(0);
        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'weekday') {
        //noinspection FallthroughInSwitchStatementJS
        switch (step) {
          case 5:
          case 2:
            clone.hours(Math.round(clone.hours() / 12) * 12);
            break;

          default:
            clone.hours(Math.round(clone.hours() / 6) * 6);
            break;
        }

        clone.minutes(0);
        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'hour') {
        switch (step) {
          case 4:
            clone.minutes(Math.round(clone.minutes() / 60) * 60);
            break;

          default:
            clone.minutes(Math.round(clone.minutes() / 30) * 30);
            break;
        }

        clone.seconds(0);
        clone.milliseconds(0);
      } else if (scale == 'minute') {
        //noinspection FallthroughInSwitchStatementJS
        switch (step) {
          case 15:
          case 10:
            clone.minutes(Math.round(clone.minutes() / 5) * 5);
            clone.seconds(0);
            break;

          case 5:
            clone.seconds(Math.round(clone.seconds() / 60) * 60);
            break;

          default:
            clone.seconds(Math.round(clone.seconds() / 30) * 30);
            break;
        }

        clone.milliseconds(0);
      } else if (scale == 'second') {
        //noinspection FallthroughInSwitchStatementJS
        switch (step) {
          case 15:
          case 10:
            clone.seconds(Math.round(clone.seconds() / 5) * 5);
            clone.milliseconds(0);
            break;

          case 5:
            clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);
            break;

          default:
            clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);
            break;
        }
      } else if (scale == 'millisecond') {
        var _step = step > 5 ? step / 2 : 1;

        clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
      }

      return clone;
    }
  }]);

  return TimeStep;
}(); // Time formatting


TimeStep.FORMAT = {
  minorLabels: {
    millisecond: 'SSS',
    second: 's',
    minute: 'HH:mm',
    hour: 'HH:mm',
    weekday: 'ddd D',
    day: 'D',
    week: 'w',
    month: 'MMM',
    year: 'YYYY'
  },
  majorLabels: {
    millisecond: 'HH:mm:ss',
    second: 'D MMMM HH:mm',
    minute: 'ddd D MMMM',
    hour: 'ddd D MMMM',
    weekday: 'MMMM YYYY',
    day: 'MMMM YYYY',
    week: 'MMMM YYYY',
    month: 'YYYY',
    year: ''
  }
};
/** A horizontal time axis */

var TimeAxis =
/*#__PURE__*/
function (_Component) {
  _inherits(TimeAxis, _Component);
  /**
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]        See TimeAxis.setOptions for the available
   *                                  options.
   * @constructor TimeAxis
   * @extends Component
   */


  function TimeAxis(body, options) {
    var _this;

    _classCallCheck(this, TimeAxis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TimeAxis).call(this));
    _this.dom = {
      foreground: null,
      lines: [],
      majorTexts: [],
      minorTexts: [],
      redundant: {
        lines: [],
        majorTexts: [],
        minorTexts: []
      }
    };
    _this.props = {
      range: {
        start: 0,
        end: 0,
        minimumStep: 0
      },
      lineTop: 0
    };
    _this.defaultOptions = {
      orientation: {
        axis: 'bottom'
      },
      // axis orientation: 'top' or 'bottom'
      showMinorLabels: true,
      showMajorLabels: true,
      maxMinorChars: 7,
      format: TimeStep.FORMAT,
      moment: moment$3,
      timeAxis: null
    };
    _this.options = util$2.extend({}, _this.defaultOptions);
    _this.body = body; // create the HTML DOM

    _this._create();

    _this.setOptions(options);

    return _this;
  }
  /**
   * Set options for the TimeAxis.
   * Parameters will be merged in current options.
   * @param {Object} options  Available options:
   *                          {string} [orientation.axis]
   *                          {boolean} [showMinorLabels]
   *                          {boolean} [showMajorLabels]
   */


  _createClass(TimeAxis, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        // copy all options that we know
        util$2.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'maxMinorChars', 'hiddenDates', 'timeAxis', 'moment', 'rtl'], this.options, options); // deep copy the format options

        util$2.selectiveDeepExtend(['format'], this.options, options);

        if ('orientation' in options) {
          if (typeof options.orientation === 'string') {
            this.options.orientation.axis = options.orientation;
          } else if (_typeof(options.orientation) === 'object' && 'axis' in options.orientation) {
            this.options.orientation.axis = options.orientation.axis;
          }
        } // apply locale to moment.js
        // TODO: not so nice, this is applied globally to moment.js


        if ('locale' in options) {
          if (typeof moment$3.locale === 'function') {
            // moment.js 2.8.1+
            moment$3.locale(options.locale);
          } else {
            moment$3.lang(options.locale);
          }
        }
      }
    }
    /**
     * Create the HTML DOM for the TimeAxis
     */

  }, {
    key: "_create",
    value: function _create() {
      this.dom.foreground = document.createElement('div');
      this.dom.background = document.createElement('div');
      this.dom.foreground.className = 'vis-time-axis vis-foreground';
      this.dom.background.className = 'vis-time-axis vis-background';
    }
    /**
     * Destroy the TimeAxis
     */

  }, {
    key: "destroy",
    value: function destroy() {
      // remove from DOM
      if (this.dom.foreground.parentNode) {
        this.dom.foreground.parentNode.removeChild(this.dom.foreground);
      }

      if (this.dom.background.parentNode) {
        this.dom.background.parentNode.removeChild(this.dom.background);
      }

      this.body = null;
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      var props = this.props;
      var foreground = this.dom.foreground;
      var background = this.dom.background; // determine the correct parent DOM element (depending on option orientation)

      var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
      var parentChanged = foreground.parentNode !== parent; // calculate character width and height

      this._calculateCharSize(); // TODO: recalculate sizes only needed when parent is resized or options is changed


      var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
      var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none'; // determine the width and height of the elemens for the axis

      props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
      props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
      props.height = props.minorLabelHeight + props.majorLabelHeight;
      props.width = foreground.offsetWidth;
      props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
      props.minorLineWidth = 1; // TODO: really calculate width

      props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
      props.majorLineWidth = 1; // TODO: really calculate width
      //  take foreground and background offline while updating (is almost twice as fast)

      var foregroundNextSibling = foreground.nextSibling;
      var backgroundNextSibling = background.nextSibling;
      foreground.parentNode && foreground.parentNode.removeChild(foreground);
      background.parentNode && background.parentNode.removeChild(background);
      foreground.style.height = "".concat(this.props.height, "px");

      this._repaintLabels(); // put DOM online again (at the same place)


      if (foregroundNextSibling) {
        parent.insertBefore(foreground, foregroundNextSibling);
      } else {
        parent.appendChild(foreground);
      }

      if (backgroundNextSibling) {
        this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
      } else {
        this.body.dom.backgroundVertical.appendChild(background);
      }

      return this._isResized() || parentChanged;
    }
    /**
     * Repaint major and minor text labels and vertical grid lines
     * @private
     */

  }, {
    key: "_repaintLabels",
    value: function _repaintLabels() {
      var orientation = this.options.orientation.axis; // calculate range and step (step such that we have space for 7 characters per label)

      var start = util$2.convert(this.body.range.start, 'Number');
      var end = util$2.convert(this.body.range.end, 'Number');
      var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
      var minimumStep = timeLabelsize - getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
      minimumStep -= this.body.util.toTime(0).valueOf();
      var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates, this.options);
      step.setMoment(this.options.moment);

      if (this.options.format) {
        step.setFormat(this.options.format);
      }

      if (this.options.timeAxis) {
        step.setScale(this.options.timeAxis);
      }

      this.step = step; // Move all DOM elements to a "redundant" list, where they
      // can be picked for re-use, and clear the lists with lines and texts.
      // At the end of the function _repaintLabels, left over elements will be cleaned up

      var dom = this.dom;
      dom.redundant.lines = dom.lines;
      dom.redundant.majorTexts = dom.majorTexts;
      dom.redundant.minorTexts = dom.minorTexts;
      dom.lines = [];
      dom.majorTexts = [];
      dom.minorTexts = [];
      var current;
      var next;
      var x;
      var xNext;
      var isMajor;
      var showMinorGrid;
      var width = 0;
      var prevWidth;
      var line;
      var xFirstMajorLabel = undefined;
      var count = 0;
      var MAX = 1000;
      var className;
      step.start();
      next = step.getCurrent();
      xNext = this.body.util.toScreen(next);

      while (step.hasNext() && count < MAX) {
        count++;
        isMajor = step.isMajor();
        className = step.getClassName();
        current = next;
        x = xNext;
        step.next();
        next = step.getCurrent();
        xNext = this.body.util.toScreen(next);
        prevWidth = width;
        width = xNext - x;

        switch (step.scale) {
          case 'week':
            showMinorGrid = true;
            break;

          default:
            showMinorGrid = width >= prevWidth * 0.4;
            break;
          // prevent displaying of the 31th of the month on a scale of 5 days
        }

        if (this.options.showMinorLabels && showMinorGrid) {
          var label = this._repaintMinorText(x, step.getLabelMinor(current), orientation, className);

          label.style.width = "".concat(width, "px"); // set width to prevent overflow
        }

        if (isMajor && this.options.showMajorLabels) {
          if (x > 0) {
            if (xFirstMajorLabel == undefined) {
              xFirstMajorLabel = x;
            }

            label = this._repaintMajorText(x, step.getLabelMajor(current), orientation, className);
          }

          line = this._repaintMajorLine(x, width, orientation, className);
        } else {
          // minor line
          if (showMinorGrid) {
            line = this._repaintMinorLine(x, width, orientation, className);
          } else {
            if (line) {
              // adjust the width of the previous grid
              line.style.width = "".concat(parseInt(line.style.width) + width, "px");
            }
          }
        }
      }

      if (count === MAX && !warnedForOverflow) {
        console.warn("Something is wrong with the Timeline scale. Limited drawing of grid lines to ".concat(MAX, " lines."));
        warnedForOverflow = true;
      } // create a major label on the left when needed


      if (this.options.showMajorLabels) {
        var leftTime = this.body.util.toTime(0); // upper bound estimation

        var leftText = step.getLabelMajor(leftTime);
        var widthText = leftText.length * (this.props.majorCharWidth || 10) + 10;

        if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
          this._repaintMajorText(0, leftText, orientation, className);
        }
      } // Cleanup leftover DOM elements from the redundant list


      util$2.forEach(this.dom.redundant, function (arr) {
        while (arr.length) {
          var elem = arr.pop();

          if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        }
      });
    }
    /**
     * Create a minor label for the axis at position x
     * @param {number} x
     * @param {string} text
     * @param {string} orientation   "top" or "bottom" (default)
     * @param {string} className
     * @return {Element} Returns the HTML element of the created label
     * @private
     */

  }, {
    key: "_repaintMinorText",
    value: function _repaintMinorText(x, text, orientation, className) {
      // reuse redundant label
      var label = this.dom.redundant.minorTexts.shift();

      if (!label) {
        // create new label
        var content = document.createTextNode('');
        label = document.createElement('div');
        label.appendChild(content);
        this.dom.foreground.appendChild(label);
      }

      this.dom.minorTexts.push(label);
      label.innerHTML = text;
      var y = orientation == 'top' ? this.props.majorLabelHeight : 0;

      this._setXY(label, x, y);

      label.className = "vis-text vis-minor ".concat(className); //label.title = title;  // TODO: this is a heavy operation

      return label;
    }
    /**
     * Create a Major label for the axis at position x
     * @param {number} x
     * @param {string} text
     * @param {string} orientation   "top" or "bottom" (default)
     * @param {string} className
     * @return {Element} Returns the HTML element of the created label
     * @private
     */

  }, {
    key: "_repaintMajorText",
    value: function _repaintMajorText(x, text, orientation, className) {
      // reuse redundant label
      var label = this.dom.redundant.majorTexts.shift();

      if (!label) {
        // create label
        var content = document.createElement('div');
        label = document.createElement('div');
        label.appendChild(content);
        this.dom.foreground.appendChild(label);
      }

      label.childNodes[0].innerHTML = text;
      label.className = "vis-text vis-major ".concat(className); //label.title = title; // TODO: this is a heavy operation

      var y = orientation == 'top' ? 0 : this.props.minorLabelHeight;

      this._setXY(label, x, y);

      this.dom.majorTexts.push(label);
      return label;
    }
    /**
     * sets xy
     * @param {string} label
     * @param {number} x
     * @param {number} y
     * @private
     */

  }, {
    key: "_setXY",
    value: function _setXY(label, x, y) {
      // If rtl is true, inverse x.
      var directionX = this.options.rtl ? x * -1 : x;
      label.style.transform = "translate(".concat(directionX, "px, ").concat(y, "px)");
    }
    /**
     * Create a minor line for the axis at position x
     * @param {number} left
     * @param {number} width
     * @param {string} orientation   "top" or "bottom" (default)
     * @param {string} className
     * @return {Element} Returns the created line
     * @private
     */

  }, {
    key: "_repaintMinorLine",
    value: function _repaintMinorLine(left, width, orientation, className) {
      // reuse redundant line
      var line = this.dom.redundant.lines.shift();

      if (!line) {
        // create vertical line
        line = document.createElement('div');
        this.dom.background.appendChild(line);
      }

      this.dom.lines.push(line);
      var props = this.props;
      line.style.width = "".concat(width, "px");
      line.style.height = "".concat(props.minorLineHeight, "px");
      var y = orientation == 'top' ? props.majorLabelHeight : this.body.domProps.top.height;
      var x = left - props.minorLineWidth / 2;

      this._setXY(line, x, y);

      line.className = "vis-grid ".concat(this.options.rtl ? 'vis-vertical-rtl' : 'vis-vertical', " vis-minor ").concat(className);
      return line;
    }
    /**
     * Create a Major line for the axis at position x
     * @param {number} left
     * @param {number} width
     * @param {string} orientation   "top" or "bottom" (default)
     * @param {string} className
     * @return {Element} Returns the created line
     * @private
     */

  }, {
    key: "_repaintMajorLine",
    value: function _repaintMajorLine(left, width, orientation, className) {
      // reuse redundant line
      var line = this.dom.redundant.lines.shift();

      if (!line) {
        // create vertical line
        line = document.createElement('div');
        this.dom.background.appendChild(line);
      }

      this.dom.lines.push(line);
      var props = this.props;
      line.style.width = "".concat(width, "px");
      line.style.height = "".concat(props.majorLineHeight, "px");
      var y = orientation == 'top' ? 0 : this.body.domProps.top.height;
      var x = left - props.majorLineWidth / 2;

      this._setXY(line, x, y);

      line.className = "vis-grid ".concat(this.options.rtl ? 'vis-vertical-rtl' : 'vis-vertical', " vis-major ").concat(className);
      return line;
    }
    /**
     * Determine the size of text on the axis (both major and minor axis).
     * The size is calculated only once and then cached in this.props.
     * @private
     */

  }, {
    key: "_calculateCharSize",
    value: function _calculateCharSize() {
      // Note: We calculate char size with every redraw. Size may change, for
      // example when any of the timelines parents had display:none for example.
      // determine the char width and height on the minor axis
      if (!this.dom.measureCharMinor) {
        this.dom.measureCharMinor = document.createElement('DIV');
        this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
        this.dom.measureCharMinor.style.position = 'absolute';
        this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
        this.dom.foreground.appendChild(this.dom.measureCharMinor);
      }

      this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
      this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth; // determine the char width and height on the major axis

      if (!this.dom.measureCharMajor) {
        this.dom.measureCharMajor = document.createElement('DIV');
        this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
        this.dom.measureCharMajor.style.position = 'absolute';
        this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
        this.dom.foreground.appendChild(this.dom.measureCharMajor);
      }

      this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
      this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
    }
  }]);

  return TimeAxis;
}(Component);

var warnedForOverflow = false;
var keycharm = createCommonjsModule(function (module, exports) {
  /**
   * Created by Alex on 11/6/2014.
   */
  // https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
  // if the module has no dependencies, the above pattern can be simplified to
  (function (root, factory) {
    {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    }
  })(commonjsGlobal, function () {
    function keycharm(options) {
      var preventDefault = options && options.preventDefault || false;
      var container = options && options.container || window;
      var _exportFunctions = {};
      var _bound = {
        keydown: {},
        keyup: {}
      };
      var _keys = {};
      var i; // a - z

      for (i = 97; i <= 122; i++) {
        _keys[String.fromCharCode(i)] = {
          code: 65 + (i - 97),
          shift: false
        };
      } // A - Z


      for (i = 65; i <= 90; i++) {
        _keys[String.fromCharCode(i)] = {
          code: i,
          shift: true
        };
      } // 0 - 9


      for (i = 0; i <= 9; i++) {
        _keys['' + i] = {
          code: 48 + i,
          shift: false
        };
      } // F1 - F12


      for (i = 1; i <= 12; i++) {
        _keys['F' + i] = {
          code: 111 + i,
          shift: false
        };
      } // num0 - num9


      for (i = 0; i <= 9; i++) {
        _keys['num' + i] = {
          code: 96 + i,
          shift: false
        };
      } // numpad misc


      _keys['num*'] = {
        code: 106,
        shift: false
      };
      _keys['num+'] = {
        code: 107,
        shift: false
      };
      _keys['num-'] = {
        code: 109,
        shift: false
      };
      _keys['num/'] = {
        code: 111,
        shift: false
      };
      _keys['num.'] = {
        code: 110,
        shift: false
      }; // arrows

      _keys['left'] = {
        code: 37,
        shift: false
      };
      _keys['up'] = {
        code: 38,
        shift: false
      };
      _keys['right'] = {
        code: 39,
        shift: false
      };
      _keys['down'] = {
        code: 40,
        shift: false
      }; // extra keys

      _keys['space'] = {
        code: 32,
        shift: false
      };
      _keys['enter'] = {
        code: 13,
        shift: false
      };
      _keys['shift'] = {
        code: 16,
        shift: undefined
      };
      _keys['esc'] = {
        code: 27,
        shift: false
      };
      _keys['backspace'] = {
        code: 8,
        shift: false
      };
      _keys['tab'] = {
        code: 9,
        shift: false
      };
      _keys['ctrl'] = {
        code: 17,
        shift: false
      };
      _keys['alt'] = {
        code: 18,
        shift: false
      };
      _keys['delete'] = {
        code: 46,
        shift: false
      };
      _keys['pageup'] = {
        code: 33,
        shift: false
      };
      _keys['pagedown'] = {
        code: 34,
        shift: false
      }; // symbols

      _keys['='] = {
        code: 187,
        shift: false
      };
      _keys['-'] = {
        code: 189,
        shift: false
      };
      _keys[']'] = {
        code: 221,
        shift: false
      };
      _keys['['] = {
        code: 219,
        shift: false
      };

      var down = function down(event) {
        handleEvent(event, 'keydown');
      };

      var up = function up(event) {
        handleEvent(event, 'keyup');
      }; // handle the actualy bound key with the event


      var handleEvent = function handleEvent(event, type) {
        if (_bound[type][event.keyCode] !== undefined) {
          var bound = _bound[type][event.keyCode];

          for (var i = 0; i < bound.length; i++) {
            if (bound[i].shift === undefined) {
              bound[i].fn(event);
            } else if (bound[i].shift == true && event.shiftKey == true) {
              bound[i].fn(event);
            } else if (bound[i].shift == false && event.shiftKey == false) {
              bound[i].fn(event);
            }
          }

          if (preventDefault == true) {
            event.preventDefault();
          }
        }
      }; // bind a key to a callback


      _exportFunctions.bind = function (key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }

        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }

        if (_bound[type][_keys[key].code] === undefined) {
          _bound[type][_keys[key].code] = [];
        }

        _bound[type][_keys[key].code].push({
          fn: callback,
          shift: _keys[key].shift
        });
      }; // bind all keys to a call back (demo purposes)


      _exportFunctions.bindAll = function (callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }

        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            _exportFunctions.bind(key, callback, type);
          }
        }
      }; // get the key label from an event


      _exportFunctions.getKey = function (event) {
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
              return key;
            } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
              return key;
            } else if (event.keyCode == _keys[key].code && key == 'shift') {
              return key;
            }
          }
        }

        return "unknown key, currently not supported";
      }; // unbind either a specific callback from a key or all of them (by leaving callback undefined)


      _exportFunctions.unbind = function (key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }

        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }

        if (callback !== undefined) {
          var newBindings = [];
          var bound = _bound[type][_keys[key].code];

          if (bound !== undefined) {
            for (var i = 0; i < bound.length; i++) {
              if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
                newBindings.push(_bound[type][_keys[key].code][i]);
              }
            }
          }

          _bound[type][_keys[key].code] = newBindings;
        } else {
          _bound[type][_keys[key].code] = [];
        }
      }; // reset all bound variables.


      _exportFunctions.reset = function () {
        _bound = {
          keydown: {},
          keyup: {}
        };
      }; // unbind all listeners and reset all variables.


      _exportFunctions.destroy = function () {
        _bound = {
          keydown: {},
          keyup: {}
        };
        container.removeEventListener('keydown', down, true);
        container.removeEventListener('keyup', up, true);
      }; // create listeners.


      container.addEventListener('keydown', down, true);
      container.addEventListener('keyup', up, true); // return the public functions.

      return _exportFunctions;
    }

    return keycharm;
  });
});
/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor Activator
 */

exports.keycharm = keycharm;

function Activator(container) {
  this.active = false;
  this.dom = {
    container: container
  };
  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';
  this.dom.container.appendChild(this.dom.overlay);
  this.hammer = Hammer$1(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this)); // block all touch events (except tap)

  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline

  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };

    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }

  this.keycharm = keycharm(); // keycharm listener only bounded when active)

  this.escListener = this.deactivate.bind(this);
} // turn into an event emitter


emitterComponent(Activator.prototype); // The currently active activator

Activator.current = null;
/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */

Activator.prototype.destroy = function () {
  this.deactivate(); // remove dom

  this.dom.overlay.parentNode.removeChild(this.dom.overlay); // remove global event listener

  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  } // remove keycharm


  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }

  this.keycharm = null; // cleanup hammer instances

  this.hammer.destroy();
  this.hammer = null; // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};
/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */


Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }

  Activator.current = this;
  this.active = true;
  this.dom.overlay.style.display = 'none';
  util$2.addClassName(this.dom.container, 'vis-active');
  this.emit('change');
  this.emit('activate'); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event

  this.keycharm.bind('esc', this.escListener);
};
/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */


Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util$2.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);
  this.emit('change');
  this.emit('deactivate');
};
/**
 * Handle a tap event: activate the container
 * @param {Event}  event   The event
 * @private
 */


Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};
/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */


function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }

    element = element.parentNode;
  }

  return false;
}

var it = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    var it = moment.defineLocale('it', {
      months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
      monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
      weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
      weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
      weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
      },
      calendar: {
        sameDay: '[Oggi alle] LT',
        nextDay: '[Domani alle] LT',
        nextWeek: 'dddd [alle] LT',
        lastDay: '[Ieri alle] LT',
        lastWeek: function lastWeek() {
          switch (this.day()) {
            case 0:
              return '[la scorsa] dddd [alle] LT';

            default:
              return '[lo scorso] dddd [alle] LT';
          }
        },
        sameElse: 'L'
      },
      relativeTime: {
        future: function future(s) {
          return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past: '%s fa',
        s: 'alcuni secondi',
        ss: '%d secondi',
        m: 'un minuto',
        mm: '%d minuti',
        h: 'un\'ora',
        hh: '%d ore',
        d: 'un giorno',
        dd: '%d giorni',
        M: 'un mese',
        MM: '%d mesi',
        y: 'un anno',
        yy: '%d anni'
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return it;
  });
});
var nl = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    var nl = moment.defineLocale('nl', {
      months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
      monthsShort: function monthsShort(m, format) {
        if (!m) {
          return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
          return monthsShortWithoutDots[m.month()];
        } else {
          return monthsShortWithDots[m.month()];
        }
      },
      monthsRegex: monthsRegex,
      monthsShortRegex: monthsRegex,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
      monthsParse: monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,
      weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
      weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
      weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD-MM-YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
      },
      calendar: {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
      },
      relativeTime: {
        future: 'over %s',
        past: '%s geleden',
        s: 'een paar seconden',
        ss: '%d seconden',
        m: 'n minuut',
        mm: '%d minuten',
        h: 'n uur',
        hh: '%d uur',
        d: 'n dag',
        dd: '%d dagen',
        M: 'n maand',
        MM: '%d maanden',
        y: 'n jaar',
        yy: '%d jaar'
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function ordinal(number) {
        return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return nl;
  });
});
var de = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
      var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
      };
      return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
      months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
      monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
      monthsParseExact: true,
      weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
      weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
      weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY HH:mm',
        LLLL: 'dddd, D. MMMM YYYY HH:mm'
      },
      calendar: {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
      },
      relativeTime: {
        future: 'in %s',
        past: 'vor %s',
        s: 'ein paar Sekunden',
        ss: '%d Sekunden',
        m: processRelativeTime,
        mm: '%d Minuten',
        h: processRelativeTime,
        hh: '%d Stunden',
        d: processRelativeTime,
        dd: processRelativeTime,
        M: processRelativeTime,
        MM: processRelativeTime,
        y: processRelativeTime,
        yy: processRelativeTime
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return de;
  });
});
var fr = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    var fr = moment.defineLocale('fr', {
      months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
      monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
      monthsParseExact: true,
      weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
      weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
      weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
      },
      calendar: {
        sameDay: '[Aujourdhui ] LT',
        nextDay: '[Demain ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[Hier ] LT',
        lastWeek: 'dddd [dernier ] LT',
        sameElse: 'L'
      },
      relativeTime: {
        future: 'dans %s',
        past: 'il y a %s',
        s: 'quelques secondes',
        ss: '%d secondes',
        m: 'une minute',
        mm: '%d minutes',
        h: 'une heure',
        hh: '%d heures',
        d: 'un jour',
        dd: '%d jours',
        M: 'un mois',
        MM: '%d mois',
        y: 'un an',
        yy: '%d ans'
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
      ordinal: function ordinal(number, period) {
        switch (period) {
          // TODO: Return 'e' when day of month > 1. Move this case inside
          // block for masculine words below.
          // See https://github.com/moment/moment/issues/3375
          case 'D':
            return number + (number === 1 ? 'er' : '');
          // Words with masculine grammatical gender: mois, trimestre, jour

          default:
          case 'M':
          case 'Q':
          case 'DDD':
          case 'd':
            return number + (number === 1 ? 'er' : 'e');
          // Words with feminine grammatical gender: semaine

          case 'w':
          case 'W':
            return number + (number === 1 ? 're' : 'e');
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return fr;
  });
});
var es = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    var es = moment.defineLocale('es', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
      monthsShort: function monthsShort(m, format) {
        if (!m) {
          return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
          return _monthsShort[m.month()];
        } else {
          return monthsShortDot[m.month()];
        }
      },
      monthsRegex: monthsRegex,
      monthsShortRegex: monthsRegex,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,
      weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D [de] MMMM [de] YYYY',
        LLL: 'D [de] MMMM [de] YYYY H:mm',
        LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
      },
      calendar: {
        sameDay: function sameDay() {
          return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
        },
        nextDay: function nextDay() {
          return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
        },
        nextWeek: function nextWeek() {
          return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
        },
        lastDay: function lastDay() {
          return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
        },
        lastWeek: function lastWeek() {
          return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
        },
        sameElse: 'L'
      },
      relativeTime: {
        future: 'en %s',
        past: 'hace %s',
        s: 'unos segundos',
        ss: '%d segundos',
        m: 'un minuto',
        mm: '%d minutos',
        h: 'una hora',
        hh: '%d horas',
        d: 'un da',
        dd: '%d das',
        M: 'un mes',
        MM: '%d meses',
        y: 'un ao',
        yy: '%d aos'
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return es;
  });
});
var uk = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    function plural(word, num) {
      var forms = word.split('_');
      return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }

    function relativeTimeWithPlural(number, withoutSuffix, key) {
      var format = {
        'ss': withoutSuffix ? '__' : '__',
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
      };

      if (key === 'm') {
        return withoutSuffix ? '' : '';
      } else if (key === 'h') {
        return withoutSuffix ? '' : '';
      } else {
        return number + ' ' + plural(format[key], +number);
      }
    }

    function weekdaysCaseReplace(m, format) {
      var weekdays = {
        'nominative': '______'.split('_'),
        'accusative': '______'.split('_'),
        'genitive': '______'.split('_')
      };

      if (m === true) {
        return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
      }

      if (!m) {
        return weekdays['nominative'];
      }

      var nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
      return weekdays[nounCase][m.day()];
    }

    function processHoursFunction(str) {
      return function () {
        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
      };
    }

    var uk = moment.defineLocale('uk', {
      months: {
        'format': '___________'.split('_'),
        'standalone': '___________'.split('_')
      },
      monthsShort: '___________'.split('_'),
      weekdays: weekdaysCaseReplace,
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY .',
        LLL: 'D MMMM YYYY ., HH:mm',
        LLLL: 'dddd, D MMMM YYYY ., HH:mm'
      },
      calendar: {
        sameDay: processHoursFunction('[ '),
        nextDay: processHoursFunction('[ '),
        lastDay: processHoursFunction('[ '),
        nextWeek: processHoursFunction('[] dddd ['),
        lastWeek: function lastWeek() {
          switch (this.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
              return processHoursFunction('[] dddd [').call(this);

            case 1:
            case 2:
            case 4:
              return processHoursFunction('[] dddd [').call(this);
          }
        },
        sameElse: 'L'
      },
      relativeTime: {
        future: ' %s',
        past: '%s ',
        s: ' ',
        ss: relativeTimeWithPlural,
        m: relativeTimeWithPlural,
        mm: relativeTimeWithPlural,
        h: '',
        hh: relativeTimeWithPlural,
        d: '',
        dd: relativeTimeWithPlural,
        M: '',
        MM: relativeTimeWithPlural,
        y: '',
        yy: relativeTimeWithPlural
      },
      // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
      meridiemParse: /|||/,
      isPM: function isPM(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function meridiem(hour, minute, isLower) {
        if (hour < 4) {
          return '';
        } else if (hour < 12) {
          return '';
        } else if (hour < 17) {
          return '';
        } else {
          return '';
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function ordinal(number, period) {
        switch (period) {
          case 'M':
          case 'd':
          case 'DDD':
          case 'w':
          case 'W':
            return number + '-';

          case 'D':
            return number + '-';

          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7 // The week that contains Jan 7th is the first week of the year.

      }
    });
    return uk;
  });
});
var ru = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    function plural(word, num) {
      var forms = word.split('_');
      return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }

    function relativeTimeWithPlural(number, withoutSuffix, key) {
      var format = {
        'ss': withoutSuffix ? '__' : '__',
        'mm': withoutSuffix ? '__' : '__',
        'hh': '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
      };

      if (key === 'm') {
        return withoutSuffix ? '' : '';
      } else {
        return number + ' ' + plural(format[key], +number);
      }
    }

    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]; // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753

    var ru = moment.defineLocale('ru', {
      months: {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
      },
      monthsShort: {
        //  CLDR  "."  ".",        ?
        format: '._._._.____._._._._.'.split('_'),
        standalone: '._.__.____._._._._.'.split('_')
      },
      weekdays: {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
      },
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      monthsParse: monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,
      //    ,   ,  ,  4 ,      
      monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
      //  
      monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
      //    
      monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
      // ,     
      monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
      longDateFormat: {
        LT: 'H:mm',
        LTS: 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D MMMM YYYY .',
        LLL: 'D MMMM YYYY ., H:mm',
        LLLL: 'dddd, D MMMM YYYY ., H:mm'
      },
      calendar: {
        sameDay: '[, ] LT',
        nextDay: '[, ] LT',
        lastDay: '[, ] LT',
        nextWeek: function nextWeek(now) {
          if (now.week() !== this.week()) {
            switch (this.day()) {
              case 0:
                return '[ ] dddd, [] LT';

              case 1:
              case 2:
              case 4:
                return '[ ] dddd, [] LT';

              case 3:
              case 5:
              case 6:
                return '[ ] dddd, [] LT';
            }
          } else {
            if (this.day() === 2) {
              return '[] dddd, [] LT';
            } else {
              return '[] dddd, [] LT';
            }
          }
        },
        lastWeek: function lastWeek(now) {
          if (now.week() !== this.week()) {
            switch (this.day()) {
              case 0:
                return '[ ] dddd, [] LT';

              case 1:
              case 2:
              case 4:
                return '[ ] dddd, [] LT';

              case 3:
              case 5:
              case 6:
                return '[ ] dddd, [] LT';
            }
          } else {
            if (this.day() === 2) {
              return '[] dddd, [] LT';
            } else {
              return '[] dddd, [] LT';
            }
          }
        },
        sameElse: 'L'
      },
      relativeTime: {
        future: ' %s',
        past: '%s ',
        s: ' ',
        ss: relativeTimeWithPlural,
        m: relativeTimeWithPlural,
        mm: relativeTimeWithPlural,
        h: '',
        hh: relativeTimeWithPlural,
        d: '',
        dd: relativeTimeWithPlural,
        M: '',
        MM: relativeTimeWithPlural,
        y: '',
        yy: relativeTimeWithPlural
      },
      meridiemParse: /|||/i,
      isPM: function isPM(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function meridiem(hour, minute, isLower) {
        if (hour < 4) {
          return '';
        } else if (hour < 12) {
          return '';
        } else if (hour < 17) {
          return '';
        } else {
          return '';
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
      ordinal: function ordinal(number, period) {
        switch (period) {
          case 'M':
          case 'd':
          case 'DDD':
            return number + '-';

          case 'D':
            return number + '-';

          case 'w':
          case 'W':
            return number + '-';

          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.

      }
    });
    return ru;
  });
});
var ja = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    typeof commonjsRequire === 'function' ? factory(moment$2) : factory(global.moment);
  })(commonjsGlobal, function (moment) {
    var ja = moment.defineLocale('ja', {
      months: '___________'.split('_'),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'YYYY/MM/DD',
        LL: 'YYYYMD',
        LLL: 'YYYYMD HH:mm',
        LLLL: 'YYYYMD dddd HH:mm',
        l: 'YYYY/MM/DD',
        ll: 'YYYYMD',
        lll: 'YYYYMD HH:mm',
        llll: 'YYYYMD(ddd) HH:mm'
      },
      meridiemParse: /|/i,
      isPM: function isPM(input) {
        return input === '';
      },
      meridiem: function meridiem(hour, minute, isLower) {
        if (hour < 12) {
          return '';
        } else {
          return '';
        }
      },
      calendar: {
        sameDay: '[] LT',
        nextDay: '[] LT',
        nextWeek: function nextWeek(now) {
          if (now.week() < this.week()) {
            return '[]dddd LT';
          } else {
            return 'dddd LT';
          }
        },
        lastDay: '[] LT',
        lastWeek: function lastWeek(now) {
          if (this.week() < now.week()) {
            return '[]dddd LT';
          } else {
            return 'dddd LT';
          }
        },
        sameElse: 'L'
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function ordinal(number, period) {
        switch (period) {
          case 'd':
          case 'D':
          case 'DDD':
            return number + '';

          default:
            return number;
        }
      },
      relativeTime: {
        future: '%s',
        past: '%s',
        s: '',
        ss: '%d',
        m: '1',
        mm: '%d',
        h: '1',
        hh: '%d',
        d: '1',
        dd: '%d',
        M: '1',
        MM: '%d',
        y: '1',
        yy: '%d'
      }
    });
    return ja;
  });
}); // English

var en = {
  current: 'current',
  time: 'time',
  deleteSelected: 'Delete selected'
};
var en_EN = en;
var en_US = en; // Italiano

var it$1 = {
  current: 'attuale',
  time: 'tempo',
  deleteSelected: 'Cancella la selezione'
};
var it_IT = it$1;
var it_CH = it$1; // Dutch

var nl$1 = {
  current: 'huidige',
  time: 'tijd',
  deleteSelected: 'Selectie verwijderen'
};
var nl_NL = nl$1;
var nl_BE = nl$1; // German

var de$1 = {
  current: 'Aktuelle',
  time: 'Zeit',
  deleteSelected: "L\xF6sche Auswahl"
};
var de_DE = de$1; // French

var fr$1 = {
  current: 'actuel',
  time: 'heure',
  deleteSelected: 'Effacer la selection'
};
var fr_FR = fr$1;
var fr_CA = fr$1;
var fr_BE = fr$1; // Espanol

var es$1 = {
  current: 'corriente',
  time: 'hora',
  deleteSelected: "Eliminar selecci\xF3n"
};
var es_ES = es$1; // Ukrainian

var uk$1 = {
  current: '',
  time: '',
  deleteSelected: ' '
};
var uk_UA = uk$1; // Russian

var ru$1 = {
  current: '',
  time: '',
  deleteSelected: ' '
};
var ru_RU = ru$1; // Japanese

var ja$1 = {
  current: '',
  time: '',
  deleteSelected: ''
};
var ja_JP = ja$1;
var locales = {
  en: en,
  en_EN: en_EN,
  en_US: en_US,
  it: it$1,
  it_IT: it_IT,
  it_CH: it_CH,
  nl: nl$1,
  nl_NL: nl_NL,
  nl_BE: nl_BE,
  de: de$1,
  de_DE: de_DE,
  fr: fr$1,
  fr_FR: fr_FR,
  fr_CA: fr_CA,
  fr_BE: fr_BE,
  es: es$1,
  es_ES: es_ES,
  uk: uk$1,
  uk_UA: uk_UA,
  ru: ru$1,
  ru_RU: ru_RU,
  ja: ja$1,
  ja_JP: ja_JP
};
/** A custom time bar */

var CustomTime =
/*#__PURE__*/
function (_Component) {
  _inherits(CustomTime, _Component);
  /**
  * @param {{range: Range, dom: Object}} body
  * @param {Object} [options]        Available parameters:
  *                                  {number | string} id
  *                                  {string} locales
  *                                  {string} locale
  * @constructor CustomTime
  * @extends Component
  */


  function CustomTime(body, options) {
    var _this;

    _classCallCheck(this, CustomTime);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CustomTime).call(this));
    _this.body = body; // default options

    _this.defaultOptions = {
      moment: moment$3,
      locales: locales,
      locale: 'en',
      id: undefined,
      title: undefined
    };
    _this.options = util$2.extend({}, _this.defaultOptions);

    _this.setOptions(options);

    _this.options.locales = util$2.extend({}, locales, _this.options.locales);
    var defaultLocales = _this.defaultOptions.locales[_this.defaultOptions.locale];
    Object.keys(_this.options.locales).forEach(function (locale) {
      _this.options.locales[locale] = util$2.extend({}, defaultLocales, _this.options.locales[locale]);
    });

    if (options && options.time) {
      _this.customTime = options.time;
    } else {
      _this.customTime = new Date();
    }

    _this.eventParams = {}; // stores state parameters while dragging the bar
    // create the DOM

    _this._create();

    return _this;
  }
  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   */


  _createClass(CustomTime, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        // copy all options that we know
        util$2.selectiveExtend(['moment', 'locale', 'locales', 'id', 'title', 'rtl'], this.options, options);
      }
    }
    /**
     * Create the DOM for the custom time
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      var bar = document.createElement('div');
      bar['custom-time'] = this;
      bar.className = "vis-custom-time ".concat(this.options.id || '');
      bar.style.position = 'absolute';
      bar.style.top = '0px';
      bar.style.height = '100%';
      this.bar = bar;
      var drag = document.createElement('div');
      drag.style.position = 'relative';
      drag.style.top = '0px';

      if (this.options.rtl) {
        drag.style.right = '-10px';
      } else {
        drag.style.left = '-10px';
      }

      drag.style.height = '100%';
      drag.style.width = '20px';
      /**
       *
       * @param {WheelEvent} e
       */

      function onMouseWheel(e) {
        this.body.range._onMouseWheel(e);
      }

      if (drag.addEventListener) {
        // IE9, Chrome, Safari, Opera
        drag.addEventListener("mousewheel", onMouseWheel.bind(this), false); // Firefox

        drag.addEventListener("DOMMouseScroll", onMouseWheel.bind(this), false);
      } else {
        // IE 6/7/8
        drag.attachEvent("onmousewheel", onMouseWheel.bind(this));
      }

      bar.appendChild(drag); // attach event listeners

      this.hammer = new Hammer$1(drag);
      this.hammer.on('panstart', this._onDragStart.bind(this));
      this.hammer.on('panmove', this._onDrag.bind(this));
      this.hammer.on('panend', this._onDragEnd.bind(this));
      this.hammer.get('pan').set({
        threshold: 5,
        direction: Hammer$1.DIRECTION_ALL
      });
    }
    /**
     * Destroy the CustomTime bar
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.hide();
      this.hammer.destroy();
      this.hammer = null;
      this.body = null;
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      var parent = this.body.dom.backgroundVertical;

      if (this.bar.parentNode != parent) {
        // attach to the dom
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }

        parent.appendChild(this.bar);
      }

      var x = this.body.util.toScreen(this.customTime);
      var locale = this.options.locales[this.options.locale];

      if (!locale) {
        if (!this.warned) {
          console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
          this.warned = true;
        }

        locale = this.options.locales['en']; // fall back on english when not available
      }

      var title = this.options.title; // To hide the title completely use empty string ''.

      if (title === undefined) {
        title = "".concat(locale.time, ": ").concat(this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss'));
        title = title.charAt(0).toUpperCase() + title.substring(1);
      } else if (typeof title === "function") {
        title = title.call(this.customTime);
      }

      this.options.rtl ? this.bar.style.right = "".concat(x, "px") : this.bar.style.left = "".concat(x, "px");
      this.bar.title = title;
      return false;
    }
    /**
     * Remove the CustomTime from the DOM
     */

  }, {
    key: "hide",
    value: function hide() {
      // remove the line from the DOM
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
    }
    /**
     * Set custom time.
     * @param {Date | number | string} time
     */

  }, {
    key: "setCustomTime",
    value: function setCustomTime(time) {
      this.customTime = util$2.convert(time, 'Date');
      this.redraw();
    }
    /**
     * Retrieve the current custom time.
     * @return {Date} customTime
     */

  }, {
    key: "getCustomTime",
    value: function getCustomTime() {
      return new Date(this.customTime.valueOf());
    }
    /**
     * Set custom marker.
     * @param {string} [title] Title of the custom marker
     * @param {boolean} [editable] Make the custom marker editable.
     */

  }, {
    key: "setCustomMarker",
    value: function setCustomMarker(title, editable) {
      var marker = document.createElement('div');
      marker.className = "vis-custom-time-marker";
      marker.innerHTML = title;
      marker.style.position = 'absolute';

      if (editable) {
        marker.setAttribute('contenteditable', 'true');
        marker.addEventListener('pointerdown', function () {
          marker.focus();
        });
        marker.addEventListener('input', this._onMarkerChange.bind(this)); // The editable div element has no change event, so here emulates the change event.

        marker.title = title;
        marker.addEventListener('blur', function (event) {
          if (this.title != event.target.innerHTML) {
            this._onMarkerChanged(event);

            this.title = event.target.innerHTML;
          }
        }.bind(this));
      }

      this.bar.appendChild(marker);
    }
    /**
      * Set custom title.
      * @param {Date | number | string} title
      */

  }, {
    key: "setCustomTitle",
    value: function setCustomTitle(title) {
      this.options.title = title;
    }
    /**
     * Start moving horizontally
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDragStart",
    value: function _onDragStart(event) {
      this.eventParams.dragging = true;
      this.eventParams.customTime = this.customTime;
      event.stopPropagation();
    }
    /**
     * Perform moving operating.
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDrag",
    value: function _onDrag(event) {
      if (!this.eventParams.dragging) return;
      var deltaX = this.options.rtl ? -1 * event.deltaX : event.deltaX;
      var x = this.body.util.toScreen(this.eventParams.customTime) + deltaX;
      var time = this.body.util.toTime(x);
      this.setCustomTime(time); // fire a timechange event

      this.body.emitter.emit('timechange', {
        id: this.options.id,
        time: new Date(this.customTime.valueOf()),
        event: event
      });
      event.stopPropagation();
    }
    /**
     * Stop moving operating.
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDragEnd",
    value: function _onDragEnd(event) {
      if (!this.eventParams.dragging) return; // fire a timechanged event

      this.body.emitter.emit('timechanged', {
        id: this.options.id,
        time: new Date(this.customTime.valueOf()),
        event: event
      });
      event.stopPropagation();
    }
    /**
     * Perform input operating.
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onMarkerChange",
    value: function _onMarkerChange(event) {
      this.body.emitter.emit('markerchange', {
        id: this.options.id,
        title: event.target.innerHTML,
        event: event
      });
      event.stopPropagation();
    }
    /**
     * Perform change operating.
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onMarkerChanged",
    value: function _onMarkerChanged(event) {
      this.body.emitter.emit('markerchanged', {
        id: this.options.id,
        title: event.target.innerHTML,
        event: event
      });
      event.stopPropagation();
    }
    /**
     * Find a custom time from an event target:
     * searches for the attribute 'custom-time' in the event target's element tree
     * @param {Event} event
     * @return {CustomTime | null} customTime
     */

  }], [{
    key: "customTimeFromTarget",
    value: function customTimeFromTarget(event) {
      var target = event.target;

      while (target) {
        if (target.hasOwnProperty('custom-time')) {
          return target['custom-time'];
        }

        target = target.parentNode;
      }

      return null;
    }
  }]);

  return CustomTime;
}(Component);
/**
 * Create a timeline visualization
 * @constructor Core
 */


var Core =
/*#__PURE__*/
function () {
  function Core() {
    _classCallCheck(this, Core);
  }

  _createClass(Core, [{
    key: "_create",

    /**
     * Create the main DOM for the Core: a root panel containing left, right,
     * top, bottom, content, and background panel.
     * @param {Element} container  The container element where the Core will
     *                             be attached.
     * @protected
     */
    value: function _create(container) {
      var _this = this;

      this.dom = {};
      this.dom.container = container;
      this.dom.container.style.position = 'relative';
      this.dom.root = document.createElement('div');
      this.dom.background = document.createElement('div');
      this.dom.backgroundVertical = document.createElement('div');
      this.dom.backgroundHorizontal = document.createElement('div');
      this.dom.centerContainer = document.createElement('div');
      this.dom.leftContainer = document.createElement('div');
      this.dom.rightContainer = document.createElement('div');
      this.dom.center = document.createElement('div');
      this.dom.left = document.createElement('div');
      this.dom.right = document.createElement('div');
      this.dom.top = document.createElement('div');
      this.dom.bottom = document.createElement('div');
      this.dom.shadowTop = document.createElement('div');
      this.dom.shadowBottom = document.createElement('div');
      this.dom.shadowTopLeft = document.createElement('div');
      this.dom.shadowBottomLeft = document.createElement('div');
      this.dom.shadowTopRight = document.createElement('div');
      this.dom.shadowBottomRight = document.createElement('div');
      this.dom.rollingModeBtn = document.createElement('div');
      this.dom.loadingScreen = document.createElement('div');
      this.dom.root.className = 'vis-timeline';
      this.dom.background.className = 'vis-panel vis-background';
      this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
      this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
      this.dom.centerContainer.className = 'vis-panel vis-center';
      this.dom.leftContainer.className = 'vis-panel vis-left';
      this.dom.rightContainer.className = 'vis-panel vis-right';
      this.dom.top.className = 'vis-panel vis-top';
      this.dom.bottom.className = 'vis-panel vis-bottom';
      this.dom.left.className = 'vis-content';
      this.dom.center.className = 'vis-content';
      this.dom.right.className = 'vis-content';
      this.dom.shadowTop.className = 'vis-shadow vis-top';
      this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
      this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
      this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
      this.dom.shadowTopRight.className = 'vis-shadow vis-top';
      this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';
      this.dom.rollingModeBtn.className = 'vis-rolling-mode-btn';
      this.dom.loadingScreen.className = 'vis-loading-screen';
      this.dom.root.appendChild(this.dom.background);
      this.dom.root.appendChild(this.dom.backgroundVertical);
      this.dom.root.appendChild(this.dom.backgroundHorizontal);
      this.dom.root.appendChild(this.dom.centerContainer);
      this.dom.root.appendChild(this.dom.leftContainer);
      this.dom.root.appendChild(this.dom.rightContainer);
      this.dom.root.appendChild(this.dom.top);
      this.dom.root.appendChild(this.dom.bottom);
      this.dom.root.appendChild(this.dom.rollingModeBtn);
      this.dom.centerContainer.appendChild(this.dom.center);
      this.dom.leftContainer.appendChild(this.dom.left);
      this.dom.rightContainer.appendChild(this.dom.right);
      this.dom.centerContainer.appendChild(this.dom.shadowTop);
      this.dom.centerContainer.appendChild(this.dom.shadowBottom);
      this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
      this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
      this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
      this.dom.rightContainer.appendChild(this.dom.shadowBottomRight); // size properties of each of the panels

      this.props = {
        root: {},
        background: {},
        centerContainer: {},
        leftContainer: {},
        rightContainer: {},
        center: {},
        left: {},
        right: {},
        top: {},
        bottom: {},
        border: {},
        scrollTop: 0,
        scrollTopMin: 0
      };
      this.on('rangechange', function () {
        if (_this.initialDrawDone === true) {
          _this._redraw();
        }
      });
      this.on('rangechanged', function () {
        if (!_this.initialRangeChangeDone) {
          _this.initialRangeChangeDone = true;
        }
      });
      this.on('touch', this._onTouch.bind(this));
      this.on('panmove', this._onDrag.bind(this));
      var me = this;
      this._origRedraw = this._redraw.bind(this);
      this._redraw = util$2.throttle(this._origRedraw);
      this.on('_change', function (properties) {
        if (me.itemSet && me.itemSet.initialItemSetDrawn && properties && properties.queue == true) {
          me._redraw();
        } else {
          me._origRedraw();
        }
      }); // create event listeners for all interesting events, these events will be
      // emitted via emitter

      this.hammer = new Hammer$1(this.dom.root);
      var pinchRecognizer = this.hammer.get('pinch').set({
        enable: true
      });
      pinchRecognizer && disablePreventDefaultVertically(pinchRecognizer);
      this.hammer.get('pan').set({
        threshold: 5,
        direction: Hammer$1.DIRECTION_ALL
      });
      this.listeners = {};
      var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend' // TODO: cleanup
      //'touch', 'pinch',
      //'tap', 'doubletap', 'hold',
      //'dragstart', 'drag', 'dragend',
      //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
      ];
      events.forEach(function (type) {
        var listener = function listener(event) {
          if (me.isActive()) {
            me.emit(type, event);
          }
        };

        me.hammer.on(type, listener);
        me.listeners[type] = listener;
      }); // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)

      onTouch(this.hammer, function (event) {
        me.emit('touch', event);
      }); // emulate a release event (emitted after a pan, pinch, tap, or press)

      onRelease(this.hammer, function (event) {
        me.emit('release', event);
      });
      /**
       *
       * @param {WheelEvent} event
       */

      function onMouseWheel(event) {
        // Reasonable default wheel deltas
        var LINE_HEIGHT = 40;
        var PAGE_HEIGHT = 800;

        if (this.isActive()) {
          this.emit('mousewheel', event);
        } // deltaX and deltaY normalization from jquery.mousewheel.js


        var deltaX = 0;
        var deltaY = 0; // Old school scrollwheel delta

        if ('detail' in event) {
          deltaY = event.detail * -1;
        }

        if ('wheelDelta' in event) {
          deltaY = event.wheelDelta;
        }

        if ('wheelDeltaY' in event) {
          deltaY = event.wheelDeltaY;
        }

        if ('wheelDeltaX' in event) {
          deltaX = event.wheelDeltaX * -1;
        } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
          deltaX = deltaY * -1;
          deltaY = 0;
        } // New school wheel delta (wheel event)


        if ('deltaY' in event) {
          deltaY = event.deltaY * -1;
        }

        if ('deltaX' in event) {
          deltaX = event.deltaX;
        } // Normalize deltas


        if (event.deltaMode) {
          if (event.deltaMode === 1) {
            // delta in LINE units
            deltaX *= LINE_HEIGHT;
            deltaY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            deltaX *= LINE_HEIGHT;
            deltaY *= PAGE_HEIGHT;
          }
        } // Prevent scrolling when zooming (no zoom key, or pressing zoom key)


        if (this.options.preferZoom) {
          if (!this.options.zoomKey || event[this.options.zoomKey]) return;
        } else {
          if (this.options.zoomKey && event[this.options.zoomKey]) return;
        } // Don't preventDefault if you can't scroll


        if (!this.options.verticalScroll && !this.options.horizontalScroll) return;

        if (this.options.verticalScroll && Math.abs(deltaY) >= Math.abs(deltaX)) {
          var current = this.props.scrollTop;
          var adjusted = current + deltaY;

          if (this.isActive()) {
            var newScrollTop = this._setScrollTop(adjusted);

            if (newScrollTop !== current) {
              this._redraw();

              this.emit('scroll', event); // Prevent default actions caused by mouse wheel
              // (else the page and timeline both scroll)

              event.preventDefault();
            }
          }
        } else if (this.options.horizontalScroll) {
          var delta = Math.abs(deltaX) >= Math.abs(deltaY) ? deltaX : deltaY; // calculate a single scroll jump relative to the range scale

          var diff = delta / 120 * (this.range.end - this.range.start) / 20; // calculate new start and end

          var newStart = this.range.start + diff;
          var newEnd = this.range.end + diff;
          var options = {
            animation: false,
            byUser: true,
            event: event
          };
          this.range.setRange(newStart, newEnd, options);
          event.preventDefault();
        }
      } // Add modern wheel event listener


      var wheelType = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
      document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
      // DOMMouseScroll - Older Firefox versions use "DOMMouseScroll"
      // onmousewheel - All the use "onmousewheel"
      this.dom.centerContainer.addEventListener ? "DOMMouseScroll" : "onmousewheel";
      this.dom.top.addEventListener ? "DOMMouseScroll" : "onmousewheel";
      this.dom.bottom.addEventListener ? "DOMMouseScroll" : "onmousewheel";
      this.dom.centerContainer.addEventListener(wheelType, onMouseWheel.bind(this), false);
      this.dom.top.addEventListener(wheelType, onMouseWheel.bind(this), false);
      this.dom.bottom.addEventListener(wheelType, onMouseWheel.bind(this), false);
      /**
       *
       * @param {scroll} event
       */

      function onMouseScrollSide(event) {
        if (!me.options.verticalScroll) return;
        event.preventDefault();

        if (me.isActive()) {
          var adjusted = -event.target.scrollTop;

          me._setScrollTop(adjusted);

          me._redraw();

          me.emit('scrollSide', event);
        }
      }

      this.dom.left.parentNode.addEventListener('scroll', onMouseScrollSide.bind(this));
      this.dom.right.parentNode.addEventListener('scroll', onMouseScrollSide.bind(this));
      var itemAddedToTimeline = false;
      /**
       *
       * @param {dragover} event
       * @returns {boolean}
       */

      function handleDragOver(event) {
        if (event.preventDefault) {
          me.emit('dragover', me.getEventProperties(event));
          event.preventDefault(); // Necessary. Allows us to drop.
        } // make sure your target is a timeline element


        if (!(event.target.className.indexOf("timeline") > -1)) return; // make sure only one item is added every time you're over the timeline

        if (itemAddedToTimeline) return;
        event.dataTransfer.dropEffect = 'move';
        itemAddedToTimeline = true;
        return false;
      }
      /**
       *
       * @param {drop} event
       * @returns {boolean}
       */


      function handleDrop(event) {
        // prevent redirect to blank page - Firefox
        if (event.preventDefault) {
          event.preventDefault();
        }

        if (event.stopPropagation) {
          event.stopPropagation();
        } // return when dropping non-timeline items


        try {
          var itemData = JSON.parse(event.dataTransfer.getData("text"));
          if (!itemData || !itemData.content) return;
        } catch (err) {
          return false;
        }

        itemAddedToTimeline = false;
        event.center = {
          x: event.clientX,
          y: event.clientY
        };

        if (itemData.target !== 'item') {
          me.itemSet._onAddItem(event);
        } else {
          me.itemSet._onDropObjectOnItem(event);
        }

        me.emit('drop', me.getEventProperties(event));
        return false;
      }

      this.dom.center.addEventListener('dragover', handleDragOver.bind(this), false);
      this.dom.center.addEventListener('drop', handleDrop.bind(this), false);
      this.customTimes = []; // store state information needed for touch events

      this.touch = {};
      this.redrawCount = 0;
      this.initialDrawDone = false;
      this.initialRangeChangeDone = false; // attach the root panel to the provided container

      if (!container) throw new Error('No container provided');
      container.appendChild(this.dom.root);
      container.appendChild(this.dom.loadingScreen);
    }
    /**
     * Set options. Options will be passed to all components loaded in the Timeline.
     * @param {Object} [options]
     *                           {String} orientation
     *                              Vertical orientation for the Timeline,
     *                              can be 'bottom' (default) or 'top'.
     *                           {string | number} width
     *                              Width for the timeline, a number in pixels or
     *                              a css string like '1000px' or '75%'. '100%' by default.
     *                           {string | number} height
     *                              Fixed height for the Timeline, a number in pixels or
     *                              a css string like '400px' or '75%'. If undefined,
     *                              The Timeline will automatically size such that
     *                              its contents fit.
     *                           {string | number} minHeight
     *                              Minimum height for the Timeline, a number in pixels or
     *                              a css string like '400px' or '75%'.
     *                           {string | number} maxHeight
     *                              Maximum height for the Timeline, a number in pixels or
     *                              a css string like '400px' or '75%'.
     *                           {number | Date | string} start
     *                              Start date for the visible window
     *                           {number | Date | string} end
     *                              End date for the visible window
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        // copy the known options
        var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'preferZoom', 'rtl', 'zoomKey', 'horizontalScroll', 'verticalScroll'];
        util$2.selectiveExtend(fields, this.options, options);
        this.dom.rollingModeBtn.style.visibility = 'hidden';

        if (this.options.rtl) {
          this.dom.container.style.direction = "rtl";
          this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical-rtl';
        }

        if (this.options.verticalScroll) {
          if (this.options.rtl) {
            this.dom.rightContainer.className = 'vis-panel vis-right vis-vertical-scroll';
          } else {
            this.dom.leftContainer.className = 'vis-panel vis-left vis-vertical-scroll';
          }
        }

        if (_typeof(this.options.orientation) !== 'object') {
          this.options.orientation = {
            item: undefined,
            axis: undefined
          };
        }

        if ('orientation' in options) {
          if (typeof options.orientation === 'string') {
            this.options.orientation = {
              item: options.orientation,
              axis: options.orientation
            };
          } else if (_typeof(options.orientation) === 'object') {
            if ('item' in options.orientation) {
              this.options.orientation.item = options.orientation.item;
            }

            if ('axis' in options.orientation) {
              this.options.orientation.axis = options.orientation.axis;
            }
          }
        }

        if (this.options.orientation.axis === 'both') {
          if (!this.timeAxis2) {
            var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);

            timeAxis2.setOptions = function (options) {
              var _options = options ? util$2.extend({}, options) : {};

              _options.orientation = 'top'; // override the orientation option, always top

              TimeAxis.prototype.setOptions.call(timeAxis2, _options);
            };

            this.components.push(timeAxis2);
          }
        } else {
          if (this.timeAxis2) {
            var index = this.components.indexOf(this.timeAxis2);

            if (index !== -1) {
              this.components.splice(index, 1);
            }

            this.timeAxis2.destroy();
            this.timeAxis2 = null;
          }
        } // if the graph2d's drawPoints is a function delegate the callback to the onRender property


        if (typeof options.drawPoints == 'function') {
          options.drawPoints = {
            onRender: options.drawPoints
          };
        }

        if ('hiddenDates' in this.options) {
          convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
        }

        if ('clickToUse' in options) {
          if (options.clickToUse) {
            if (!this.activator) {
              this.activator = new Activator(this.dom.root);
            }
          } else {
            if (this.activator) {
              this.activator.destroy();
              delete this.activator;
            }
          }
        } // enable/disable autoResize


        this._initAutoResize();
      } // propagate options to all components


      this.components.forEach(function (component) {
        return component.setOptions(options);
      }); // enable/disable configure

      if ('configure' in options) {
        if (!this.configurator) {
          this.configurator = this._createConfigurator();
        }

        this.configurator.setOptions(options.configure); // collect the settings of all components, and pass them to the configuration system

        var appliedOptions = util$2.deepExtend({}, this.options);
        this.components.forEach(function (component) {
          util$2.deepExtend(appliedOptions, component.options);
        });
        this.configurator.setModuleOptions({
          global: appliedOptions
        });
      }

      this._redraw();
    }
    /**
     * Returns true when the Timeline is active.
     * @returns {boolean}
     */

  }, {
    key: "isActive",
    value: function isActive() {
      return !this.activator || this.activator.active;
    }
    /**
     * Destroy the Core, clean up all DOM elements and event listeners.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      // unbind datasets
      this.setItems(null);
      this.setGroups(null); // remove all event listeners

      this.off(); // stop checking for changed size

      this._stopAutoResize(); // remove from DOM


      if (this.dom.root.parentNode) {
        this.dom.root.parentNode.removeChild(this.dom.root);
      }

      this.dom = null; // remove Activator

      if (this.activator) {
        this.activator.destroy();
        delete this.activator;
      } // cleanup hammer touch events


      for (var event in this.listeners) {
        if (this.listeners.hasOwnProperty(event)) {
          delete this.listeners[event];
        }
      }

      this.listeners = null;
      this.hammer && this.hammer.destroy();
      this.hammer = null; // give all components the opportunity to cleanup

      this.components.forEach(function (component) {
        return component.destroy();
      });
      this.body = null;
    }
    /**
     * Set a custom time bar
     * @param {Date} time
     * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
     */

  }, {
    key: "setCustomTime",
    value: function setCustomTime(time, id) {
      var customTimes = this.customTimes.filter(function (component) {
        return id === component.options.id;
      });

      if (customTimes.length === 0) {
        throw new Error("No custom time bar found with id ".concat(JSON.stringify(id)));
      }

      if (customTimes.length > 0) {
        customTimes[0].setCustomTime(time);
      }
    }
    /**
     * Retrieve the current custom time.
     * @param {number} [id=undefined]    Id of the custom time bar.
     * @return {Date | undefined} customTime
     */

  }, {
    key: "getCustomTime",
    value: function getCustomTime(id) {
      var customTimes = this.customTimes.filter(function (component) {
        return component.options.id === id;
      });

      if (customTimes.length === 0) {
        throw new Error("No custom time bar found with id ".concat(JSON.stringify(id)));
      }

      return customTimes[0].getCustomTime();
    }
    /**
     * Set a custom marker for the custom time bar.
     * @param {string} [title] Title of the custom marker.
     * @param {number} [id=undefined] Id of the custom marker.
     * @param {boolean} [editable=false] Make the custom marker editable.
     */

  }, {
    key: "setCustomTimeMarker",
    value: function setCustomTimeMarker(title, id, editable) {
      var customTimes = this.customTimes.filter(function (component) {
        return component.options.id === id;
      });

      if (customTimes.length === 0) {
        throw new Error("No custom time bar found with id ".concat(JSON.stringify(id)));
      }

      if (customTimes.length > 0) {
        customTimes[0].setCustomMarker(title, editable);
      }
    }
    /**
     * Set a custom title for the custom time bar.
     * @param {string} [title] Custom title
     * @param {number} [id=undefined]    Id of the custom time bar.
     * @returns {*}
     */

  }, {
    key: "setCustomTimeTitle",
    value: function setCustomTimeTitle(title, id) {
      var customTimes = this.customTimes.filter(function (component) {
        return component.options.id === id;
      });

      if (customTimes.length === 0) {
        throw new Error("No custom time bar found with id ".concat(JSON.stringify(id)));
      }

      if (customTimes.length > 0) {
        return customTimes[0].setCustomTitle(title);
      }
    }
    /**
     * Retrieve meta information from an event.
     * Should be overridden by classes extending Core
     * @param {Event} event
     * @return {Object} An object with related information.
     */

  }, {
    key: "getEventProperties",
    value: function getEventProperties(event) {
      return {
        event: event
      };
    }
    /**
     * Add custom vertical bar
     * @param {Date | string | number} [time]  A Date, unix timestamp, or
     *                                         ISO date string. Time point where
     *                                         the new bar should be placed.
     *                                         If not provided, `new Date()` will
     *                                         be used.
     * @param {number | string} [id=undefined] Id of the new bar. Optional
     * @return {number | string}               Returns the id of the new bar
     */

  }, {
    key: "addCustomTime",
    value: function addCustomTime(time, id) {
      var timestamp = time !== undefined ? util$2.convert(time, 'Date').valueOf() : new Date();
      var exists = this.customTimes.some(function (customTime) {
        return customTime.options.id === id;
      });

      if (exists) {
        throw new Error("A custom time with id ".concat(JSON.stringify(id), " already exists"));
      }

      var customTime = new CustomTime(this.body, util$2.extend({}, this.options, {
        time: timestamp,
        id: id
      }));
      this.customTimes.push(customTime);
      this.components.push(customTime);

      this._redraw();

      return id;
    }
    /**
     * Remove previously added custom bar
     * @param {int} id ID of the custom bar to be removed
     * [at]returns {boolean} True if the bar exists and is removed, false otherwise
     */

  }, {
    key: "removeCustomTime",
    value: function removeCustomTime(id) {
      var _this2 = this;

      var customTimes = this.customTimes.filter(function (bar) {
        return bar.options.id === id;
      });

      if (customTimes.length === 0) {
        throw new Error("No custom time bar found with id ".concat(JSON.stringify(id)));
      }

      customTimes.forEach(function (customTime) {
        _this2.customTimes.splice(_this2.customTimes.indexOf(customTime), 1);

        _this2.components.splice(_this2.components.indexOf(customTime), 1);

        customTime.destroy();
      });
    }
    /**
     * Get the id's of the currently visible items.
     * @returns {Array} The ids of the visible items
     */

  }, {
    key: "getVisibleItems",
    value: function getVisibleItems() {
      return this.itemSet && this.itemSet.getVisibleItems() || [];
    }
    /**
     * Get the id's of the currently visible groups.
     * @returns {Array} The ids of the visible groups
     */

  }, {
    key: "getVisibleGroups",
    value: function getVisibleGroups() {
      return this.itemSet && this.itemSet.getVisibleGroups() || [];
    }
    /**
     * Set Core window such that it fits all items
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback] a callback funtion to be executed at the end of this function
     */

  }, {
    key: "fit",
    value: function fit(options, callback) {
      var range = this.getDataRange(); // skip range set if there is no min and max date

      if (range.min === null && range.max === null) {
        return;
      } // apply a margin of 1% left and right of the data


      var interval = range.max - range.min;
      var min = new Date(range.min.valueOf() - interval * 0.01);
      var max = new Date(range.max.valueOf() + interval * 0.01);
      var animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(min, max, {
        animation: animation
      }, callback);
    }
    /**
     * Calculate the data range of the items start and end dates
     * [at]returns {{min: [Date], max: [Date]}}
     * @protected
     */

  }, {
    key: "getDataRange",
    value: function getDataRange() {
      // must be implemented by Timeline and Graph2d
      throw new Error('Cannot invoke abstract method getDataRange');
    }
    /**
     * Set the visible window. Both parameters are optional, you can change only
     * start or only end. Syntax:
     *
     *     TimeLine.setWindow(start, end)
     *     TimeLine.setWindow(start, end, options)
     *     TimeLine.setWindow(range)
     *
     * Where start and end can be a Date, number, or string, and range is an
     * object with properties start and end.
     *
     * @param {Date | number | string | Object} [start] Start date of visible window
     * @param {Date | number | string} [end]            End date of visible window
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback] a callback funtion to be executed at the end of this function
     */

  }, {
    key: "setWindow",
    value: function setWindow(start, end, options, callback) {
      if (typeof arguments[2] == "function") {
        callback = arguments[2];
        options = {};
      }

      var animation;
      var range;

      if (arguments.length == 1) {
        range = arguments[0];
        animation = range.animation !== undefined ? range.animation : true;
        this.range.setRange(range.start, range.end, {
          animation: animation
        });
      } else if (arguments.length == 2 && typeof arguments[1] == "function") {
        range = arguments[0];
        callback = arguments[1];
        animation = range.animation !== undefined ? range.animation : true;
        this.range.setRange(range.start, range.end, {
          animation: animation
        }, callback);
      } else {
        animation = options && options.animation !== undefined ? options.animation : true;
        this.range.setRange(start, end, {
          animation: animation
        }, callback);
      }
    }
    /**
     * Move the window such that given time is centered on screen.
     * @param {Date | number | string} time
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback] a callback funtion to be executed at the end of this function
     */

  }, {
    key: "moveTo",
    value: function moveTo(time, options, callback) {
      if (typeof arguments[1] == "function") {
        callback = arguments[1];
        options = {};
      }

      var interval = this.range.end - this.range.start;
      var t = util$2.convert(time, 'Date').valueOf();
      var start = t - interval / 2;
      var end = t + interval / 2;
      var animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(start, end, {
        animation: animation
      }, callback);
    }
    /**
     * Get the visible window
     * @return {{start: Date, end: Date}}   Visible range
     */

  }, {
    key: "getWindow",
    value: function getWindow() {
      var range = this.range.getRange();
      return {
        start: new Date(range.start),
        end: new Date(range.end)
      };
    }
    /**
     * Zoom in the window such that given time is centered on screen.
     * @param {number} percentage - must be between [0..1]
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback] a callback funtion to be executed at the end of this function
     */

  }, {
    key: "zoomIn",
    value: function zoomIn(percentage, options, callback) {
      if (!percentage || percentage < 0 || percentage > 1) return;

      if (typeof arguments[1] == "function") {
        callback = arguments[1];
        options = {};
      }

      var range = this.getWindow();
      var start = range.start.valueOf();
      var end = range.end.valueOf();
      var interval = end - start;
      var newInterval = interval / (1 + percentage);
      var distance = (interval - newInterval) / 2;
      var newStart = start + distance;
      var newEnd = end - distance;
      this.setWindow(newStart, newEnd, options, callback);
    }
    /**
     * Zoom out the window such that given time is centered on screen.
     * @param {number} percentage - must be between [0..1]
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback] a callback funtion to be executed at the end of this function
     */

  }, {
    key: "zoomOut",
    value: function zoomOut(percentage, options, callback) {
      if (!percentage || percentage < 0 || percentage > 1) return;

      if (typeof arguments[1] == "function") {
        callback = arguments[1];
        options = {};
      }

      var range = this.getWindow();
      var start = range.start.valueOf();
      var end = range.end.valueOf();
      var interval = end - start;
      var newStart = start - interval * percentage / 2;
      var newEnd = end + interval * percentage / 2;
      this.setWindow(newStart, newEnd, options, callback);
    }
    /**
     * Force a redraw. Can be overridden by implementations of Core
     *
     * Note: this function will be overridden on construction with a trottled version
     */

  }, {
    key: "redraw",
    value: function redraw() {
      this._redraw();
    }
    /**
     * Redraw for internal use. Redraws all components. See also the public
     * method redraw.
     * @protected
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      this.redrawCount++;
      var dom = this.dom;
      if (!dom || !dom.container || dom.root.offsetWidth == 0) return; // when destroyed, or invisible

      var resized = false;
      var options = this.options;
      var props = this.props;
      updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates); // update class names

      if (options.orientation == 'top') {
        util$2.addClassName(dom.root, 'vis-top');
        util$2.removeClassName(dom.root, 'vis-bottom');
      } else {
        util$2.removeClassName(dom.root, 'vis-top');
        util$2.addClassName(dom.root, 'vis-bottom');
      }

      if (options.rtl) {
        util$2.addClassName(dom.root, 'vis-rtl');
        util$2.removeClassName(dom.root, 'vis-ltr');
      } else {
        util$2.addClassName(dom.root, 'vis-ltr');
        util$2.removeClassName(dom.root, 'vis-rtl');
      } // update root width and height options


      dom.root.style.maxHeight = util$2.option.asSize(options.maxHeight, '');
      dom.root.style.minHeight = util$2.option.asSize(options.minHeight, '');
      dom.root.style.width = util$2.option.asSize(options.width, '');
      var rootClientHeight = dom.root.clientHeight;
      var rootOffsetHeight = dom.root.offsetHeight;
      var rootOffsetWidth = dom.root.offsetWidth;
      var centerContainerClientHeight = dom.centerContainer.clientHeight; // calculate border widths

      props.border.left = Math.floor((dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2);
      props.border.right = props.border.left;
      props.border.top = Math.floor((dom.centerContainer.offsetHeight - centerContainerClientHeight) / 2);
      props.border.bottom = props.border.top;
      props.borderRootHeight = rootOffsetHeight - rootClientHeight;
      props.borderRootWidth = rootOffsetWidth - dom.root.clientWidth; // workaround for a bug in IE: the clientWidth of an element with
      // a height:0px and overflow:hidden is not calculated and always has value 0

      if (centerContainerClientHeight === 0) {
        props.border.left = props.border.top;
        props.border.right = props.border.left;
      }

      if (rootClientHeight === 0) {
        props.borderRootWidth = props.borderRootHeight;
      } // calculate the heights. If any of the side panels is empty, we set the height to
      // minus the border width, such that the border will be invisible


      props.center.height = dom.center.offsetHeight;
      props.left.height = dom.left.offsetHeight;
      props.right.height = dom.right.offsetHeight;
      props.top.height = dom.top.clientHeight || -props.border.top;
      props.bottom.height = dom.bottom.clientHeight || -props.border.bottom; // TODO: compensate borders when any of the panels is empty.
      // apply auto height
      // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)

      var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
      var autoHeight = props.top.height + contentHeight + props.bottom.height + props.borderRootHeight + props.border.top + props.border.bottom;
      dom.root.style.height = util$2.option.asSize(options.height, "".concat(autoHeight, "px")); // calculate heights of the content panels

      props.root.height = dom.root.offsetHeight;
      props.background.height = props.root.height - props.borderRootHeight;
      var containerHeight = props.root.height - props.top.height - props.bottom.height - props.borderRootHeight;
      props.centerContainer.height = containerHeight;
      props.leftContainer.height = containerHeight;
      props.rightContainer.height = props.leftContainer.height; // calculate the widths of the panels

      props.root.width = rootOffsetWidth;
      props.background.width = props.root.width - props.borderRootWidth;

      if (!this.initialDrawDone) {
        props.scrollbarWidth = util$2.getScrollBarWidth();
      }

      var leftContainerClientWidth = dom.leftContainer.clientWidth;
      var rightContainerClientWidth = dom.rightContainer.clientWidth;

      if (options.verticalScroll) {
        if (options.rtl) {
          props.left.width = leftContainerClientWidth || -props.border.left;
          props.right.width = rightContainerClientWidth + props.scrollbarWidth || -props.border.right;
        } else {
          props.left.width = leftContainerClientWidth + props.scrollbarWidth || -props.border.left;
          props.right.width = rightContainerClientWidth || -props.border.right;
        }
      } else {
        props.left.width = leftContainerClientWidth || -props.border.left;
        props.right.width = rightContainerClientWidth || -props.border.right;
      }

      this._setDOM(); // update the scrollTop, feasible range for the offset can be changed
      // when the height of the Core or of the contents of the center changed


      var offset = this._updateScrollTop(); // reposition the scrollable contents


      if (options.orientation.item != 'top') {
        offset += Math.max(props.centerContainer.height - props.center.height - props.border.top - props.border.bottom, 0);
      }

      dom.center.style.transform = "translateY(".concat(offset, "px)"); // show shadows when vertical scrolling is available

      var visibilityTop = props.scrollTop == 0 ? 'hidden' : '';
      var visibilityBottom = props.scrollTop == props.scrollTopMin ? 'hidden' : '';
      dom.shadowTop.style.visibility = visibilityTop;
      dom.shadowBottom.style.visibility = visibilityBottom;
      dom.shadowTopLeft.style.visibility = visibilityTop;
      dom.shadowBottomLeft.style.visibility = visibilityBottom;
      dom.shadowTopRight.style.visibility = visibilityTop;
      dom.shadowBottomRight.style.visibility = visibilityBottom;

      if (options.verticalScroll) {
        dom.rightContainer.className = 'vis-panel vis-right vis-vertical-scroll';
        dom.leftContainer.className = 'vis-panel vis-left vis-vertical-scroll';
        dom.shadowTopRight.style.visibility = "hidden";
        dom.shadowBottomRight.style.visibility = "hidden";
        dom.shadowTopLeft.style.visibility = "hidden";
        dom.shadowBottomLeft.style.visibility = "hidden";
        dom.left.style.top = '0px';
        dom.right.style.top = '0px';
      }

      if (!options.verticalScroll || props.center.height < props.centerContainer.height) {
        dom.left.style.top = "".concat(offset, "px");
        dom.right.style.top = "".concat(offset, "px");
        dom.rightContainer.className = dom.rightContainer.className.replace(new RegExp('(?:^|\\s)' + 'vis-vertical-scroll' + '(?:\\s|$)'), ' ');
        dom.leftContainer.className = dom.leftContainer.className.replace(new RegExp('(?:^|\\s)' + 'vis-vertical-scroll' + '(?:\\s|$)'), ' ');
        props.left.width = leftContainerClientWidth || -props.border.left;
        props.right.width = rightContainerClientWidth || -props.border.right;

        this._setDOM();
      } // enable/disable vertical panning


      var contentsOverflow = props.center.height > props.centerContainer.height;
      this.hammer.get('pan').set({
        direction: contentsOverflow ? Hammer$1.DIRECTION_ALL : Hammer$1.DIRECTION_HORIZONTAL
      }); // redraw all components

      this.components.forEach(function (component) {
        resized = component.redraw() || resized;
      });
      var MAX_REDRAW = 5;

      if (resized) {
        if (this.redrawCount < MAX_REDRAW) {
          this.body.emitter.emit('_change');
          return;
        } else {
          console.log('WARNING: infinite loop in redraw?');
        }
      } else {
        this.redrawCount = 0;
      } //Emit public 'changed' event for UI updates, see issue #1592


      this.body.emitter.emit("changed");
    }
    /**
     * sets the basic DOM components needed for the timeline\graph2d
     */

  }, {
    key: "_setDOM",
    value: function _setDOM() {
      var props = this.props;
      var dom = this.dom;
      props.leftContainer.width = props.left.width;
      props.rightContainer.width = props.right.width;
      var centerWidth = props.root.width - props.left.width - props.right.width - props.borderRootWidth;
      props.center.width = centerWidth;
      props.centerContainer.width = centerWidth;
      props.top.width = centerWidth;
      props.bottom.width = centerWidth; // resize the panels

      dom.background.style.height = "".concat(props.background.height, "px");
      dom.backgroundVertical.style.height = "".concat(props.background.height, "px");
      dom.backgroundHorizontal.style.height = "".concat(props.centerContainer.height, "px");
      dom.centerContainer.style.height = "".concat(props.centerContainer.height, "px");
      dom.leftContainer.style.height = "".concat(props.leftContainer.height, "px");
      dom.rightContainer.style.height = "".concat(props.rightContainer.height, "px");
      dom.background.style.width = "".concat(props.background.width, "px");
      dom.backgroundVertical.style.width = "".concat(props.centerContainer.width, "px");
      dom.backgroundHorizontal.style.width = "".concat(props.background.width, "px");
      dom.centerContainer.style.width = "".concat(props.center.width, "px");
      dom.top.style.width = "".concat(props.top.width, "px");
      dom.bottom.style.width = "".concat(props.bottom.width, "px"); // reposition the panels

      dom.background.style.left = '0';
      dom.background.style.top = '0';
      dom.backgroundVertical.style.left = "".concat(props.left.width + props.border.left, "px");
      dom.backgroundVertical.style.top = '0';
      dom.backgroundHorizontal.style.left = '0';
      dom.backgroundHorizontal.style.top = "".concat(props.top.height, "px");
      dom.centerContainer.style.left = "".concat(props.left.width, "px");
      dom.centerContainer.style.top = "".concat(props.top.height, "px");
      dom.leftContainer.style.left = '0';
      dom.leftContainer.style.top = "".concat(props.top.height, "px");
      dom.rightContainer.style.left = "".concat(props.left.width + props.center.width, "px");
      dom.rightContainer.style.top = "".concat(props.top.height, "px");
      dom.top.style.left = "".concat(props.left.width, "px");
      dom.top.style.top = '0';
      dom.bottom.style.left = "".concat(props.left.width, "px");
      dom.bottom.style.top = "".concat(props.top.height + props.centerContainer.height, "px");
      dom.center.style.left = '0';
      dom.left.style.left = '0';
      dom.right.style.left = '0';
    }
    /**
     * Set a current time. This can be used for example to ensure that a client's
     * time is synchronized with a shared server time.
     * Only applicable when option `showCurrentTime` is true.
     * @param {Date | string | number} time     A Date, unix timestamp, or
     *                                          ISO date string.
     */

  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(time) {
      if (!this.currentTime) {
        throw new Error('Option showCurrentTime must be true');
      }

      this.currentTime.setCurrentTime(time);
    }
    /**
     * Get the current time.
     * Only applicable when option `showCurrentTime` is true.
     * @return {Date} Returns the current time.
     */

  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      if (!this.currentTime) {
        throw new Error('Option showCurrentTime must be true');
      }

      return this.currentTime.getCurrentTime();
    }
    /**
     * Convert a position on screen (pixels) to a datetime
     * @param {int}     x    Position on the screen in pixels
     * @return {Date}   time The datetime the corresponds with given position x
     * @protected
     * TODO: move this function to Range
     */

  }, {
    key: "_toTime",
    value: function _toTime(x) {
      return toTime(this, x, this.props.center.width);
    }
    /**
     * Convert a position on the global screen (pixels) to a datetime
     * @param {int}     x    Position on the screen in pixels
     * @return {Date}   time The datetime the corresponds with given position x
     * @protected
     * TODO: move this function to Range
     */

  }, {
    key: "_toGlobalTime",
    value: function _toGlobalTime(x) {
      return toTime(this, x, this.props.root.width); //var conversion = this.range.conversion(this.props.root.width);
      //return new Date(x / conversion.scale + conversion.offset);
    }
    /**
     * Convert a datetime (Date object) into a position on the screen
     * @param {Date}   time A date
     * @return {int}   x    The position on the screen in pixels which corresponds
     *                      with the given date.
     * @protected
     * TODO: move this function to Range
     */

  }, {
    key: "_toScreen",
    value: function _toScreen(time) {
      return toScreen(this, time, this.props.center.width);
    }
    /**
     * Convert a datetime (Date object) into a position on the root
     * This is used to get the pixel density estimate for the screen, not the center panel
     * @param {Date}   time A date
     * @return {int}   x    The position on root in pixels which corresponds
     *                      with the given date.
     * @protected
     * TODO: move this function to Range
     */

  }, {
    key: "_toGlobalScreen",
    value: function _toGlobalScreen(time) {
      return toScreen(this, time, this.props.root.width); //var conversion = this.range.conversion(this.props.root.width);
      //return (time.valueOf() - conversion.offset) * conversion.scale;
    }
    /**
     * Initialize watching when option autoResize is true
     * @private
     */

  }, {
    key: "_initAutoResize",
    value: function _initAutoResize() {
      if (this.options.autoResize == true) {
        this._startAutoResize();
      } else {
        this._stopAutoResize();
      }
    }
    /**
     * Watch for changes in the size of the container. On resize, the Panel will
     * automatically redraw itself.
     * @private
     */

  }, {
    key: "_startAutoResize",
    value: function _startAutoResize() {
      var me = this;

      this._stopAutoResize();

      this._onResize = function () {
        if (me.options.autoResize != true) {
          // stop watching when the option autoResize is changed to false
          me._stopAutoResize();

          return;
        }

        if (me.dom.root) {
          var rootOffsetHeight = me.dom.root.offsetHeight;
          var rootOffsetWidth = me.dom.root.offsetWidth; // check whether the frame is resized
          // Note: we compare offsetWidth here, not clientWidth. For some reason,
          // IE does not restore the clientWidth from 0 to the actual width after
          // changing the timeline's container display style from none to visible

          if (rootOffsetWidth != me.props.lastWidth || rootOffsetHeight != me.props.lastHeight) {
            me.props.lastWidth = rootOffsetWidth;
            me.props.lastHeight = rootOffsetHeight;
            me.props.scrollbarWidth = util$2.getScrollBarWidth();
            me.body.emitter.emit('_change');
          }
        }
      }; // add event listener to window resize


      util$2.addEventListener(window, 'resize', this._onResize); //Prevent initial unnecessary redraw

      if (me.dom.root) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;
      }

      this.watchTimer = setInterval(this._onResize, 1000);
    }
    /**
     * Stop watching for a resize of the frame.
     * @private
     */

  }, {
    key: "_stopAutoResize",
    value: function _stopAutoResize() {
      if (this.watchTimer) {
        clearInterval(this.watchTimer);
        this.watchTimer = undefined;
      } // remove event listener on window.resize


      if (this._onResize) {
        util$2.removeEventListener(window, 'resize', this._onResize);
        this._onResize = null;
      }
    }
    /**
     * Start moving the timeline vertically
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onTouch",
    value: function _onTouch(event) {
      // eslint-disable-line no-unused-vars
      this.touch.allowDragging = true;
      this.touch.initialScrollTop = this.props.scrollTop;
    }
    /**
     * Start moving the timeline vertically
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onPinch",
    value: function _onPinch(event) {
      // eslint-disable-line no-unused-vars
      this.touch.allowDragging = false;
    }
    /**
     * Move the timeline vertically
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDrag",
    value: function _onDrag(event) {
      if (!event) return; // refuse to drag when we where pinching to prevent the timeline make a jump
      // when releasing the fingers in opposite order from the touch screen

      if (!this.touch.allowDragging) return;
      var delta = event.deltaY;

      var oldScrollTop = this._getScrollTop();

      var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

      if (this.options.verticalScroll) {
        this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
        this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
      }

      if (newScrollTop != oldScrollTop) {
        this.emit("verticalDrag");
      }
    }
    /**
     * Apply a scrollTop
     * @param {number} scrollTop
     * @returns {number} scrollTop  Returns the applied scrollTop
     * @private
     */

  }, {
    key: "_setScrollTop",
    value: function _setScrollTop(scrollTop) {
      this.props.scrollTop = scrollTop;

      this._updateScrollTop();

      return this.props.scrollTop;
    }
    /**
     * Update the current scrollTop when the height of  the containers has been changed
     * @returns {number} scrollTop  Returns the applied scrollTop
     * @private
     */

  }, {
    key: "_updateScrollTop",
    value: function _updateScrollTop() {
      // recalculate the scrollTopMin
      var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero

      if (scrollTopMin != this.props.scrollTopMin) {
        // in case of bottom orientation, change the scrollTop such that the contents
        // do not move relative to the time axis at the bottom
        if (this.options.orientation.item != 'top') {
          this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
        }

        this.props.scrollTopMin = scrollTopMin;
      } // limit the scrollTop to the feasible scroll range


      if (this.props.scrollTop > 0) this.props.scrollTop = 0;
      if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

      if (this.options.verticalScroll) {
        this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
        this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
      }

      return this.props.scrollTop;
    }
    /**
     * Get the current scrollTop
     * @returns {number} scrollTop
     * @private
     */

  }, {
    key: "_getScrollTop",
    value: function _getScrollTop() {
      return this.props.scrollTop;
    }
    /**
     * Load a configurator
     * [at]returns {Object}
     * @private
     */

  }, {
    key: "_createConfigurator",
    value: function _createConfigurator() {
      throw new Error('Cannot invoke abstract method _createConfigurator');
    }
  }]);

  return Core;
}(); // turn Core into an event emitter


emitterComponent(Core.prototype);
/**
 * A current time bar
 */

var CurrentTime =
/*#__PURE__*/
function (_Component) {
  _inherits(CurrentTime, _Component);
  /**
   * @param {{range: Range, dom: Object, domProps: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {Boolean} [showCurrentTime]
   *                                  {String}  [alignCurrentTime]
   * @constructor CurrentTime
   * @extends Component
   */


  function CurrentTime(body, options) {
    var _this;

    _classCallCheck(this, CurrentTime);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CurrentTime).call(this));
    _this.body = body; // default options

    _this.defaultOptions = {
      rtl: false,
      showCurrentTime: true,
      alignCurrentTime: undefined,
      moment: moment$3,
      locales: locales,
      locale: 'en'
    };
    _this.options = util$2.extend({}, _this.defaultOptions);

    _this.setOptions(options);

    _this.options.locales = util$2.extend({}, locales, _this.options.locales);
    var defaultLocales = _this.defaultOptions.locales[_this.defaultOptions.locale];
    Object.keys(_this.options.locales).forEach(function (locale) {
      _this.options.locales[locale] = util$2.extend({}, defaultLocales, _this.options.locales[locale]);
    });
    _this.offset = 0;

    _this._create();

    return _this;
  }
  /**
   * Create the HTML DOM for the current time bar
   * @private
   */


  _createClass(CurrentTime, [{
    key: "_create",
    value: function _create() {
      var bar = document.createElement('div');
      bar.className = 'vis-current-time';
      bar.style.position = 'absolute';
      bar.style.top = '0px';
      bar.style.height = '100%';
      this.bar = bar;
    }
    /**
     * Destroy the CurrentTime bar
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.options.showCurrentTime = false;
      this.redraw(); // will remove the bar from the DOM and stop refreshing

      this.body = null;
    }
    /**
     * Set options for the component. Options will be merged in current options.
     * @param {Object} options  Available parameters:
     *                          {boolean} [showCurrentTime]
     *                          {String}  [alignCurrentTime]
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        // copy all options that we know
        util$2.selectiveExtend(['rtl', 'showCurrentTime', 'alignCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
      }
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      if (this.options.showCurrentTime) {
        var parent = this.body.dom.backgroundVertical;

        if (this.bar.parentNode != parent) {
          // attach to the dom
          if (this.bar.parentNode) {
            this.bar.parentNode.removeChild(this.bar);
          }

          parent.appendChild(this.bar);
          this.start();
        }

        var now = this.options.moment(Date.now() + this.offset);

        if (this.options.alignCurrentTime) {
          now = now.startOf(this.options.alignCurrentTime);
        }

        var x = this.body.util.toScreen(now);
        var locale = this.options.locales[this.options.locale];

        if (!locale) {
          if (!this.warned) {
            console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
            this.warned = true;
          }

          locale = this.options.locales['en']; // fall back on english when not available
        }

        var title = "".concat(locale.current, " ").concat(locale.time, ": ").concat(now.format('dddd, MMMM Do YYYY, H:mm:ss'));
        title = title.charAt(0).toUpperCase() + title.substring(1);

        if (this.options.rtl) {
          this.bar.style.transform = "translateX(".concat(x * -1, "px)");
        } else {
          this.bar.style.transform = "translateX(".concat(x, "px)");
        }

        this.bar.title = title;
      } else {
        // remove the line from the DOM
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }

        this.stop();
      }

      return false;
    }
    /**
     * Start auto refreshing the current time bar
     */

  }, {
    key: "start",
    value: function start() {
      var me = this;
      /**
       *  Updates the current time.
       */

      function update() {
        me.stop(); // determine interval to refresh

        var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
        var interval = 1 / scale / 10;
        if (interval < 30) interval = 30;
        if (interval > 1000) interval = 1000;
        me.redraw();
        me.body.emitter.emit('currentTimeTick'); // start a renderTimer to adjust for the new time

        me.currentTimeTimer = setTimeout(update, interval);
      }

      update();
    }
    /**
     * Stop auto refreshing the current time bar
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this.currentTimeTimer !== undefined) {
        clearTimeout(this.currentTimeTimer);
        delete this.currentTimeTimer;
      }
    }
    /**
     * Set a current time. This can be used for example to ensure that a client's
     * time is synchronized with a shared server time.
     * @param {Date | string | number} time     A Date, unix timestamp, or
     *                                          ISO date string.
     */

  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(time) {
      var t = util$2.convert(time, 'Date').valueOf();
      var now = Date.now();
      this.offset = t - now;
      this.redraw();
    }
    /**
     * Get the current time.
     * @return {Date} Returns the current time.
     */

  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      return new Date(Date.now() + this.offset);
    }
  }]);

  return CurrentTime;
}(Component);

var $find$1 = arrayIteration.find;
var FIND = 'find';
var SKIPS_HOLES = true; // Shouldn't skip holes

if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES = false;
}); // `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find

_export({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES
}, {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables(FIND);
var iterate_1 = createCommonjsModule(function (module) {
  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }

        return new Result(false);
      }

      iterator = iterFn.call(iterable);
    }

    while (!(step = iterator.next()).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (result && result instanceof Result) return result;
    }

    return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
});

var collection = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var ADDER = IS_MAP ? 'set' : 'add';
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  }; // eslint-disable-next-line max-len


  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    internalMetadata.REQUIRED = true;
  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;

  _export({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var defineProperty$9 = objectDefineProperty.f;
var fastKey = internalMetadata.fastKey;
var setInternalState$3 = internalState.set;
var internalStateGetterFor = internalState.getterFor;
var collectionStrong = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState$3(that, {
        type: CONSTRUCTOR_NAME,
        index: objectCreate(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!descriptors) that.size = 0;
      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (descriptors) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (descriptors) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (descriptors) state.size--;else that.size--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (descriptors) defineProperty$9(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$3(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) entry = entry.previous; // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(CONSTRUCTOR_NAME);
  }
}; // `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects

var es_set = collection('Set', function (get) {
  return function Set() {
    return get(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);
var $includes$1 = arrayIncludes.includes; // `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes

_export({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes$1(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('includes');

var notARegexp = function (it) {
  if (isRegexp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }

  return it;
};

var MATCH$2 = wellKnownSymbol('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH$2] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {
      /* empty */
    }
  }

  return false;
}; // `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes


_export({
  target: 'String',
  proto: true,
  forced: !correctIsRegexpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
}); // Utility functions for ordering and stacking of items


var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */

function orderByStart(items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
}
/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */


function orderByEnd(items) {
  items.sort(function (a, b) {
    var aTime = 'end' in a.data ? a.data.end : a.data.start;
    var bTime = 'end' in b.data ? b.data.end : b.data.start;
    return aTime - bTime;
  });
}
/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 * @param {function} shouldBailItemsRedrawFunction
 *            bailing function
 * @return {boolean} shouldBail
 */


function stack(items, margin, force, shouldBailItemsRedrawFunction) {
  if (force) {
    // reset top position of all items
    for (var i = 0; i < items.length; i++) {
      items[i].top = null;
    }
  } // calculate new, non-overlapping positions


  for (var i = 0; i < items.length; i++) {
    // eslint-disable-line no-redeclare
    var item = items[i];

    if (item.stack && item.top === null) {
      // initialize top position
      item.top = margin.axis;
      var shouldBail = false;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;

        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          shouldBail = shouldBailItemsRedrawFunction() || false;

          if (shouldBail) {
            return true;
          }

          if (other.top !== null && other !== item && other.stack && collision(item, other, margin.item, other.options.rtl)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }

  return shouldBail;
}
/**
 * Adjust vertical positions of the items within a single subgroup such that they 
 * don't overlap each other.
 * @param {Item[]} items
 *            All items withina subgroup
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {subgroup} subgroup
 *            The subgroup that is being stacked 
 */


function substack(items, margin, subgroup) {
  for (var i = 0; i < items.length; i++) {
    items[i].top = null;
  } // Set the initial height


  var subgroupHeight = subgroup.height; // calculate new, non-overlapping positions

  for (i = 0; i < items.length; i++) {
    var item = items[i];

    if (item.stack && item.top === null) {
      // initialize top position
      item.top = item.baseTop; //margin.axis + item.baseTop;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;

        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];

          if (other.top !== null && other !== item
          /*&& other.stack*/
          && collision(item, other, margin.item, other.options.rtl)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical; // + item.baseTop;
        }

        if (item.top + item.height > subgroupHeight) {
          subgroupHeight = item.top + item.height;
        }
      } while (collidingItem);
    }
  } // Set the new height


  subgroup.height = subgroupHeight - subgroup.top + 0.5 * margin.item.vertical;
}
/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {subgroups[]} subgroups
 *            All subgroups
 * @param {boolean} isStackSubgroups
 */


function nostack(items, margin, subgroups, isStackSubgroups) {
  for (var i = 0; i < items.length; i++) {
    if (items[i].data.subgroup == undefined) {
      items[i].top = margin.item.vertical;
    } else if (items[i].data.subgroup !== undefined && isStackSubgroups) {
      var newTop = 0;

      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
            newTop += subgroups[subgroup].height;
            subgroups[items[i].data.subgroup].top = newTop;
          }
        }
      }

      items[i].top = newTop + 0.5 * margin.item.vertical;
    }
  }

  if (!isStackSubgroups) {
    stackSubgroups(items, margin, subgroups);
  }
}
/**
 * Adjust vertical positions of the subgroups such that they don't overlap each
 * other.
 * @param {Array.<timeline.Item>} items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin Margins between items and between items and the axis.
 * @param {subgroups[]} subgroups
 *            All subgroups
 */


function stackSubgroups(items, margin, subgroups) {
  for (var subgroup in subgroups) {
    if (subgroups.hasOwnProperty(subgroup)) {
      subgroups[subgroup].top = 0;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;

        for (var otherSubgroup in subgroups) {
          if (subgroups[otherSubgroup].top !== null && otherSubgroup !== subgroup && subgroups[subgroup].index > subgroups[otherSubgroup].index && collisionByTimes(subgroups[subgroup], subgroups[otherSubgroup])) {
            collidingItem = subgroups[otherSubgroup];
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the subgroups above the colliding element
          subgroups[subgroup].top = collidingItem.top + collidingItem.height;
        }
      } while (collidingItem);
    }
  }

  for (var i = 0; i < items.length; i++) {
    if (items[i].data.subgroup !== undefined) {
      items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;
    }
  }
}
/**
 * Adjust vertical positions of the subgroups such that they don't overlap each
 * other, then stacks the contents of each subgroup individually.
 * @param {Item[]} subgroupItems
 *            All the items in a subgroup
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {subgroups[]} subgroups
 *            All subgroups 
 */


function stackSubgroupsWithInnerStack(subgroupItems, margin, subgroups) {
  var doSubStack = false; // Run subgroups in their order (if any)

  var subgroupOrder = [];

  for (var subgroup in subgroups) {
    if (subgroups[subgroup].hasOwnProperty("index")) {
      subgroupOrder[subgroups[subgroup].index] = subgroup;
    } else {
      subgroupOrder.push(subgroup);
    }
  }

  for (var j = 0; j < subgroupOrder.length; j++) {
    subgroup = subgroupOrder[j];

    if (subgroups.hasOwnProperty(subgroup)) {
      doSubStack = doSubStack || subgroups[subgroup].stack;
      subgroups[subgroup].top = 0;

      for (var otherSubgroup in subgroups) {
        if (subgroups[otherSubgroup].visible && subgroups[subgroup].index > subgroups[otherSubgroup].index) {
          subgroups[subgroup].top += subgroups[otherSubgroup].height;
        }
      }

      var items = subgroupItems[subgroup];

      for (var i = 0; i < items.length; i++) {
        if (items[i].data.subgroup !== undefined) {
          items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;

          if (subgroups[subgroup].stack) {
            items[i].baseTop = items[i].top;
          }
        }
      }

      if (doSubStack && subgroups[subgroup].stack) {
        substack(subgroupItems[subgroup], margin, subgroups[subgroup]);
      }
    }
  }
}
/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @param {boolean} rtl
 * @return {boolean}        true if a and b collide, else false
 */


function collision(a, b, margin, rtl) {
  if (rtl) {
    return a.right - margin.horizontal + EPSILON < b.right + b.width && a.right + a.width + margin.horizontal - EPSILON > b.right && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
  } else {
    return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
  }
}
/**
 * Test if the two provided objects collide
 * The objects must have parameters start, end, top, and height.
 * @param {Object} a          The first Object
 * @param {Object} b          The second Object
 * @return {boolean}        true if a and b collide, else false
 */


function collisionByTimes(a, b) {
  return a.start <= b.start && a.end >= b.start && a.top < b.top + b.height && a.top + a.height > b.top || b.start <= a.start && b.end >= a.start && b.top < a.top + a.height && b.top + b.height > a.top;
}

var stack$1 =
/*#__PURE__*/
Object.freeze({
  orderByStart: orderByStart,
  orderByEnd: orderByEnd,
  stack: stack,
  substack: substack,
  nostack: nostack,
  stackSubgroups: stackSubgroups,
  stackSubgroupsWithInnerStack: stackSubgroupsWithInnerStack,
  collision: collision,
  collisionByTimes: collisionByTimes
});
var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items

var BACKGROUND = '__background__'; // reserved group id for background items without group

var ReservedGroupIds = {
  UNGROUPED: UNGROUPED,
  BACKGROUND: BACKGROUND
  /**
   * @constructor Group
   */

};

var Group =
/*#__PURE__*/
function () {
  /**
  * @param {number | string} groupId
  * @param {Object} data
  * @param {ItemSet} itemSet
  * @constructor Group
  */
  function Group(groupId, data, itemSet) {
    _classCallCheck(this, Group);

    this.groupId = groupId;
    this.subgroups = {};
    this.subgroupStack = {};
    this.subgroupStackAll = false;
    this.subgroupVisibility = {};
    this.doInnerStack = false;
    this.shouldBailStackItems = false;
    this.subgroupIndex = 0;
    this.subgroupOrderer = data && data.subgroupOrder;
    this.itemSet = itemSet;
    this.isVisible = null;
    this.stackDirty = true; // if true, items will be restacked on next redraw

    if (data && data.nestedGroups) {
      this.nestedGroups = data.nestedGroups;

      if (data.showNested == false) {
        this.showNested = false;
      } else {
        this.showNested = true;
      }
    }

    if (data && data.subgroupStack) {
      if (typeof data.subgroupStack === "boolean") {
        this.doInnerStack = data.subgroupStack;
        this.subgroupStackAll = data.subgroupStack;
      } else {
        // We might be doing stacking on specific sub groups, but only
        // if at least one is set to do stacking
        for (var key in data.subgroupStack) {
          this.subgroupStack[key] = data.subgroupStack[key];
          this.doInnerStack = this.doInnerStack || data.subgroupStack[key];
        }
      }
    }

    if (data && data.heightMode) {
      this.heightMode = data.heightMode;
    } else {
      this.heightMode = itemSet.options.groupHeightMode;
    }

    this.nestedInGroup = null;
    this.dom = {};
    this.props = {
      label: {
        width: 0,
        height: 0
      }
    };
    this.className = null;
    this.items = {}; // items filtered by groupId of this group

    this.visibleItems = []; // items currently visible in window

    this.itemsInRange = []; // items currently in range

    this.orderedItems = {
      byStart: [],
      byEnd: []
    };
    this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.

    var me = this;
    this.itemSet.body.emitter.on("checkRangedItems", function () {
      me.checkRangedItems = true;
    });

    this._create();

    this.setData(data);
  }
  /**
   * Create DOM elements for the group
   * @private
   */


  _createClass(Group, [{
    key: "_create",
    value: function _create() {
      var label = document.createElement('div');

      if (this.itemSet.options.groupEditable.order) {
        label.className = 'vis-label draggable';
      } else {
        label.className = 'vis-label';
      }

      this.dom.label = label;
      var inner = document.createElement('div');
      inner.className = 'vis-inner';
      label.appendChild(inner);
      this.dom.inner = inner;
      var foreground = document.createElement('div');
      foreground.className = 'vis-group';
      foreground['vis-group'] = this;
      this.dom.foreground = foreground;
      this.dom.background = document.createElement('div');
      this.dom.background.className = 'vis-group';
      this.dom.axis = document.createElement('div');
      this.dom.axis.className = 'vis-group'; // create a hidden marker to detect when the Timelines container is attached
      // to the DOM, or the style of a parent of the Timeline is changed from
      // display:none is changed to visible.

      this.dom.marker = document.createElement('div');
      this.dom.marker.style.visibility = 'hidden';
      this.dom.marker.style.position = 'absolute';
      this.dom.marker.innerHTML = '';
      this.dom.background.appendChild(this.dom.marker);
    }
    /**
     * Set the group data for this group
     * @param {Object} data   Group data, can contain properties content and className
     */

  }, {
    key: "setData",
    value: function setData(data) {
      if (this.itemSet.groupTouchParams.isDragging) return; // update contents

      var content;
      var templateFunction;

      if (data && data.subgroupVisibility) {
        for (var key in data.subgroupVisibility) {
          this.subgroupVisibility[key] = data.subgroupVisibility[key];
        }
      }

      if (this.itemSet.options && this.itemSet.options.groupTemplate) {
        templateFunction = this.itemSet.options.groupTemplate.bind(this);
        content = templateFunction(data, this.dom.inner);
      } else {
        content = data && data.content;
      }

      if (content instanceof Element) {
        while (this.dom.inner.firstChild) {
          this.dom.inner.removeChild(this.dom.inner.firstChild);
        }

        this.dom.inner.appendChild(content);
      } else if (content instanceof Object && content.isReactComponent) ;else if (content instanceof Object) {
        templateFunction(data, this.dom.inner);
      } else if (content !== undefined && content !== null) {
        this.dom.inner.innerHTML = content;
      } else {
        this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
      } // update title


      this.dom.label.title = data && data.title || '';

      if (!this.dom.inner.firstChild) {
        util$2.addClassName(this.dom.inner, 'vis-hidden');
      } else {
        util$2.removeClassName(this.dom.inner, 'vis-hidden');
      }

      if (data && data.nestedGroups) {
        if (!this.nestedGroups || this.nestedGroups != data.nestedGroups) {
          this.nestedGroups = data.nestedGroups;
        }

        if (data.showNested !== undefined || this.showNested === undefined) {
          if (data.showNested == false) {
            this.showNested = false;
          } else {
            this.showNested = true;
          }
        }

        util$2.addClassName(this.dom.label, 'vis-nesting-group');

        if (this.showNested) {
          util$2.removeClassName(this.dom.label, 'collapsed');
          util$2.addClassName(this.dom.label, 'expanded');
        } else {
          util$2.removeClassName(this.dom.label, 'expanded');
          util$2.addClassName(this.dom.label, 'collapsed');
        }
      } else if (this.nestedGroups) {
        this.nestedGroups = null;
        util$2.removeClassName(this.dom.label, 'collapsed');
        util$2.removeClassName(this.dom.label, 'expanded');
        util$2.removeClassName(this.dom.label, 'vis-nesting-group');
      }

      if (data && (data.treeLevel || data.nestedInGroup)) {
        util$2.addClassName(this.dom.label, 'vis-nested-group');

        if (data.treeLevel) {
          util$2.addClassName(this.dom.label, 'vis-group-level-' + data.treeLevel);
        } else {
          // Nesting level is unknown, but we're sure it's at least 1
          util$2.addClassName(this.dom.label, 'vis-group-level-unknown-but-gte1');
        }
      } else {
        util$2.addClassName(this.dom.label, 'vis-group-level-0');
      } // update className


      var className = data && data.className || null;

      if (className != this.className) {
        if (this.className) {
          util$2.removeClassName(this.dom.label, this.className);
          util$2.removeClassName(this.dom.foreground, this.className);
          util$2.removeClassName(this.dom.background, this.className);
          util$2.removeClassName(this.dom.axis, this.className);
        }

        util$2.addClassName(this.dom.label, className);
        util$2.addClassName(this.dom.foreground, className);
        util$2.addClassName(this.dom.background, className);
        util$2.addClassName(this.dom.axis, className);
        this.className = className;
      } // update style


      if (this.style) {
        util$2.removeCssText(this.dom.label, this.style);
        this.style = null;
      }

      if (data && data.style) {
        util$2.addCssText(this.dom.label, data.style);
        this.style = data.style;
      }
    }
    /**
     * Get the width of the group label
     * @return {number} width
     */

  }, {
    key: "getLabelWidth",
    value: function getLabelWidth() {
      return this.props.label.width;
    }
    /**
     * check if group has had an initial height hange
     * @returns {boolean} 
     */

  }, {
    key: "_didMarkerHeightChange",
    value: function _didMarkerHeightChange() {
      var markerHeight = this.dom.marker.clientHeight;

      if (markerHeight != this.lastMarkerHeight) {
        this.lastMarkerHeight = markerHeight;
        var redrawQueue = {};
        var redrawQueueLength = 0;
        util$2.forEach(this.items, function (item, key) {
          item.dirty = true;

          if (item.displayed) {
            var returnQueue = true;
            redrawQueue[key] = item.redraw(returnQueue);
            redrawQueueLength = redrawQueue[key].length;
          }
        });
        var needRedraw = redrawQueueLength > 0;

        if (needRedraw) {
          var _loop = function _loop(i) {
            util$2.forEach(redrawQueue, function (fns) {
              fns[i]();
            });
          }; // redraw all regular items


          for (var i = 0; i < redrawQueueLength; i++) {
            _loop(i);
          }
        }

        return true;
      } else {
        return false;
      }
    }
    /**
     * calculate group dimentions and position
     * @param {number} pixels
     */

  }, {
    key: "_calculateGroupSizeAndPosition",
    value: function _calculateGroupSizeAndPosition() {
      var _this$dom$foreground = this.dom.foreground,
          offsetTop = _this$dom$foreground.offsetTop,
          offsetLeft = _this$dom$foreground.offsetLeft,
          offsetWidth = _this$dom$foreground.offsetWidth;
      this.top = offsetTop;
      this.right = offsetLeft;
      this.width = offsetWidth;
    }
    /**
     * checks if should bail redraw of items
     * @returns {boolean} should bail 
     */

  }, {
    key: "_shouldBailItemsRedraw",
    value: function _shouldBailItemsRedraw() {
      var me = this;
      var timeoutOptions = this.itemSet.options.onTimeout;
      var bailOptions = {
        relativeBailingTime: this.itemSet.itemsSettingTime,
        bailTimeMs: timeoutOptions && timeoutOptions.timeoutMs,
        userBailFunction: timeoutOptions && timeoutOptions.callback,
        shouldBailStackItems: this.shouldBailStackItems
      };
      var bail = null;

      if (!this.itemSet.initialDrawDone) {
        if (bailOptions.shouldBailStackItems) {
          return true;
        }

        if (Math.abs(Date.now() - new Date(bailOptions.relativeBailingTime)) > bailOptions.bailTimeMs) {
          if (bailOptions.userBailFunction && this.itemSet.userContinueNotBail == null) {
            bailOptions.userBailFunction(function (didUserContinue) {
              me.itemSet.userContinueNotBail = didUserContinue;
              bail = !didUserContinue;
            });
          } else if (me.itemSet.userContinueNotBail == false) {
            bail = true;
          } else {
            bail = false;
          }
        }
      }

      return bail;
    }
    /**
     * redraws items
     * @param {boolean} forceRestack
     * @param {boolean} lastIsVisible
     * @param {number} margin
     * @param {object} range
     * @private
     */

  }, {
    key: "_redrawItems",
    value: function _redrawItems(forceRestack, lastIsVisible, margin, range) {
      var _this = this;

      var restack = forceRestack || this.stackDirty || this.isVisible && !lastIsVisible; // if restacking, reposition visible items vertically

      if (restack) {
        var orderedItems = {
          byEnd: this.orderedItems.byEnd.filter(function (item) {
            return !item.isCluster;
          }),
          byStart: this.orderedItems.byStart.filter(function (item) {
            return !item.isCluster;
          })
        };
        var orderedClusters = {
          byEnd: _toConsumableArray(new Set(this.orderedItems.byEnd.map(function (item) {
            return item.cluster;
          }).filter(function (item) {
            return !!item;
          }))),
          byStart: _toConsumableArray(new Set(this.orderedItems.byStart.map(function (item) {
            return item.cluster;
          }).filter(function (item) {
            return !!item;
          })))
          /**
          * Get all visible items in range
          * @return {array} items
          */

        };

        var getVisibleItems = function getVisibleItems() {
          var visibleItems = _this._updateItemsInRange(orderedItems, _this.visibleItems.filter(function (item) {
            return !item.isCluster;
          }), range);

          var visibleClusters = _this._updateClustersInRange(orderedClusters, _this.visibleItems.filter(function (item) {
            return item.isCluster;
          }), range);

          return [].concat(_toConsumableArray(visibleItems), _toConsumableArray(visibleClusters));
        };
        /**
         * Get visible items grouped by subgroup
         * @param {function} orderFn An optional function to order items inside the subgroups
         * @return {Object}
         */


        var getVisibleItemsGroupedBySubgroup = function getVisibleItemsGroupedBySubgroup(orderFn) {
          var visibleSubgroupsItems = {};

          var _loop2 = function _loop2(subgroup) {
            var items = _this.visibleItems.filter(function (item) {
              return item.data.subgroup === subgroup;
            });

            visibleSubgroupsItems[subgroup] = orderFn ? items.sort(function (a, b) {
              return orderFn(a.data, b.data);
            }) : items;
          };

          for (var subgroup in _this.subgroups) {
            _loop2(subgroup);
          }

          return visibleSubgroupsItems;
        };

        if (typeof this.itemSet.options.order === 'function') {
          // a custom order function
          //show all items
          var me = this;

          if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
            // Order the items within each subgroup
            var visibleSubgroupsItems = getVisibleItemsGroupedBySubgroup(this.itemSet.options.order);
            stackSubgroupsWithInnerStack(visibleSubgroupsItems, margin, this.subgroups);
            this.visibleItems = getVisibleItems();

            this._updateSubGroupHeights(margin);
          } else {
            this.visibleItems = getVisibleItems();

            this._updateSubGroupHeights(margin); // order all items and force a restacking
            // order all items outside clusters and force a restacking


            var customOrderedItems = this.visibleItems.slice().filter(function (item) {
              return item.isCluster || !item.isCluster && !item.cluster;
            }).sort(function (a, b) {
              return me.itemSet.options.order(a.data, b.data);
            });
            this.shouldBailStackItems = stack(customOrderedItems, margin, true, this._shouldBailItemsRedraw.bind(this));
          }
        } else {
          // no custom order function, lazy stacking
          this.visibleItems = getVisibleItems();

          this._updateSubGroupHeights(margin);

          if (this.itemSet.options.stack) {
            if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
              var _visibleSubgroupsItems = getVisibleItemsGroupedBySubgroup();

              stackSubgroupsWithInnerStack(_visibleSubgroupsItems, margin, this.subgroups);
            } else {
              // TODO: ugly way to access options...
              this.shouldBailStackItems = stack(this.visibleItems, margin, true, this._shouldBailItemsRedraw.bind(this));
            }
          } else {
            // no stacking
            nostack(this.visibleItems, margin, this.subgroups, this.itemSet.options.stackSubgroups);
          }
        }

        for (var i = 0; i < this.visibleItems.length; i++) {
          this.visibleItems[i].repositionX();

          if (this.subgroupVisibility[this.visibleItems[i].data.subgroup] !== undefined) {
            if (!this.subgroupVisibility[this.visibleItems[i].data.subgroup]) {
              this.visibleItems[i].hide();
            }
          }
        }

        if (this.itemSet.options.cluster) {
          util$2.forEach(this.items, function (item) {
            if (item.cluster && item.displayed) {
              item.hide();
            }
          });
        }

        if (this.shouldBailStackItems) {
          this.itemSet.body.emitter.emit('destroyTimeline');
        }

        this.stackDirty = false;
      }
    }
    /**
     * check if group resized
     * @param {boolean} resized
     * @param {number} height
     * @return {boolean} did resize
     */

  }, {
    key: "_didResize",
    value: function _didResize(resized, height) {
      resized = util$2.updateProperty(this, 'height', height) || resized; // recalculate size of label

      var labelWidth = this.dom.inner.clientWidth;
      var labelHeight = this.dom.inner.clientHeight;
      resized = util$2.updateProperty(this.props.label, 'width', labelWidth) || resized;
      resized = util$2.updateProperty(this.props.label, 'height', labelHeight) || resized;
      return resized;
    }
    /**
     * apply group height
     * @param {number} height
     */

  }, {
    key: "_applyGroupHeight",
    value: function _applyGroupHeight(height) {
      this.dom.background.style.height = "".concat(height, "px");
      this.dom.foreground.style.height = "".concat(height, "px");
      this.dom.label.style.height = "".concat(height, "px");
    }
    /**
     * update vertical position of items after they are re-stacked and the height of the group is calculated
     * @param {number} margin
     */

  }, {
    key: "_updateItemsVerticalPosition",
    value: function _updateItemsVerticalPosition(margin) {
      for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
        var item = this.visibleItems[i];
        item.repositionY(margin);

        if (!this.isVisible && this.groupId != ReservedGroupIds.BACKGROUND) {
          if (item.displayed) item.hide();
        }
      }
    }
    /**
     * Repaint this group
     * @param {{start: number, end: number}} range
     * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
     * @param {boolean} [forceRestack=false]  Force restacking of all items
     * @param {boolean} [returnQueue=false]  return the queue or if the group resized
     * @return {boolean} Returns true if the group is resized or the redraw queue if returnQueue=true
     */

  }, {
    key: "redraw",
    value: function redraw(range, margin, forceRestack, returnQueue) {
      var _this2 = this;

      var resized = false;
      var lastIsVisible = this.isVisible;
      var height;
      var queue = [function () {
        forceRestack = _this2._didMarkerHeightChange.call(_this2) || forceRestack;
      }, // recalculate the height of the subgroups
      this._updateSubGroupHeights.bind(this, margin), // calculate actual size and position
      this._calculateGroupSizeAndPosition.bind(this), function () {
        _this2.isVisible = _this2._isGroupVisible.bind(_this2)(range, margin);
      }, function () {
        _this2._redrawItems.bind(_this2)(forceRestack, lastIsVisible, margin, range);
      }, // update subgroups
      this._updateSubgroupsSizes.bind(this), function () {
        height = _this2._calculateHeight.bind(_this2)(margin);
      }, // calculate actual size and position again
      this._calculateGroupSizeAndPosition.bind(this), function () {
        resized = _this2._didResize.bind(_this2)(resized, height);
      }, function () {
        _this2._applyGroupHeight.bind(_this2)(height);
      }, function () {
        _this2._updateItemsVerticalPosition.bind(_this2)(margin);
      }, function () {
        if (!_this2.isVisible && _this2.height) {
          resized = false;
        }

        return resized;
      }.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * recalculate the height of the subgroups
     *
     * @param {{item: timeline.Item}} margin
     * @private
     */

  }, {
    key: "_updateSubGroupHeights",
    value: function _updateSubGroupHeights(margin) {
      var _this3 = this;

      if (Object.keys(this.subgroups).length > 0) {
        var me = this;

        this._resetSubgroups();

        util$2.forEach(this.visibleItems, function (item) {
          if (item.data.subgroup !== undefined) {
            me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height + margin.item.vertical);
            me.subgroups[item.data.subgroup].visible = typeof _this3.subgroupVisibility[item.data.subgroup] === 'undefined' ? true : Boolean(_this3.subgroupVisibility[item.data.subgroup]);
          }
        });
      }
    }
    /**
     * check if group is visible
     *
     * @param {timeline.Range} range
     * @param {{axis: timeline.DataAxis}} margin
     * @returns {boolean} is visible
     * @private
     */

  }, {
    key: "_isGroupVisible",
    value: function _isGroupVisible(range, margin) {
      return this.top <= range.body.domProps.centerContainer.height - range.body.domProps.scrollTop + margin.axis && this.top + this.height + margin.axis >= -range.body.domProps.scrollTop;
    }
    /**
     * recalculate the height of the group
     * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
     * @returns {number} Returns the height
     * @private
     */

  }, {
    key: "_calculateHeight",
    value: function _calculateHeight(margin) {
      // recalculate the height of the group
      var height;
      var items;

      if (this.heightMode === 'fixed') {
        items = util$2.toArray(this.items);
      } else {
        // default or 'auto'
        items = this.visibleItems;
      }

      if (items.length > 0) {
        var min = items[0].top;
        var max = items[0].top + items[0].height;
        util$2.forEach(items, function (item) {
          min = Math.min(min, item.top);
          max = Math.max(max, item.top + item.height);
        });

        if (min > margin.axis) {
          // there is an empty gap between the lowest item and the axis
          var offset = min - margin.axis;
          max -= offset;
          util$2.forEach(items, function (item) {
            item.top -= offset;
          });
        }

        height = Math.ceil(max + margin.item.vertical / 2);

        if (this.heightMode !== "fitItems") {
          height = Math.max(height, this.props.label.height);
        }
      } else {
        height = this.props.label.height;
      }

      return height;
    }
    /**
     * Show this group: attach to the DOM
     */

  }, {
    key: "show",
    value: function show() {
      if (!this.dom.label.parentNode) {
        this.itemSet.dom.labelSet.appendChild(this.dom.label);
      }

      if (!this.dom.foreground.parentNode) {
        this.itemSet.dom.foreground.appendChild(this.dom.foreground);
      }

      if (!this.dom.background.parentNode) {
        this.itemSet.dom.background.appendChild(this.dom.background);
      }

      if (!this.dom.axis.parentNode) {
        this.itemSet.dom.axis.appendChild(this.dom.axis);
      }
    }
    /**
     * Hide this group: remove from the DOM
     */

  }, {
    key: "hide",
    value: function hide() {
      var label = this.dom.label;

      if (label.parentNode) {
        label.parentNode.removeChild(label);
      }

      var foreground = this.dom.foreground;

      if (foreground.parentNode) {
        foreground.parentNode.removeChild(foreground);
      }

      var background = this.dom.background;

      if (background.parentNode) {
        background.parentNode.removeChild(background);
      }

      var axis = this.dom.axis;

      if (axis.parentNode) {
        axis.parentNode.removeChild(axis);
      }
    }
    /**
     * Add an item to the group
     * @param {Item} item
     */

  }, {
    key: "add",
    value: function add(item) {
      this.items[item.id] = item;
      item.setParent(this);
      this.stackDirty = true; // add to

      if (item.data.subgroup !== undefined) {
        this._addToSubgroup(item);

        this.orderSubgroups();
      }

      if (!this.visibleItems.includes(item)) {
        var range = this.itemSet.body.range; // TODO: not nice accessing the range like this

        this._checkIfVisible(item, this.visibleItems, range);
      }
    }
    /**
     * add item to subgroup
     * @param {object} item
     * @param {string} subgroupId
     */

  }, {
    key: "_addToSubgroup",
    value: function _addToSubgroup(item) {
      var subgroupId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : item.data.subgroup;

      if (subgroupId != undefined && this.subgroups[subgroupId] === undefined) {
        this.subgroups[subgroupId] = {
          height: 0,
          top: 0,
          start: item.data.start,
          end: item.data.end || item.data.start,
          visible: false,
          index: this.subgroupIndex,
          items: [],
          stack: this.subgroupStackAll || this.subgroupStack[subgroupId] || false
        };
        this.subgroupIndex++;
      }

      if (new Date(item.data.start) < new Date(this.subgroups[subgroupId].start)) {
        this.subgroups[subgroupId].start = item.data.start;
      }

      var itemEnd = item.data.end || item.data.start;

      if (new Date(itemEnd) > new Date(this.subgroups[subgroupId].end)) {
        this.subgroups[subgroupId].end = itemEnd;
      }

      this.subgroups[subgroupId].items.push(item);
    }
    /**
     * update subgroup sizes
     */

  }, {
    key: "_updateSubgroupsSizes",
    value: function _updateSubgroupsSizes() {
      var me = this;

      if (me.subgroups) {
        var _loop3 = function _loop3(subgroup) {
          var initialEnd = me.subgroups[subgroup].items[0].data.end || me.subgroups[subgroup].items[0].data.start;
          var newStart = me.subgroups[subgroup].items[0].data.start;
          var newEnd = initialEnd - 1;
          me.subgroups[subgroup].items.forEach(function (item) {
            if (new Date(item.data.start) < new Date(newStart)) {
              newStart = item.data.start;
            }

            var itemEnd = item.data.end || item.data.start;

            if (new Date(itemEnd) > new Date(newEnd)) {
              newEnd = itemEnd;
            }
          });
          me.subgroups[subgroup].start = newStart;
          me.subgroups[subgroup].end = new Date(newEnd - 1); // -1 to compensate for colliding end to start subgroups;
        };

        for (var subgroup in me.subgroups) {
          _loop3(subgroup);
        }
      }
    }
    /**
     * order subgroups
     */

  }, {
    key: "orderSubgroups",
    value: function orderSubgroups() {
      if (this.subgroupOrderer !== undefined) {
        var sortArray = [];

        if (typeof this.subgroupOrderer == 'string') {
          for (var subgroup in this.subgroups) {
            sortArray.push({
              subgroup: subgroup,
              sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer]
            });
          }

          sortArray.sort(function (a, b) {
            return a.sortField - b.sortField;
          });
        } else if (typeof this.subgroupOrderer == 'function') {
          for (var _subgroup in this.subgroups) {
            sortArray.push(this.subgroups[_subgroup].items[0].data);
          }

          sortArray.sort(this.subgroupOrderer);
        }

        if (sortArray.length > 0) {
          for (var i = 0; i < sortArray.length; i++) {
            this.subgroups[sortArray[i].subgroup].index = i;
          }
        }
      }
    }
    /**
     * add item to subgroup
     */

  }, {
    key: "_resetSubgroups",
    value: function _resetSubgroups() {
      for (var subgroup in this.subgroups) {
        if (this.subgroups.hasOwnProperty(subgroup)) {
          this.subgroups[subgroup].visible = false;
          this.subgroups[subgroup].height = 0;
        }
      }
    }
    /**
     * Remove an item from the group
     * @param {Item} item
     */

  }, {
    key: "remove",
    value: function remove(item) {
      delete this.items[item.id];
      item.setParent(null);
      this.stackDirty = true; // remove from visible items

      var index = this.visibleItems.indexOf(item);
      if (index != -1) this.visibleItems.splice(index, 1);

      if (item.data.subgroup !== undefined) {
        this._removeFromSubgroup(item);

        this.orderSubgroups();
      }
    }
    /**
     * remove item from subgroup
     * @param {object} item
     * @param {string} subgroupId
     */

  }, {
    key: "_removeFromSubgroup",
    value: function _removeFromSubgroup(item) {
      var subgroupId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : item.data.subgroup;

      if (subgroupId != undefined) {
        var subgroup = this.subgroups[subgroupId];

        if (subgroup) {
          var itemIndex = subgroup.items.indexOf(item); //  Check the item is actually in this subgroup. How should items not in the group be handled?

          if (itemIndex >= 0) {
            subgroup.items.splice(itemIndex, 1);

            if (!subgroup.items.length) {
              delete this.subgroups[subgroupId];
            } else {
              this._updateSubgroupsSizes();
            }
          }
        }
      }
    }
    /**
     * Remove an item from the corresponding DataSet
     * @param {Item} item
     */

  }, {
    key: "removeFromDataSet",
    value: function removeFromDataSet(item) {
      this.itemSet.removeItem(item.id);
    }
    /**
     * Reorder the items
     */

  }, {
    key: "order",
    value: function order() {
      var array = util$2.toArray(this.items);
      var startArray = [];
      var endArray = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i].data.end !== undefined) {
          endArray.push(array[i]);
        }

        startArray.push(array[i]);
      }

      this.orderedItems = {
        byStart: startArray,
        byEnd: endArray
      };
      orderByStart(this.orderedItems.byStart);
      orderByEnd(this.orderedItems.byEnd);
    }
    /**
     * Update the visible items
     * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
     * @param {Item[]} oldVisibleItems                          The previously visible items.
     * @param {{start: number, end: number}} range              Visible range
     * @return {Item[]} visibleItems                            The new visible items.
     * @private
     */

  }, {
    key: "_updateItemsInRange",
    value: function _updateItemsInRange(orderedItems, oldVisibleItems, range) {
      var visibleItems = [];
      var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems

      if (!this.isVisible && this.groupId != ReservedGroupIds.BACKGROUND) {
        for (var i = 0; i < oldVisibleItems.length; i++) {
          var item = oldVisibleItems[i];
          if (item.displayed) item.hide();
        }

        return visibleItems;
      }

      var interval = (range.end - range.start) / 4;
      var lowerBound = range.start - interval;
      var upperBound = range.end + interval; // this function is used to do the binary search for items having start date only.

      var startSearchFunction = function startSearchFunction(value) {
        if (value < lowerBound) {
          return -1;
        } else if (value <= upperBound) {
          return 0;
        } else {
          return 1;
        }
      }; // this function is used to do the binary search for items having start and end dates (range).


      var endSearchFunction = function endSearchFunction(value) {
        if (value < lowerBound) {
          return -1;
        } else {
          return 0;
        }
      }; // first check if the items that were in view previously are still in view.
      // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
      // also cleans up invisible items.


      if (oldVisibleItems.length > 0) {
        for (var _i = 0; _i < oldVisibleItems.length; _i++) {
          this._checkIfVisibleWithReference(oldVisibleItems[_i], visibleItems, visibleItemsLookup, range);
        }
      } // we do a binary search for the items that have only start values.


      var initialPosByStart = util$2.binarySearchCustom(orderedItems.byStart, startSearchFunction, 'data', 'start'); // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.

      this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
        return item.data.start < lowerBound || item.data.start > upperBound;
      }); // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
      // We therefore have to brute force check all items in the byEnd list


      if (this.checkRangedItems == true) {
        this.checkRangedItems = false;

        for (var _i2 = 0; _i2 < orderedItems.byEnd.length; _i2++) {
          this._checkIfVisibleWithReference(orderedItems.byEnd[_i2], visibleItems, visibleItemsLookup, range);
        }
      } else {
        // we do a binary search for the items that have defined end times.
        var initialPosByEnd = util$2.binarySearchCustom(orderedItems.byEnd, endSearchFunction, 'data', 'end'); // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.

        this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
          return item.data.end < lowerBound || item.data.start > upperBound;
        });
      }

      var redrawQueue = {};
      var redrawQueueLength = 0;

      for (var _i3 = 0; _i3 < visibleItems.length; _i3++) {
        var _item = visibleItems[_i3];

        if (!_item.displayed) {
          var returnQueue = true;
          redrawQueue[_i3] = _item.redraw(returnQueue);
          redrawQueueLength = redrawQueue[_i3].length;
        }
      }

      var needRedraw = redrawQueueLength > 0;

      if (needRedraw) {
        var _loop4 = function _loop4(j) {
          util$2.forEach(redrawQueue, function (fns) {
            fns[j]();
          });
        }; // redraw all regular items


        for (var j = 0; j < redrawQueueLength; j++) {
          _loop4(j);
        }
      }

      for (var _i4 = 0; _i4 < visibleItems.length; _i4++) {
        visibleItems[_i4].repositionX();
      }

      return visibleItems;
    }
    /**
     * trace visible items in group
     * @param {number} initialPos
     * @param {array} items
     * @param {aray} visibleItems
     * @param {object} visibleItemsLookup
     * @param {function} breakCondition
     */

  }, {
    key: "_traceVisible",
    value: function _traceVisible(initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
      if (initialPos != -1) {
        for (var i = initialPos; i >= 0; i--) {
          var item = items[i];

          if (breakCondition(item)) {
            break;
          } else {
            if (!(item.isCluster && !item.hasItems()) && !item.cluster) {
              if (visibleItemsLookup[item.id] === undefined) {
                visibleItemsLookup[item.id] = true;
                visibleItems.push(item);
              }
            }
          }
        }

        for (var _i5 = initialPos + 1; _i5 < items.length; _i5++) {
          var _item2 = items[_i5];

          if (breakCondition(_item2)) {
            break;
          } else {
            if (!(_item2.isCluster && !_item2.hasItems()) && !_item2.cluster) {
              if (visibleItemsLookup[_item2.id] === undefined) {
                visibleItemsLookup[_item2.id] = true;
                visibleItems.push(_item2);
              }
            }
          }
        }
      }
    }
    /**
     * this function is very similar to the _checkIfInvisible() but it does not
     * return booleans, hides the item if it should not be seen and always adds to
     * the visibleItems.
     * this one is for brute forcing and hiding.
     *
     * @param {Item} item
     * @param {Array} visibleItems
     * @param {{start:number, end:number}} range
     * @private
     */

  }, {
    key: "_checkIfVisible",
    value: function _checkIfVisible(item, visibleItems, range) {
      if (item.isVisible(range)) {
        if (!item.displayed) item.show(); // reposition item horizontally

        item.repositionX();
        visibleItems.push(item);
      } else {
        if (item.displayed) item.hide();
      }
    }
    /**
     * this function is very similar to the _checkIfInvisible() but it does not
     * return booleans, hides the item if it should not be seen and always adds to
     * the visibleItems.
     * this one is for brute forcing and hiding.
     *
     * @param {Item} item
     * @param {Array.<timeline.Item>} visibleItems
     * @param {Object<number, boolean>} visibleItemsLookup
     * @param {{start:number, end:number}} range
     * @private
     */

  }, {
    key: "_checkIfVisibleWithReference",
    value: function _checkIfVisibleWithReference(item, visibleItems, visibleItemsLookup, range) {
      if (item.isVisible(range)) {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      } else {
        if (item.displayed) item.hide();
      }
    }
    /**
     * Update the visible items
     * @param {array} orderedClusters 
     * @param {array} oldVisibleClusters                         
     * @param {{start: number, end: number}} range             
     * @return {Item[]} visibleItems                            
     * @private
     */

  }, {
    key: "_updateClustersInRange",
    value: function _updateClustersInRange(orderedClusters, oldVisibleClusters, range) {
      // Clusters can overlap each other so we cannot use binary search here
      var visibleClusters = [];
      var visibleClustersLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems

      if (oldVisibleClusters.length > 0) {
        for (var i = 0; i < oldVisibleClusters.length; i++) {
          this._checkIfVisibleWithReference(oldVisibleClusters[i], visibleClusters, visibleClustersLookup, range);
        }
      }

      for (var _i6 = 0; _i6 < orderedClusters.byStart.length; _i6++) {
        this._checkIfVisibleWithReference(orderedClusters.byStart[_i6], visibleClusters, visibleClustersLookup, range);
      }

      for (var _i7 = 0; _i7 < orderedClusters.byEnd.length; _i7++) {
        this._checkIfVisibleWithReference(orderedClusters.byEnd[_i7], visibleClusters, visibleClustersLookup, range);
      }

      var redrawQueue = {};
      var redrawQueueLength = 0;

      for (var _i8 = 0; _i8 < visibleClusters.length; _i8++) {
        var item = visibleClusters[_i8];

        if (!item.displayed) {
          var returnQueue = true;
          redrawQueue[_i8] = item.redraw(returnQueue);
          redrawQueueLength = redrawQueue[_i8].length;
        }
      }

      var needRedraw = redrawQueueLength > 0;

      if (needRedraw) {
        // redraw all regular items
        for (var j = 0; j < redrawQueueLength; j++) {
          util$2.forEach(redrawQueue, function (fns) {
            fns[j]();
          });
        }
      }

      for (var _i9 = 0; _i9 < visibleClusters.length; _i9++) {
        visibleClusters[_i9].repositionX();
      }

      return visibleClusters;
    }
    /**
     * change item subgroup
     * @param {object} item
     * @param {string} oldSubgroup
     * @param {string} newSubgroup
     */

  }, {
    key: "changeSubgroup",
    value: function changeSubgroup(item, oldSubgroup, newSubgroup) {
      this._removeFromSubgroup(item, oldSubgroup);

      this._addToSubgroup(item, newSubgroup);

      this.orderSubgroups();
    }
  }]);

  return Group;
}();
/**
 * @constructor BackgroundGroup
 * @extends Group
 */


var BackgroundGroup =
/*#__PURE__*/
function (_Group) {
  _inherits(BackgroundGroup, _Group);
  /**
  * @param {number | string} groupId
  * @param {Object} data
  * @param {ItemSet} itemSet
  */


  function BackgroundGroup(groupId, data, itemSet) {
    var _this;

    _classCallCheck(this, BackgroundGroup);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BackgroundGroup).call(this, groupId, data, itemSet)); // Group.call(this, groupId, data, itemSet);

    _this.width = 0;
    _this.height = 0;
    _this.top = 0;
    _this.left = 0;
    return _this;
  }
  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [forceRestack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */


  _createClass(BackgroundGroup, [{
    key: "redraw",
    value: function redraw(range, margin, forceRestack) {
      // eslint-disable-line no-unused-vars
      var resized = false;
      this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, range); // calculate actual size

      this.width = this.dom.background.offsetWidth; // apply new height (just always zero for BackgroundGroup

      this.dom.background.style.height = '0'; // update vertical position of items after they are re-stacked and the height of the group is calculated

      for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
        var item = this.visibleItems[i];
        item.repositionY(margin);
      }

      return resized;
    }
    /**
     * Show this group: attach to the DOM
     */

  }, {
    key: "show",
    value: function show() {
      if (!this.dom.background.parentNode) {
        this.itemSet.dom.background.appendChild(this.dom.background);
      }
    }
  }]);

  return BackgroundGroup;
}(Group);
/**
 * Item
 */


var Item =
/*#__PURE__*/
function () {
  /**
  * @constructor Item
  * @param {Object} data             Object containing (optional) parameters type,
  *                                  start, end, content, group, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} options          Configuration options
  *                                  // TODO: describe available options
  */
  function Item(data, conversion, options) {
    var _this = this;

    _classCallCheck(this, Item);

    this.id = null;
    this.parent = null;
    this.data = data;
    this.dom = null;
    this.conversion = conversion || {};
    this.defaultOptions = {
      locales: locales,
      locale: 'en'
    };
    this.options = util$2.extend({}, this.defaultOptions, options);
    this.options.locales = util$2.extend({}, locales, this.options.locales);
    var defaultLocales = this.defaultOptions.locales[this.defaultOptions.locale];
    Object.keys(this.options.locales).forEach(function (locale) {
      _this.options.locales[locale] = util$2.extend({}, defaultLocales, _this.options.locales[locale]);
    });
    this.selected = false;
    this.displayed = false;
    this.groupShowing = true;
    this.selectable = options && options.selectable || false;
    this.dirty = true;
    this.top = null;
    this.right = null;
    this.left = null;
    this.width = null;
    this.height = null;
    this.setSelectability(data);
    this.editable = null;

    this._updateEditStatus();
  }
  /**
   * Select current item
   */


  _createClass(Item, [{
    key: "select",
    value: function select() {
      if (this.selectable) {
        this.selected = true;
        this.dirty = true;
        if (this.displayed) this.redraw();
      }
    }
    /**
     * Unselect current item
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
      this.dirty = true;
      if (this.displayed) this.redraw();
    }
    /**
     * Set data for the item. Existing data will be updated. The id should not
     * be changed. When the item is displayed, it will be redrawn immediately.
     * @param {Object} data
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var groupChanged = data.group != undefined && this.data.group != data.group;

      if (groupChanged && this.parent != null) {
        this.parent.itemSet._moveToGroup(this, data.group);
      }

      this.setSelectability(data);

      if (this.parent) {
        this.parent.stackDirty = true;
      }

      var subGroupChanged = data.subgroup != undefined && this.data.subgroup != data.subgroup;

      if (subGroupChanged && this.parent != null) {
        this.parent.changeSubgroup(this, this.data.subgroup, data.subgroup);
      }

      this.data = data;

      this._updateEditStatus();

      this.dirty = true;
      if (this.displayed) this.redraw();
    }
    /**
     * Set whether the item can be selected.
     * Can only be set/unset if the timeline's `selectable` configuration option is `true`.
     * @param {Object} data `data` from `constructor` and `setData`
     */

  }, {
    key: "setSelectability",
    value: function setSelectability(data) {
      if (data) {
        this.selectable = typeof data.selectable === 'undefined' ? true : Boolean(data.selectable);
      }
    }
    /**
     * Set a parent for the item
     * @param {Group} parent
     */

  }, {
    key: "setParent",
    value: function setParent(parent) {
      if (this.displayed) {
        this.hide();
        this.parent = parent;

        if (this.parent) {
          this.show();
        }
      } else {
        this.parent = parent;
      }
    }
    /**
     * Check whether this item is visible inside given range
     * @param {timeline.Range} range with a timestamp for start and end
     * @returns {boolean} True if visible
     */

  }, {
    key: "isVisible",
    value: function isVisible(range) {
      // eslint-disable-line no-unused-vars
      return false;
    }
    /**
     * Show the Item in the DOM (when not already visible)
     * @return {Boolean} changed
     */

  }, {
    key: "show",
    value: function show() {
      return false;
    }
    /**
     * Hide the Item from the DOM (when visible)
     * @return {Boolean} changed
     */

  }, {
    key: "hide",
    value: function hide() {
      return false;
    }
    /**
     * Repaint the item
     */

  }, {
    key: "redraw",
    value: function redraw() {} // should be implemented by the item

    /**
     * Reposition the Item horizontally
     */

  }, {
    key: "repositionX",
    value: function repositionX() {} // should be implemented by the item

    /**
     * Reposition the Item vertically
     */

  }, {
    key: "repositionY",
    value: function repositionY() {} // should be implemented by the item

    /**
     * Repaint a drag area on the center of the item when the item is selected
     * @protected
     */

  }, {
    key: "_repaintDragCenter",
    value: function _repaintDragCenter() {
      if (this.selected && this.options.editable.updateTime && !this.dom.dragCenter) {
        var me = this; // create and show drag area

        var dragCenter = document.createElement('div');
        dragCenter.className = 'vis-drag-center';
        dragCenter.dragCenterItem = this;
        this.hammerDragCenter = new Hammer$1(dragCenter);
        this.hammerDragCenter.on('tap', function (event) {
          me.parent.itemSet.body.emitter.emit('click', {
            event: event,
            item: me.id
          });
        });
        this.hammerDragCenter.on('doubletap', function (event) {
          event.stopPropagation();

          me.parent.itemSet._onUpdateItem(me);

          me.parent.itemSet.body.emitter.emit('doubleClick', {
            event: event,
            item: me.id
          });
        });
        this.hammerDragCenter.on('panstart', me.parent.itemSet._onDragStart.bind(me.parent.itemSet));
        this.hammerDragCenter.on('panmove', me.parent.itemSet._onDrag.bind(me.parent.itemSet));
        this.hammerDragCenter.on('panend', me.parent.itemSet._onDragEnd.bind(me.parent.itemSet));

        if (this.dom.box) {
          if (this.dom.dragLeft) {
            this.dom.box.insertBefore(dragCenter, this.dom.dragLeft);
          } else {
            this.dom.box.appendChild(dragCenter);
          }
        } else if (this.dom.point) {
          this.dom.point.appendChild(dragCenter);
        }

        this.dom.dragCenter = dragCenter;
      } else if (!this.selected && this.dom.dragCenter) {
        // delete drag area
        if (this.dom.dragCenter.parentNode) {
          this.dom.dragCenter.parentNode.removeChild(this.dom.dragCenter);
        }

        this.dom.dragCenter = null;

        if (this.hammerDragCenter) {
          this.hammerDragCenter.destroy();
          this.hammerDragCenter = null;
        }
      }
    }
    /**
     * Repaint a delete button on the top right of the item when the item is selected
     * @param {HTMLElement} anchor
     * @protected
     */

  }, {
    key: "_repaintDeleteButton",
    value: function _repaintDeleteButton(anchor) {
      var editable = (this.options.editable.overrideItems || this.editable == null) && this.options.editable.remove || !this.options.editable.overrideItems && this.editable != null && this.editable.remove;

      if (this.selected && editable && !this.dom.deleteButton) {
        // create and show button
        var me = this;
        var deleteButton = document.createElement('div');

        if (this.options.rtl) {
          deleteButton.className = 'vis-delete-rtl';
        } else {
          deleteButton.className = 'vis-delete';
        }

        var _locales = this.options.locales[this.options.locale];

        if (!_locales) {
          if (!this.warned) {
            console.warn("WARNING: options.locales['".concat(this.options.locale, "'] not found. See https://visjs.github.io/vis-timeline/docs/timeline/#Localization"));
            this.warned = true;
          }

          _locales = this.options.locales['en']; // fall back on english when not available
        }

        deleteButton.title = _locales.deleteSelected; // TODO: be able to destroy the delete button

        this.hammerDeleteButton = new Hammer$1(deleteButton).on('tap', function (event) {
          event.stopPropagation();
          me.parent.removeFromDataSet(me);
        });
        anchor.appendChild(deleteButton);
        this.dom.deleteButton = deleteButton;
      } else if (!this.selected && this.dom.deleteButton) {
        // remove button
        if (this.dom.deleteButton.parentNode) {
          this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
        }

        this.dom.deleteButton = null;

        if (this.hammerDeleteButton) {
          this.hammerDeleteButton.destroy();
          this.hammerDeleteButton = null;
        }
      }
    }
    /**
     * Repaint a onChange tooltip on the top right of the item when the item is selected
     * @param {HTMLElement} anchor
     * @protected
     */

  }, {
    key: "_repaintOnItemUpdateTimeTooltip",
    value: function _repaintOnItemUpdateTimeTooltip(anchor) {
      if (!this.options.tooltipOnItemUpdateTime) return;
      var editable = (this.options.editable.updateTime || this.data.editable === true) && this.data.editable !== false;

      if (this.selected && editable && !this.dom.onItemUpdateTimeTooltip) {
        var onItemUpdateTimeTooltip = document.createElement('div');
        onItemUpdateTimeTooltip.className = 'vis-onUpdateTime-tooltip';
        anchor.appendChild(onItemUpdateTimeTooltip);
        this.dom.onItemUpdateTimeTooltip = onItemUpdateTimeTooltip;
      } else if (!this.selected && this.dom.onItemUpdateTimeTooltip) {
        // remove button
        if (this.dom.onItemUpdateTimeTooltip.parentNode) {
          this.dom.onItemUpdateTimeTooltip.parentNode.removeChild(this.dom.onItemUpdateTimeTooltip);
        }

        this.dom.onItemUpdateTimeTooltip = null;
      } // position onChange tooltip


      if (this.dom.onItemUpdateTimeTooltip) {
        // only show when editing
        this.dom.onItemUpdateTimeTooltip.style.visibility = this.parent.itemSet.touchParams.itemIsDragging ? 'visible' : 'hidden'; // position relative to item's content

        this.dom.onItemUpdateTimeTooltip.style.transform = 'translateX(-50%)';
        this.dom.onItemUpdateTimeTooltip.style.left = '50%'; // position above or below the item depending on the item's position in the window

        var tooltipOffset = 50; // TODO: should be tooltip height (depends on template)

        var scrollTop = this.parent.itemSet.body.domProps.scrollTop; // TODO: this.top for orientation:true is actually the items distance from the bottom... 
        // (should be this.bottom)

        var itemDistanceFromTop;

        if (this.options.orientation.item == 'top') {
          itemDistanceFromTop = this.top;
        } else {
          itemDistanceFromTop = this.parent.height - this.top - this.height;
        }

        var isCloseToTop = itemDistanceFromTop + this.parent.top - tooltipOffset < -scrollTop;

        if (isCloseToTop) {
          this.dom.onItemUpdateTimeTooltip.style.bottom = "";
          this.dom.onItemUpdateTimeTooltip.style.top = "".concat(this.height + 2, "px");
        } else {
          this.dom.onItemUpdateTimeTooltip.style.top = "";
          this.dom.onItemUpdateTimeTooltip.style.bottom = "".concat(this.height + 2, "px");
        } // handle tooltip content


        var content;
        var templateFunction;

        if (this.options.tooltipOnItemUpdateTime && this.options.tooltipOnItemUpdateTime.template) {
          templateFunction = this.options.tooltipOnItemUpdateTime.template.bind(this);
          content = templateFunction(this.data);
        } else {
          content = "start: ".concat(moment$3(this.data.start).format('MM/DD/YYYY hh:mm'));

          if (this.data.end) {
            content += "<br> end: ".concat(moment$3(this.data.end).format('MM/DD/YYYY hh:mm'));
          }
        }

        this.dom.onItemUpdateTimeTooltip.innerHTML = content;
      }
    }
    /**
    * get item data
    * @return {object}
    * @private
    */

  }, {
    key: "_getItemData",
    value: function _getItemData() {
      return this.parent.itemSet.itemsData.get(this.id);
    }
    /**
     * Set HTML contents for the item
     * @param {Element} element   HTML element to fill with the contents
     * @private
     */

  }, {
    key: "_updateContents",
    value: function _updateContents(element) {
      var content;
      var changed;
      var templateFunction;
      var itemVisibleFrameContent;
      var visibleFrameTemplateFunction;

      var itemData = this._getItemData(); // get a clone of the data from the dataset


      var frameElement = this.dom.box || this.dom.point;
      var itemVisibleFrameContentElement = frameElement.getElementsByClassName('vis-item-visible-frame')[0];

      if (this.options.visibleFrameTemplate) {
        visibleFrameTemplateFunction = this.options.visibleFrameTemplate.bind(this);
        itemVisibleFrameContent = visibleFrameTemplateFunction(itemData, itemVisibleFrameContentElement);
      } else {
        itemVisibleFrameContent = '';
      }

      if (itemVisibleFrameContentElement) {
        if (itemVisibleFrameContent instanceof Object && !(itemVisibleFrameContent instanceof Element)) {
          visibleFrameTemplateFunction(itemData, itemVisibleFrameContentElement);
        } else {
          changed = this._contentToString(this.itemVisibleFrameContent) !== this._contentToString(itemVisibleFrameContent);

          if (changed) {
            // only replace the content when changed
            if (itemVisibleFrameContent instanceof Element) {
              itemVisibleFrameContentElement.innerHTML = '';
              itemVisibleFrameContentElement.appendChild(itemVisibleFrameContent);
            } else if (itemVisibleFrameContent != undefined) {
              itemVisibleFrameContentElement.innerHTML = itemVisibleFrameContent;
            } else {
              if (!(this.data.type == 'background' && this.data.content === undefined)) {
                throw new Error("Property \"content\" missing in item ".concat(this.id));
              }
            }

            this.itemVisibleFrameContent = itemVisibleFrameContent;
          }
        }
      }

      if (this.options.template) {
        templateFunction = this.options.template.bind(this);
        content = templateFunction(itemData, element, this.data);
      } else {
        content = this.data.content;
      }

      if (content instanceof Object && !(content instanceof Element)) {
        templateFunction(itemData, element);
      } else {
        changed = this._contentToString(this.content) !== this._contentToString(content);

        if (changed) {
          // only replace the content when changed
          if (content instanceof Element) {
            element.innerHTML = '';
            element.appendChild(content);
          } else if (content != undefined) {
            element.innerHTML = content;
          } else {
            if (!(this.data.type == 'background' && this.data.content === undefined)) {
              throw new Error("Property \"content\" missing in item ".concat(this.id));
            }
          }

          this.content = content;
        }
      }
    }
    /**
     * Process dataAttributes timeline option and set as data- attributes on dom.content
     * @param {Element} element   HTML element to which the attributes will be attached
     * @private
     */

  }, {
    key: "_updateDataAttributes",
    value: function _updateDataAttributes(element) {
      if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
        var attributes = [];

        if (Array.isArray(this.options.dataAttributes)) {
          attributes = this.options.dataAttributes;
        } else if (this.options.dataAttributes == 'all') {
          attributes = Object.keys(this.data);
        } else {
          return;
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;
            var value = this.data[name];

            if (value != null) {
              element.setAttribute("data-".concat(name), value);
            } else {
              element.removeAttribute("data-".concat(name));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
    /**
     * Update custom styles of the element
     * @param {Element} element
     * @private
     */

  }, {
    key: "_updateStyle",
    value: function _updateStyle(element) {
      // remove old styles
      if (this.style) {
        util$2.removeCssText(element, this.style);
        this.style = null;
      } // append new styles


      if (this.data.style) {
        util$2.addCssText(element, this.data.style);
        this.style = this.data.style;
      }
    }
    /**
     * Stringify the items contents
     * @param {string | Element | undefined} content
     * @returns {string | undefined}
     * @private
     */

  }, {
    key: "_contentToString",
    value: function _contentToString(content) {
      if (typeof content === 'string') return content;
      if (content && 'outerHTML' in content) return content.outerHTML;
      return content;
    }
    /**
     * Update the editability of this item.
     */

  }, {
    key: "_updateEditStatus",
    value: function _updateEditStatus() {
      if (this.options) {
        if (typeof this.options.editable === 'boolean') {
          this.editable = {
            updateTime: this.options.editable,
            updateGroup: this.options.editable,
            remove: this.options.editable
          };
        } else if (_typeof(this.options.editable) === 'object') {
          this.editable = {};
          util$2.selectiveExtend(['updateTime', 'updateGroup', 'remove'], this.editable, this.options.editable);
        }
      } // Item data overrides, except if options.editable.overrideItems is set.


      if (!this.options || !this.options.editable || this.options.editable.overrideItems !== true) {
        if (this.data) {
          if (typeof this.data.editable === 'boolean') {
            this.editable = {
              updateTime: this.data.editable,
              updateGroup: this.data.editable,
              remove: this.data.editable
            };
          } else if (_typeof(this.data.editable) === 'object') {
            // TODO: in timeline.js 5.0, we should change this to not reset options from the timeline configuration.
            // Basically just remove the next line...
            this.editable = {};
            util$2.selectiveExtend(['updateTime', 'updateGroup', 'remove'], this.editable, this.data.editable);
          }
        }
      }
    }
    /**
     * Return the width of the item left from its start date
     * @return {number}
     */

  }, {
    key: "getWidthLeft",
    value: function getWidthLeft() {
      return 0;
    }
    /**
     * Return the width of the item right from the max of its start and end date
     * @return {number}
     */

  }, {
    key: "getWidthRight",
    value: function getWidthRight() {
      return 0;
    }
    /**
     * Return the title of the item
     * @return {string | undefined}
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      if (this.options.tooltip && this.options.tooltip.template) {
        var templateFunction = this.options.tooltip.template.bind(this);
        return templateFunction(this._getItemData(), this.data);
      }

      return this.data.title;
    }
  }]);

  return Item;
}();

Item.prototype.stack = true;
/**
 * @constructor BoxItem
 * @extends Item
 */

var BoxItem =
/*#__PURE__*/
function (_Item) {
  _inherits(BoxItem, _Item);
  /**
  * @param {Object} data             Object containing parameters start
  *                                  content, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} [options]        Configuration options
  *                                  // TODO: describe available options
  */


  function BoxItem(data, conversion, options) {
    var _this;

    _classCallCheck(this, BoxItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BoxItem).call(this, data, conversion, options));
    _this.props = {
      dot: {
        width: 0,
        height: 0
      },
      line: {
        width: 0,
        height: 0
      }
    };
    _this.options = options; // validate data

    if (data) {
      if (data.start == undefined) {
        throw new Error("Property \"start\" missing in item ".concat(data));
      }
    }

    return _this;
  }
  /**
   * Check whether this item is visible inside given range
   * @param {{start: number, end: number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */


  _createClass(BoxItem, [{
    key: "isVisible",
    value: function isVisible(range) {
      if (this.cluster) {
        return false;
      } // determine visibility


      var isVisible;
      var align = this.data.align || this.options.align;
      var widthInMs = this.width * range.getMillisecondsPerPixel();

      if (align == 'right') {
        isVisible = this.data.start.getTime() > range.start && this.data.start.getTime() - widthInMs < range.end;
      } else if (align == 'left') {
        isVisible = this.data.start.getTime() + widthInMs > range.start && this.data.start.getTime() < range.end;
      } else {
        // default or 'center'
        isVisible = this.data.start.getTime() + widthInMs / 2 > range.start && this.data.start.getTime() - widthInMs / 2 < range.end;
      }

      return isVisible;
    }
    /**
    * create DOM element
    * @private
    */

  }, {
    key: "_createDomElement",
    value: function _createDomElement() {
      if (!this.dom) {
        // create DOM
        this.dom = {}; // create main box

        this.dom.box = document.createElement('DIV'); // contents box (inside the background box). used for making margins

        this.dom.content = document.createElement('DIV');
        this.dom.content.className = 'vis-item-content';
        this.dom.box.appendChild(this.dom.content); // line to axis

        this.dom.line = document.createElement('DIV');
        this.dom.line.className = 'vis-line'; // dot on axis

        this.dom.dot = document.createElement('DIV');
        this.dom.dot.className = 'vis-dot'; // attach this item as attribute

        this.dom.box['vis-item'] = this;
        this.dirty = true;
      }
    }
    /**
     * append DOM element
     * @private
     */

  }, {
    key: "_appendDomElement",
    value: function _appendDomElement() {
      if (!this.parent) {
        throw new Error('Cannot redraw item: no parent attached');
      }

      if (!this.dom.box.parentNode) {
        var foreground = this.parent.dom.foreground;
        if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
        foreground.appendChild(this.dom.box);
      }

      if (!this.dom.line.parentNode) {
        var background = this.parent.dom.background;
        if (!background) throw new Error('Cannot redraw item: parent has no background container element');
        background.appendChild(this.dom.line);
      }

      if (!this.dom.dot.parentNode) {
        var axis = this.parent.dom.axis;
        if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
        axis.appendChild(this.dom.dot);
      }

      this.displayed = true;
    }
    /**
     * update dirty DOM element
     * @private
     */

  }, {
    key: "_updateDirtyDomComponents",
    value: function _updateDirtyDomComponents() {
      // An item is marked dirty when:
      // - the item is not yet rendered
      // - the item's data is changed
      // - the item is selected/deselected
      if (this.dirty) {
        this._updateContents(this.dom.content);

        this._updateDataAttributes(this.dom.box);

        this._updateStyle(this.dom.box);

        var editable = this.editable.updateTime || this.editable.updateGroup; // update class

        var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
        this.dom.box.className = "vis-item vis-box".concat(className);
        this.dom.line.className = "vis-item vis-line".concat(className);
        this.dom.dot.className = "vis-item vis-dot".concat(className);
      }
    }
    /**
     * get DOM components sizes
     * @return {object}
     * @private
     */

  }, {
    key: "_getDomComponentsSizes",
    value: function _getDomComponentsSizes() {
      return {
        previous: {
          right: this.dom.box.style.right,
          left: this.dom.box.style.left
        },
        dot: {
          height: this.dom.dot.offsetHeight,
          width: this.dom.dot.offsetWidth
        },
        line: {
          width: this.dom.line.offsetWidth
        },
        box: {
          width: this.dom.box.offsetWidth,
          height: this.dom.box.offsetHeight
        }
      };
    }
    /**
     * update DOM components sizes
     * @param {object} sizes
     * @private
     */

  }, {
    key: "_updateDomComponentsSizes",
    value: function _updateDomComponentsSizes(sizes) {
      if (this.options.rtl) {
        this.dom.box.style.right = "0px";
      } else {
        this.dom.box.style.left = "0px";
      } // recalculate size


      this.props.dot.height = sizes.dot.height;
      this.props.dot.width = sizes.dot.width;
      this.props.line.width = sizes.line.width;
      this.width = sizes.box.width;
      this.height = sizes.box.height; // restore previous position

      if (this.options.rtl) {
        this.dom.box.style.right = sizes.previous.right;
      } else {
        this.dom.box.style.left = sizes.previous.left;
      }

      this.dirty = false;
    }
    /**
     * repaint DOM additionals
     * @private
     */

  }, {
    key: "_repaintDomAdditionals",
    value: function _repaintDomAdditionals() {
      this._repaintOnItemUpdateTimeTooltip(this.dom.box);

      this._repaintDragCenter();

      this._repaintDeleteButton(this.dom.box);
    }
    /**
     * Repaint the item
     * @param {boolean} [returnQueue=false]  return the queue
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "redraw",
    value: function redraw(returnQueue) {
      var _this2 = this;

      var sizes;
      var queue = [// create item DOM
      this._createDomElement.bind(this), // append DOM to parent DOM
      this._appendDomElement.bind(this), // update dirty DOM
      this._updateDirtyDomComponents.bind(this), function () {
        if (_this2.dirty) {
          sizes = _this2._getDomComponentsSizes();
        }
      }, function () {
        if (_this2.dirty) {
          _this2._updateDomComponentsSizes.bind(_this2)(sizes);
        }
      }, // repaint DOM additionals
      this._repaintDomAdditionals.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * Show the item in the DOM (when not already visible). The items DOM will
     * be created when needed.
     * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "show",
    value: function show(returnQueue) {
      if (!this.displayed) {
        return this.redraw(returnQueue);
      }
    }
    /**
     * Hide the item from the DOM (when visible)
     */

  }, {
    key: "hide",
    value: function hide() {
      if (this.displayed) {
        var dom = this.dom;
        if (dom.box.parentNode) dom.box.remove();
        if (dom.line.parentNode) dom.line.remove();
        if (dom.dot.parentNode) dom.dot.remove();
        this.displayed = false;
      }
    }
    /**
     * Reposition the item XY
     */

  }, {
    key: "repositionXY",
    value: function repositionXY() {
      var rtl = this.options.rtl;

      var repositionXY = function repositionXY(element, x, y) {
        var rtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        if (x === undefined && y === undefined) return; // If rtl invert the number.

        var directionX = rtl ? x * -1 : x; //no y. translate x

        if (y === undefined) {
          element.style.transform = "translateX(".concat(directionX, "px)");
          return;
        } //no x. translate y


        if (x === undefined) {
          element.style.transform = "translateY(".concat(y, "px)");
          return;
        }

        element.style.transform = "translate(".concat(directionX, "px, ").concat(y, "px)");
      };

      repositionXY(this.dom.box, this.boxX, this.boxY, rtl);
      repositionXY(this.dom.dot, this.dotX, this.dotY, rtl);
      repositionXY(this.dom.line, this.lineX, this.lineY, rtl);
    }
    /**
     * Reposition the item horizontally
     * @Override
     */

  }, {
    key: "repositionX",
    value: function repositionX() {
      var start = this.conversion.toScreen(this.data.start);
      var align = this.data.align === undefined ? this.options.align : this.data.align;
      var lineWidth = this.props.line.width;
      var dotWidth = this.props.dot.width;

      if (align == 'right') {
        // calculate right position of the box
        this.boxX = start - this.width;
        this.lineX = start - lineWidth;
        this.dotX = start - lineWidth / 2 - dotWidth / 2;
      } else if (align == 'left') {
        // calculate left position of the box
        this.boxX = start;
        this.lineX = start;
        this.dotX = start + lineWidth / 2 - dotWidth / 2;
      } else {
        // default or 'center'
        this.boxX = start - this.width / 2;
        this.lineX = this.options.rtl ? start - lineWidth : start - lineWidth / 2;
        this.dotX = start - dotWidth / 2;
      }

      if (this.options.rtl) this.right = this.boxX;else this.left = this.boxX;
      this.repositionXY();
    }
    /**
     * Reposition the item vertically
     * @Override
     */

  }, {
    key: "repositionY",
    value: function repositionY() {
      var orientation = this.options.orientation.item;
      var lineStyle = this.dom.line.style;

      if (orientation == 'top') {
        var lineHeight = this.parent.top + this.top + 1;
        this.boxY = this.top || 0;
        lineStyle.height = "".concat(lineHeight, "px");
        lineStyle.bottom = '';
        lineStyle.top = '0';
      } else {
        // orientation 'bottom'
        var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty

        var _lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

        this.boxY = this.parent.height - this.top - (this.height || 0);
        lineStyle.height = "".concat(_lineHeight, "px");
        lineStyle.top = '';
        lineStyle.bottom = '0';
      }

      this.dotY = -this.props.dot.height / 2;
      this.repositionXY();
    }
    /**
     * Return the width of the item left from its start date
     * @return {number}
     */

  }, {
    key: "getWidthLeft",
    value: function getWidthLeft() {
      return this.width / 2;
    }
    /**
     * Return the width of the item right from its start date
     * @return {number}
     */

  }, {
    key: "getWidthRight",
    value: function getWidthRight() {
      return this.width / 2;
    }
  }]);

  return BoxItem;
}(Item);
/**
 * @constructor PointItem
 * @extends Item
 */


var PointItem =
/*#__PURE__*/
function (_Item) {
  _inherits(PointItem, _Item);
  /**
  * @param {Object} data             Object containing parameters start
  *                                  content, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} [options]        Configuration options
  *                                  // TODO: describe available options
  */


  function PointItem(data, conversion, options) {
    var _this;

    _classCallCheck(this, PointItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PointItem).call(this, data, conversion, options));
    _this.props = {
      dot: {
        top: 0,
        width: 0,
        height: 0
      },
      content: {
        height: 0,
        marginLeft: 0,
        marginRight: 0
      }
    };
    _this.options = options; // validate data

    if (data) {
      if (data.start == undefined) {
        throw new Error("Property \"start\" missing in item ".concat(data));
      }
    }

    return _this;
  }
  /**
   * Check whether this item is visible inside given range
   * @param {{start: number, end: number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */


  _createClass(PointItem, [{
    key: "isVisible",
    value: function isVisible(range) {
      if (this.cluster) {
        return false;
      } // determine visibility


      var widthInMs = this.width * range.getMillisecondsPerPixel();
      return this.data.start.getTime() + widthInMs > range.start && this.data.start < range.end;
    }
    /**
     * create DOM element
     * @private
     */

  }, {
    key: "_createDomElement",
    value: function _createDomElement() {
      if (!this.dom) {
        // create DOM
        this.dom = {}; // background box

        this.dom.point = document.createElement('div'); // className is updated in redraw()
        // contents box, right from the dot

        this.dom.content = document.createElement('div');
        this.dom.content.className = 'vis-item-content';
        this.dom.point.appendChild(this.dom.content); // dot at start

        this.dom.dot = document.createElement('div');
        this.dom.point.appendChild(this.dom.dot); // attach this item as attribute

        this.dom.point['vis-item'] = this;
        this.dirty = true;
      }
    }
    /**
     * append DOM element
     * @private
     */

  }, {
    key: "_appendDomElement",
    value: function _appendDomElement() {
      if (!this.parent) {
        throw new Error('Cannot redraw item: no parent attached');
      }

      if (!this.dom.point.parentNode) {
        var foreground = this.parent.dom.foreground;

        if (!foreground) {
          throw new Error('Cannot redraw item: parent has no foreground container element');
        }

        foreground.appendChild(this.dom.point);
      }

      this.displayed = true;
    }
    /**
     * update dirty DOM components
     * @private
     */

  }, {
    key: "_updateDirtyDomComponents",
    value: function _updateDirtyDomComponents() {
      // An item is marked dirty when:
      // - the item is not yet rendered
      // - the item's data is changed
      // - the item is selected/deselected
      if (this.dirty) {
        this._updateContents(this.dom.content);

        this._updateDataAttributes(this.dom.point);

        this._updateStyle(this.dom.point);

        var editable = this.editable.updateTime || this.editable.updateGroup; // update class

        var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
        this.dom.point.className = "vis-item vis-point".concat(className);
        this.dom.dot.className = "vis-item vis-dot".concat(className);
      }
    }
    /**
     * get DOM component sizes
     * @return {object}
     * @private
     */

  }, {
    key: "_getDomComponentsSizes",
    value: function _getDomComponentsSizes() {
      return {
        dot: {
          width: this.dom.dot.offsetWidth,
          height: this.dom.dot.offsetHeight
        },
        content: {
          width: this.dom.content.offsetWidth,
          height: this.dom.content.offsetHeight
        },
        point: {
          width: this.dom.point.offsetWidth,
          height: this.dom.point.offsetHeight
        }
      };
    }
    /**
     * update DOM components sizes
     * @param {array} sizes
     * @private
     */

  }, {
    key: "_updateDomComponentsSizes",
    value: function _updateDomComponentsSizes(sizes) {
      // recalculate size of dot and contents
      this.props.dot.width = sizes.dot.width;
      this.props.dot.height = sizes.dot.height;
      this.props.content.height = sizes.content.height; // resize contents

      if (this.options.rtl) {
        this.dom.content.style.marginRight = "".concat(2 * this.props.dot.width, "px");
      } else {
        this.dom.content.style.marginLeft = "".concat(2 * this.props.dot.width, "px");
      } //this.dom.content.style.marginRight = ... + 'px'; // TODO: margin right
      // recalculate size


      this.width = sizes.point.width;
      this.height = sizes.point.height; // reposition the dot

      this.dom.dot.style.top = "".concat((this.height - this.props.dot.height) / 2, "px");
      var dotWidth = this.props.dot.width;
      var translateX = this.options.rtl ? dotWidth / 2 * -1 : dotWidth / 2;
      this.dom.dot.style.transform = "translateX(".concat(translateX, "px");
      this.dirty = false;
    }
    /**
     * Repain DOM additionals
     * @private
     */

  }, {
    key: "_repaintDomAdditionals",
    value: function _repaintDomAdditionals() {
      this._repaintOnItemUpdateTimeTooltip(this.dom.point);

      this._repaintDragCenter();

      this._repaintDeleteButton(this.dom.point);
    }
    /**
     * Repaint the item
     * @param {boolean} [returnQueue=false]  return the queue
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "redraw",
    value: function redraw(returnQueue) {
      var _this2 = this;

      var sizes;
      var queue = [// create item DOM
      this._createDomElement.bind(this), // append DOM to parent DOM
      this._appendDomElement.bind(this), // update dirty DOM
      this._updateDirtyDomComponents.bind(this), function () {
        if (_this2.dirty) {
          sizes = _this2._getDomComponentsSizes();
        }
      }, function () {
        if (_this2.dirty) {
          _this2._updateDomComponentsSizes.bind(_this2)(sizes);
        }
      }, // repaint DOM additionals
      this._repaintDomAdditionals.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * Reposition XY
     */

  }, {
    key: "repositionXY",
    value: function repositionXY() {
      var rtl = this.options.rtl;

      var repositionXY = function repositionXY(element, x, y) {
        var rtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        if (x === undefined && y === undefined) return; // If rtl invert the number.

        var directionX = rtl ? x * -1 : x; //no y. translate x

        if (y === undefined) {
          element.style.transform = "translateX(".concat(directionX, "px)");
          return;
        } //no x. translate y


        if (x === undefined) {
          element.style.transform = "translateY(".concat(y, "px)");
          return;
        }

        element.style.transform = "translate(".concat(directionX, "px, ").concat(y, "px)");
      };

      repositionXY(this.dom.point, this.pointX, this.pointY, rtl);
    }
    /**
     * Show the item in the DOM (when not already visible). The items DOM will
     * be created when needed.
     * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "show",
    value: function show(returnQueue) {
      if (!this.displayed) {
        return this.redraw(returnQueue);
      }
    }
    /**
     * Hide the item from the DOM (when visible)
     */

  }, {
    key: "hide",
    value: function hide() {
      if (this.displayed) {
        if (this.dom.point.parentNode) {
          this.dom.point.parentNode.removeChild(this.dom.point);
        }

        this.displayed = false;
      }
    }
    /**
     * Reposition the item horizontally
     * @Override
     */

  }, {
    key: "repositionX",
    value: function repositionX() {
      var start = this.conversion.toScreen(this.data.start);
      this.pointX = start;

      if (this.options.rtl) {
        this.right = start - this.props.dot.width;
      } else {
        this.left = start - this.props.dot.width;
      }

      this.repositionXY();
    }
    /**
     * Reposition the item vertically
     * @Override
     */

  }, {
    key: "repositionY",
    value: function repositionY() {
      var orientation = this.options.orientation.item;

      if (orientation == 'top') {
        this.pointY = this.top;
      } else {
        this.pointY = this.parent.height - this.top - this.height;
      }

      this.repositionXY();
    }
    /**
     * Return the width of the item left from its start date
     * @return {number}
     */

  }, {
    key: "getWidthLeft",
    value: function getWidthLeft() {
      return this.props.dot.width;
    }
    /**
     * Return the width of the item right from  its start date
     * @return {number}
     */

  }, {
    key: "getWidthRight",
    value: function getWidthRight() {
      return this.props.dot.width;
    }
  }]);

  return PointItem;
}(Item);
/**
 * @constructor RangeItem
 * @extends Item
 */


var RangeItem =
/*#__PURE__*/
function (_Item) {
  _inherits(RangeItem, _Item);
  /**
  * @param {Object} data             Object containing parameters start, end
  *                                  content, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} [options]        Configuration options
  *                                  // TODO: describe options
  */


  function RangeItem(data, conversion, options) {
    var _this;

    _classCallCheck(this, RangeItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeItem).call(this, data, conversion, options));
    _this.props = {
      content: {
        width: 0
      }
    };
    _this.overflow = false; // if contents can overflow (css styling), this flag is set to true

    _this.options = options; // validate data

    if (data) {
      if (data.start == undefined) {
        throw new Error("Property \"start\" missing in item ".concat(data.id));
      }

      if (data.end == undefined) {
        throw new Error("Property \"end\" missing in item ".concat(data.id));
      }
    }

    return _this;
  }
  /**
   * Check whether this item is visible inside given range
   *
   * @param {timeline.Range} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */


  _createClass(RangeItem, [{
    key: "isVisible",
    value: function isVisible(range) {
      if (this.cluster) {
        return false;
      } // determine visibility


      return this.data.start < range.end && this.data.end > range.start;
    }
    /**
     * create DOM elements
     * @private
     */

  }, {
    key: "_createDomElement",
    value: function _createDomElement() {
      if (!this.dom) {
        // create DOM
        this.dom = {}; // background box

        this.dom.box = document.createElement('div'); // className is updated in redraw()
        // frame box (to prevent the item contents from overflowing)

        this.dom.frame = document.createElement('div');
        this.dom.frame.className = 'vis-item-overflow';
        this.dom.box.appendChild(this.dom.frame); // visible frame box (showing the frame that is always visible)

        this.dom.visibleFrame = document.createElement('div');
        this.dom.visibleFrame.className = 'vis-item-visible-frame';
        this.dom.box.appendChild(this.dom.visibleFrame); // contents box

        this.dom.content = document.createElement('div');
        this.dom.content.className = 'vis-item-content';
        this.dom.frame.appendChild(this.dom.content); // attach this item as attribute

        this.dom.box['vis-item'] = this;
        this.dirty = true;
      }
    }
    /**
     * append element to DOM
     * @private
     */

  }, {
    key: "_appendDomElement",
    value: function _appendDomElement() {
      if (!this.parent) {
        throw new Error('Cannot redraw item: no parent attached');
      }

      if (!this.dom.box.parentNode) {
        var foreground = this.parent.dom.foreground;

        if (!foreground) {
          throw new Error('Cannot redraw item: parent has no foreground container element');
        }

        foreground.appendChild(this.dom.box);
      }

      this.displayed = true;
    }
    /**
     * update dirty DOM components
     * @private
     */

  }, {
    key: "_updateDirtyDomComponents",
    value: function _updateDirtyDomComponents() {
      // update dirty DOM. An item is marked dirty when:
      // - the item is not yet rendered
      // - the item's data is changed
      // - the item is selected/deselected
      if (this.dirty) {
        this._updateContents(this.dom.content);

        this._updateDataAttributes(this.dom.box);

        this._updateStyle(this.dom.box);

        var editable = this.editable.updateTime || this.editable.updateGroup; // update class

        var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
        this.dom.box.className = this.baseClassName + className; // turn off max-width to be able to calculate the real width
        // this causes an extra browser repaint/reflow, but so be it

        this.dom.content.style.maxWidth = 'none';
      }
    }
    /**
     * get DOM component sizes
     * @return {object}
     * @private
     */

  }, {
    key: "_getDomComponentsSizes",
    value: function _getDomComponentsSizes() {
      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(this.dom.frame).overflow !== 'hidden';
      this.whiteSpace = window.getComputedStyle(this.dom.content).whiteSpace !== 'nowrap';
      return {
        content: {
          width: this.dom.content.offsetWidth
        },
        box: {
          height: this.dom.box.offsetHeight
        }
      };
    }
    /**
     * update DOM component sizes
     * @param {array} sizes
     * @private
     */

  }, {
    key: "_updateDomComponentsSizes",
    value: function _updateDomComponentsSizes(sizes) {
      this.props.content.width = sizes.content.width;
      this.height = sizes.box.height;
      this.dom.content.style.maxWidth = '';
      this.dirty = false;
    }
    /**
     * repaint DOM additional components
     * @private
     */

  }, {
    key: "_repaintDomAdditionals",
    value: function _repaintDomAdditionals() {
      this._repaintOnItemUpdateTimeTooltip(this.dom.box);

      this._repaintDeleteButton(this.dom.box);

      this._repaintDragCenter();

      this._repaintDragLeft();

      this._repaintDragRight();
    }
    /**
     * Repaint the item
     * @param {boolean} [returnQueue=false]  return the queue
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "redraw",
    value: function redraw(returnQueue) {
      var _this2 = this;

      var sizes;
      var queue = [// create item DOM
      this._createDomElement.bind(this), // append DOM to parent DOM
      this._appendDomElement.bind(this), // update dirty DOM 
      this._updateDirtyDomComponents.bind(this), function () {
        if (_this2.dirty) {
          sizes = _this2._getDomComponentsSizes.bind(_this2)();
        }
      }, function () {
        if (_this2.dirty) {
          _this2._updateDomComponentsSizes.bind(_this2)(sizes);
        }
      }, // repaint DOM additionals
      this._repaintDomAdditionals.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * Show the item in the DOM (when not already visible). The items DOM will
     * be created when needed.
     * @param {boolean} [returnQueue=false]  whether to return a queue of functions to execute instead of just executing them
     * @return {boolean} the redraw queue if returnQueue=true
     */

  }, {
    key: "show",
    value: function show(returnQueue) {
      if (!this.displayed) {
        return this.redraw(returnQueue);
      }
    }
    /**
     * Hide the item from the DOM (when visible)
     */

  }, {
    key: "hide",
    value: function hide() {
      if (this.displayed) {
        var box = this.dom.box;

        if (box.parentNode) {
          box.parentNode.removeChild(box);
        }

        this.displayed = false;
      }
    }
    /**
     * Reposition the item horizontally
     * @param {boolean} [limitSize=true] If true (default), the width of the range
     *                                   item will be limited, as the browser cannot
     *                                   display very wide divs. This means though
     *                                   that the applied left and width may
     *                                   not correspond to the ranges start and end
     * @Override
     */

  }, {
    key: "repositionX",
    value: function repositionX(limitSize) {
      var parentWidth = this.parent.width;
      var start = this.conversion.toScreen(this.data.start);
      var end = this.conversion.toScreen(this.data.end);
      var align = this.data.align === undefined ? this.options.align : this.data.align;
      var contentStartPosition;
      var contentWidth; // limit the width of the range, as browsers cannot draw very wide divs
      // unless limitSize: false is explicitly set in item data

      if (this.data.limitSize !== false && (limitSize === undefined || limitSize === true)) {
        if (start < -parentWidth) {
          start = -parentWidth;
        }

        if (end > 2 * parentWidth) {
          end = 2 * parentWidth;
        }
      } //round to 3 decimals to compensate floating-point values rounding


      var boxWidth = Math.max(Math.round((end - start) * 1000) / 1000, 1);

      if (this.overflow) {
        if (this.options.rtl) {
          this.right = start;
        } else {
          this.left = start;
        }

        this.width = boxWidth + this.props.content.width;
        contentWidth = this.props.content.width; // Note: The calculation of width is an optimistic calculation, giving
        //       a width which will not change when moving the Timeline
        //       So no re-stacking needed, which is nicer for the eye;
      } else {
        if (this.options.rtl) {
          this.right = start;
        } else {
          this.left = start;
        }

        this.width = boxWidth;
        contentWidth = Math.min(end - start, this.props.content.width);
      }

      if (this.options.rtl) {
        this.dom.box.style.transform = "translateX(".concat(this.right * -1, "px)");
      } else {
        this.dom.box.style.transform = "translateX(".concat(this.left, "px)");
      }

      this.dom.box.style.width = "".concat(boxWidth, "px");

      if (this.whiteSpace) {
        this.height = this.dom.box.offsetHeight;
      }

      switch (align) {
        case 'left':
          this.dom.content.style.transform = 'translateX(0)';
          break;

        case 'right':
          if (this.options.rtl) {
            var translateX = Math.max(boxWidth - contentWidth, 0) * -1;
            this.dom.content.style.transform = "translateX(".concat(translateX, "px)");
          } else {
            this.dom.content.style.transform = "translateX(".concat(Math.max(boxWidth - contentWidth, 0), "px)");
          }

          break;

        case 'center':
          if (this.options.rtl) {
            var _translateX = Math.max((boxWidth - contentWidth) / 2, 0) * -1;

            this.dom.content.style.transform = "translateX(".concat(_translateX, "px)");
          } else {
            this.dom.content.style.transform = "translateX(".concat(Math.max((boxWidth - contentWidth) / 2, 0), "px)");
          }

          break;

        default:
          // 'auto'
          // when range exceeds left of the window, position the contents at the left of the visible area
          if (this.overflow) {
            if (end > 0) {
              contentStartPosition = Math.max(-start, 0);
            } else {
              contentStartPosition = -contentWidth; // ensure it's not visible anymore
            }
          } else {
            if (start < 0) {
              contentStartPosition = -start;
            } else {
              contentStartPosition = 0;
            }
          }

          if (this.options.rtl) {
            var _translateX2 = contentStartPosition * -1;

            this.dom.content.style.transform = "translateX(".concat(_translateX2, "px)");
          } else {
            this.dom.content.style.transform = "translateX(".concat(contentStartPosition, "px)"); // this.dom.content.style.width = `calc(100% - ${contentStartPosition}px)`;
          }

      }
    }
    /**
     * Reposition the item vertically
     * @Override
     */

  }, {
    key: "repositionY",
    value: function repositionY() {
      var orientation = this.options.orientation.item;
      var box = this.dom.box;

      if (orientation == 'top') {
        box.style.top = "".concat(this.top, "px");
      } else {
        box.style.top = "".concat(this.parent.height - this.top - this.height, "px");
      }
    }
    /**
     * Repaint a drag area on the left side of the range when the range is selected
     * @protected
     */

  }, {
    key: "_repaintDragLeft",
    value: function _repaintDragLeft() {
      if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragLeft) {
        // create and show drag area
        var dragLeft = document.createElement('div');
        dragLeft.className = 'vis-drag-left';
        dragLeft.dragLeftItem = this;
        this.dom.box.appendChild(dragLeft);
        this.dom.dragLeft = dragLeft;
      } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragLeft) {
        // delete drag area
        if (this.dom.dragLeft.parentNode) {
          this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
        }

        this.dom.dragLeft = null;
      }
    }
    /**
     * Repaint a drag area on the right side of the range when the range is selected
     * @protected
     */

  }, {
    key: "_repaintDragRight",
    value: function _repaintDragRight() {
      if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragRight) {
        // create and show drag area
        var dragRight = document.createElement('div');
        dragRight.className = 'vis-drag-right';
        dragRight.dragRightItem = this;
        this.dom.box.appendChild(dragRight);
        this.dom.dragRight = dragRight;
      } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragRight) {
        // delete drag area
        if (this.dom.dragRight.parentNode) {
          this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
        }

        this.dom.dragRight = null;
      }
    }
  }]);

  return RangeItem;
}(Item);

RangeItem.prototype.baseClassName = 'vis-item vis-range';
/**
 * @constructor BackgroundItem
 * @extends Item
 */

var BackgroundItem =
/*#__PURE__*/
function (_Item) {
  _inherits(BackgroundItem, _Item);
  /**
  * @constructor BackgroundItem
  * @param {Object} data             Object containing parameters start, end
  *                                  content, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} [options]        Configuration options
  *                                  // TODO: describe options
  * // TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
  */


  function BackgroundItem(data, conversion, options) {
    var _this;

    _classCallCheck(this, BackgroundItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BackgroundItem).call(this, data, conversion, options));
    _this.props = {
      content: {
        width: 0
      }
    };
    _this.overflow = false; // if contents can overflow (css styling), this flag is set to true
    // validate data

    if (data) {
      if (data.start == undefined) {
        throw new Error("Property \"start\" missing in item ".concat(data.id));
      }

      if (data.end == undefined) {
        throw new Error("Property \"end\" missing in item ".concat(data.id));
      }
    }

    return _this;
  }
  /**
   * Check whether this item is visible inside given range
   * @param {timeline.Range} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */


  _createClass(BackgroundItem, [{
    key: "isVisible",
    value: function isVisible(range) {
      // determine visibility
      return this.data.start < range.end && this.data.end > range.start;
    }
    /**
     * create DOM element
     * @private
     */

  }, {
    key: "_createDomElement",
    value: function _createDomElement() {
      if (!this.dom) {
        // create DOM
        this.dom = {}; // background box

        this.dom.box = document.createElement('div'); // className is updated in redraw()
        // frame box (to prevent the item contents from overflowing

        this.dom.frame = document.createElement('div');
        this.dom.frame.className = 'vis-item-overflow';
        this.dom.box.appendChild(this.dom.frame); // contents box

        this.dom.content = document.createElement('div');
        this.dom.content.className = 'vis-item-content';
        this.dom.frame.appendChild(this.dom.content); // Note: we do NOT attach this item as attribute to the DOM,
        //       such that background items cannot be selected
        //this.dom.box['vis-item'] = this;

        this.dirty = true;
      }
    }
    /**
     * append DOM element
     * @private
     */

  }, {
    key: "_appendDomElement",
    value: function _appendDomElement() {
      if (!this.parent) {
        throw new Error('Cannot redraw item: no parent attached');
      }

      if (!this.dom.box.parentNode) {
        var background = this.parent.dom.background;

        if (!background) {
          throw new Error('Cannot redraw item: parent has no background container element');
        }

        background.appendChild(this.dom.box);
      }

      this.displayed = true;
    }
    /**
     * update DOM Dirty components
     * @private
     */

  }, {
    key: "_updateDirtyDomComponents",
    value: function _updateDirtyDomComponents() {
      // update dirty DOM. An item is marked dirty when:
      // - the item is not yet rendered
      // - the item's data is changed
      // - the item is selected/deselected
      if (this.dirty) {
        this._updateContents(this.dom.content);

        this._updateDataAttributes(this.dom.content);

        this._updateStyle(this.dom.box); // update class


        var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
        this.dom.box.className = this.baseClassName + className;
      }
    }
    /**
     * get DOM components sizes
     * @return {object}
     * @private
     */

  }, {
    key: "_getDomComponentsSizes",
    value: function _getDomComponentsSizes() {
      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(this.dom.content).overflow !== 'hidden';
      return {
        content: {
          width: this.dom.content.offsetWidth
        }
      };
    }
    /**
     * update DOM components sizes
     * @param {object} sizes
     * @private
     */

  }, {
    key: "_updateDomComponentsSizes",
    value: function _updateDomComponentsSizes(sizes) {
      // recalculate size
      this.props.content.width = sizes.content.width;
      this.height = 0; // set height zero, so this item will be ignored when stacking items

      this.dirty = false;
    }
    /**
     * repaint DOM additionals
     * @private
     */

  }, {
    key: "_repaintDomAdditionals",
    value: function _repaintDomAdditionals() {}
    /**
     * Repaint the item
     * @param {boolean} [returnQueue=false]  return the queue
     * @return {boolean} the redraw result or the redraw queue if returnQueue=true
     */

  }, {
    key: "redraw",
    value: function redraw(returnQueue) {
      var _this2 = this;

      var sizes;
      var queue = [// create item DOM
      this._createDomElement.bind(this), // append DOM to parent DOM
      this._appendDomElement.bind(this), this._updateDirtyDomComponents.bind(this), function () {
        if (_this2.dirty) {
          sizes = _this2._getDomComponentsSizes.bind(_this2)();
        }
      }, function () {
        if (_this2.dirty) {
          _this2._updateDomComponentsSizes.bind(_this2)(sizes);
        }
      }, // repaint DOM additionals
      this._repaintDomAdditionals.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * Reposition the item vertically
     * @Override
     */

  }, {
    key: "repositionY",
    value: function repositionY(margin) {
      // eslint-disable-line no-unused-vars
      var height;
      var orientation = this.options.orientation.item; // special positioning for subgroups

      if (this.data.subgroup !== undefined) {
        // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset
        var itemSubgroup = this.data.subgroup;
        this.dom.box.style.height = "".concat(this.parent.subgroups[itemSubgroup].height, "px");

        if (orientation == 'top') {
          this.dom.box.style.top = "".concat(this.parent.top + this.parent.subgroups[itemSubgroup].top, "px");
        } else {
          this.dom.box.style.top = "".concat(this.parent.top + this.parent.height - this.parent.subgroups[itemSubgroup].top - this.parent.subgroups[itemSubgroup].height, "px");
        }

        this.dom.box.style.bottom = '';
      } // and in the case of no subgroups:
      else {
          // we want backgrounds with groups to only show in groups.
          if (this.parent instanceof BackgroundGroup) {
            // if the item is not in a group:
            height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
            this.dom.box.style.bottom = orientation == 'bottom' ? '0' : '';
            this.dom.box.style.top = orientation == 'top' ? '0' : '';
          } else {
            height = this.parent.height; // same alignment for items when orientation is top or bottom

            this.dom.box.style.top = "".concat(this.parent.top, "px");
            this.dom.box.style.bottom = '';
          }
        }

      this.dom.box.style.height = "".concat(height, "px");
    }
  }]);

  return BackgroundItem;
}(Item);

BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
BackgroundItem.prototype.stack = false;
/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */

BackgroundItem.prototype.show = RangeItem.prototype.show;
/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */

BackgroundItem.prototype.hide = RangeItem.prototype.hide;
/**
 * Reposition the item horizontally
 * @Override
 */

BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;
/**
 * Popup is a class to create a popup window with some text
 */

var Popup =
/*#__PURE__*/
function () {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip', 'cap' or 'none')
   */
  function Popup(container, overflowMethod) {
    _classCallCheck(this, Popup);

    this.container = container;
    this.overflowMethod = overflowMethod || 'cap';
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false; // create the frame

    this.frame = document.createElement('div');
    this.frame.className = 'vis-tooltip';
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */


  _createClass(Popup, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.x = parseInt(x);
      this.y = parseInt(y);
    }
    /**
     * Set the content for the popup window. This can be HTML code or text.
     * @param {string | Element} content
     */

  }, {
    key: "setText",
    value: function setText(content) {
      if (content instanceof Element) {
        this.frame.innerHTML = '';
        this.frame.appendChild(content);
      } else {
        this.frame.innerHTML = content; // string containing text or HTML
      }
    }
    /**
     * Show the popup window
     * @param {boolean} [doShow]    Show or hide the window
     */

  }, {
    key: "show",
    value: function show(doShow) {
      if (doShow === undefined) {
        doShow = true;
      }

      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;
        var left = 0,
            top = 0;

        if (this.overflowMethod == 'flip' || this.overflowMethod == 'none') {
          var isLeft = false,
              isTop = true; // Where around the position it's located

          if (this.overflowMethod == 'flip') {
            if (this.y - height < this.padding) {
              isTop = false;
            }

            if (this.x + width > maxWidth - this.padding) {
              isLeft = true;
            }
          }

          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }

          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          // this.overflowMethod == 'cap'
          top = this.y - height;

          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }

          if (top < this.padding) {
            top = this.padding;
          }

          left = this.x;

          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }

          if (left < this.padding) {
            left = this.padding;
          }
        }

        this.frame.style.left = left + "px";
        this.frame.style.top = top + "px";
        this.frame.style.visibility = "visible";
        this.hidden = false;
      } else {
        this.hide();
      }
    }
    /**
     * Hide the popup window
     */

  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = "0";
      this.frame.style.top = "0";
      this.frame.style.visibility = "hidden";
    }
    /**
     * Remove the popup window
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM
    }
  }]);

  return Popup;
}();

var $every$1 = arrayIteration.every; // `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every

_export({
  target: 'Array',
  proto: true,
  forced: sloppyArrayMethod('every')
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
/**
 * ClusterItem
 */


var ClusterItem =
/*#__PURE__*/
function (_Item) {
  _inherits(ClusterItem, _Item);
  /**
  * @constructor Item
  * @param {Object} data             Object containing (optional) parameters type,
  *                                  start, end, content, group, className.
  * @param {{toScreen: function, toTime: function}} conversion
  *                                  Conversion functions from time to screen and vice versa
  * @param {Object} options          Configuration options
  *                                  // TODO: describe available options
  */


  function ClusterItem(data, conversion, options) {
    var _this;

    _classCallCheck(this, ClusterItem);

    var modifiedOptions = Object.assign({}, {
      fitOnDoubleClick: true
    }, options, {
      editable: false
    });
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClusterItem).call(this, data, conversion, modifiedOptions));
    _this.props = {
      content: {
        width: 0,
        height: 0
      }
    };
    _this.options = modifiedOptions;

    if (!data || data.uiItems == undefined) {
      throw new Error('Property "uiItems" missing in item ' + data.id);
    }

    _this.id = util$2.randomUUID();
    _this.group = data.group;

    _this._setupRange();

    _this.emitter = _this.data.eventEmitter;
    _this.range = _this.data.range;
    _this.attached = false;
    _this.isCluster = true;
    _this.data.isCluster = true;
    return _this;
  }
  /**
   * check if there are items
   * @return {boolean}
   */


  _createClass(ClusterItem, [{
    key: "hasItems",
    value: function hasItems() {
      return this.data.uiItems && this.data.uiItems.length && this.attached;
    }
    /**
     * set UI items
     * @param {array} items
     */

  }, {
    key: "setUiItems",
    value: function setUiItems(items) {
      this.detach();
      this.data.uiItems = items;

      this._setupRange();

      this.attach();
    }
    /**
     * check is visible
     * @param {object} range
     * @return {boolean}
     */

  }, {
    key: "isVisible",
    value: function isVisible(range) {
      var rangeWidth = this.data.end ? this.data.end - this.data.start : 0;
      var widthInMs = this.width * range.getMillisecondsPerPixel();
      var end = Math.max(rangeWidth, this.data.start.getTime() + widthInMs);
      return this.data.start < range.end && end > range.start && this.hasItems();
    }
    /**
     * get cluster data
     * @return {object}
     */

  }, {
    key: "getData",
    value: function getData() {
      return {
        isCluster: true,
        id: this.id,
        items: this.data.items || [],
        data: this.data
      };
    }
    /**
     * redraw cluster item
     * @param {boolean} returnQueue
     * @return {boolean}
     */

  }, {
    key: "redraw",
    value: function redraw(returnQueue) {
      var sizes;
      var queue = [// create item DOM
      this._createDomElement.bind(this), // append DOM to parent DOM
      this._appendDomElement.bind(this), // update dirty DOM
      this._updateDirtyDomComponents.bind(this), function () {
        if (this.dirty) {
          sizes = this._getDomComponentsSizes();
        }
      }.bind(this), function () {
        if (this.dirty) {
          this._updateDomComponentsSizes.bind(this)(sizes);
        }
      }.bind(this), // repaint DOM additionals
      this._repaintDomAdditionals.bind(this)];

      if (returnQueue) {
        return queue;
      } else {
        var result;
        queue.forEach(function (fn) {
          result = fn();
        });
        return result;
      }
    }
    /**
     * show cluster item
     */

  }, {
    key: "show",
    value: function show() {
      if (!this.displayed) {
        this.redraw();
      }
    }
    /**
     * Hide the item from the DOM (when visible)
     */

  }, {
    key: "hide",
    value: function hide() {
      if (this.displayed) {
        var dom = this.dom;

        if (dom.box.parentNode) {
          dom.box.parentNode.removeChild(dom.box);
        }

        if (this.options.showStipes) {
          if (dom.line.parentNode) {
            dom.line.parentNode.removeChild(dom.line);
          }

          if (dom.dot.parentNode) {
            dom.dot.parentNode.removeChild(dom.dot);
          }
        }

        this.displayed = false;
      }
    }
    /**
     * reposition item x axis
     */

  }, {
    key: "repositionX",
    value: function repositionX() {
      var start = this.conversion.toScreen(this.data.start);
      var end = this.data.end ? this.conversion.toScreen(this.data.end) : 0;

      if (end) {
        this.repositionXWithRanges(start, end);
      } else {
        var align = this.data.align === undefined ? this.options.align : this.data.align;
        this.repositionXWithoutRanges(start, align);
      }

      if (this.options.showStipes) {
        this.dom.line.style.display = this._isStipeVisible() ? 'block' : 'none';
        this.dom.dot.style.display = this._isStipeVisible() ? 'block' : 'none';

        if (this._isStipeVisible()) {
          this.repositionStype(start, end);
        }
      }
    }
    /**
     * reposition item stype
     * @param {date} start
     * @param {date} end
     */

  }, {
    key: "repositionStype",
    value: function repositionStype(start, end) {
      this.dom.line.style.display = 'block';
      this.dom.dot.style.display = 'block';
      var lineOffsetWidth = this.dom.line.offsetWidth;
      var dotOffsetWidth = this.dom.dot.offsetWidth;

      if (end) {
        var lineOffset = lineOffsetWidth + start + (end - start) / 2;
        var dotOffset = lineOffset - dotOffsetWidth / 2;
        var lineOffsetDirection = this.options.rtl ? lineOffset * -1 : lineOffset;
        var dotOffsetDirection = this.options.rtl ? dotOffset * -1 : dotOffset;
        this.dom.line.style.transform = "translateX(".concat(lineOffsetDirection, ")px");
        this.dom.dot.style.transform = "translateX(".concat(dotOffsetDirection, "px)");
      } else {
        var _lineOffsetDirection = this.options.rtl ? start * -1 : start;

        var _dotOffsetDirection = this.options.rtl ? (start - dotOffsetWidth / 2) * -1 : start - dotOffsetWidth / 2;

        this.dom.line.style.transform = "".concat(_lineOffsetDirection, "px");
        this.dom.dot.style.transform = "".concat(_dotOffsetDirection, "px");
      }
    }
    /**
     * reposition x without ranges
     * @param {date} start
     * @param {string} align
     */

  }, {
    key: "repositionXWithoutRanges",
    value: function repositionXWithoutRanges(start, align) {
      // calculate left position of the box
      if (align == 'right') {
        if (this.options.rtl) {
          this.right = start - this.width; // reposition box, line, and dot

          this.dom.box.style.right = this.right + 'px';
        } else {
          this.left = start - this.width; // reposition box, line, and dot

          this.dom.box.style.left = this.left + 'px';
        }
      } else if (align == 'left') {
        if (this.options.rtl) {
          this.right = start; // reposition box, line, and dot

          this.dom.box.style.right = this.right + 'px';
        } else {
          this.left = start; // reposition box, line, and dot

          this.dom.box.style.left = this.left + 'px';
        }
      } else {
        // default or 'center'
        if (this.options.rtl) {
          this.right = start - this.width / 2; // reposition box, line, and dot

          this.dom.box.style.right = this.right + 'px';
        } else {
          this.left = start - this.width / 2; // reposition box, line, and dot

          this.dom.box.style.left = this.left + 'px';
        }
      }
    }
    /**
     * reposition x with ranges
     * @param {date} start
     * @param {date} end
     */

  }, {
    key: "repositionXWithRanges",
    value: function repositionXWithRanges(start, end) {
      var boxWidth = Math.round(Math.max(end - start + 0.5, 1));

      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }

      this.width = Math.max(boxWidth, this.minWidth || 0);

      if (this.options.rtl) {
        this.dom.box.style.right = this.right + 'px';
      } else {
        this.dom.box.style.left = this.left + 'px';
      }

      this.dom.box.style.width = boxWidth + 'px';
    }
    /**
     * reposition item y axis
     */

  }, {
    key: "repositionY",
    value: function repositionY() {
      var orientation = this.options.orientation.item;
      var box = this.dom.box;

      if (orientation == 'top') {
        box.style.top = (this.top || 0) + 'px';
      } else {
        // orientation 'bottom'
        box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
      }

      if (this.options.showStipes) {
        if (orientation == 'top') {
          this.dom.line.style.top = '0';
          this.dom.line.style.height = this.parent.top + this.top + 1 + 'px';
          this.dom.line.style.bottom = '';
        } else {
          // orientation 'bottom'
          var itemSetHeight = this.parent.itemSet.props.height;
          var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;
          this.dom.line.style.top = itemSetHeight - lineHeight + 'px';
          this.dom.line.style.bottom = '0';
        }

        this.dom.dot.style.top = -this.dom.dot.offsetHeight / 2 + 'px';
      }
    }
    /**
     * get width left
     * @return {number}
     */

  }, {
    key: "getWidthLeft",
    value: function getWidthLeft() {
      return this.width / 2;
    }
    /**
     * get width right
     * @return {number}
     */

  }, {
    key: "getWidthRight",
    value: function getWidthRight() {
      return this.width / 2;
    }
    /**
     * move cluster item
     */

  }, {
    key: "move",
    value: function move() {
      this.repositionX();
      this.repositionY();
    }
    /**
     * attach
     */

  }, {
    key: "attach",
    value: function attach() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.data.uiItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          item.cluster = this;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.data.items = this.data.uiItems.map(function (item) {
        return item.data;
      });
      this.attached = true;
      this.dirty = true;
    }
    /**
     * detach
     * @param {boolean} detachFromParent
     * @return {void}
     */

  }, {
    key: "detach",
    value: function detach() {
      var detachFromParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.hasItems()) {
        return;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.data.uiItems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;
          delete item.cluster;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.attached = false;

      if (detachFromParent && this.group) {
        this.group.remove(this);
        this.group = null;
      }

      this.data.items = [];
      this.dirty = true;
    }
    /**
     * handle on double click
     */

  }, {
    key: "_onDoubleClick",
    value: function _onDoubleClick() {
      this._fit();
    }
    /**
     * set range
     */

  }, {
    key: "_setupRange",
    value: function _setupRange() {
      var stats = this.data.uiItems.map(function (item) {
        return {
          start: item.data.start.valueOf(),
          end: item.data.end ? item.data.end.valueOf() : item.data.start.valueOf()
        };
      });
      this.data.min = Math.min.apply(Math, _toConsumableArray(stats.map(function (s) {
        return Math.min(s.start, s.end || s.start);
      })));
      this.data.max = Math.max.apply(Math, _toConsumableArray(stats.map(function (s) {
        return Math.max(s.start, s.end || s.start);
      })));
      var centers = this.data.uiItems.map(function (item) {
        return item.center;
      });
      var avg = centers.reduce(function (sum, value) {
        return sum + value;
      }, 0) / this.data.uiItems.length;

      if (this.data.uiItems.some(function (item) {
        return item.data.end;
      })) {
        // contains ranges
        this.data.start = new Date(this.data.min);
        this.data.end = new Date(this.data.max);
      } else {
        this.data.start = new Date(avg);
        this.data.end = null;
      }
    }
    /**
     * get UI items
     * @return {array}
     */

  }, {
    key: "_getUiItems",
    value: function _getUiItems() {
      var _this2 = this;

      if (this.data.uiItems && this.data.uiItems.length) {
        return this.data.uiItems.filter(function (item) {
          return item.cluster === _this2;
        });
      }

      return [];
    }
    /**
     * create DOM element
     */

  }, {
    key: "_createDomElement",
    value: function _createDomElement() {
      if (!this.dom) {
        // create DOM
        this.dom = {}; // create main box

        this.dom.box = document.createElement('DIV'); // contents box (inside the background box). used for making margins

        this.dom.content = document.createElement('DIV');
        this.dom.content.className = 'vis-item-content';
        this.dom.box.appendChild(this.dom.content);

        if (this.options.showStipes) {
          // line to axis
          this.dom.line = document.createElement('DIV');
          this.dom.line.className = 'vis-cluster-line';
          this.dom.line.style.display = 'none'; // dot on axis

          this.dom.dot = document.createElement('DIV');
          this.dom.dot.className = 'vis-cluster-dot';
          this.dom.dot.style.display = 'none';
        }

        if (this.options.fitOnDoubleClick) {
          this.dom.box.ondblclick = ClusterItem.prototype._onDoubleClick.bind(this);
        } // attach this item as attribute


        this.dom.box['vis-item'] = this;
        this.dirty = true;
      }
    }
    /**
     * append element to DOM
     */

  }, {
    key: "_appendDomElement",
    value: function _appendDomElement() {
      if (!this.parent) {
        throw new Error('Cannot redraw item: no parent attached');
      }

      if (!this.dom.box.parentNode) {
        var foreground = this.parent.dom.foreground;

        if (!foreground) {
          throw new Error('Cannot redraw item: parent has no foreground container element');
        }

        foreground.appendChild(this.dom.box);
      }

      var background = this.parent.dom.background;

      if (this.options.showStipes) {
        if (!this.dom.line.parentNode) {
          if (!background) throw new Error('Cannot redraw item: parent has no background container element');
          background.appendChild(this.dom.line);
        }

        if (!this.dom.dot.parentNode) {
          var axis = this.parent.dom.axis;
          if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
          axis.appendChild(this.dom.dot);
        }
      }

      this.displayed = true;
    }
    /**
     * update dirty DOM components
     */

  }, {
    key: "_updateDirtyDomComponents",
    value: function _updateDirtyDomComponents() {
      // An item is marked dirty when:
      // - the item is not yet rendered
      // - the item's data is changed
      // - the item is selected/deselected
      if (this.dirty) {
        this._updateContents(this.dom.content);

        this._updateDataAttributes(this.dom.box);

        this._updateStyle(this.dom.box); // update class


        var className = this.baseClassName + ' ' + (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + ' vis-readonly';
        this.dom.box.className = 'vis-item ' + className;

        if (this.options.showStipes) {
          this.dom.line.className = 'vis-item vis-cluster-line ' + (this.selected ? ' vis-selected' : '');
          this.dom.dot.className = 'vis-item vis-cluster-dot ' + (this.selected ? ' vis-selected' : '');
        }

        if (this.data.end) {
          // turn off max-width to be able to calculate the real width
          // this causes an extra browser repaint/reflow, but so be it
          this.dom.content.style.maxWidth = 'none';
        }
      }
    }
    /**
     * get DOM components sizes
     * @return {object}
     */

  }, {
    key: "_getDomComponentsSizes",
    value: function _getDomComponentsSizes() {
      return {
        previous: {
          right: this.dom.box.style.right,
          left: this.dom.box.style.left
        },
        box: {
          width: this.dom.box.offsetWidth,
          height: this.dom.box.offsetHeight
        }
      };
    }
    /**
     * update DOM components sizes
     * @param {object} sizes
     */

  }, {
    key: "_updateDomComponentsSizes",
    value: function _updateDomComponentsSizes(sizes) {
      if (this.options.rtl) {
        this.dom.box.style.right = "0px";
      } else {
        this.dom.box.style.left = "0px";
      } // recalculate size


      if (!this.data.end) {
        this.width = sizes.box.width;
      } else {
        this.minWidth = sizes.box.width;
      }

      this.height = sizes.box.height; // restore previous position

      if (this.options.rtl) {
        this.dom.box.style.right = sizes.previous.right;
      } else {
        this.dom.box.style.left = sizes.previous.left;
      }

      this.dirty = false;
    }
    /**
     * repaint DOM additional components
     */

  }, {
    key: "_repaintDomAdditionals",
    value: function _repaintDomAdditionals() {
      this._repaintOnItemUpdateTimeTooltip(this.dom.box);
    }
    /**
     * check is stripe visible
     * @return {number}
     * @private
     */

  }, {
    key: "_isStipeVisible",
    value: function _isStipeVisible() {
      return this.minWidth >= this.width || !this.data.end;
    }
    /**
     * get fit range
     * @return {object}
     * @private
     */

  }, {
    key: "_getFitRange",
    value: function _getFitRange() {
      var offset = 0.05 * (this.data.max - this.data.min) / 2;
      return {
        fitStart: this.data.min - offset,
        fitEnd: this.data.max + offset
      };
    }
    /**
    * fit
    * @private
    */

  }, {
    key: "_fit",
    value: function _fit() {
      if (this.emitter) {
        var _this$_getFitRange = this._getFitRange(),
            fitStart = _this$_getFitRange.fitStart,
            fitEnd = _this$_getFitRange.fitEnd;

        var fitArgs = {
          start: new Date(fitStart),
          end: new Date(fitEnd),
          animation: true
        };
        this.emitter.emit('fit', fitArgs);
      }
    }
    /**
    * get item data
    * @return {object}
    * @private
    */

  }, {
    key: "_getItemData",
    value: function _getItemData() {
      return this.data;
    }
  }]);

  return ClusterItem;
}(Item);

ClusterItem.prototype.baseClassName = 'vis-item vis-range vis-cluster';
var UNGROUPED$1 = '__ungrouped__'; // reserved group id for ungrouped items

var BACKGROUND$1 = '__background__'; // reserved group id for background items without group

var ReservedGroupIds$1 = {
  UNGROUPED: UNGROUPED$1,
  BACKGROUND: BACKGROUND$1
  /**
   * An Cluster generator generates cluster items
   */

};

var ClusterGenerator =
/*#__PURE__*/
function () {
  /**
   * @param {ItemSet} itemSet itemsSet instance
   * @constructor ClusterGenerator
  */
  function ClusterGenerator(itemSet) {
    _classCallCheck(this, ClusterGenerator);

    this.itemSet = itemSet;
    this.groups = {};
    this.cache = {};
    this.cache[-1] = [];
  }
  /**
   * @param {Object} itemData             Object containing parameters start content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   * @return {Object} newItem
  */


  _createClass(ClusterGenerator, [{
    key: "createClusterItem",
    value: function createClusterItem(itemData, conversion, options) {
      var newItem = new ClusterItem(itemData, conversion, options);
      return newItem;
    }
    /**
     * Set the items to be clustered.
     * This will clear cached clusters.
     * @param {Item[]} items
     * @param {Object} [options]  Available options:
     *                            {boolean} applyOnChangedLevel
     *                                If true (default), the changed data is applied
     *                                as soon the cluster level changes. If false,
     *                                The changed data is applied immediately
     */

  }, {
    key: "setItems",
    value: function setItems(items, options) {
      this.items = items || [];
      this.dataChanged = true;
      this.applyOnChangedLevel = false;

      if (options && options.applyOnChangedLevel) {
        this.applyOnChangedLevel = options.applyOnChangedLevel;
      }
    }
    /**
     * Update the current data set: clear cache, and recalculate the clustering for
     * the current level
     */

  }, {
    key: "updateData",
    value: function updateData() {
      this.dataChanged = true;
      this.applyOnChangedLevel = false;
    }
    /**
     * Cluster the items which are too close together
     * @param {array} oldClusters 
     * @param {number} scale      The scale of the current window : (windowWidth / (endDate - startDate)) 
     * @param {{maxItems: number, clusterCriteria: function, titleTemplate: string}} options             
     * @return {array} clusters
    */

  }, {
    key: "getClusters",
    value: function getClusters(oldClusters, scale, options) {
      var _ref = typeof options === "boolean" ? {} : options,
          maxItems = _ref.maxItems,
          clusterCriteria = _ref.clusterCriteria;

      if (!clusterCriteria) {
        clusterCriteria = function clusterCriteria() {
          return true;
        };
      }

      maxItems = maxItems || 1;
      var level = -1;
      var granularity = 2;
      var timeWindow = 0;

      if (scale > 0) {
        if (scale >= 1) {
          return [];
        }

        level = Math.abs(Math.round(Math.log(100 / scale) / Math.log(granularity)));
        timeWindow = Math.abs(Math.pow(granularity, level));
      } // clear the cache when and re-generate groups the data when needed.


      if (this.dataChanged) {
        var levelChanged = level != this.cacheLevel;
        var applyDataNow = this.applyOnChangedLevel ? levelChanged : true;

        if (applyDataNow) {
          this._dropLevelsCache();

          this._filterData();
        }
      }

      this.cacheLevel = level;
      var clusters = this.cache[level];

      if (!clusters) {
        clusters = [];

        for (var groupName in this.groups) {
          if (this.groups.hasOwnProperty(groupName)) {
            var items = this.groups[groupName];
            var iMax = items.length;
            var i = 0;

            while (i < iMax) {
              // find all items around current item, within the timeWindow
              var item = items[i];
              var neighbors = 1; // start at 1, to include itself)
              // loop through items left from the current item

              var j = i - 1;

              while (j >= 0 && item.center - items[j].center < timeWindow / 2) {
                if (!items[j].cluster && clusterCriteria(item.data, items[j].data)) {
                  neighbors++;
                }

                j--;
              } // loop through items right from the current item


              var k = i + 1;

              while (k < items.length && items[k].center - item.center < timeWindow / 2) {
                if (clusterCriteria(item.data, items[k].data)) {
                  neighbors++;
                }

                k++;
              } // loop through the created clusters


              var l = clusters.length - 1;

              while (l >= 0 && item.center - clusters[l].center < timeWindow) {
                if (item.group == clusters[l].group && clusterCriteria(item.data, clusters[l].data)) {
                  neighbors++;
                }

                l--;
              } // aggregate until the number of items is within maxItems


              if (neighbors > maxItems) {
                // too busy in this window.
                var num = neighbors - maxItems + 1;
                var clusterItems = []; // append the items to the cluster,
                // and calculate the average start for the cluster

                var m = i;

                while (clusterItems.length < num && m < items.length) {
                  if (clusterCriteria(items[m].data, items[m].data)) {
                    clusterItems.push(items[m]);
                  }

                  m++;
                }

                var groupId = this.itemSet.getGroupId(item.data);
                var group = this.itemSet.groups[groupId] || this.itemSet.groups[ReservedGroupIds$1.UNGROUPED];

                var cluster = this._getClusterForItems(clusterItems, group, oldClusters, options);

                clusters.push(cluster);
                i += num;
              } else {
                delete item.cluster;
                i += 1;
              }
            }
          }
        }

        this.cache[level] = clusters;
      }

      return clusters;
    }
    /**
     * Filter the items per group.
     * @private
     */

  }, {
    key: "_filterData",
    value: function _filterData() {
      // filter per group
      var groups = {};
      this.groups = groups; // split the items per group

      for (var _i = 0, _Object$values = Object.values(this.items); _i < _Object$values.length; _i++) {
        var item = _Object$values[_i]; // put the item in the correct group

        var groupName = item.parent ? item.parent.groupId : '';
        var group = groups[groupName];

        if (!group) {
          group = [];
          groups[groupName] = group;
        }

        group.push(item); // calculate the center of the item

        if (item.data.start) {
          if (item.data.end) {
            // range
            item.center = (item.data.start.valueOf() + item.data.end.valueOf()) / 2;
          } else {
            // box, dot
            item.center = item.data.start.valueOf();
          }
        }
      } // sort the items per group


      for (var currentGroupName in groups) {
        if (groups.hasOwnProperty(currentGroupName)) {
          groups[currentGroupName].sort(function (a, b) {
            return a.center - b.center;
          });
        }
      }

      this.dataChanged = false;
    }
    /**
     * Create new cluster or return existing
     * @private
     * @param {array} clusterItems    
     * @param {object} group 
     * @param {array} oldClusters 
     * @param {object} options 
     * @returns {object} cluster
     */

  }, {
    key: "_getClusterForItems",
    value: function _getClusterForItems(clusterItems, group, oldClusters, options) {
      var oldClustersLookup = (oldClusters || []).map(function (cluster) {
        return {
          cluster: cluster,
          itemsIds: new Set(cluster.data.uiItems.map(function (item) {
            return item.id;
          }))
        };
      });
      var cluster;

      if (oldClustersLookup.length) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          var _loop = function _loop() {
            var oldClusterData = _step.value;

            if (oldClusterData.itemsIds.size === clusterItems.length && clusterItems.every(function (clusterItem) {
              return oldClusterData.itemsIds.has(clusterItem.id);
            })) {
              cluster = oldClusterData.cluster;
              return "break";
            }
          };

          for (var _iterator = oldClustersLookup[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ret = _loop();

            if (_ret === "break") break;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (cluster) {
        cluster.setUiItems(clusterItems);

        if (cluster.group !== group) {
          if (cluster.group) {
            cluster.group.remove(cluster);
          }

          if (group) {
            group.add(cluster);
            cluster.group = group;
          }
        }

        return cluster;
      }

      var titleTemplate = options.titleTemplate || '';
      var conversion = {
        toScreen: this.itemSet.body.util.toScreen,
        toTime: this.itemSet.body.util.toTime
      };
      var clusterContent = '<div title="' + title + '">' + clusterItems.length + '</div>';
      var title = titleTemplate.replace(/{count}/, clusterItems.length);
      var clusterOptions = Object.assign({}, options, this.itemSet.options);
      var data = {
        'content': clusterContent,
        'title': title,
        'group': group,
        'uiItems': clusterItems,
        'eventEmitter': this.itemSet.body.emitter,
        'range': this.itemSet.body.range
      };
      cluster = this.createClusterItem(data, conversion, clusterOptions);

      if (group) {
        group.add(cluster);
        cluster.group = group;
      }

      cluster.attach();
      return cluster;
    }
    /**
     * Drop cache
     * @private
     */

  }, {
    key: "_dropLevelsCache",
    value: function _dropLevelsCache() {
      this.cache = {};
      this.cacheLevel = -1;
      this.cache[this.cacheLevel] = [];
    }
  }]);

  return ClusterGenerator;
}();

var UNGROUPED$2 = '__ungrouped__'; // reserved group id for ungrouped items

var BACKGROUND$2 = '__background__'; // reserved group id for background items without group

var ItemSet =
/*#__PURE__*/
function (_Component) {
  _inherits(ItemSet, _Component);
  /**
  * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
  * @param {Object} [options]      See ItemSet.setOptions for the available options.
  * @constructor ItemSet
  * @extends Component
  */


  function ItemSet(body, options) {
    var _this;

    _classCallCheck(this, ItemSet);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ItemSet).call(this));
    _this.body = body;
    _this.defaultOptions = {
      type: null,
      // 'box', 'point', 'range', 'background'
      orientation: {
        item: 'bottom' // item orientation: 'top' or 'bottom'

      },
      align: 'auto',
      // alignment of box items
      stack: true,
      stackSubgroups: true,
      groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
        // eslint-disable-line no-unused-vars
        var targetOrder = toGroup.order;
        toGroup.order = fromGroup.order;
        fromGroup.order = targetOrder;
      },
      groupOrder: 'order',
      selectable: true,
      multiselect: false,
      itemsAlwaysDraggable: {
        item: false,
        range: false
      },
      editable: {
        updateTime: false,
        updateGroup: false,
        add: false,
        remove: false,
        overrideItems: false
      },
      groupEditable: {
        order: false,
        add: false,
        remove: false
      },
      snap: TimeStep.snap,
      // Only called when `objectData.target === 'item'.
      onDropObjectOnItem: function onDropObjectOnItem(objectData, item, callback) {
        callback(item);
      },
      onAdd: function onAdd(item, callback) {
        callback(item);
      },
      onUpdate: function onUpdate(item, callback) {
        callback(item);
      },
      onMove: function onMove(item, callback) {
        callback(item);
      },
      onRemove: function onRemove(item, callback) {
        callback(item);
      },
      onMoving: function onMoving(item, callback) {
        callback(item);
      },
      onAddGroup: function onAddGroup(item, callback) {
        callback(item);
      },
      onMoveGroup: function onMoveGroup(item, callback) {
        callback(item);
      },
      onRemoveGroup: function onRemoveGroup(item, callback) {
        callback(item);
      },
      margin: {
        item: {
          horizontal: 10,
          vertical: 10
        },
        axis: 20
      },
      showTooltips: true,
      tooltip: {
        followMouse: false,
        overflowMethod: 'flip',
        delay: 500
      },
      tooltipOnItemUpdateTime: false
    }; // options is shared by this ItemSet and all its items

    _this.options = util$2.extend({}, _this.defaultOptions);
    _this.options.rtl = options.rtl;
    _this.options.onTimeout = options.onTimeout; // options for getting items from the DataSet with the correct type

    _this.itemOptions = {
      type: {
        start: 'Date',
        end: 'Date'
      }
    };
    _this.conversion = {
      toScreen: body.util.toScreen,
      toTime: body.util.toTime
    };
    _this.dom = {};
    _this.props = {};
    _this.hammer = null;

    var me = _assertThisInitialized(_this);

    _this.itemsData = null; // DataSet

    _this.groupsData = null; // DataSet

    _this.itemsSettingTime = null;
    _this.initialItemSetDrawn = false;
    _this.userContinueNotBail = null;
    _this.sequentialSelection = false; // listeners for the DataSet of the items

    _this.itemListeners = {
      'add': function add(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onAdd(params.items);

        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }

        me.redraw();
      },
      'update': function update(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onUpdate(params.items);

        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }

        me.redraw();
      },
      'remove': function remove(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onRemove(params.items);

        if (me.options.cluster) {
          me.clusterGenerator.setItems(me.items, {
            applyOnChangedLevel: false
          });
        }

        me.redraw();
      }
    }; // listeners for the DataSet of the groups

    _this.groupListeners = {
      'add': function add(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onAddGroups(params.items);

        if (me.groupsData && me.groupsData.length > 0) {
          var groupsData = me.groupsData.getDataSet();
          groupsData.get().forEach(function (groupData) {
            if (groupData.nestedGroups) {
              if (groupData.showNested != false) {
                groupData.showNested = true;
              }

              var updatedGroups = [];
              groupData.nestedGroups.forEach(function (nestedGroupId) {
                var updatedNestedGroup = groupsData.get(nestedGroupId);

                if (!updatedNestedGroup) {
                  return;
                }

                updatedNestedGroup.nestedInGroup = groupData.id;

                if (groupData.showNested == false) {
                  updatedNestedGroup.visible = false;
                }

                updatedGroups = updatedGroups.concat(updatedNestedGroup);
              });
              groupsData.update(updatedGroups, senderId);
            }
          });
        }
      },
      'update': function update(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        // eslint-disable-line no-unused-vars
        me._onRemoveGroups(params.items);
      }
    };
    _this.items = {}; // object with an Item for every data item

    _this.groups = {}; // Group object for every group

    _this.groupIds = [];
    _this.selection = []; // list with the ids of all selected nodes

    _this.popup = null;
    _this.popupTimer = null;
    _this.touchParams = {}; // stores properties while dragging

    _this.groupTouchParams = {
      group: null,
      isDragging: false
    }; // create the HTML DOM

    _this._create();

    _this.setOptions(options);

    _this.clusters = [];
    return _this;
  }
  /**
   * Create the HTML DOM for the ItemSet
   */


  _createClass(ItemSet, [{
    key: "_create",
    value: function _create() {
      var _this2 = this;

      var frame = document.createElement('div');
      frame.className = 'vis-itemset';
      frame['vis-itemset'] = this;
      this.dom.frame = frame; // create background panel

      var background = document.createElement('div');
      background.className = 'vis-background';
      frame.appendChild(background);
      this.dom.background = background; // create foreground panel

      var foreground = document.createElement('div');
      foreground.className = 'vis-foreground';
      frame.appendChild(foreground);
      this.dom.foreground = foreground; // create axis panel

      var axis = document.createElement('div');
      axis.className = 'vis-axis';
      this.dom.axis = axis; // create labelset

      var labelSet = document.createElement('div');
      labelSet.className = 'vis-labelset';
      this.dom.labelSet = labelSet; // create ungrouped Group

      this._updateUngrouped(); // create background Group


      var backgroundGroup = new BackgroundGroup(BACKGROUND$2, null, this);
      backgroundGroup.show();
      this.groups[BACKGROUND$2] = backgroundGroup; // attach event listeners
      // Note: we bind to the centerContainer for the case where the height
      //       of the center container is larger than of the ItemSet, so we
      //       can click in the empty area to create a new item or deselect an item.

      this.hammer = new Hammer$1(this.body.dom.centerContainer); // drag items when selected

      this.hammer.on('hammer.input', function (event) {
        if (event.isFirst) {
          _this2._onTouch(event);
        }
      });
      this.hammer.on('panstart', this._onDragStart.bind(this));
      this.hammer.on('panmove', this._onDrag.bind(this));
      this.hammer.on('panend', this._onDragEnd.bind(this));
      this.hammer.get('pan').set({
        threshold: 5,
        direction: Hammer$1.ALL
      }); // single select (or unselect) when tapping an item

      this.hammer.on('tap', this._onSelectItem.bind(this)); // multi select when holding mouse/touch, or on ctrl+click

      this.hammer.on('press', this._onMultiSelectItem.bind(this)); // add item on doubletap

      this.hammer.on('doubletap', this._onAddItem.bind(this));

      if (this.options.rtl) {
        this.groupHammer = new Hammer$1(this.body.dom.rightContainer);
      } else {
        this.groupHammer = new Hammer$1(this.body.dom.leftContainer);
      }

      this.groupHammer.on('tap', this._onGroupClick.bind(this));
      this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
      this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
      this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
      this.groupHammer.get('pan').set({
        threshold: 5,
        direction: Hammer$1.DIRECTION_VERTICAL
      });
      this.body.dom.centerContainer.addEventListener('mouseover', this._onMouseOver.bind(this));
      this.body.dom.centerContainer.addEventListener('mouseout', this._onMouseOut.bind(this));
      this.body.dom.centerContainer.addEventListener('mousemove', this._onMouseMove.bind(this)); // right-click on timeline 

      this.body.dom.centerContainer.addEventListener('contextmenu', this._onDragEnd.bind(this));
      this.body.dom.centerContainer.addEventListener('mousewheel', this._onMouseWheel.bind(this)); // attach to the DOM

      this.show();
    }
    /**
     * Set options for the ItemSet. Existing options will be extended/overwritten.
     * @param {Object} [options] The following options are available:
     *                           {string} type
     *                              Default type for the items. Choose from 'box'
     *                              (default), 'point', 'range', or 'background'.
     *                              The default style can be overwritten by
     *                              individual items.
     *                           {string} align
     *                              Alignment for the items, only applicable for
     *                              BoxItem. Choose 'center' (default), 'left', or
     *                              'right'.
     *                           {string} orientation.item
     *                              Orientation of the item set. Choose 'top' or
     *                              'bottom' (default).
     *                           {Function} groupOrder
     *                              A sorting function for ordering groups
     *                           {boolean} stack
     *                              If true (default), items will be stacked on
     *                              top of each other.
     *                           {number} margin.axis
     *                              Margin between the axis and the items in pixels.
     *                              Default is 20.
     *                           {number} margin.item.horizontal
     *                              Horizontal margin between items in pixels.
     *                              Default is 10.
     *                           {number} margin.item.vertical
     *                              Vertical Margin between items in pixels.
     *                              Default is 10.
     *                           {number} margin.item
     *                              Margin between items in pixels in both horizontal
     *                              and vertical direction. Default is 10.
     *                           {number} margin
     *                              Set margin for both axis and items in pixels.
     *                           {boolean} selectable
     *                              If true (default), items can be selected.
     *                           {boolean} multiselect
     *                              If true, multiple items can be selected.
     *                              False by default.
     *                           {boolean} editable
     *                              Set all editable options to true or false
     *                           {boolean} editable.updateTime
     *                              Allow dragging an item to an other moment in time
     *                           {boolean} editable.updateGroup
     *                              Allow dragging an item to an other group
     *                           {boolean} editable.add
     *                              Allow creating new items on double tap
     *                           {boolean} editable.remove
     *                              Allow removing items by clicking the delete button
     *                              top right of a selected item.
     *                           {Function(item: Item, callback: Function)} onAdd
     *                              Callback function triggered when an item is about to be added:
     *                              when the user double taps an empty space in the Timeline.
     *                           {Function(item: Item, callback: Function)} onUpdate
     *                              Callback function fired when an item is about to be updated.
     *                              This function typically has to show a dialog where the user
     *                              change the item. If not implemented, nothing happens.
     *                           {Function(item: Item, callback: Function)} onMove
     *                              Fired when an item has been moved. If not implemented,
     *                              the move action will be accepted.
     *                           {Function(item: Item, callback: Function)} onRemove
     *                              Fired when an item is about to be deleted.
     *                              If not implemented, the item will be always removed.
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this3 = this;

      if (options) {
        // copy all options that we know
        var fields = ['type', 'rtl', 'align', 'order', 'stack', 'stackSubgroups', 'selectable', 'multiselect', 'sequentialSelection', 'multiselectPerGroup', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'visibleFrameTemplate', 'hide', 'snap', 'groupOrderSwap', 'showTooltips', 'tooltip', 'tooltipOnItemUpdateTime', 'groupHeightMode', 'onTimeout'];
        util$2.selectiveExtend(fields, this.options, options);

        if ('itemsAlwaysDraggable' in options) {
          if (typeof options.itemsAlwaysDraggable === 'boolean') {
            this.options.itemsAlwaysDraggable.item = options.itemsAlwaysDraggable;
            this.options.itemsAlwaysDraggable.range = false;
          } else if (_typeof(options.itemsAlwaysDraggable) === 'object') {
            util$2.selectiveExtend(['item', 'range'], this.options.itemsAlwaysDraggable, options.itemsAlwaysDraggable); // only allow range always draggable when item is always draggable as well

            if (!this.options.itemsAlwaysDraggable.item) {
              this.options.itemsAlwaysDraggable.range = false;
            }
          }
        }

        if ('sequentialSelection' in options) {
          if (typeof options.sequentialSelection === 'boolean') {
            this.options.sequentialSelection = options.sequentialSelection;
          }
        }

        if ('orientation' in options) {
          if (typeof options.orientation === 'string') {
            this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
          } else if (_typeof(options.orientation) === 'object' && 'item' in options.orientation) {
            this.options.orientation.item = options.orientation.item;
          }
        }

        if ('margin' in options) {
          if (typeof options.margin === 'number') {
            this.options.margin.axis = options.margin;
            this.options.margin.item.horizontal = options.margin;
            this.options.margin.item.vertical = options.margin;
          } else if (_typeof(options.margin) === 'object') {
            util$2.selectiveExtend(['axis'], this.options.margin, options.margin);

            if ('item' in options.margin) {
              if (typeof options.margin.item === 'number') {
                this.options.margin.item.horizontal = options.margin.item;
                this.options.margin.item.vertical = options.margin.item;
              } else if (_typeof(options.margin.item) === 'object') {
                util$2.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
              }
            }
          }
        }

        ['locale', 'locales'].forEach(function (key) {
          if (key in options) {
            _this3.options[key] = options[key];
          }
        });

        if ('editable' in options) {
          if (typeof options.editable === 'boolean') {
            this.options.editable.updateTime = options.editable;
            this.options.editable.updateGroup = options.editable;
            this.options.editable.add = options.editable;
            this.options.editable.remove = options.editable;
            this.options.editable.overrideItems = false;
          } else if (_typeof(options.editable) === 'object') {
            util$2.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove', 'overrideItems'], this.options.editable, options.editable);
          }
        }

        if ('groupEditable' in options) {
          if (typeof options.groupEditable === 'boolean') {
            this.options.groupEditable.order = options.groupEditable;
            this.options.groupEditable.add = options.groupEditable;
            this.options.groupEditable.remove = options.groupEditable;
          } else if (_typeof(options.groupEditable) === 'object') {
            util$2.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
          }
        } // callback functions


        var addCallback = function addCallback(name) {
          var fn = options[name];

          if (fn) {
            if (!(typeof fn === 'function')) {
              throw new Error("option ".concat(name, " must be a function ").concat(name, "(item, callback)"));
            }

            _this3.options[name] = fn;
          }
        };

        ['onDropObjectOnItem', 'onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

        if (options.cluster) {
          Object.assign(this.options, {
            cluster: options.cluster
          });

          if (!this.clusterGenerator) {
            this.clusterGenerator = new ClusterGenerator(this);
          }

          this.clusterGenerator.setItems(this.items, {
            applyOnChangedLevel: false
          });
          this.markDirty({
            refreshItems: true,
            restackGroups: true
          });
          this.redraw();
        } else if (this.clusterGenerator) {
          this._detachAllClusters();

          this.clusters = [];
          this.clusterGenerator = null;
          this.options.cluster = undefined;
          this.markDirty({
            refreshItems: true,
            restackGroups: true
          });
          this.redraw();
        } else {
          // force the itemSet to refresh: options like orientation and margins may be changed
          this.markDirty();
        }
      }
    }
    /**
     * Mark the ItemSet dirty so it will refresh everything with next redraw.
     * Optionally, all items can be marked as dirty and be refreshed.
     * @param {{refreshItems: boolean}} [options]
     */

  }, {
    key: "markDirty",
    value: function markDirty(options) {
      this.groupIds = [];

      if (options) {
        if (options.refreshItems) {
          util$2.forEach(this.items, function (item) {
            item.dirty = true;
            if (item.displayed) item.redraw();
          });
        }

        if (options.restackGroups) {
          util$2.forEach(this.groups, function (group, key) {
            if (key === BACKGROUND$2) return;
            group.stackDirty = true;
          });
        }
      }
    }
    /**
     * Destroy the ItemSet
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.clearPopupTimer();
      this.hide();
      this.setItems(null);
      this.setGroups(null);
      this.hammer && this.hammer.destroy();
      this.groupHammer && this.groupHammer.destroy();
      this.hammer = null;
      this.body = null;
      this.conversion = null;
    }
    /**
     * Hide the component from the DOM
     */

  }, {
    key: "hide",
    value: function hide() {
      // remove the frame containing the items
      if (this.dom.frame.parentNode) {
        this.dom.frame.parentNode.removeChild(this.dom.frame);
      } // remove the axis with dots


      if (this.dom.axis.parentNode) {
        this.dom.axis.parentNode.removeChild(this.dom.axis);
      } // remove the labelset containing all group labels


      if (this.dom.labelSet.parentNode) {
        this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
      }
    }
    /**
     * Show the component in the DOM (when not already visible).
     */

  }, {
    key: "show",
    value: function show() {
      // show frame containing the items
      if (!this.dom.frame.parentNode) {
        this.body.dom.center.appendChild(this.dom.frame);
      } // show axis with dots


      if (!this.dom.axis.parentNode) {
        this.body.dom.backgroundVertical.appendChild(this.dom.axis);
      } // show labelset containing labels


      if (!this.dom.labelSet.parentNode) {
        if (this.options.rtl) {
          this.body.dom.right.appendChild(this.dom.labelSet);
        } else {
          this.body.dom.left.appendChild(this.dom.labelSet);
        }
      }
    }
    /**
     * Activates the popup timer to show the given popup after a fixed time.
     * @param {Popup} popup
     */

  }, {
    key: "setPopupTimer",
    value: function setPopupTimer(popup) {
      this.clearPopupTimer();

      if (popup) {
        var delay = this.options.tooltip.delay || typeof this.options.tooltip.delay === 'number' ? this.options.tooltip.delay : 500;
        this.popupTimer = setTimeout(function () {
          popup.show();
        }, delay);
      }
    }
    /**
     * Clears the popup timer for the tooltip.
     */

  }, {
    key: "clearPopupTimer",
    value: function clearPopupTimer() {
      if (this.popupTimer != null) {
        clearTimeout(this.popupTimer);
        this.popupTimer = null;
      }
    }
    /**
     * Set selected items by their id. Replaces the current selection
     * Unknown id's are silently ignored.
     * @param {string[] | string} [ids] An array with zero or more id's of the items to be
     *                                  selected, or a single item id. If ids is undefined
     *                                  or an empty array, all items will be unselected.
     */

  }, {
    key: "setSelection",
    value: function setSelection(ids) {
      if (ids == undefined) {
        ids = [];
      }

      if (!Array.isArray(ids)) {
        ids = [ids];
      }

      var idsToDeselect = this.selection.filter(function (id) {
        return ids.indexOf(id) === -1;
      }); // unselect currently selected items

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = idsToDeselect[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var selectedId = _step.value;
          var item = this.getItemById(selectedId);

          if (item) {
            item.unselect();
          }
        } // select items

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.selection = _toConsumableArray(ids);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var id = _step2.value;

          var _item2 = this.getItemById(id);

          if (_item2) {
            _item2.select();
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * Get the selected items by their id
     * @return {Array} ids  The ids of the selected items
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return this.selection.concat([]);
    }
    /**
     * Get the id's of the currently visible items.
     * @returns {Array} The ids of the visible items
     */

  }, {
    key: "getVisibleItems",
    value: function getVisibleItems() {
      var range = this.body.range.getRange();
      var right;
      var left;

      if (this.options.rtl) {
        right = this.body.util.toScreen(range.start);
        left = this.body.util.toScreen(range.end);
      } else {
        left = this.body.util.toScreen(range.start);
        right = this.body.util.toScreen(range.end);
      }

      var ids = [];

      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          var group = this.groups[groupId];
          var rawVisibleItems = group.isVisible ? group.visibleItems : []; // filter the "raw" set with visibleItems into a set which is really
          // visible by pixels

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = rawVisibleItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var item = _step3.value; // TODO: also check whether visible vertically

              if (this.options.rtl) {
                if (item.right < left && item.right + item.width > right) {
                  ids.push(item.id);
                }
              } else {
                if (item.left < right && item.left + item.width > left) {
                  ids.push(item.id);
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }

      return ids;
    }
    /**
     * Get the id's of the currently visible groups.
     * @returns {Array} The ids of the visible groups
     */

  }, {
    key: "getVisibleGroups",
    value: function getVisibleGroups() {
      var ids = [];

      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          var group = this.groups[groupId];

          if (group.isVisible) {
            ids.push(groupId);
          }
        }
      }

      return ids;
    }
    /**
     * get item by id
     * @param {string} id
     * @return {object} item
     */

  }, {
    key: "getItemById",
    value: function getItemById(id) {
      return this.items[id] || this.clusters.find(function (cluster) {
        return cluster.id === id;
      });
    }
    /**
     * Deselect a selected item
     * @param {string | number} id
     * @private
     */

  }, {
    key: "_deselect",
    value: function _deselect(id) {
      var selection = this.selection;

      for (var i = 0, ii = selection.length; i < ii; i++) {
        if (selection[i] == id) {
          // non-strict comparison!
          selection.splice(i, 1);
          break;
        }
      }
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      var _this4 = this;

      var margin = this.options.margin;
      var range = this.body.range;
      var asSize = util$2.option.asSize;
      var options = this.options;
      var orientation = options.orientation.item;
      var resized = false;
      var frame = this.dom.frame; // recalculate absolute position (before redrawing groups)

      this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;

      if (this.options.rtl) {
        this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
      } else {
        this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
      } // update class name


      frame.className = 'vis-itemset';

      if (this.options.cluster) {
        this._clusterItems();
      } // reorder the groups (if needed)


      resized = this._orderGroups() || resized; // check whether zoomed (in that case we need to re-stack everything)
      // TODO: would be nicer to get this as a trigger from Range

      var visibleInterval = range.end - range.start;
      var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
      var scrolled = range.start != this.lastRangeStart;
      var changedStackOption = options.stack != this.lastStack;
      var changedStackSubgroupsOption = options.stackSubgroups != this.lastStackSubgroups;
      var forceRestack = zoomed || scrolled || changedStackOption || changedStackSubgroupsOption;
      this.lastVisibleInterval = visibleInterval;
      this.lastRangeStart = range.start;
      this.lastStack = options.stack;
      this.lastStackSubgroups = options.stackSubgroups;
      this.props.lastWidth = this.props.width;

      var firstGroup = this._firstGroup();

      var firstMargin = {
        item: margin.item,
        axis: margin.axis
      };
      var nonFirstMargin = {
        item: margin.item,
        axis: margin.item.vertical / 2
      };
      var height = 0;
      var minHeight = margin.axis + margin.item.vertical; // redraw the background group

      this.groups[BACKGROUND$2].redraw(range, nonFirstMargin, forceRestack);
      var redrawQueue = {};
      var redrawQueueLength = 0; // collect redraw functions

      util$2.forEach(this.groups, function (group, key) {
        if (key === BACKGROUND$2) return;
        var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
        var returnQueue = true;
        redrawQueue[key] = group.redraw(range, groupMargin, forceRestack, returnQueue);
        redrawQueueLength = redrawQueue[key].length;
      });
      var needRedraw = redrawQueueLength > 0;

      if (needRedraw) {
        (function () {
          var redrawResults = {};

          var _loop = function _loop(i) {
            util$2.forEach(redrawQueue, function (fns, key) {
              redrawResults[key] = fns[i]();
            });
          };

          for (var i = 0; i < redrawQueueLength; i++) {
            _loop(i);
          } // redraw all regular groups


          util$2.forEach(_this4.groups, function (group, key) {
            if (key === BACKGROUND$2) return;
            var groupResized = redrawResults[key];
            resized = groupResized || resized;
            height += group.height;
          });
          height = Math.max(height, minHeight);
        })();
      }

      height = Math.max(height, minHeight); // update frame height

      frame.style.height = asSize(height); // calculate actual size

      this.props.width = frame.offsetWidth;
      this.props.height = height; // reposition axis

      this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);

      if (this.options.rtl) {
        this.dom.axis.style.right = '0';
      } else {
        this.dom.axis.style.left = '0';
      }

      this.initialItemSetDrawn = true; // check if this component is resized

      resized = this._isResized() || resized;
      return resized;
    }
    /**
     * Get the first group, aligned with the axis
     * @return {Group | null} firstGroup
     * @private
     */

  }, {
    key: "_firstGroup",
    value: function _firstGroup() {
      var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
      var firstGroupId = this.groupIds[firstGroupIndex];
      var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED$2];
      return firstGroup || null;
    }
    /**
     * Create or delete the group holding all ungrouped items. This group is used when
     * there are no groups specified.
     * @protected
     */

  }, {
    key: "_updateUngrouped",
    value: function _updateUngrouped() {
      var ungrouped = this.groups[UNGROUPED$2];
      var item;
      var itemId;

      if (this.groupsData) {
        // remove the group holding all ungrouped items
        if (ungrouped) {
          ungrouped.hide();
          delete this.groups[UNGROUPED$2];

          for (itemId in this.items) {
            if (this.items.hasOwnProperty(itemId)) {
              item = this.items[itemId];
              item.parent && item.parent.remove(item);
              var groupId = this.getGroupId(item.data);
              var group = this.groups[groupId];
              group && group.add(item) || item.hide();
            }
          }
        }
      } else {
        // create a group holding all (unfiltered) items
        if (!ungrouped) {
          var id = null;
          var data = null;
          ungrouped = new Group(id, data, this);
          this.groups[UNGROUPED$2] = ungrouped;

          for (itemId in this.items) {
            if (this.items.hasOwnProperty(itemId)) {
              item = this.items[itemId];
              ungrouped.add(item);
            }
          }

          ungrouped.show();
        }
      }
    }
    /**
     * Get the element for the labelset
     * @return {HTMLElement} labelSet
     */

  }, {
    key: "getLabelSet",
    value: function getLabelSet() {
      return this.dom.labelSet;
    }
    /**
     * Set items
     * @param {vis.DataSet | null} items
     */

  }, {
    key: "setItems",
    value: function setItems(items) {
      this.itemsSettingTime = new Date();
      var me = this;
      var ids;
      var oldItemsData = this.itemsData; // replace the dataset

      if (!items) {
        this.itemsData = null;
      } else if (items instanceof DataSet || items instanceof DataView$2) {
        this.itemsData = items;
      } else {
        throw new TypeError('Data must be an instance of DataSet or DataView');
      }

      if (oldItemsData) {
        // unsubscribe from old dataset
        util$2.forEach(this.itemListeners, function (callback, event) {
          oldItemsData.off(event, callback);
        }); // remove all drawn items

        ids = oldItemsData.getIds();

        this._onRemove(ids);
      }

      if (this.itemsData) {
        // subscribe to new dataset
        var id = this.id;
        util$2.forEach(this.itemListeners, function (callback, event) {
          me.itemsData.on(event, callback, id);
        }); // add all new items

        ids = this.itemsData.getIds();

        this._onAdd(ids); // update the group holding all ungrouped items


        this._updateUngrouped();
      }

      this.body.emitter.emit('_change', {
        queue: true
      });
    }
    /**
     * Get the current items
     * @returns {vis.DataSet | null}
     */

  }, {
    key: "getItems",
    value: function getItems() {
      return this.itemsData;
    }
    /**
     * Set groups
     * @param {vis.DataSet} groups
     */

  }, {
    key: "setGroups",
    value: function setGroups(groups) {
      var me = this;
      var ids; // unsubscribe from current dataset

      if (this.groupsData) {
        util$2.forEach(this.groupListeners, function (callback, event) {
          me.groupsData.off(event, callback);
        }); // remove all drawn groups

        ids = this.groupsData.getIds();
        this.groupsData = null;

        this._onRemoveGroups(ids); // note: this will cause a redraw

      } // replace the dataset


      if (!groups) {
        this.groupsData = null;
      } else if (groups instanceof DataSet || groups instanceof DataView$2) {
        this.groupsData = groups;
      } else {
        throw new TypeError('Data must be an instance of DataSet or DataView');
      }

      if (this.groupsData) {
        // go over all groups nesting
        var groupsData = this.groupsData;

        if (this.groupsData instanceof DataView$2) {
          groupsData = this.groupsData.getDataSet();
        }

        groupsData.get().forEach(function (group) {
          if (group.nestedGroups) {
            group.nestedGroups.forEach(function (nestedGroupId) {
              var updatedNestedGroup = groupsData.get(nestedGroupId);
              updatedNestedGroup.nestedInGroup = group.id;

              if (group.showNested == false) {
                updatedNestedGroup.visible = false;
              }

              groupsData.update(updatedNestedGroup);
            });
          }
        }); // subscribe to new dataset

        var id = this.id;
        util$2.forEach(this.groupListeners, function (callback, event) {
          me.groupsData.on(event, callback, id);
        }); // draw all ms

        ids = this.groupsData.getIds();

        this._onAddGroups(ids);
      } // update the group holding all ungrouped items


      this._updateUngrouped(); // update the order of all items in each group


      this._order();

      if (this.options.cluster) {
        this.clusterGenerator.updateData();

        this._clusterItems();

        this.markDirty({
          refreshItems: true,
          restackGroups: true
        });
      }

      this.body.emitter.emit('_change', {
        queue: true
      });
    }
    /**
     * Get the current groups
     * @returns {vis.DataSet | null} groups
     */

  }, {
    key: "getGroups",
    value: function getGroups() {
      return this.groupsData;
    }
    /**
     * Remove an item by its id
     * @param {string | number} id
     */

  }, {
    key: "removeItem",
    value: function removeItem(id) {
      var item = this.itemsData.get(id);
      var dataset = this.itemsData.getDataSet();

      if (item) {
        // confirm deletion
        this.options.onRemove(item, function (item) {
          if (item) {
            // remove by id here, it is possible that an item has no id defined
            // itself, so better not delete by the item itself
            dataset.remove(id);
          }
        });
      }
    }
    /**
     * Get the time of an item based on it's data and options.type
     * @param {Object} itemData
     * @returns {string} Returns the type
     * @private
     */

  }, {
    key: "_getType",
    value: function _getType(itemData) {
      return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
    }
    /**
     * Get the group id for an item
     * @param {Object} itemData
     * @returns {string} Returns the groupId
     * @private
     */

  }, {
    key: "getGroupId",
    value: function getGroupId(itemData) {
      var type = this._getType(itemData);

      if (type == 'background' && itemData.group == undefined) {
        return BACKGROUND$2;
      } else {
        return this.groupsData ? itemData.group : UNGROUPED$2;
      }
    }
    /**
     * Handle updated items
     * @param {number[]} ids
     * @protected
     */

  }, {
    key: "_onUpdate",
    value: function _onUpdate(ids) {
      var _this5 = this;

      var me = this;
      ids.forEach(function (id) {
        var itemData = me.itemsData.get(id, me.itemOptions);
        var item = me.items[id];
        var type = itemData ? me._getType(itemData) : null;
        var constructor = ItemSet.types[type];
        var selected;

        if (item) {
          // update item   	
          if (!constructor || !(item instanceof constructor)) {
            // item type has changed, delete the item and recreate it
            selected = item.selected; // preserve selection of this item

            me._removeItem(item);

            item = null;
          } else {
            me._updateItem(item, itemData);
          }
        }

        if (!item && itemData) {
          // create item
          if (constructor) {
            item = new constructor(itemData, me.conversion, me.options);
            item.id = id; // TODO: not so nice setting id afterwards

            me._addItem(item);

            if (selected) {
              _this5.selection.push(id);

              item.select();
            }
          } else {
            throw new TypeError("Unknown item type \"".concat(type, "\""));
          }
        }
      });

      this._order();

      if (this.options.cluster) {
        this.clusterGenerator.setItems(this.items, {
          applyOnChangedLevel: false
        });

        this._clusterItems();
      }

      this.body.emitter.emit('_change', {
        queue: true
      });
    }
    /**
     * Handle removed items
     * @param {number[]} ids
     * @protected
     */

  }, {
    key: "_onRemove",
    value: function _onRemove(ids) {
      var count = 0;
      var me = this;
      ids.forEach(function (id) {
        var item = me.items[id];

        if (item) {
          count++;

          me._removeItem(item);
        }
      });

      if (count) {
        // update order
        this._order();

        this.body.emitter.emit('_change', {
          queue: true
        });
      }
    }
    /**
     * Update the order of item in all groups
     * @private
     */

  }, {
    key: "_order",
    value: function _order() {
      // reorder the items in all groups
      // TODO: optimization: only reorder groups affected by the changed items
      util$2.forEach(this.groups, function (group) {
        group.order();
      });
    }
    /**
     * Handle updated groups
     * @param {number[]} ids
     * @private
     */

  }, {
    key: "_onUpdateGroups",
    value: function _onUpdateGroups(ids) {
      this._onAddGroups(ids);
    }
    /**
     * Handle changed groups (added or updated)
     * @param {number[]} ids
     * @private
     */

  }, {
    key: "_onAddGroups",
    value: function _onAddGroups(ids) {
      var me = this;
      ids.forEach(function (id) {
        var groupData = me.groupsData.get(id);
        var group = me.groups[id];

        if (!group) {
          // check for reserved ids
          if (id == UNGROUPED$2 || id == BACKGROUND$2) {
            throw new Error("Illegal group id. ".concat(id, " is a reserved id."));
          }

          var groupOptions = Object.create(me.options);
          util$2.extend(groupOptions, {
            height: null
          });
          group = new Group(id, groupData, me);
          me.groups[id] = group; // add items with this groupId to the new group

          for (var itemId in me.items) {
            if (me.items.hasOwnProperty(itemId)) {
              var item = me.items[itemId];

              if (item.data.group == id) {
                group.add(item);
              }
            }
          }

          group.order();
          group.show();
        } else {
          // update group
          group.setData(groupData);
        }
      });
      this.body.emitter.emit('_change', {
        queue: true
      });
    }
    /**
     * Handle removed groups
     * @param {number[]} ids
     * @private
     */

  }, {
    key: "_onRemoveGroups",
    value: function _onRemoveGroups(ids) {
      var groups = this.groups;
      ids.forEach(function (id) {
        var group = groups[id];

        if (group) {
          group.hide();
          delete groups[id];
        }
      });

      if (this.options.cluster) {
        this.clusterGenerator.updateData();

        this._clusterItems();
      }

      this.markDirty({
        restackGroups: !!this.options.cluster
      });
      this.body.emitter.emit('_change', {
        queue: true
      });
    }
    /**
     * Reorder the groups if needed
     * @return {boolean} changed
     * @private
     */

  }, {
    key: "_orderGroups",
    value: function _orderGroups() {
      if (this.groupsData) {
        // reorder the groups
        var groupIds = this.groupsData.getIds({
          order: this.options.groupOrder
        });
        groupIds = this._orderNestedGroups(groupIds);
        var changed = !util$2.equalArray(groupIds, this.groupIds);

        if (changed) {
          // hide all groups, removes them from the DOM
          var groups = this.groups;
          groupIds.forEach(function (groupId) {
            groups[groupId].hide();
          }); // show the groups again, attach them to the DOM in correct order

          groupIds.forEach(function (groupId) {
            groups[groupId].show();
          });
          this.groupIds = groupIds;
        }

        return changed;
      } else {
        return false;
      }
    }
    /**
     * Reorder the nested groups
     *
     * @param {Array.<number>} groupIds
     * @returns {Array.<number>}
     * @private
     */

  }, {
    key: "_orderNestedGroups",
    value: function _orderNestedGroups(groupIds) {
      var _this6 = this;
      /**
       * Recursively order nested groups
       *
       * @param {ItemSet} t
       * @param {Array.<number>} groupIds
       * @returns {Array.<number>}
       * @private
       */


      function getOrderedNestedGroups(t, groupIds) {
        var result = [];
        groupIds.forEach(function (groupId) {
          result.push(groupId);
          var groupData = t.groupsData.get(groupId);

          if (groupData.nestedGroups) {
            var nestedGroupIds = t.groupsData.get({
              filter: function filter(nestedGroup) {
                return nestedGroup.nestedInGroup == groupId;
              },
              order: t.options.groupOrder
            }).map(function (nestedGroup) {
              return nestedGroup.id;
            });
            result = result.concat(getOrderedNestedGroups(t, nestedGroupIds));
          }
        });
        return result;
      }

      var topGroupIds = groupIds.filter(function (groupId) {
        return !_this6.groupsData.get(groupId).nestedInGroup;
      });
      return getOrderedNestedGroups(this, topGroupIds);
    }
    /**
     * Add a new item
     * @param {Item} item
     * @private
     */

  }, {
    key: "_addItem",
    value: function _addItem(item) {
      this.items[item.id] = item; // add to group

      var groupId = this.getGroupId(item.data);
      var group = this.groups[groupId];

      if (!group) {
        item.groupShowing = false;
      } else if (group && group.data && group.data.showNested) {
        item.groupShowing = true;
      }

      if (group) group.add(item);
    }
    /**
     * Update an existing item
     * @param {Item} item
     * @param {Object} itemData
     * @private
     */

  }, {
    key: "_updateItem",
    value: function _updateItem(item, itemData) {
      // update the items data (will redraw the item when displayed)
      item.setData(itemData);
      var groupId = this.getGroupId(item.data);
      var group = this.groups[groupId];

      if (!group) {
        item.groupShowing = false;
      } else if (group && group.data && group.data.showNested) {
        item.groupShowing = true;
      }
    }
    /**
     * Delete an item from the ItemSet: remove it from the DOM, from the map
     * with items, and from the map with visible items, and from the selection
     * @param {Item} item
     * @private
     */

  }, {
    key: "_removeItem",
    value: function _removeItem(item) {
      // remove from DOM
      item.hide(); // remove from items

      delete this.items[item.id]; // remove from selection

      var index = this.selection.indexOf(item.id);
      if (index != -1) this.selection.splice(index, 1); // remove from group

      item.parent && item.parent.remove(item); // remove Tooltip from DOM

      if (this.popup != null) {
        this.popup.hide();
      }
    }
    /**
     * Create an array containing all items being a range (having an end date)
     * @param {Array.<Object>} array
     * @returns {Array}
     * @private
     */

  }, {
    key: "_constructByEndArray",
    value: function _constructByEndArray(array) {
      var endArray = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i] instanceof RangeItem) {
          endArray.push(array[i]);
        }
      }

      return endArray;
    }
    /**
     * Register the clicked item on touch, before dragStart is initiated.
     *
     * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
     * already moving. Therefore, the mouse/touch can sometimes be above an other
     * DOM element than the item itself.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onTouch",
    value: function _onTouch(event) {
      // store the touched item, used in _onDragStart
      this.touchParams.item = this.itemFromTarget(event);
      this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
      this.touchParams.dragRightItem = event.target.dragRightItem || false;
      this.touchParams.itemProps = null;
    }
    /**
     * Given an group id, returns the index it has.
     *
     * @param {number} groupId
     * @returns {number} index / groupId
     * @private
     */

  }, {
    key: "_getGroupIndex",
    value: function _getGroupIndex(groupId) {
      for (var i = 0; i < this.groupIds.length; i++) {
        if (groupId == this.groupIds[i]) return i;
      }
    }
    /**
     * Start dragging the selected events
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDragStart",
    value: function _onDragStart(event) {
      var _this7 = this;

      if (this.touchParams.itemIsDragging) {
        return;
      }

      var item = this.touchParams.item || null;
      var me = this;
      var props;

      if (item && (item.selected || this.options.itemsAlwaysDraggable.item)) {
        if (this.options.editable.overrideItems && !this.options.editable.updateTime && !this.options.editable.updateGroup) {
          return;
        } // override options.editable


        if (item.editable != null && !item.editable.updateTime && !item.editable.updateGroup && !this.options.editable.overrideItems) {
          return;
        }

        var dragLeftItem = this.touchParams.dragLeftItem;
        var dragRightItem = this.touchParams.dragRightItem;
        this.touchParams.itemIsDragging = true;
        this.touchParams.selectedItem = item;

        if (dragLeftItem) {
          props = {
            item: dragLeftItem,
            initialX: event.center.x,
            dragLeft: true,
            data: this._cloneItemData(item.data)
          };
          this.touchParams.itemProps = [props];
        } else if (dragRightItem) {
          props = {
            item: dragRightItem,
            initialX: event.center.x,
            dragRight: true,
            data: this._cloneItemData(item.data)
          };
          this.touchParams.itemProps = [props];
        } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
          // create a new range item when dragging with ctrl key down
          this._onDragStartAddItem(event);
        } else {
          if (this.groupIds.length < 1) {
            // Mitigates a race condition if _onDragStart() is
            // called after markDirty() without redraw() being called between.
            this.redraw();
          }

          var baseGroupIndex = this._getGroupIndex(item.data.group);

          var itemsToDrag = this.options.itemsAlwaysDraggable.item && !item.selected ? [item.id] : this.getSelection();
          this.touchParams.itemProps = itemsToDrag.map(function (id) {
            var item = me.items[id];

            var groupIndex = me._getGroupIndex(item.data.group);

            return {
              item: item,
              initialX: event.center.x,
              groupOffset: baseGroupIndex - groupIndex,
              data: _this7._cloneItemData(item.data)
            };
          });
        }

        event.stopPropagation();
      } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
        // create a new range item when dragging with ctrl key down
        this._onDragStartAddItem(event);
      }
    }
    /**
     * Start creating a new range item by dragging.
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDragStartAddItem",
    value: function _onDragStartAddItem(event) {
      var snap = this.options.snap || null;
      var frameRect = this.dom.frame.getBoundingClientRect(); // plus (if rtl) 10 to compensate for the drag starting as soon as you've moved 10px

      var x = this.options.rtl ? frameRect.right - event.center.x + 10 : event.center.x - frameRect.left - 10;
      var time = this.body.util.toTime(x);
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();
      var start = snap ? snap(time, scale, step) : time;
      var end = start;
      var itemData = {
        type: 'range',
        start: start,
        end: end,
        content: 'new item'
      };
      var id = util$2.randomUUID();
      itemData[this.itemsData._idProp] = id;
      var group = this.groupFromTarget(event);

      if (group) {
        itemData.group = group.groupId;
      }

      var newItem = new RangeItem(itemData, this.conversion, this.options);
      newItem.id = id; // TODO: not so nice setting id afterwards

      newItem.data = this._cloneItemData(itemData);

      this._addItem(newItem);

      this.touchParams.selectedItem = newItem;
      var props = {
        item: newItem,
        initialX: event.center.x,
        data: newItem.data
      };

      if (this.options.rtl) {
        props.dragLeft = true;
      } else {
        props.dragRight = true;
      }

      this.touchParams.itemProps = [props];
      event.stopPropagation();
    }
    /**
     * Drag selected items
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDrag",
    value: function _onDrag(event) {
      var _this8 = this;

      if (this.popup != null && this.options.showTooltips && !this.popup.hidden) {
        // this.popup.hide();
        var container = this.body.dom.centerContainer;
        var containerRect = container.getBoundingClientRect();
        this.popup.setPosition(event.center.x - containerRect.left + container.offsetLeft, event.center.y - containerRect.top + container.offsetTop);
        this.popup.show(); // redraw
      }

      if (this.touchParams.itemProps) {
        event.stopPropagation();
        var me = this;
        var snap = this.options.snap || null;
        var domRootOffsetLeft = this.body.dom.root.offsetLeft;
        var xOffset = this.options.rtl ? domRootOffsetLeft + this.body.domProps.right.width : domRootOffsetLeft + this.body.domProps.left.width;
        var scale = this.body.util.getScale();
        var step = this.body.util.getStep(); //only calculate the new group for the item that's actually dragged

        var selectedItem = this.touchParams.selectedItem;
        var updateGroupAllowed = (this.options.editable.overrideItems || selectedItem.editable == null) && this.options.editable.updateGroup || !this.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateGroup;
        var newGroupBase = null;

        if (updateGroupAllowed && selectedItem) {
          if (selectedItem.data.group != undefined) {
            // drag from one group to another
            var group = me.groupFromTarget(event);

            if (group) {
              //we know the offset for all items, so the new group for all items
              //will be relative to this one.
              newGroupBase = this._getGroupIndex(group.groupId);
            }
          }
        } // move


        this.touchParams.itemProps.forEach(function (props) {
          var current = me.body.util.toTime(event.center.x - xOffset);
          var initial = me.body.util.toTime(props.initialX - xOffset);
          var offset;
          var initialStart;
          var initialEnd;
          var start;
          var end;

          if (_this8.options.rtl) {
            offset = -(current - initial); // ms
          } else {
            offset = current - initial; // ms
          }

          var itemData = _this8._cloneItemData(props.item.data); // clone the data


          if (props.item.editable != null && !props.item.editable.updateTime && !props.item.editable.updateGroup && !me.options.editable.overrideItems) {
            return;
          }

          var updateTimeAllowed = (_this8.options.editable.overrideItems || selectedItem.editable == null) && _this8.options.editable.updateTime || !_this8.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateTime;

          if (updateTimeAllowed) {
            if (props.dragLeft) {
              // drag left side of a range item
              if (_this8.options.rtl) {
                if (itemData.end != undefined) {
                  initialEnd = util$2.convert(props.data.end, 'Date');
                  end = new Date(initialEnd.valueOf() + offset); // TODO: pass a Moment instead of a Date to snap(). (Breaking change)

                  itemData.end = snap ? snap(end, scale, step) : end;
                }
              } else {
                if (itemData.start != undefined) {
                  initialStart = util$2.convert(props.data.start, 'Date');
                  start = new Date(initialStart.valueOf() + offset); // TODO: pass a Moment instead of a Date to snap(). (Breaking change)

                  itemData.start = snap ? snap(start, scale, step) : start;
                }
              }
            } else if (props.dragRight) {
              // drag right side of a range item
              if (_this8.options.rtl) {
                if (itemData.start != undefined) {
                  initialStart = util$2.convert(props.data.start, 'Date');
                  start = new Date(initialStart.valueOf() + offset); // TODO: pass a Moment instead of a Date to snap(). (Breaking change)

                  itemData.start = snap ? snap(start, scale, step) : start;
                }
              } else {
                if (itemData.end != undefined) {
                  initialEnd = util$2.convert(props.data.end, 'Date');
                  end = new Date(initialEnd.valueOf() + offset); // TODO: pass a Moment instead of a Date to snap(). (Breaking change)

                  itemData.end = snap ? snap(end, scale, step) : end;
                }
              }
            } else {
              // drag both start and end
              if (itemData.start != undefined) {
                initialStart = util$2.convert(props.data.start, 'Date').valueOf();
                start = new Date(initialStart + offset);

                if (itemData.end != undefined) {
                  initialEnd = util$2.convert(props.data.end, 'Date');
                  var duration = initialEnd.valueOf() - initialStart.valueOf(); // TODO: pass a Moment instead of a Date to snap(). (Breaking change)

                  itemData.start = snap ? snap(start, scale, step) : start;
                  itemData.end = new Date(itemData.start.valueOf() + duration);
                } else {
                  // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                  itemData.start = snap ? snap(start, scale, step) : start;
                }
              }
            }
          }

          if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
            if (itemData.group != undefined) {
              var newOffset = newGroupBase - props.groupOffset; //make sure we stay in bounds

              newOffset = Math.max(0, newOffset);
              newOffset = Math.min(me.groupIds.length - 1, newOffset);
              itemData.group = me.groupIds[newOffset];
            }
          } // confirm moving the item


          itemData = _this8._cloneItemData(itemData); // convert start and end to the correct type

          me.options.onMoving(itemData, function (itemData) {
            if (itemData) {
              props.item.setData(_this8._cloneItemData(itemData, 'Date'));
            }
          });
        });
        this.body.emitter.emit('_change');
      }
    }
    /**
     * Move an item to another group
     * @param {Item} item
     * @param {string | number} groupId
     * @private
     */

  }, {
    key: "_moveToGroup",
    value: function _moveToGroup(item, groupId) {
      var group = this.groups[groupId];

      if (group && group.groupId != item.data.group) {
        var oldGroup = item.parent;
        oldGroup.remove(item);
        oldGroup.order();
        item.data.group = group.groupId;
        group.add(item);
        group.order();
      }
    }
    /**
     * End of dragging selected items
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onDragEnd",
    value: function _onDragEnd(event) {
      var _this9 = this;

      this.touchParams.itemIsDragging = false;

      if (this.touchParams.itemProps) {
        event.stopPropagation();
        var me = this;
        var dataset = this.itemsData.getDataSet();
        var itemProps = this.touchParams.itemProps;
        this.touchParams.itemProps = null;
        itemProps.forEach(function (props) {
          var id = props.item.id;
          var exists = me.itemsData.get(id, me.itemOptions) != null;

          if (!exists) {
            // add a new item
            me.options.onAdd(props.item.data, function (itemData) {
              me._removeItem(props.item); // remove temporary item


              if (itemData) {
                me.itemsData.getDataSet().add(itemData);
              } // force re-stacking of all items next redraw


              me.body.emitter.emit('_change');
            });
          } else {
            // update existing item
            var itemData = _this9._cloneItemData(props.item.data); // convert start and end to the correct type


            me.options.onMove(itemData, function (itemData) {
              if (itemData) {
                // apply changes
                itemData[dataset._idProp] = id; // ensure the item contains its id (can be undefined)

                dataset.update(itemData);
              } else {
                // restore original values
                props.item.setData(props.data);
                me.body.emitter.emit('_change');
              }
            });
          }
        });
      }
    }
    /**
     * On group click
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onGroupClick",
    value: function _onGroupClick(event) {
      var _this10 = this;

      var group = this.groupFromTarget(event);
      setTimeout(function () {
        _this10.toggleGroupShowNested(group);
      }, 1);
    }
    /**
     * Toggle show nested
     * @param {object} group
     * @param {boolean} force
     */

  }, {
    key: "toggleGroupShowNested",
    value: function toggleGroupShowNested(group) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (!group || !group.nestedGroups) return;
      var groupsData = this.groupsData.getDataSet();

      if (force != undefined) {
        group.showNested = !!force;
      } else {
        group.showNested = !group.showNested;
      }

      var nestingGroup = groupsData.get(group.groupId);
      nestingGroup.showNested = group.showNested;
      var fullNestedGroups = group.nestedGroups;
      var nextLevel = fullNestedGroups;

      while (nextLevel.length > 0) {
        var current = nextLevel;
        nextLevel = [];

        for (var i = 0; i < current.length; i++) {
          var node = groupsData.get(current[i]);

          if (node.nestedGroups) {
            nextLevel = nextLevel.concat(node.nestedGroups);
          }
        }

        if (nextLevel.length > 0) {
          fullNestedGroups = fullNestedGroups.concat(nextLevel);
        }
      }

      var nestedGroups = groupsData.get(fullNestedGroups).map(function (nestedGroup) {
        if (nestedGroup.visible == undefined) {
          nestedGroup.visible = true;
        }

        nestedGroup.visible = !!nestingGroup.showNested;
        return nestedGroup;
      });
      groupsData.update(nestedGroups.concat(nestingGroup));

      if (nestingGroup.showNested) {
        util$2.removeClassName(group.dom.label, 'collapsed');
        util$2.addClassName(group.dom.label, 'expanded');
      } else {
        util$2.removeClassName(group.dom.label, 'expanded');
        util$2.addClassName(group.dom.label, 'collapsed');
      }
    }
    /**
     * Toggle group drag classname
     * @param {object} group
     */

  }, {
    key: "toggleGroupDragClassName",
    value: function toggleGroupDragClassName(group) {
      group.dom.label.classList.toggle('vis-group-is-dragging');
      group.dom.foreground.classList.toggle('vis-group-is-dragging');
    }
    /**
     * on drag start
     * @param {Event} event
     * @return {void}   
     * @private
     */

  }, {
    key: "_onGroupDragStart",
    value: function _onGroupDragStart(event) {
      if (this.groupTouchParams.isDragging) return;

      if (this.options.groupEditable.order) {
        this.groupTouchParams.group = this.groupFromTarget(event);

        if (this.groupTouchParams.group) {
          event.stopPropagation();
          this.groupTouchParams.isDragging = true;
          this.toggleGroupDragClassName(this.groupTouchParams.group);
          this.groupTouchParams.originalOrder = this.groupsData.getIds({
            order: this.options.groupOrder
          });
        }
      }
    }
    /**
     * on drag
     * @param {Event} event
     * @return {void}
     * @private
     */

  }, {
    key: "_onGroupDrag",
    value: function _onGroupDrag(event) {
      if (this.options.groupEditable.order && this.groupTouchParams.group) {
        event.stopPropagation();
        var groupsData = this.groupsData;

        if (this.groupsData instanceof DataView$2) {
          groupsData = this.groupsData.getDataSet();
        } // drag from one group to another


        var group = this.groupFromTarget(event); // try to avoid toggling when groups differ in height

        if (group && group.height != this.groupTouchParams.group.height) {
          var movingUp = group.top < this.groupTouchParams.group.top;
          var clientY = event.center ? event.center.y : event.clientY;
          var targetGroup = group.dom.foreground.getBoundingClientRect();
          var draggedGroupHeight = this.groupTouchParams.group.height;

          if (movingUp) {
            // skip swapping the groups when the dragged group is not below clientY afterwards
            if (targetGroup.top + draggedGroupHeight < clientY) {
              return;
            }
          } else {
            var targetGroupHeight = group.height; // skip swapping the groups when the dragged group is not below clientY afterwards

            if (targetGroup.top + targetGroupHeight - draggedGroupHeight > clientY) {
              return;
            }
          }
        }

        if (group && group != this.groupTouchParams.group) {
          var _targetGroup = groupsData.get(group.groupId);

          var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId); // switch groups

          if (draggedGroup && _targetGroup) {
            this.options.groupOrderSwap(draggedGroup, _targetGroup, groupsData);
            groupsData.update(draggedGroup);
            groupsData.update(_targetGroup);
          } // fetch current order of groups


          var newOrder = groupsData.getIds({
            order: this.options.groupOrder
          }); // in case of changes since _onGroupDragStart

          if (!util$2.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
            var origOrder = this.groupTouchParams.originalOrder;
            var draggedId = this.groupTouchParams.group.groupId;
            var numGroups = Math.min(origOrder.length, newOrder.length);
            var curPos = 0;
            var newOffset = 0;
            var orgOffset = 0;

            while (curPos < numGroups) {
              // as long as the groups are where they should be step down along the groups order
              while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
                curPos++;
              } // all ok


              if (curPos + newOffset >= numGroups) {
                break;
              } // not all ok
              // if dragged group was move upwards everything below should have an offset


              if (newOrder[curPos + newOffset] == draggedId) {
                newOffset = 1;
              } // if dragged group was move downwards everything above should have an offset
              else if (origOrder[curPos + orgOffset] == draggedId) {
                  orgOffset = 1;
                } // found a group (apart from dragged group) that has the wrong position -> switch with the 
                // group at the position where other one should be, fix index arrays and continue
                else {
                    var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                    var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                    var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                    this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                    groupsData.update(switchGroup);
                    groupsData.update(shouldBeGroup);
                    var switchGroupId = newOrder[curPos + newOffset];
                    newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                    newOrder[slippedPosition] = switchGroupId;
                    curPos++;
                  }
            }
          }
        }
      }
    }
    /**
     * on drag end
     * @param {Event} event
     * @return {void}
     * @private
     */

  }, {
    key: "_onGroupDragEnd",
    value: function _onGroupDragEnd(event) {
      this.groupTouchParams.isDragging = false;

      if (this.options.groupEditable.order && this.groupTouchParams.group) {
        event.stopPropagation(); // update existing group

        var me = this;
        var id = me.groupTouchParams.group.groupId;
        var dataset = me.groupsData.getDataSet();
        var groupData = util$2.extend({}, dataset.get(id)); // clone the data

        me.options.onMoveGroup(groupData, function (groupData) {
          if (groupData) {
            // apply changes
            groupData[dataset._idProp] = id; // ensure the group contains its id (can be undefined)

            dataset.update(groupData);
          } else {
            // fetch current order of groups
            var newOrder = dataset.getIds({
              order: me.options.groupOrder
            }); // restore original order

            if (!util$2.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
              var origOrder = me.groupTouchParams.originalOrder;
              var numGroups = Math.min(origOrder.length, newOrder.length);
              var curPos = 0;

              while (curPos < numGroups) {
                // as long as the groups are where they should be step down along the groups order
                while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                  curPos++;
                } // all ok


                if (curPos >= numGroups) {
                  break;
                } // found a group that has the wrong position -> switch with the
                // group at the position where other one should be, fix index arrays and continue


                var slippedPosition = newOrder.indexOf(origOrder[curPos]);
                var switchGroup = dataset.get(newOrder[curPos]);
                var shouldBeGroup = dataset.get(origOrder[curPos]);
                me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
                dataset.update(switchGroup);
                dataset.update(shouldBeGroup);
                var switchGroupId = newOrder[curPos];
                newOrder[curPos] = origOrder[curPos];
                newOrder[slippedPosition] = switchGroupId;
                curPos++;
              }
            }
          }
        });
        me.body.emitter.emit('groupDragged', {
          groupId: id
        });
        this.toggleGroupDragClassName(this.groupTouchParams.group);
        this.groupTouchParams.group = null;
      }
    }
    /**
     * Handle selecting/deselecting an item when tapping it
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onSelectItem",
    value: function _onSelectItem(event) {
      if (!this.options.selectable) return;
      var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
      var shiftKey = event.srcEvent && event.srcEvent.shiftKey;

      if (ctrlKey || shiftKey) {
        this._onMultiSelectItem(event);

        return;
      }

      var oldSelection = this.getSelection();
      var item = this.itemFromTarget(event);
      var selection = item && item.selectable ? [item.id] : [];
      this.setSelection(selection);
      var newSelection = this.getSelection(); // emit a select event,
      // except when old selection is empty and new selection is still empty

      if (newSelection.length > 0 || oldSelection.length > 0) {
        this.body.emitter.emit('select', {
          items: newSelection,
          event: event
        });
      }
    }
    /**
     * Handle hovering an item
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onMouseOver",
    value: function _onMouseOver(event) {
      var item = this.itemFromTarget(event);
      if (!item) return; // Item we just left

      var related = this.itemFromRelatedTarget(event);

      if (item === related) {
        // We haven't changed item, just element in the item
        return;
      }

      var title = item.getTitle();

      if (this.options.showTooltips && title) {
        if (this.popup == null) {
          this.popup = new Popup(this.body.dom.root, this.options.tooltip.overflowMethod || 'flip');
        }

        this.popup.setText(title);
        var container = this.body.dom.centerContainer;
        var containerRect = container.getBoundingClientRect();
        this.popup.setPosition(event.clientX - containerRect.left + container.offsetLeft, event.clientY - containerRect.top + container.offsetTop);
        this.setPopupTimer(this.popup);
      } else {
        // Hovering over item without a title, hide popup
        // Needed instead of _just_ in _onMouseOut due to #2572
        this.clearPopupTimer();

        if (this.popup != null) {
          this.popup.hide();
        }
      }

      this.body.emitter.emit('itemover', {
        item: item.id,
        event: event
      });
    }
    /**
     * on mouse start
     * @param {Event} event
     * @return {void}   
     * @private
     */

  }, {
    key: "_onMouseOut",
    value: function _onMouseOut(event) {
      var item = this.itemFromTarget(event);
      if (!item) return; // Item we are going to

      var related = this.itemFromRelatedTarget(event);

      if (item === related) {
        // We aren't changing item, just element in the item
        return;
      }

      this.clearPopupTimer();

      if (this.popup != null) {
        this.popup.hide();
      }

      this.body.emitter.emit('itemout', {
        item: item.id,
        event: event
      });
    }
    /**
     * on mouse move
     * @param {Event} event
     * @return {void}   
     * @private
     */

  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(event) {
      var item = this.itemFromTarget(event);
      if (!item) return;

      if (this.popupTimer != null) {
        // restart timer
        this.setPopupTimer(this.popup);
      }

      if (this.options.showTooltips && this.options.tooltip.followMouse && this.popup && !this.popup.hidden) {
        var container = this.body.dom.centerContainer;
        var containerRect = container.getBoundingClientRect();
        this.popup.setPosition(event.clientX - containerRect.left + container.offsetLeft, event.clientY - containerRect.top + container.offsetTop);
        this.popup.show(); // Redraw
      }
    }
    /**
     * Handle mousewheel
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_onMouseWheel",
    value: function _onMouseWheel(event) {
      if (this.touchParams.itemIsDragging) {
        this._onDragEnd(event);
      }
    }
    /**
     * Handle updates of an item on double tap
     * @param {timeline.Item}  item   The item
     * @private
     */

  }, {
    key: "_onUpdateItem",
    value: function _onUpdateItem(item) {
      if (!this.options.selectable) return;
      if (!this.options.editable.updateTime) return;
      if (!this.options.editable.updateGroup) return;
      var me = this;

      if (item) {
        // execute async handler to update the item (or cancel it)
        var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset

        this.options.onUpdate(itemData, function (itemData) {
          if (itemData) {
            me.itemsData.getDataSet().update(itemData);
          }
        });
      }
    }
    /**
     * Handle drop event of data on item
     * Only called when `objectData.target === 'item'.
     * @param {Event} event The event 
     * @private
     */

  }, {
    key: "_onDropObjectOnItem",
    value: function _onDropObjectOnItem(event) {
      var item = this.itemFromTarget(event);
      var objectData = JSON.parse(event.dataTransfer.getData("text"));
      this.options.onDropObjectOnItem(objectData, item);
    }
    /**
     * Handle creation of an item on double tap or drop of a drag event
     * @param {Event} event   The event
     * @private
     */

  }, {
    key: "_onAddItem",
    value: function _onAddItem(event) {
      if (!this.options.selectable) return;
      if (!this.options.editable.add) return;
      var me = this;
      var snap = this.options.snap || null; // add item

      var frameRect = this.dom.frame.getBoundingClientRect();
      var x = this.options.rtl ? frameRect.right - event.center.x : event.center.x - frameRect.left;
      var start = this.body.util.toTime(x);
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();
      var end;
      var newItemData;

      if (event.type == 'drop') {
        newItemData = JSON.parse(event.dataTransfer.getData("text"));
        newItemData.content = newItemData.content ? newItemData.content : 'new item';
        newItemData.start = newItemData.start ? newItemData.start : snap ? snap(start, scale, step) : start;
        newItemData.type = newItemData.type || 'box';
        newItemData[this.itemsData._idProp] = newItemData.id || util$2.randomUUID();

        if (newItemData.type == 'range' && !newItemData.end) {
          end = this.body.util.toTime(x + this.props.width / 5);
          newItemData.end = snap ? snap(end, scale, step) : end;
        }
      } else {
        newItemData = {
          start: snap ? snap(start, scale, step) : start,
          content: 'new item'
        };
        newItemData[this.itemsData._idProp] = util$2.randomUUID(); // when default type is a range, add a default end date to the new item

        if (this.options.type === 'range') {
          end = this.body.util.toTime(x + this.props.width / 5);
          newItemData.end = snap ? snap(end, scale, step) : end;
        }
      }

      var group = this.groupFromTarget(event);

      if (group) {
        newItemData.group = group.groupId;
      } // execute async handler to customize (or cancel) adding an item


      newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type

      this.options.onAdd(newItemData, function (item) {
        if (item) {
          me.itemsData.getDataSet().add(item);

          if (event.type == 'drop') {
            me.setSelection([item.id]);
          } // TODO: need to trigger a redraw?

        }
      });
    }
    /**
     * Handle selecting/deselecting multiple items when holding an item
     * @param {Event} event
     * @private
     */

  }, {
    key: "_onMultiSelectItem",
    value: function _onMultiSelectItem(event) {
      var _this11 = this;

      if (!this.options.selectable) return;
      var item = this.itemFromTarget(event);

      if (item) {
        // multi select items (if allowed)
        var selection = this.options.multiselect ? this.getSelection() // take current selection
        : []; // deselect current selection

        var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

        if ((shiftKey || this.options.sequentialSelection) && this.options.multiselect) {
          // select all items between the old selection and the tapped item
          var itemGroup = this.itemsData.get(item.id).group; // when filtering get the group of the last selected item

          var lastSelectedGroup = undefined;

          if (this.options.multiselectPerGroup) {
            if (selection.length > 0) {
              lastSelectedGroup = this.itemsData.get(selection[0]).group;
            }
          } // determine the selection range


          if (!this.options.multiselectPerGroup || lastSelectedGroup == undefined || lastSelectedGroup == itemGroup) {
            selection.push(item.id);
          }

          var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

          if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
            // select all items within the selection range
            selection = [];

            for (var id in this.items) {
              if (this.items.hasOwnProperty(id)) {
                var _item = this.items[id];
                var start = _item.data.start;
                var end = _item.data.end !== undefined ? _item.data.end : start;

                if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
                  selection.push(_item.id); // do not use id but item.id, id itself is stringified
                }
              }
            }
          }
        } else {
          // add/remove this item from the current selection
          var index = selection.indexOf(item.id);

          if (index == -1) {
            // item is not yet selected -> select it
            selection.push(item.id);
          } else {
            // item is already selected -> deselect it
            selection.splice(index, 1);
          }
        }

        var filteredSelection = selection.filter(function (item) {
          return _this11.getItemById(item).selectable;
        });
        this.setSelection(filteredSelection);
        this.body.emitter.emit('select', {
          items: this.getSelection(),
          event: event
        });
      }
    }
    /**
     * Calculate the time range of a list of items
     * @param {Array.<Object>} itemsData
     * @return {{min: Date, max: Date}} Returns the range of the provided items
     * @private
     */

  }, {
    key: "itemFromElement",

    /**
     * Find an item from an element:
     * searches for the attribute 'vis-item' in the element's tree
     * @param {HTMLElement} element
     * @return {Item | null} item
     */
    value: function itemFromElement(element) {
      var cur = element;

      while (cur) {
        if (cur.hasOwnProperty('vis-item')) {
          return cur['vis-item'];
        }

        cur = cur.parentNode;
      }

      return null;
    }
    /**
     * Find an item from an event target:
     * searches for the attribute 'vis-item' in the event target's element tree
     * @param {Event} event
     * @return {Item | null} item
     */

  }, {
    key: "itemFromTarget",
    value: function itemFromTarget(event) {
      return this.itemFromElement(event.target);
    }
    /**
     * Find an item from an event's related target:
     * searches for the attribute 'vis-item' in the related target's element tree
     * @param {Event} event
     * @return {Item | null} item
     */

  }, {
    key: "itemFromRelatedTarget",
    value: function itemFromRelatedTarget(event) {
      return this.itemFromElement(event.relatedTarget);
    }
    /**
     * Find the Group from an event target:
     * searches for the attribute 'vis-group' in the event target's element tree
     * @param {Event} event
     * @return {Group | null} group
     */

  }, {
    key: "groupFromTarget",
    value: function groupFromTarget(event) {
      var clientY = event.center ? event.center.y : event.clientY;
      var groupIds = this.groupIds;

      if (groupIds.length <= 0 && this.groupsData) {
        groupIds = this.groupsData.getIds({
          order: this.options.groupOrder
        });
      }

      for (var i = 0; i < groupIds.length; i++) {
        var groupId = groupIds[i];
        var group = this.groups[groupId];
        var foreground = group.dom.foreground;
        var foregroundRect = foreground.getBoundingClientRect();

        if (clientY >= foregroundRect.top && clientY < foregroundRect.top + foreground.offsetHeight) {
          return group;
        }

        if (this.options.orientation.item === 'top') {
          if (i === this.groupIds.length - 1 && clientY > foregroundRect.top) {
            return group;
          }
        } else {
          if (i === 0 && clientY < foregroundRect.top + foreground.offset) {
            return group;
          }
        }
      }

      return null;
    }
    /**
     * Find the ItemSet from an event target:
     * searches for the attribute 'vis-itemset' in the event target's element tree
     * @param {Event} event
     * @return {ItemSet | null} item
     */

  }, {
    key: "_cloneItemData",

    /**
     * Clone the data of an item, and "normalize" it: convert the start and end date
     * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
     * start and end are converted to Date.
     * @param {Object} itemData, typically `item.data`
     * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
     * @return {Object} The cloned object
     * @private
     */
    value: function _cloneItemData(itemData, type) {
      var clone = util$2.extend({}, itemData);

      if (!type) {
        // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
        type = this.itemsData.getDataSet()._options.type;
      }

      if (clone.start != undefined) {
        clone.start = util$2.convert(clone.start, type && type.start || 'Date');
      }

      if (clone.end != undefined) {
        clone.end = util$2.convert(clone.end, type && type.end || 'Date');
      }

      return clone;
    }
    /**
     * cluster items
     * @return {void}   
     * @private
     */

  }, {
    key: "_clusterItems",
    value: function _clusterItems() {
      if (!this.options.cluster) {
        return;
      }

      var _this$body$range$conv = this.body.range.conversion(this.body.domProps.center.width),
          scale = _this$body$range$conv.scale;

      var clusters = this.clusterGenerator.getClusters(this.clusters, scale, this.options.cluster);

      if (this.clusters != clusters) {
        this._detachAllClusters();

        if (clusters) {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = clusters[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var cluster = _step4.value;
              cluster.attach();
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          this.clusters = clusters;
        }

        this._updateClusters(clusters);
      }
    }
    /**
     * detach all cluster items
     * @private
     */

  }, {
    key: "_detachAllClusters",
    value: function _detachAllClusters() {
      if (this.options.cluster) {
        if (this.clusters && this.clusters.length) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this.clusters[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var cluster = _step5.value;
              cluster.detach();
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      }
    }
    /**
     * update clusters
     * @param {array} clusters
     * @private
     */

  }, {
    key: "_updateClusters",
    value: function _updateClusters(clusters) {
      if (this.clusters && this.clusters.length) {
        var newClustersIds = new Set(clusters.map(function (cluster) {
          return cluster.id;
        }));
        var clustersToUnselect = this.clusters.filter(function (cluster) {
          return !newClustersIds.has(cluster.id);
        });
        var selectionChanged = false;
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = clustersToUnselect[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var cluster = _step6.value;
            var selectedIdx = this.selection.indexOf(cluster.id);

            if (selectedIdx !== -1) {
              cluster.unselect();
              this.selection.splice(selectedIdx, 1);
              selectionChanged = true;
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        if (selectionChanged) {
          var newSelection = this.getSelection();
          this.body.emitter.emit('select', {
            items: newSelection,
            event: event
          });
        }
      }

      this.clusters = clusters || [];
    }
  }], [{
    key: "_getItemRange",
    value: function _getItemRange(itemsData) {
      var max = null;
      var min = null;
      itemsData.forEach(function (data) {
        if (min == null || data.start < min) {
          min = data.start;
        }

        if (data.end != undefined) {
          if (max == null || data.end > max) {
            max = data.end;
          }
        } else {
          if (max == null || data.start > max) {
            max = data.start;
          }
        }
      });
      return {
        min: min,
        max: max
      };
    }
  }, {
    key: "itemSetFromTarget",
    value: function itemSetFromTarget(event) {
      var target = event.target;

      while (target) {
        if (target.hasOwnProperty('vis-itemset')) {
          return target['vis-itemset'];
        }

        target = target.parentNode;
      }

      return null;
    }
  }]);

  return ItemSet;
}(Component); // available item types will be registered here


ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};
/**
 * Handle added items
 * @param {number[]} ids
 * @protected
 */

ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;
var errorFound = false;
var allOptions;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator =
/*#__PURE__*/
function () {
  /**
   * @ignore
   */
  function Validator() {
    _classCallCheck(this, Validator);
  }
  /**
   * Main function to be called
   * @param {Object} options
   * @param {Object} referenceOptions
   * @param {Object} subObject
   * @returns {boolean}
   * @static
   */


  _createClass(Validator, null, [{
    key: "validate",
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;

      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }

      Validator.parse(options, usedOptions, []);
      return errorFound;
    }
    /**
     * Will traverse an object recursively and check every value
     * @param {Object} options
     * @param {Object} referenceOptions
     * @param {array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "parse",
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }
    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param {string} option
     * @param {Object} options
     * @param {Object} referenceOptions
     * @param {array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "check",
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
        return;
      }

      var referenceOption = option;
      var is_object = true;

      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // NOTE: This only triggers if the __any__ is in the top level of the options object.
        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
        // TODO: Examine if needed, remove if possible
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        referenceOption = '__any__'; // if the any-subgroup is not a predefined object in the configurator,
        // we do not look deeper into the object.

        is_object = Validator.getType(options[option]) === 'object';
      }

      var refOptionObj = referenceOptions[referenceOption];

      if (is_object && refOptionObj.__type__ !== undefined) {
        refOptionObj = refOptionObj.__type__;
      }

      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
    }
    /**
     *
     * @param {string}  option           | the option property
     * @param {Object}  options          | The supplied options object
     * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */

  }, {
    key: "checkFields",
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var log = function log(message) {
        console.log('%c' + message + Validator.printLocation(path, option), printStyle);
      };

      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];

      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array' && refOptionType.indexOf(options[option]) === -1) {
          log('Invalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === 'object' && referenceOption !== "__any__") {
          path = util$2.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        log('Invalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }
    /**
     *
     * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object
     * @returns {string}
     * @static
     */

  }, {
    key: "getType",
    value: function getType(object) {
      var type = _typeof(object);

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }

        if (object instanceof Boolean) {
          return 'boolean';
        }

        if (object instanceof Number) {
          return 'number';
        }

        if (object instanceof String) {
          return 'string';
        }

        if (Array.isArray(object)) {
          return 'array';
        }

        if (object instanceof Date) {
          return 'date';
        }

        if (object.nodeType !== undefined) {
          return 'dom';
        }

        if (object._isAMomentObject === true) {
          return 'moment';
        }

        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }

      return type;
    }
    /**
     * @param {string} option
     * @param {Object} options
     * @param {Array.<string>} path
     * @static
     */

  }, {
    key: "getSuggestion",
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);
      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;
      var msg;

      if (localSearch.indexMatch !== undefined) {
        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, '');
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option);
      } else {
        msg = '. Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option);
      }

      console.log('%cUnknown option detected: "' + option + '"' + msg, printStyle);
      errorFound = true;
    }
    /**
     * traverse the options in search for a match.
     * @param {string} option
     * @param {Object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */

  }, {
    key: "findInOptions",
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;

      for (var op in options) {
        // eslint-disable-line guard-for-in
        var distance = void 0;

        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util$2.copyAndExtendArray(path, op));

          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }

          distance = Validator.levenshteinDistance(option, op);

          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util$2.copyArray(path);
            min = distance;
          }
        }
      }

      return {
        closestMatch: closestMatch,
        path: closestMatchPath,
        distance: min,
        indexMatch: indexMatch
      };
    }
    /**
     * @param {Array.<string>} path
     * @param {Object} option
     * @param {string} prefix
     * @returns {String}
     * @static
     */

  }, {
    key: "printLocation",
    value: function printLocation(path, option) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Problem value found at: \n';
      var str = '\n\n' + prefix + 'options = {\n';

      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }

        str += path[i] + ': {\n';
      }

      for (var _j = 0; _j < path.length + 1; _j++) {
        str += '  ';
      }

      str += option + '\n';

      for (var _i = 0; _i < path.length + 1; _i++) {
        for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
          str += '  ';
        }

        str += '}\n';
      }

      return str + '\n\n';
    }
    /**
     * @param {Object} options
     * @returns {String}
     * @static
     */

  }, {
    key: "print",
    value: function print(options) {
      return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
    }
    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */

  }, {
    key: "levenshteinDistance",
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      var matrix = []; // increment along the first column of each row

      var i;

      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      } // increment each column in the first row


      var j;

      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      } // Fill in the rest of the matrix


      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator;
}();
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */


var string = 'string';
var bool = 'boolean';
var number = 'number';
var array = 'array';
var date = 'date';
var object = 'object'; // should only be in a __type__ property

var dom = 'dom';
var moment$4 = 'moment';
var any = 'any';
var allOptions$1 = {
  configure: {
    enabled: {
      'boolean': bool
    },
    filter: {
      'boolean': bool,
      'function': 'function'
    },
    container: {
      dom: dom
    },
    __type__: {
      object: object,
      'boolean': bool,
      'function': 'function'
    }
  },
  //globals :
  align: {
    string: string
  },
  alignCurrentTime: {
    string: string,
    'undefined': 'undefined'
  },
  rtl: {
    'boolean': bool,
    'undefined': 'undefined'
  },
  rollingMode: {
    follow: {
      'boolean': bool
    },
    offset: {
      number: number,
      'undefined': 'undefined'
    },
    __type__: {
      object: object
    }
  },
  onTimeout: {
    timeoutMs: {
      number: number
    },
    callback: {
      'function': 'function'
    },
    __type__: {
      object: object
    }
  },
  verticalScroll: {
    'boolean': bool,
    'undefined': 'undefined'
  },
  horizontalScroll: {
    'boolean': bool,
    'undefined': 'undefined'
  },
  autoResize: {
    'boolean': bool
  },
  throttleRedraw: {
    number: number
  },
  // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
  clickToUse: {
    'boolean': bool
  },
  dataAttributes: {
    string: string,
    array: array
  },
  editable: {
    add: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    remove: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    updateGroup: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    updateTime: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    overrideItems: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    __type__: {
      'boolean': bool,
      object: object
    }
  },
  end: {
    number: number,
    date: date,
    string: string,
    moment: moment$4
  },
  format: {
    minorLabels: {
      millisecond: {
        string: string,
        'undefined': 'undefined'
      },
      second: {
        string: string,
        'undefined': 'undefined'
      },
      minute: {
        string: string,
        'undefined': 'undefined'
      },
      hour: {
        string: string,
        'undefined': 'undefined'
      },
      weekday: {
        string: string,
        'undefined': 'undefined'
      },
      day: {
        string: string,
        'undefined': 'undefined'
      },
      week: {
        string: string,
        'undefined': 'undefined'
      },
      month: {
        string: string,
        'undefined': 'undefined'
      },
      year: {
        string: string,
        'undefined': 'undefined'
      },
      __type__: {
        object: object,
        'function': 'function'
      }
    },
    majorLabels: {
      millisecond: {
        string: string,
        'undefined': 'undefined'
      },
      second: {
        string: string,
        'undefined': 'undefined'
      },
      minute: {
        string: string,
        'undefined': 'undefined'
      },
      hour: {
        string: string,
        'undefined': 'undefined'
      },
      weekday: {
        string: string,
        'undefined': 'undefined'
      },
      day: {
        string: string,
        'undefined': 'undefined'
      },
      week: {
        string: string,
        'undefined': 'undefined'
      },
      month: {
        string: string,
        'undefined': 'undefined'
      },
      year: {
        string: string,
        'undefined': 'undefined'
      },
      __type__: {
        object: object,
        'function': 'function'
      }
    },
    __type__: {
      object: object
    }
  },
  moment: {
    'function': 'function'
  },
  groupHeightMode: {
    string: string
  },
  groupOrder: {
    string: string,
    'function': 'function'
  },
  groupEditable: {
    add: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    remove: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    order: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    __type__: {
      'boolean': bool,
      object: object
    }
  },
  groupOrderSwap: {
    'function': 'function'
  },
  height: {
    string: string,
    number: number
  },
  hiddenDates: {
    start: {
      date: date,
      number: number,
      string: string,
      moment: moment$4
    },
    end: {
      date: date,
      number: number,
      string: string,
      moment: moment$4
    },
    repeat: {
      string: string
    },
    __type__: {
      object: object,
      array: array
    }
  },
  itemsAlwaysDraggable: {
    item: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    range: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    __type__: {
      'boolean': bool,
      object: object
    }
  },
  limitSize: {
    'boolean': bool
  },
  locale: {
    string: string
  },
  locales: {
    __any__: {
      any: any
    },
    __type__: {
      object: object
    }
  },
  margin: {
    axis: {
      number: number
    },
    item: {
      horizontal: {
        number: number,
        'undefined': 'undefined'
      },
      vertical: {
        number: number,
        'undefined': 'undefined'
      },
      __type__: {
        object: object,
        number: number
      }
    },
    __type__: {
      object: object,
      number: number
    }
  },
  max: {
    date: date,
    number: number,
    string: string,
    moment: moment$4
  },
  maxHeight: {
    number: number,
    string: string
  },
  maxMinorChars: {
    number: number
  },
  min: {
    date: date,
    number: number,
    string: string,
    moment: moment$4
  },
  minHeight: {
    number: number,
    string: string
  },
  moveable: {
    'boolean': bool
  },
  multiselect: {
    'boolean': bool
  },
  multiselectPerGroup: {
    'boolean': bool
  },
  onAdd: {
    'function': 'function'
  },
  onDropObjectOnItem: {
    'function': 'function'
  },
  onUpdate: {
    'function': 'function'
  },
  onMove: {
    'function': 'function'
  },
  onMoving: {
    'function': 'function'
  },
  onRemove: {
    'function': 'function'
  },
  onAddGroup: {
    'function': 'function'
  },
  onMoveGroup: {
    'function': 'function'
  },
  onRemoveGroup: {
    'function': 'function'
  },
  onInitialDrawComplete: {
    'function': 'function'
  },
  order: {
    'function': 'function'
  },
  orientation: {
    axis: {
      string: string,
      'undefined': 'undefined'
    },
    item: {
      string: string,
      'undefined': 'undefined'
    },
    __type__: {
      string: string,
      object: object
    }
  },
  selectable: {
    'boolean': bool
  },
  sequentialSelection: {
    'boolean': bool
  },
  showCurrentTime: {
    'boolean': bool
  },
  showMajorLabels: {
    'boolean': bool
  },
  showMinorLabels: {
    'boolean': bool
  },
  stack: {
    'boolean': bool
  },
  stackSubgroups: {
    'boolean': bool
  },
  cluster: {
    maxItems: {
      'number': number,
      'undefined': 'undefined'
    },
    titleTemplate: {
      'string': string,
      'undefined': 'undefined'
    },
    clusterCriteria: {
      'function': 'function',
      'undefined': 'undefined'
    },
    showStipes: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    fitOnDoubleClick: {
      'boolean': bool,
      'undefined': 'undefined'
    },
    __type__: {
      'boolean': bool,
      object: object
    }
  },
  snap: {
    'function': 'function',
    'null': 'null'
  },
  start: {
    date: date,
    number: number,
    string: string,
    moment: moment$4
  },
  template: {
    'function': 'function'
  },
  loadingScreenTemplate: {
    'function': 'function'
  },
  groupTemplate: {
    'function': 'function'
  },
  visibleFrameTemplate: {
    string: string,
    'function': 'function'
  },
  showTooltips: {
    'boolean': bool
  },
  tooltip: {
    followMouse: {
      'boolean': bool
    },
    overflowMethod: {
      'string': ['cap', 'flip', 'none']
    },
    delay: {
      number: number
    },
    template: {
      'function': 'function'
    },
    __type__: {
      object: object
    }
  },
  tooltipOnItemUpdateTime: {
    template: {
      'function': 'function'
    },
    __type__: {
      'boolean': bool,
      object: object
    }
  },
  timeAxis: {
    scale: {
      string: string,
      'undefined': 'undefined'
    },
    step: {
      number: number,
      'undefined': 'undefined'
    },
    __type__: {
      object: object
    }
  },
  type: {
    string: string
  },
  width: {
    string: string,
    number: number
  },
  preferZoom: {
    'boolean': bool
  },
  zoomable: {
    'boolean': bool
  },
  zoomKey: {
    string: ['ctrlKey', 'altKey', 'shiftKey', 'metaKey', '']
  },
  zoomFriction: {
    number: number
  },
  zoomMax: {
    number: number
  },
  zoomMin: {
    number: number
  },
  __type__: {
    object: object
  }
};
var configureOptions = {
  global: {
    align: ['center', 'left', 'right'],
    alignCurrentTime: ['none', 'year', 'month', 'quarter', 'week', 'isoWeek', 'day', 'date', 'hour', 'minute', 'second'],
    direction: false,
    autoResize: true,
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        week: 'w',
        month: 'MMM',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        week: 'MMMM YYYY',
        month: 'YYYY',
        year: ''
      }
    },
    groupHeightMode: ['auto', 'fixed', 'fitItems'],
    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: '',
    //hiddenDates: {object, array},
    locale: '',
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: '',
    maxHeight: '',
    maxMinorChars: [7, 0, 20, 1],
    min: '',
    minHeight: '',
    moveable: false,
    multiselect: false,
    multiselectPerGroup: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ['both', 'bottom', 'top'],
      item: ['bottom', 'top']
    },
    preferZoom: false,
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    stackSubgroups: true,
    cluster: false,
    //snap: {'function': 'function', nada},
    start: '',
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    showTooltips: true,
    tooltip: {
      followMouse: false,
      overflowMethod: 'flip',
      delay: [500, 0, 99999, 100]
    },
    tooltipOnItemUpdateTime: false,
    type: ['box', 'point', 'range', 'background'],
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'shiftKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1]
  }
}; // `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill

_export({
  target: 'Array',
  proto: true
}, {
  fill: arrayFill
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('fill');
var htmlColors = {
  black: '#000000',
  navy: '#000080',
  darkblue: '#00008B',
  mediumblue: '#0000CD',
  blue: '#0000FF',
  darkgreen: '#006400',
  green: '#008000',
  teal: '#008080',
  darkcyan: '#008B8B',
  deepskyblue: '#00BFFF',
  darkturquoise: '#00CED1',
  mediumspringgreen: '#00FA9A',
  lime: '#00FF00',
  springgreen: '#00FF7F',
  aqua: '#00FFFF',
  cyan: '#00FFFF',
  midnightblue: '#191970',
  dodgerblue: '#1E90FF',
  lightseagreen: '#20B2AA',
  forestgreen: '#228B22',
  seagreen: '#2E8B57',
  darkslategray: '#2F4F4F',
  limegreen: '#32CD32',
  mediumseagreen: '#3CB371',
  turquoise: '#40E0D0',
  royalblue: '#4169E1',
  steelblue: '#4682B4',
  darkslateblue: '#483D8B',
  mediumturquoise: '#48D1CC',
  indigo: '#4B0082',
  darkolivegreen: '#556B2F',
  cadetblue: '#5F9EA0',
  cornflowerblue: '#6495ED',
  mediumaquamarine: '#66CDAA',
  dimgray: '#696969',
  slateblue: '#6A5ACD',
  olivedrab: '#6B8E23',
  slategray: '#708090',
  lightslategray: '#778899',
  mediumslateblue: '#7B68EE',
  lawngreen: '#7CFC00',
  chartreuse: '#7FFF00',
  aquamarine: '#7FFFD4',
  maroon: '#800000',
  purple: '#800080',
  olive: '#808000',
  gray: '#808080',
  skyblue: '#87CEEB',
  lightskyblue: '#87CEFA',
  blueviolet: '#8A2BE2',
  darkred: '#8B0000',
  darkmagenta: '#8B008B',
  saddlebrown: '#8B4513',
  darkseagreen: '#8FBC8F',
  lightgreen: '#90EE90',
  mediumpurple: '#9370D8',
  darkviolet: '#9400D3',
  palegreen: '#98FB98',
  darkorchid: '#9932CC',
  yellowgreen: '#9ACD32',
  sienna: '#A0522D',
  brown: '#A52A2A',
  darkgray: '#A9A9A9',
  lightblue: '#ADD8E6',
  greenyellow: '#ADFF2F',
  paleturquoise: '#AFEEEE',
  lightsteelblue: '#B0C4DE',
  powderblue: '#B0E0E6',
  firebrick: '#B22222',
  darkgoldenrod: '#B8860B',
  mediumorchid: '#BA55D3',
  rosybrown: '#BC8F8F',
  darkkhaki: '#BDB76B',
  silver: '#C0C0C0',
  mediumvioletred: '#C71585',
  indianred: '#CD5C5C',
  peru: '#CD853F',
  chocolate: '#D2691E',
  tan: '#D2B48C',
  lightgrey: '#D3D3D3',
  palevioletred: '#D87093',
  thistle: '#D8BFD8',
  orchid: '#DA70D6',
  goldenrod: '#DAA520',
  crimson: '#DC143C',
  gainsboro: '#DCDCDC',
  plum: '#DDA0DD',
  burlywood: '#DEB887',
  lightcyan: '#E0FFFF',
  lavender: '#E6E6FA',
  darksalmon: '#E9967A',
  violet: '#EE82EE',
  palegoldenrod: '#EEE8AA',
  lightcoral: '#F08080',
  khaki: '#F0E68C',
  aliceblue: '#F0F8FF',
  honeydew: '#F0FFF0',
  azure: '#F0FFFF',
  sandybrown: '#F4A460',
  wheat: '#F5DEB3',
  beige: '#F5F5DC',
  whitesmoke: '#F5F5F5',
  mintcream: '#F5FFFA',
  ghostwhite: '#F8F8FF',
  salmon: '#FA8072',
  antiquewhite: '#FAEBD7',
  linen: '#FAF0E6',
  lightgoldenrodyellow: '#FAFAD2',
  oldlace: '#FDF5E6',
  red: '#FF0000',
  fuchsia: '#FF00FF',
  magenta: '#FF00FF',
  deeppink: '#FF1493',
  orangered: '#FF4500',
  tomato: '#FF6347',
  hotpink: '#FF69B4',
  coral: '#FF7F50',
  darkorange: '#FF8C00',
  lightsalmon: '#FFA07A',
  orange: '#FFA500',
  lightpink: '#FFB6C1',
  pink: '#FFC0CB',
  gold: '#FFD700',
  peachpuff: '#FFDAB9',
  navajowhite: '#FFDEAD',
  moccasin: '#FFE4B5',
  bisque: '#FFE4C4',
  mistyrose: '#FFE4E1',
  blanchedalmond: '#FFEBCD',
  papayawhip: '#FFEFD5',
  lavenderblush: '#FFF0F5',
  seashell: '#FFF5EE',
  cornsilk: '#FFF8DC',
  lemonchiffon: '#FFFACD',
  floralwhite: '#FFFAF0',
  snow: '#FFFAFA',
  yellow: '#FFFF00',
  lightyellow: '#FFFFE0',
  ivory: '#FFFFF0',
  white: '#FFFFFF'
};
/**
 * @param {number} [pixelRatio=1]
 */

var ColorPicker =
/*#__PURE__*/
function () {
  /**
   * @param {number} [pixelRatio=1]
   */
  function ColorPicker() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    _classCallCheck(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.hueCircle = undefined;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.previousColor = undefined;
    this.applied = false; // bound by

    this.updateCallback = function () {};

    this.closeCallback = function () {}; // create all DOM elements


    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   * @param {Element} container
   */


  _createClass(ColorPicker, [{
    key: "insertTo",
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }

      this.container = container;
      this.container.appendChild(this.frame);

      this._bindHammer();

      this._setSize();
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param {function} callback
     */

  }, {
    key: "setUpdateCallback",
    value: function setUpdateCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      }
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param {function} callback
     */

  }, {
    key: "setCloseCallback",
    value: function setCloseCallback(callback) {
      if (typeof callback === 'function') {
        this.closeCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      }
    }
    /**
     *
     * @param {string} color
     * @returns {String}
     * @private
     */

  }, {
    key: "_isColorString",
    value: function _isColorString(color) {
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }
    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param {string|Object} color
     * @param {boolean} [setInitial=true]
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (color === 'none') {
        return;
      }

      var rgba; // if a html color shorthand is used, convert to hex

      var htmlColor = this._isColorString(color);

      if (htmlColor !== undefined) {
        color = htmlColor;
      } // check format


      if (util$2.isString(color) === true) {
        if (util$2.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = {
            r: rgbaArray[0],
            g: rgbaArray[1],
            b: rgbaArray[2],
            a: 1.0
          };
        } else if (util$2.isValidRGBA(color) === true) {
          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');

          rgba = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (util$2.isValidHex(color) === true) {
          var rgbObj = util$2.hexToRGB(color);
          rgba = {
            r: rgbObj.r,
            g: rgbObj.g,
            b: rgbObj.b,
            a: 1.0
          };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = {
              r: color.r,
              g: color.g,
              b: color.b,
              a: alpha
            };
          }
        }
      } // set color


      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }
    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */

  }, {
    key: "show",
    value: function show() {
      if (this.closeCallback !== undefined) {
        this.closeCallback();
        this.closeCallback = undefined;
      }

      this.applied = false;
      this.frame.style.display = 'block';

      this._generateHueCircle();
    } // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param {boolean} [storePrevious=true]
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide() {
      var _this = this;

      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true; // store the previous color for next time;

      if (storePrevious === true) {
        this.previousColor = util$2.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none'; // call the closing callback, restoring the onclick method.
      // this is in a setTimeout because it will trigger the show again before the click is done.

      setTimeout(function () {
        if (_this.closeCallback !== undefined) {
          _this.closeCallback();

          _this.closeCallback = undefined;
        }
      }, 0);
    }
    /**
     * bound to the save button. Saves and hides.
     * @private
     */

  }, {
    key: "_save",
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;

      this._hide();
    }
    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */

  }, {
    key: "_apply",
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);

      this._updatePicker(this.color);
    }
    /**
     * load the color from the previous session.
     * @private
     */

  }, {
    key: "_loadLast",
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }
    /**
     * set the color, place the picker
     * @param {Object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */

  }, {
    key: "_setColor",
    value: function _setColor(rgba) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; // store the initial color

      if (setInitial === true) {
        this.initialColor = util$2.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util$2.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }
    /**
     * bound to opacity control
     * @param {number} value
     * @private
     */

  }, {
    key: "_setOpacity",
    value: function _setOpacity(value) {
      this.color.a = value / 100;

      this._updatePicker(this.color);
    }
    /**
     * bound to brightness control
     * @param {number} value
     * @private
     */

  }, {
    key: "_setBrightness",
    value: function _setBrightness(value) {
      var hsv = util$2.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util$2.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      this._updatePicker();
    }
    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param {Object} rgba
     * @private
     */

  }, {
    key: "_updatePicker",
    value: function _updatePicker() {
      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;
      var hsv = util$2.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');

      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();
      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
    /**
     * used by create to set the size of the canvas.
     * @private
     */

  }, {
    key: "_setSize",
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';
      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';
      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);
      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';
      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';
      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';
      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';
      this.opacityRange = document.createElement('input');

      try {
        this.opacityRange.type = 'range'; // Not supported on IE9

        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } // TODO: Add some error handling and remove this lint exception
      catch (err) {} // eslint-disable-line no-empty


      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';
      this.brightnessRange = document.createElement('input');

      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9

        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } // TODO: Add some error handling and remove this lint exception
      catch (err) {} // eslint-disable-line no-empty


      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';
      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);
      var me = this;

      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };

      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };

      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };

      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerHTML = 'brightness:';
      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerHTML = 'opacity:';
      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerHTML = 'new';
      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerHTML = 'initial';
      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);
      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);
      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);
      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);
      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);
      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }
    /**
     * bind hammer to the color picker
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this2 = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer$1(this.colorPickerCanvas);
      this.hammer.get('pinch').set({
        enable: true
      });
      onTouch(this.hammer, function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this2._moveSelector(event);
      });
    }
    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */

  }, {
    key: "_generateHueCircle",
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');

        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }

        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // draw hue circle

        var x, y, hue, sat;
        this.centerCoordinates = {
          x: w * 0.5,
          y: h * 0.5
        };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb;

        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util$2.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }

        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();
        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }

      this.generated = true;
    }
    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_moveSelector",
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;
      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;
      var x = left - centerX;
      var y = top - centerY;
      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;
      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px'; // set color

      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util$2.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util$2.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba; // update previews

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);

  return ColorPicker;
}();
/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */


var Configurator =
/*#__PURE__*/
function () {
  /**
   * @param {Object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {Object} defaultContainer    | the default container of the module
   * @param {Object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   */
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util$2.extend(this.options, this.defaultOptions);
    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker(pixelRatio);
    this.wrapper = undefined;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {Object} options
   */


  _createClass(Configurator, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};

        this._removePopup();

        var enabled = true;

        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if (_typeof(options) === 'object') {
          if (options == null) {
            throw new TypeError('options cannot be null');
          }

          if (options.container !== undefined) {
            this.options.container = options.container;
          }

          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }

          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }

          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }

        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }

      this._clean();
    }
    /**
     *
     * @param {Object} moduleOptions
     */

  }, {
    key: "setModuleOptions",
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;

      if (this.options.enabled === true) {
        this._clean();

        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }

        this._create();
      }
    }
    /**
     * Create all DOM elements
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      this._clean();

      this.changedOptions = [];
      var filter = this.options.filter;
      var counter = 0;
      var show = false;

      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;

          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true; // linebreak between categories

            if (counter > 0) {
              this._makeItem([]);
            } // a header for the category


            this._makeHeader(option); // get the sub options


            this._handleObject(this.configureOptions[option], [option]);
          }

          counter++;
        }
      }

      this._makeButton();

      this._push(); //~ this.colorPicker.insertTo(this.container);

    }
    /**
     * draw all DOM elements on the screen
     * @private
     */

  }, {
    key: "_push",
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);

      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }
    /**
     * delete all DOM elements
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }

      this.domElements = [];

      this._removePopup();
    }
    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */

  }, {
    key: "_getValue",
    value: function _getValue(path) {
      var base = this.moduleOptions;

      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }

      return base;
    }
    /**
     * all option elements are wrapped in an item
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */

  }, {
    key: "_makeItem",
    value: function _makeItem(path) {
      if (this.allowCreation === true) {
        var item = document.createElement('div');
        item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

        for (var _len = arguments.length, domElements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          domElements[_key - 1] = arguments[_key];
        }

        domElements.forEach(function (element) {
          item.appendChild(element);
        });
        this.domElements.push(item);
        return this.domElements.length;
      }

      return 0;
    }
    /**
     * header for major subjects
     * @param {string} name
     * @private
     */

  }, {
    key: "_makeHeader",
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;

      this._makeItem([], div);
    }
    /**
     * make a label, if it is an object label, it gets different styling.
     * @param {string} name
     * @param {array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_makeLabel",
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;

      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }

      return div;
    }
    /**
     * make a dropdown list for multiple possible string optoins
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeDropdown",
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;

      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];

        if (i === selectedValue) {
          option.selected = 'selected';
        }

        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;

      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, select);
    }
    /**
     * make a range object for numeric options
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeRange",
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';

      try {
        range.type = 'range'; // not supported on IE9

        range.min = min;
        range.max = max;
      } // TODO: Add some error handling and remove this lint exception
      catch (err) {} // eslint-disable-line no-empty


      range.step = step; // set up the popup settings in case they are needed.

      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.20;

        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }

        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }

        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;
      var me = this;

      range.onchange = function () {
        input.value = this.value;

        me._update(Number(this.value), path);
      };

      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);

      var itemIndex = this._makeItem(path, label, range, input); // if a popup is needed AND it has not been shown for this value, show it.


      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;

        this._setupPopup(popupString, itemIndex);
      }
    }
    /**
     * make a button object
     * @private
     */

  }, {
    key: "_makeButton",
    value: function _makeButton() {
      var _this = this;

      if (this.options.showButton === true) {
        var generateButton = document.createElement('div');
        generateButton.className = 'vis-configuration vis-config-button';
        generateButton.innerHTML = 'generate options';

        generateButton.onclick = function () {
          _this._printOptions();
        };

        generateButton.onmouseover = function () {
          generateButton.className = 'vis-configuration vis-config-button hover';
        };

        generateButton.onmouseout = function () {
          generateButton.className = 'vis-configuration vis-config-button';
        };

        this.optionsContainer = document.createElement('div');
        this.optionsContainer.className = 'vis-configuration vis-config-option-container';
        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }
    /**
     * prepare the popup
     * @param {string} string
     * @param {number} index
     * @private
     */

  }, {
    key: "_setupPopup",
    value: function _setupPopup(string, index) {
      var _this2 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerHTML = string;

        div.onclick = function () {
          _this2._removePopup();
        };

        this.popupCounter += 1;
        this.popupDiv = {
          html: div,
          index: index
        };
      }
    }
    /**
     * remove the popup from the dom
     * @private
     */

  }, {
    key: "_removePopup",
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }
    /**
     * Show the popup if it is needed.
     * @private
     */

  }, {
    key: "_showPopupIfNeeded",
    value: function _showPopupIfNeeded() {
      var _this3 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;

        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this3.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this3._removePopup();
        }, 1800);
      }
    }
    /**
     * make a checkbox for boolean options.
     * @param {number} defaultValue
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeCheckbox",
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;

      if (value !== undefined) {
        checkbox.checked = value;

        if (value !== defaultValue) {
          if (_typeof(defaultValue) === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({
                path: path,
                value: value
              });
            }
          } else {
            this.changedOptions.push({
              path: path,
              value: value
            });
          }
        }
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a text input field for string options.
     * @param {number} defaultValue
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeTextInput",
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;

      if (value !== defaultValue) {
        this.changedOptions.push({
          path: path,
          value: value
        });
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a color field with a color picker for color fields
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeColorField",
    value: function _makeColorField(arr, value, path) {
      var _this4 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;

      div.onclick = function () {
        _this4._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, div);
    }
    /**
     * used by the color buttons to call the color picker.
     * @param {number} value
     * @param {HTMLElement} div
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_showColorPicker",
    value: function _showColorPicker(value, div, path) {
      var _this5 = this; // clear the callback from this div


      div.onclick = function () {};

      this.colorPicker.insertTo(div);
      this.colorPicker.show();
      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;

        _this5._update(colorString, path);
      }); // on close of the colorpicker, restore the callback.

      this.colorPicker.setCloseCallback(function () {
        div.onclick = function () {
          _this5._showColorPicker(value, div, path);
        };
      });
    }
    /**
     * parse an object and draw the correct items
     * @param {Object} obj
     * @param {array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_handleObject",
    value: function _handleObject(obj) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;

      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util$2.copyAndExtendArray(path, subObj);

          if (typeof filter === 'function') {
            show = filter(subObj, path); // if needed we must go deeper into the object.

            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;

            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;

              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util$2.copyAndExtendArray(newPath, 'enabled');

                  var enabledValue = this._getValue(enabledPath);

                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);

                    this._makeItem(newPath, label);

                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);

                  this._makeItem(newPath, _label);

                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }

      return visibleInSet;
    }
    /**
     * handle the array type of option
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_handleArray",
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);

        if (arr[1] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: Number(value)
          });
        }
      }
    }
    /**
     * called to update the network with the new settings.
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_update",
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }

      this.initialized = true;
      this.parent.setOptions(options);
    }
    /**
     *
     * @param {string|Boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */

  }, {
    key: "_constructOptions",
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var pointer = optionsObj; // when dropdown boxes can be string or boolean, we typecast it into correct types

      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }

          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }

      return optionsObj;
    }
    /**
     * @private
     */

  }, {
    key: "_printOptions",
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
    }
    /**
     *
     * @returns {{}} options
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = {};

      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }

      return options;
    }
  }]);

  return Configurator;
}();
/**
 * Create a timeline visualization
 * @extends Core
 */


var Timeline =
/*#__PURE__*/
function (_Core) {
  _inherits(Timeline, _Core);
  /**
  * @param {HTMLElement} container
  * @param {vis.DataSet | vis.DataView | Array} [items]
  * @param {vis.DataSet | vis.DataView | Array} [groups]
  * @param {Object} [options]  See Timeline.setOptions for the available options.
  * @constructor Timeline
  */


  function Timeline(container, items, groups, options) {
    var _this;

    _classCallCheck(this, Timeline);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Timeline).call(this));
    _this.initTime = new Date();
    _this.itemsDone = false;

    if (!(_assertThisInitialized(_this) instanceof Timeline)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    } // if the third element is options, the forth is groups (optionally);


    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView$2) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    } // TODO: REMOVE THIS in the next MAJOR release
    // see https://github.com/almende/vis/issues/2511


    if (options && options.throttleRedraw) {
      console.warn("Timeline option \"throttleRedraw\" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.");
    }

    var me = _assertThisInitialized(_this);

    _this.defaultOptions = {
      autoResize: true,
      orientation: {
        axis: 'bottom',
        // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant

      },
      moment: moment$3
    };
    _this.options = util$2.deepExtend({}, _this.defaultOptions); // Create the DOM, props, and emitter

    _this._create(container);

    if (!options || options && typeof options.rtl == "undefined") {
      _this.dom.root.style.visibility = 'hidden';
      var directionFromDom;
      var domNode = _this.dom.root;

      while (!directionFromDom && domNode) {
        directionFromDom = window.getComputedStyle(domNode, null).direction;
        domNode = domNode.parentElement;
      }

      _this.options.rtl = directionFromDom && directionFromDom.toLowerCase() == "rtl";
    } else {
      _this.options.rtl = options.rtl;
    }

    if (options) {
      if (options.rollingMode) {
        _this.options.rollingMode = options.rollingMode;
      }

      if (options.onInitialDrawComplete) {
        _this.options.onInitialDrawComplete = options.onInitialDrawComplete;
      }

      if (options.onTimeout) {
        _this.options.onTimeout = options.onTimeout;
      }

      if (options.loadingScreenTemplate) {
        _this.options.loadingScreenTemplate = options.loadingScreenTemplate;
      }
    } // Prepare loading screen


    var loadingScreenFragment = document.createElement('div');

    if (_this.options.loadingScreenTemplate) {
      var templateFunction = _this.options.loadingScreenTemplate.bind(_assertThisInitialized(_this));

      var loadingScreen = templateFunction(_this.dom.loadingScreen);

      if (loadingScreen instanceof Object && !(loadingScreen instanceof Element)) {
        templateFunction(loadingScreenFragment);
      } else {
        if (loadingScreen instanceof Element) {
          loadingScreenFragment.innerHTML = '';
          loadingScreenFragment.appendChild(loadingScreen);
        } else if (loadingScreen != undefined) {
          loadingScreenFragment.innerHTML = loadingScreen;
        }
      }
    }

    _this.dom.loadingScreen.appendChild(loadingScreenFragment); // all components listed here will be repainted automatically


    _this.components = [];
    _this.body = {
      dom: _this.dom,
      domProps: _this.props,
      emitter: {
        on: _this.on.bind(_assertThisInitialized(_this)),
        off: _this.off.bind(_assertThisInitialized(_this)),
        emit: _this.emit.bind(_assertThisInitialized(_this))
      },
      hiddenDates: [],
      util: {
        getScale: function getScale() {
          return me.timeAxis.step.scale;
        },
        getStep: function getStep() {
          return me.timeAxis.step.step;
        },
        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me),
        // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    }; // range

    _this.range = new Range(_this.body, _this.options);

    _this.components.push(_this.range);

    _this.body.range = _this.range; // time axis

    _this.timeAxis = new TimeAxis(_this.body, _this.options);
    _this.timeAxis2 = null; // used in case of orientation option 'both'

    _this.components.push(_this.timeAxis); // current time bar


    _this.currentTime = new CurrentTime(_this.body, _this.options);

    _this.components.push(_this.currentTime); // item set


    _this.itemSet = new ItemSet(_this.body, _this.options);

    _this.components.push(_this.itemSet);

    _this.itemsData = null; // DataSet

    _this.groupsData = null; // DataSet

    _this.dom.root.onclick = function (event) {
      me.emit('click', me.getEventProperties(event));
    };

    _this.dom.root.ondblclick = function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    };

    _this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    _this.dom.root.onmouseover = function (event) {
      me.emit('mouseOver', me.getEventProperties(event));
    };

    if (window.PointerEvent) {
      _this.dom.root.onpointerdown = function (event) {
        me.emit('mouseDown', me.getEventProperties(event));
      };

      _this.dom.root.onpointermove = function (event) {
        me.emit('mouseMove', me.getEventProperties(event));
      };

      _this.dom.root.onpointerup = function (event) {
        me.emit('mouseUp', me.getEventProperties(event));
      };
    } else {
      _this.dom.root.onmousemove = function (event) {
        me.emit('mouseMove', me.getEventProperties(event));
      };

      _this.dom.root.onmousedown = function (event) {
        me.emit('mouseDown', me.getEventProperties(event));
      };

      _this.dom.root.onmouseup = function (event) {
        me.emit('mouseUp', me.getEventProperties(event));
      };
    } //Single time autoscale/fit


    _this.initialFitDone = false;

    _this.on('changed', function () {
      if (me.itemsData == null) return;

      if (!me.initialFitDone && !me.options.rollingMode) {
        me.initialFitDone = true;

        if (me.options.start != undefined || me.options.end != undefined) {
          if (me.options.start == undefined || me.options.end == undefined) {
            var range = me.getItemRange();
          }

          var start = me.options.start != undefined ? me.options.start : range.min;
          var end = me.options.end != undefined ? me.options.end : range.max;
          me.setWindow(start, end, {
            animation: false
          });
        } else {
          me.fit({
            animation: false
          });
        }
      }

      if (!me.initialDrawDone && (me.initialRangeChangeDone || !me.options.start && !me.options.end || me.options.rollingMode)) {
        me.initialDrawDone = true;
        me.itemSet.initialDrawDone = true;
        me.dom.root.style.visibility = 'visible';
        me.dom.loadingScreen.parentNode.removeChild(me.dom.loadingScreen);

        if (me.options.onInitialDrawComplete) {
          setTimeout(function () {
            return me.options.onInitialDrawComplete();
          }, 0);
        }
      }
    });

    _this.on('destroyTimeline', function () {
      me.destroy();
    }); // apply options


    if (options) {
      _this.setOptions(options);
    }

    _this.body.emitter.on('fit', function (args) {
      _this._onFit(args);

      _this.redraw();
    }); // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!


    if (groups) {
      _this.setGroups(groups);
    } // create itemset


    if (items) {
      _this.setItems(items);
    } // draw for the first time


    _this._redraw();

    return _this;
  }
  /**
   * Load a configurator
   * @return {Object}
   * @private
   */


  _createClass(Timeline, [{
    key: "_createConfigurator",
    value: function _createConfigurator() {
      return new Configurator(this, this.dom.container, configureOptions);
    }
    /**
     * Force a redraw. The size of all items will be recalculated.
     * Can be useful to manually redraw when option autoResize=false and the window
     * has been resized, or when the items CSS has been changed.
     *
     * Note: this function will be overridden on construction with a trottled version
     */

  }, {
    key: "redraw",
    value: function redraw() {
      this.itemSet && this.itemSet.markDirty({
        refreshItems: true
      });

      this._redraw();
    }
    /**
     * Remove an item from the group
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      // validate options
      var errorFound = Validator.validate(options, allOptions$1);

      if (errorFound === true) {
        console.log('%cErrors have been found in the supplied options object.', printStyle);
      }

      Core.prototype.setOptions.call(this, options);

      if ('type' in options) {
        if (options.type !== this.options.type) {
          this.options.type = options.type; // force recreation of all items

          var itemsData = this.itemsData;

          if (itemsData) {
            var selection = this.getSelection();
            this.setItems(null); // remove all

            this.setItems(itemsData); // add all

            this.setSelection(selection); // restore selection
          }
        }
      }
    }
    /**
     * Set items
     * @param {vis.DataSet | Array | null} items
     */

  }, {
    key: "setItems",
    value: function setItems(items) {
      this.itemsDone = false; // convert to type DataSet when needed

      var newDataSet;

      if (!items) {
        newDataSet = null;
      } else if (items instanceof DataSet || items instanceof DataView$2) {
        newDataSet = items;
      } else {
        // turn an array into a dataset
        newDataSet = new DataSet(items, {
          type: {
            start: 'Date',
            end: 'Date'
          }
        });
      } // set items


      this.itemsData = newDataSet;
      this.itemSet && this.itemSet.setItems(newDataSet);
    }
    /**
     * Set groups
     * @param {vis.DataSet | Array} groups
     */

  }, {
    key: "setGroups",
    value: function setGroups(groups) {
      // convert to type DataSet when needed
      var newDataSet;

      if (!groups) {
        newDataSet = null;
      } else {
        var filter = function filter(group) {
          return group.visible !== false;
        };

        if (groups instanceof DataSet || groups instanceof DataView$2) {
          newDataSet = new DataView$2(groups, {
            filter: filter
          });
        } else {
          // turn an array into a dataset
          newDataSet = new DataSet(groups.filter(filter));
        }
      }

      this.groupsData = newDataSet;
      this.itemSet.setGroups(newDataSet);
    }
    /**
     * Set both items and groups in one go
     * @param {{items: (Array | vis.DataSet), groups: (Array | vis.DataSet)}} data
     */

  }, {
    key: "setData",
    value: function setData(data) {
      if (data && data.groups) {
        this.setGroups(data.groups);
      }

      if (data && data.items) {
        this.setItems(data.items);
      }
    }
    /**
     * Set selected items by their id. Replaces the current selection
     * Unknown id's are silently ignored.
     * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
     *                                selected. If ids is an empty array, all items will be
     *                                unselected.
     * @param {Object} [options]      Available options:
     *                                `focus: boolean`
     *                                    If true, focus will be set to the selected item(s)
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     *                                    Only applicable when option focus is true.
     */

  }, {
    key: "setSelection",
    value: function setSelection(ids, options) {
      this.itemSet && this.itemSet.setSelection(ids);

      if (options && options.focus) {
        this.focus(ids, options);
      }
    }
    /**
     * Get the selected items by their id
     * @return {Array} ids  The ids of the selected items
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return this.itemSet && this.itemSet.getSelection() || [];
    }
    /**
     * Adjust the visible window such that the selected item (or multiple items)
     * are centered on screen.
     * @param {string | String[]} id     An item id or array with item ids
     * @param {Object} [options]      Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     */

  }, {
    key: "focus",
    value: function focus(id, options) {
      if (!this.itemsData || id == undefined) return;
      var ids = Array.isArray(id) ? id : [id]; // get the specified item(s)

      var itemsData = this.itemsData.getDataSet().get(ids, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      }); // calculate minimum start and maximum end of specified items

      var start = null;
      var end = null;
      itemsData.forEach(function (itemData) {
        var s = itemData.start.valueOf();
        var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

        if (start === null || s < start) {
          start = s;
        }

        if (end === null || e > end) {
          end = e;
        }
      });

      if (start !== null && end !== null) {
        var me = this; // Use the first item for the vertical focus

        var item = this.itemSet.items[ids[0]];
        var startPos = this._getScrollTop() * -1;
        var initialVerticalScroll = null; // Setup a handler for each frame of the vertical scroll

        var verticalAnimationFrame = function verticalAnimationFrame(ease, willDraw, done) {
          var verticalScroll = getItemVerticalScroll(me, item);

          if (verticalScroll === false) {
            return; // We don't need to scroll, so do nothing
          }

          if (!initialVerticalScroll) {
            initialVerticalScroll = verticalScroll;
          }

          if (initialVerticalScroll.itemTop == verticalScroll.itemTop && !initialVerticalScroll.shouldScroll) {
            return; // We don't need to scroll, so do nothing
          } else if (initialVerticalScroll.itemTop != verticalScroll.itemTop && verticalScroll.shouldScroll) {
            // The redraw shifted elements, so reset the animation to correct
            initialVerticalScroll = verticalScroll;
            startPos = me._getScrollTop() * -1;
          }

          var from = startPos;
          var to = initialVerticalScroll.scrollOffset;
          var scrollTop = done ? to : from + (to - from) * ease;

          me._setScrollTop(-scrollTop);

          if (!willDraw) {
            me._redraw();
          }
        }; // Enforces the final vertical scroll position


        var setFinalVerticalPosition = function setFinalVerticalPosition() {
          var finalVerticalScroll = getItemVerticalScroll(me, item);

          if (finalVerticalScroll.shouldScroll && finalVerticalScroll.itemTop != initialVerticalScroll.itemTop) {
            me._setScrollTop(-finalVerticalScroll.scrollOffset);

            me._redraw();
          }
        }; // Perform one last check at the end to make sure the final vertical
        // position is correct


        var finalVerticalCallback = function finalVerticalCallback() {
          // Double check we ended at the proper scroll position
          setFinalVerticalPosition(); // Let the redraw settle and finalize the position.      

          setTimeout(setFinalVerticalPosition, 100);
        }; // calculate the new middle and interval for the window


        var middle = (start + end) / 2;
        var interval = (end - start) * 1.1;
        var animation = options && options.animation !== undefined ? options.animation : true;

        if (!animation) {
          // We aren't animating so set a default so that the final callback forces the vertical location
          initialVerticalScroll = {
            shouldScroll: false,
            scrollOffset: -1,
            itemTop: -1
          };
        }

        this.range.setRange(middle - interval / 2, middle + interval / 2, {
          animation: animation
        }, finalVerticalCallback, verticalAnimationFrame);
      }
    }
    /**
     * Set Timeline window such that it fits all items
     * @param {Object} [options]  Available options:
     *                                `animation: boolean | {duration: number, easingFunction: string}`
     *                                    If true (default), the range is animated
     *                                    smoothly to the new window. An object can be
     *                                    provided to specify duration and easing function.
     *                                    Default duration is 500 ms, and default easing
     *                                    function is 'easeInOutQuad'.
     * @param {function} [callback]
     */

  }, {
    key: "fit",
    value: function fit(options, callback) {
      var animation = options && options.animation !== undefined ? options.animation : true;
      var range;
      var dataset = this.itemsData && this.itemsData.getDataSet();

      if (dataset.length === 1 && dataset.get()[0].end === undefined) {
        // a single item -> don't fit, just show a range around the item from -4 to +3 days
        range = this.getDataRange();
        this.moveTo(range.min.valueOf(), {
          animation: animation
        }, callback);
      } else {
        // exactly fit the items (plus a small margin)
        range = this.getItemRange();
        this.range.setRange(range.min, range.max, {
          animation: animation
        }, callback);
      }
    }
    /**
     * Determine the range of the items, taking into account their actual width
     * and a margin of 10 pixels on both sides.
     *
     * @returns {{min: Date, max: Date}}
     */

  }, {
    key: "getItemRange",
    value: function getItemRange() {
      var _this2 = this; // get a rough approximation for the range based on the items start and end dates


      var range = this.getDataRange();
      var min = range.min !== null ? range.min.valueOf() : null;
      var max = range.max !== null ? range.max.valueOf() : null;
      var minItem = null;
      var maxItem = null;

      if (min != null && max != null) {
        var interval = max - min; // ms

        if (interval <= 0) {
          interval = 10;
        }

        var factor = interval / this.props.center.width;
        var redrawQueue = {};
        var redrawQueueLength = 0; // collect redraw functions

        util$2.forEach(this.itemSet.items, function (item, key) {
          if (item.groupShowing) {
            var returnQueue = true;
            redrawQueue[key] = item.redraw(returnQueue);
            redrawQueueLength = redrawQueue[key].length;
          }
        });
        var needRedraw = redrawQueueLength > 0;

        if (needRedraw) {
          var _loop = function _loop(i) {
            util$2.forEach(redrawQueue, function (fns) {
              fns[i]();
            });
          }; // redraw all regular items


          for (var i = 0; i < redrawQueueLength; i++) {
            _loop(i);
          }
        } // calculate the date of the left side and right side of the items given


        util$2.forEach(this.itemSet.items, function (item) {
          var start = getStart(item);
          var end = getEnd(item);
          var startSide;
          var endSide;

          if (_this2.options.rtl) {
            startSide = start - (item.getWidthRight() + 10) * factor;
            endSide = end + (item.getWidthLeft() + 10) * factor;
          } else {
            startSide = start - (item.getWidthLeft() + 10) * factor;
            endSide = end + (item.getWidthRight() + 10) * factor;
          }

          if (startSide < min) {
            min = startSide;
            minItem = item;
          }

          if (endSide > max) {
            max = endSide;
            maxItem = item;
          }
        });

        if (minItem && maxItem) {
          var lhs = minItem.getWidthLeft() + 10;
          var rhs = maxItem.getWidthRight() + 10;
          var delta = this.props.center.width - lhs - rhs; // px

          if (delta > 0) {
            if (this.options.rtl) {
              min = getStart(minItem) - rhs * interval / delta; // ms

              max = getEnd(maxItem) + lhs * interval / delta; // ms
            } else {
              min = getStart(minItem) - lhs * interval / delta; // ms

              max = getEnd(maxItem) + rhs * interval / delta; // ms
            }
          }
        }
      }

      return {
        min: min != null ? new Date(min) : null,
        max: max != null ? new Date(max) : null
      };
    }
    /**
     * Calculate the data range of the items start and end dates
     * @returns {{min: Date, max: Date}}
     */

  }, {
    key: "getDataRange",
    value: function getDataRange() {
      var min = null;
      var max = null;
      var dataset = this.itemsData && this.itemsData.getDataSet();

      if (dataset) {
        dataset.forEach(function (item) {
          var start = util$2.convert(item.start, 'Date').valueOf();
          var end = util$2.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();

          if (min === null || start < min) {
            min = start;
          }

          if (max === null || end > max) {
            max = end;
          }
        });
      }

      return {
        min: min != null ? new Date(min) : null,
        max: max != null ? new Date(max) : null
      };
    }
    /**
     * Generate Timeline related information from an event
     * @param {Event} event
     * @return {Object} An object with related information, like on which area
     *                  The event happened, whether clicked on an item, etc.
     */

  }, {
    key: "getEventProperties",
    value: function getEventProperties(event) {
      var clientX = event.center ? event.center.x : event.clientX;
      var clientY = event.center ? event.center.y : event.clientY;
      var centerContainerRect = this.dom.centerContainer.getBoundingClientRect();
      var x = this.options.rtl ? centerContainerRect.right - clientX : clientX - centerContainerRect.left;
      var y = clientY - centerContainerRect.top;
      var item = this.itemSet.itemFromTarget(event);
      var group = this.itemSet.groupFromTarget(event);
      var customTime = CustomTime.customTimeFromTarget(event);
      var snap = this.itemSet.options.snap || null;
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      var time = this._toTime(x);

      var snappedTime = snap ? snap(time, scale, step) : time;
      var element = util$2.getTarget(event);
      var what = null;

      if (item != null) {
        what = 'item';
      } else if (customTime != null) {
        what = 'custom-time';
      } else if (util$2.hasParent(element, this.timeAxis.dom.foreground)) {
        what = 'axis';
      } else if (this.timeAxis2 && util$2.hasParent(element, this.timeAxis2.dom.foreground)) {
        what = 'axis';
      } else if (util$2.hasParent(element, this.itemSet.dom.labelSet)) {
        what = 'group-label';
      } else if (util$2.hasParent(element, this.currentTime.bar)) {
        what = 'current-time';
      } else if (util$2.hasParent(element, this.dom.center)) {
        what = 'background';
      }

      return {
        event: event,
        item: item ? item.id : null,
        isCluster: item ? !!item.isCluster : false,
        items: item ? item.items || [] : null,
        group: group ? group.groupId : null,
        customTime: customTime ? customTime.options.id : null,
        what: what,
        pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
        pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
        x: x,
        y: y,
        time: time,
        snappedTime: snappedTime
      };
    }
    /**
     * Toggle Timeline rolling mode
     */

  }, {
    key: "toggleRollingMode",
    value: function toggleRollingMode() {
      if (this.range.rolling) {
        this.range.stopRolling();
      } else {
        if (this.options.rollingMode == undefined) {
          this.setOptions(this.options);
        }

        this.range.startRolling();
      }
    }
    /**
     * redraw
     * @private
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      Core.prototype._redraw.call(this);
    }
    /**
     * on fit callback
     * @param {object} args
     * @private
     */

  }, {
    key: "_onFit",
    value: function _onFit(args) {
      var start = args.start,
          end = args.end,
          animation = args.animation;

      if (!end) {
        this.moveTo(start.valueOf(), {
          animation: animation
        });
      } else {
        this.range.setRange(start, end, {
          animation: animation
        });
      }
    }
  }]);

  return Timeline;
}(Core);

exports.Timeline = Timeline;

function getStart(item) {
  return util$2.convert(item.data.start, 'Date').valueOf();
}
/**
 *
 * @param {timeline.Item} item
 * @returns {number}
 */


function getEnd(item) {
  var end = item.data.end != undefined ? item.data.end : item.data.start;
  return util$2.convert(end, 'Date').valueOf();
}
/**
 * @param {vis.Timeline} timeline
 * @param {timeline.Item} item
 * @return {{shouldScroll: bool, scrollOffset: number, itemTop: number}}
 */


function getItemVerticalScroll(timeline, item) {
  if (!item.parent) {
    // The item no longer exists, so ignore this focus.
    return false;
  }

  var itemsetHeight = timeline.options.rtl ? timeline.props.rightContainer.height : timeline.props.leftContainer.height;
  var contentHeight = timeline.props.center.height;
  var group = item.parent;
  var offset = group.top;
  var shouldScroll = true;
  var orientation = timeline.timeAxis.options.orientation.axis;

  var itemTop = function itemTop() {
    if (orientation == "bottom") {
      return group.height - item.top - item.height;
    } else {
      return item.top;
    }
  };

  var currentScrollHeight = timeline._getScrollTop() * -1;
  var targetOffset = offset + itemTop();
  var height = item.height;

  if (targetOffset < currentScrollHeight) {
    if (offset + itemsetHeight <= offset + itemTop() + height) {
      offset += itemTop() - timeline.itemSet.options.margin.item.vertical;
    }
  } else if (targetOffset + height > currentScrollHeight + itemsetHeight) {
    offset += itemTop() + height - itemsetHeight + timeline.itemSet.options.margin.item.vertical;
  } else {
    shouldScroll = false;
  }

  offset = Math.min(offset, contentHeight - itemsetHeight);
  return {
    shouldScroll: shouldScroll,
    scrollOffset: offset,
    itemTop: targetOffset
  };
}

var nativeToPrecision = 1.0.toPrecision;
var FORCED$b = fails(function () {
  // IE7-
  return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToPrecision.call({});
}); // `Number.prototype.toPrecision` method
// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision

_export({
  target: 'Number',
  proto: true,
  forced: FORCED$b
}, {
  toPrecision: function toPrecision(precision) {
    return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
  }
});
/** DataScale */


var DataScale =
/*#__PURE__*/
function () {
  /**
   *
   * @param {number} start
   * @param {number} end
   * @param {boolean} autoScaleStart
   * @param {boolean} autoScaleEnd
   * @param {number} containerHeight
   * @param {number} majorCharHeight
   * @param {boolean} zeroAlign
   * @param {function} formattingFunction
   * @constructor DataScale
   */
  function DataScale(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
    var zeroAlign = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var formattingFunction = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    _classCallCheck(this, DataScale);

    this.majorSteps = [1, 2, 5, 10];
    this.minorSteps = [0.25, 0.5, 1, 2];
    this.customLines = null;
    this.containerHeight = containerHeight;
    this.majorCharHeight = majorCharHeight;
    this._start = start;
    this._end = end;
    this.scale = 1;
    this.minorStepIdx = -1;
    this.magnitudefactor = 1;
    this.determineScale();
    this.zeroAlign = zeroAlign;
    this.autoScaleStart = autoScaleStart;
    this.autoScaleEnd = autoScaleEnd;
    this.formattingFunction = formattingFunction;

    if (autoScaleStart || autoScaleEnd) {
      var me = this;

      var roundToMinor = function roundToMinor(value) {
        var rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);

        if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
          return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
        } else {
          return rounded;
        }
      };

      if (autoScaleStart) {
        this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
        this._start = roundToMinor(this._start);
      }

      if (autoScaleEnd) {
        this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
        this._end = roundToMinor(this._end);
      }

      this.determineScale();
    }
  }
  /**
   * set chart height
   * @param {number} majorCharHeight 
   */


  _createClass(DataScale, [{
    key: "setCharHeight",
    value: function setCharHeight(majorCharHeight) {
      this.majorCharHeight = majorCharHeight;
    }
    /**
     * set height
     * @param {number} containerHeight 
     */

  }, {
    key: "setHeight",
    value: function setHeight(containerHeight) {
      this.containerHeight = containerHeight;
    }
    /**
     * determine scale
     */

  }, {
    key: "determineScale",
    value: function determineScale() {
      var range = this._end - this._start;
      this.scale = this.containerHeight / range;
      var minimumStepValue = this.majorCharHeight / this.scale;
      var orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;
      this.minorStepIdx = -1;
      this.magnitudefactor = Math.pow(10, orderOfMagnitude);
      var start = 0;

      if (orderOfMagnitude < 0) {
        start = orderOfMagnitude;
      }

      var solutionFound = false;

      for (var l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
        this.magnitudefactor = Math.pow(10, l);

        for (var j = 0; j < this.minorSteps.length; j++) {
          var stepSize = this.magnitudefactor * this.minorSteps[j];

          if (stepSize >= minimumStepValue) {
            solutionFound = true;
            this.minorStepIdx = j;
            break;
          }
        }

        if (solutionFound === true) {
          break;
        }
      }
    }
    /**
     * returns if value is major
     * @param {number} value
     * @returns {boolean} 
     */

  }, {
    key: "is_major",
    value: function is_major(value) {
      return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
    }
    /**
     * returns step size
     * @returns {number} 
     */

  }, {
    key: "getStep",
    value: function getStep() {
      return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
    }
    /**
     * returns first major
     * @returns {number} 
     */

  }, {
    key: "getFirstMajor",
    value: function getFirstMajor() {
      var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
      return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
    }
    /**
     * returns first major
     * @param {date} current
     * @returns {date} formatted date
     */

  }, {
    key: "formatValue",
    value: function formatValue(current) {
      var returnValue = current.toPrecision(5);

      if (typeof this.formattingFunction === 'function') {
        returnValue = this.formattingFunction(current);
      }

      if (typeof returnValue === 'number') {
        return "".concat(returnValue);
      } else if (typeof returnValue === 'string') {
        return returnValue;
      } else {
        return current.toPrecision(5);
      }
    }
    /**
     * returns lines
     * @returns {object} lines
     */

  }, {
    key: "getLines",
    value: function getLines() {
      var lines = [];
      var step = this.getStep();
      var bottomOffset = (step - this._start % step) % step;

      for (var i = this._start + bottomOffset; this._end - i > 0.00001; i += step) {
        if (i != this._start) {
          //Skip the bottom line
          lines.push({
            major: this.is_major(i),
            y: this.convertValue(i),
            val: this.formatValue(i)
          });
        }
      }

      return lines;
    }
    /**
     * follow scale
     * @param {object} other
     */

  }, {
    key: "followScale",
    value: function followScale(other) {
      var oldStepIdx = this.minorStepIdx;
      var oldStart = this._start;
      var oldEnd = this._end;
      var me = this;

      var increaseMagnitude = function increaseMagnitude() {
        me.magnitudefactor *= 2;
      };

      var decreaseMagnitude = function decreaseMagnitude() {
        me.magnitudefactor /= 2;
      };

      if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) ;else if (other.minorStepIdx < this.minorStepIdx) {
        //I'm 5, they are 4 per major.
        this.minorStepIdx = 1;

        if (oldStepIdx == 2) {
          increaseMagnitude();
        } else {
          increaseMagnitude();
          increaseMagnitude();
        }
      } else {
        //I'm 4, they are 5 per major
        this.minorStepIdx = 2;

        if (oldStepIdx == 1) {
          decreaseMagnitude();
        } else {
          decreaseMagnitude();
          decreaseMagnitude();
        }
      } //Get masters stats:

      var otherZero = other.convertValue(0);
      var otherStep = other.getStep() * other.scale;
      var done = false;
      var count = 0; //Loop until magnitude is correct for given constrains.

      while (!done && count++ < 5) {
        //Get my stats:
        this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
        var newRange = this.containerHeight / this.scale; //For the case the magnitudefactor has changed:

        this._start = oldStart;
        this._end = this._start + newRange;
        var myOriginalZero = this._end * this.scale;
        var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
        var majorOffset = this.getFirstMajor() - other.getFirstMajor();

        if (this.zeroAlign) {
          var zeroOffset = otherZero - myOriginalZero;
          this._end += zeroOffset / this.scale;
          this._start = this._end - newRange;
        } else {
          if (!this.autoScaleStart) {
            this._start += majorStep - majorOffset / this.scale;
            this._end = this._start + newRange;
          } else {
            this._start -= majorOffset / this.scale;
            this._end = this._start + newRange;
          }
        }

        if (!this.autoScaleEnd && this._end > oldEnd + 0.00001) {
          //Need to decrease magnitude to prevent scale overshoot! (end)
          decreaseMagnitude();
          done = false;
          continue;
        }

        if (!this.autoScaleStart && this._start < oldStart - 0.00001) {
          if (this.zeroAlign && oldStart >= 0) {
            console.warn("Can't adhere to given 'min' range, due to zeroalign");
          } else {
            //Need to decrease magnitude to prevent scale overshoot! (start)
            decreaseMagnitude();
            done = false;
            continue;
          }
        }

        if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
          increaseMagnitude();
          done = false;
          continue;
        }

        done = true;
      }
    }
    /**
     * convert value
     * @param {number} value
     * @returns {number} 
     */

  }, {
    key: "convertValue",
    value: function convertValue(value) {
      return this.containerHeight - (value - this._start) * this.scale;
    }
    /**
     * returns screen to value
     * @param {number} pixels
     * @returns {number} 
     */

  }, {
    key: "screenToValue",
    value: function screenToValue(pixels) {
      return (this.containerHeight - pixels) / this.scale + this._start;
    }
  }]);

  return DataScale;
}();
/** A horizontal time axis */


var DataAxis =
/*#__PURE__*/
function (_Component) {
  _inherits(DataAxis, _Component);
  /**
  * @param {Object} body
  * @param {Object} [options]        See DataAxis.setOptions for the available
  *                                  options.
  * @param {SVGElement} svg
  * @param {timeline.LineGraph.options} linegraphOptions
  * @constructor DataAxis
  * @extends Component
  */


  function DataAxis(body, options, svg, linegraphOptions) {
    var _this;

    _classCallCheck(this, DataAxis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataAxis).call(this));
    _this.id = util$2.randomUUID();
    _this.body = body;
    _this.defaultOptions = {
      orientation: 'left',
      // supported: 'left', 'right'
      showMinorLabels: true,
      showMajorLabels: true,
      icons: false,
      majorLinesOffset: 7,
      minorLinesOffset: 4,
      labelOffsetX: 10,
      labelOffsetY: 2,
      iconWidth: 20,
      width: '40px',
      visible: true,
      alignZeros: true,
      left: {
        range: {
          min: undefined,
          max: undefined
        },
        format: function format(value) {
          return "".concat(parseFloat(value.toPrecision(3)));
        },
        title: {
          text: undefined,
          style: undefined
        }
      },
      right: {
        range: {
          min: undefined,
          max: undefined
        },
        format: function format(value) {
          return "".concat(parseFloat(value.toPrecision(3)));
        },
        title: {
          text: undefined,
          style: undefined
        }
      }
    };
    _this.linegraphOptions = linegraphOptions;
    _this.linegraphSVG = svg;
    _this.props = {};
    _this.DOMelements = {
      // dynamic elements
      lines: {},
      labels: {},
      title: {}
    };
    _this.dom = {};
    _this.scale = undefined;
    _this.range = {
      start: 0,
      end: 0
    };
    _this.options = util$2.extend({}, _this.defaultOptions);
    _this.conversionFactor = 1;

    _this.setOptions(options);

    _this.width = Number("".concat(_this.options.width).replace("px", ""));
    _this.minWidth = _this.width;
    _this.height = _this.linegraphSVG.getBoundingClientRect().height;
    _this.hidden = false;
    _this.stepPixels = 25;
    _this.zeroCrossing = -1;
    _this.amountOfSteps = -1;
    _this.lineOffset = 0;
    _this.master = true;
    _this.masterAxis = null;
    _this.svgElements = {};
    _this.iconsRemoved = false;
    _this.groups = {};
    _this.amountOfGroups = 0; // create the HTML DOM

    _this._create();

    if (_this.scale == undefined) {
      _this._redrawLabels();
    }

    _this.framework = {
      svg: _this.svg,
      svgElements: _this.svgElements,
      options: _this.options,
      groups: _this.groups
    };

    var me = _assertThisInitialized(_this);

    _this.body.emitter.on("verticalDrag", function () {
      me.dom.lineContainer.style.top = "".concat(me.body.domProps.scrollTop, "px");
    });

    return _this;
  }
  /**
   * Adds group to data axis
   * @param {string} label 
   * @param {object} graphOptions
   */


  _createClass(DataAxis, [{
    key: "addGroup",
    value: function addGroup(label, graphOptions) {
      if (!this.groups.hasOwnProperty(label)) {
        this.groups[label] = graphOptions;
      }

      this.amountOfGroups += 1;
    }
    /**
     * updates group of data axis
     * @param {string} label 
     * @param {object} graphOptions
     */

  }, {
    key: "updateGroup",
    value: function updateGroup(label, graphOptions) {
      if (!this.groups.hasOwnProperty(label)) {
        this.amountOfGroups += 1;
      }

      this.groups[label] = graphOptions;
    }
    /**
     * removes group of data axis
     * @param {string} label 
     */

  }, {
    key: "removeGroup",
    value: function removeGroup(label) {
      if (this.groups.hasOwnProperty(label)) {
        delete this.groups[label];
        this.amountOfGroups -= 1;
      }
    }
    /**
     * sets options
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        var redraw = false;

        if (this.options.orientation != options.orientation && options.orientation !== undefined) {
          redraw = true;
        }

        var fields = ['orientation', 'showMinorLabels', 'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', 'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', 'right', 'alignZeros'];
        util$2.selectiveDeepExtend(fields, this.options, options);
        this.minWidth = Number("".concat(this.options.width).replace("px", ""));

        if (redraw === true && this.dom.frame) {
          this.hide();
          this.show();
        }
      }
    }
    /**
     * Create the HTML DOM for the DataAxis
     */

  }, {
    key: "_create",
    value: function _create() {
      this.dom.frame = document.createElement('div');
      this.dom.frame.style.width = this.options.width;
      this.dom.frame.style.height = this.height;
      this.dom.lineContainer = document.createElement('div');
      this.dom.lineContainer.style.width = '100%';
      this.dom.lineContainer.style.height = this.height;
      this.dom.lineContainer.style.position = 'relative';
      this.dom.lineContainer.style.visibility = 'visible';
      this.dom.lineContainer.style.display = 'block'; // create svg element for graph drawing.

      this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
      this.svg.style.position = "absolute";
      this.svg.style.top = '0px';
      this.svg.style.height = '100%';
      this.svg.style.width = '100%';
      this.svg.style.display = "block";
      this.dom.frame.appendChild(this.svg);
    }
    /**
     * redraws groups icons
     */

  }, {
    key: "_redrawGroupIcons",
    value: function _redrawGroupIcons() {
      prepareElements(this.svgElements);
      var x;
      var iconWidth = this.options.iconWidth;
      var iconHeight = 15;
      var iconOffset = 4;
      var y = iconOffset + 0.5 * iconHeight;

      if (this.options.orientation === 'left') {
        x = iconOffset;
      } else {
        x = this.width - iconWidth - iconOffset;
      }

      var groupArray = Object.keys(this.groups);
      groupArray.sort(function (a, b) {
        return a < b ? -1 : 1;
      });

      for (var _i = 0, _groupArray = groupArray; _i < _groupArray.length; _i++) {
        var groupId = _groupArray[_i];

        if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
          this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
          y += iconHeight + iconOffset;
        }
      }

      cleanupElements(this.svgElements);
      this.iconsRemoved = false;
    }
    /**
     * Cleans up icons
     */

  }, {
    key: "_cleanupIcons",
    value: function _cleanupIcons() {
      if (this.iconsRemoved === false) {
        prepareElements(this.svgElements);
        cleanupElements(this.svgElements);
        this.iconsRemoved = true;
      }
    }
    /**
     * Create the HTML DOM for the DataAxis
     */

  }, {
    key: "show",
    value: function show() {
      this.hidden = false;

      if (!this.dom.frame.parentNode) {
        if (this.options.orientation === 'left') {
          this.body.dom.left.appendChild(this.dom.frame);
        } else {
          this.body.dom.right.appendChild(this.dom.frame);
        }
      }

      if (!this.dom.lineContainer.parentNode) {
        this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
      }

      this.dom.lineContainer.style.display = 'block';
    }
    /**
     * Create the HTML DOM for the DataAxis
     */

  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;

      if (this.dom.frame.parentNode) {
        this.dom.frame.parentNode.removeChild(this.dom.frame);
      }

      this.dom.lineContainer.style.display = 'none';
    }
    /**
     * Set a range (start and end)
     * @param {number} start
     * @param {number} end
     */

  }, {
    key: "setRange",
    value: function setRange(start, end) {
      this.range.start = start;
      this.range.end = end;
    }
    /**
     * Repaint the component
     * @return {boolean} Returns true if the component is resized
     */

  }, {
    key: "redraw",
    value: function redraw() {
      var resized = false;
      var activeGroups = 0; // Make sure the line container adheres to the vertical scrolling.

      this.dom.lineContainer.style.top = "".concat(this.body.domProps.scrollTop, "px");

      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
            activeGroups++;
          }
        }
      }

      if (this.amountOfGroups === 0 || activeGroups === 0) {
        this.hide();
      } else {
        this.show();
        this.height = Number(this.linegraphSVG.style.height.replace("px", "")); // svg offsetheight did not work in firefox and explorer...

        this.dom.lineContainer.style.height = "".concat(this.height, "px");
        this.width = this.options.visible === true ? Number("".concat(this.options.width).replace("px", "")) : 0;
        var props = this.props;
        var frame = this.dom.frame; // update classname

        frame.className = 'vis-data-axis'; // calculate character width and height

        this._calculateCharSize();

        var orientation = this.options.orientation;
        var showMinorLabels = this.options.showMinorLabels;
        var showMajorLabels = this.options.showMajorLabels;
        var backgroundHorizontalOffsetWidth = this.body.dom.backgroundHorizontal.offsetWidth; // determine the width and height of the elements for the axis

        props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
        props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
        props.minorLineWidth = backgroundHorizontalOffsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
        props.minorLineHeight = 1;
        props.majorLineWidth = backgroundHorizontalOffsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
        props.majorLineHeight = 1; //  take frame offline while updating (is almost twice as fast)

        if (orientation === 'left') {
          frame.style.top = '0';
          frame.style.left = '0';
          frame.style.bottom = '';
          frame.style.width = "".concat(this.width, "px");
          frame.style.height = "".concat(this.height, "px");
          this.props.width = this.body.domProps.left.width;
          this.props.height = this.body.domProps.left.height;
        } else {
          // right
          frame.style.top = '';
          frame.style.bottom = '0';
          frame.style.left = '0';
          frame.style.width = "".concat(this.width, "px");
          frame.style.height = "".concat(this.height, "px");
          this.props.width = this.body.domProps.right.width;
          this.props.height = this.body.domProps.right.height;
        }

        resized = this._redrawLabels();
        resized = this._isResized() || resized;

        if (this.options.icons === true) {
          this._redrawGroupIcons();
        } else {
          this._cleanupIcons();
        }

        this._redrawTitle(orientation);
      }

      return resized;
    }
    /**
     * Repaint major and minor text labels and vertical grid lines
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_redrawLabels",
    value: function _redrawLabels() {
      var _this2 = this;

      var resized = false;
      prepareElements(this.DOMelements.lines);
      prepareElements(this.DOMelements.labels);
      var orientation = this.options['orientation'];
      var customRange = this.options[orientation].range != undefined ? this.options[orientation].range : {}; //Override range with manual options:

      var autoScaleEnd = true;

      if (customRange.max != undefined) {
        this.range.end = customRange.max;
        autoScaleEnd = false;
      }

      var autoScaleStart = true;

      if (customRange.min != undefined) {
        this.range.start = customRange.min;
        autoScaleStart = false;
      }

      this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);

      if (this.master === false && this.masterAxis != undefined) {
        this.scale.followScale(this.masterAxis.scale);
        this.dom.lineContainer.style.display = 'none';
      } else {
        this.dom.lineContainer.style.display = 'block';
      } //Is updated in side-effect of _redrawLabel():


      this.maxLabelSize = 0;
      var lines = this.scale.getLines();
      lines.forEach(function (line) {
        var y = line.y;
        var isMajor = line.major;

        if (_this2.options['showMinorLabels'] && isMajor === false) {
          _this2._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-minor', _this2.props.minorCharHeight);
        }

        if (isMajor) {
          if (y >= 0) {
            _this2._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-major', _this2.props.majorCharHeight);
          }
        }

        if (_this2.master === true) {
          if (isMajor) {
            _this2._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-major', _this2.options.majorLinesOffset, _this2.props.majorLineWidth);
          } else {
            _this2._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-minor', _this2.options.minorLinesOffset, _this2.props.minorLineWidth);
          }
        }
      }); // Note that title is rotated, so we're using the height, not width!

      var titleWidth = 0;

      if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
        titleWidth = this.props.titleCharHeight;
      }

      var offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15; // this will resize the yAxis to accommodate the labels.

      if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
        this.width = this.maxLabelSize + offset;
        this.options.width = "".concat(this.width, "px");
        cleanupElements(this.DOMelements.lines);
        cleanupElements(this.DOMelements.labels);
        this.redraw();
        resized = true;
      } // this will resize the yAxis if it is too big for the labels.
      else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
          this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
          this.options.width = "".concat(this.width, "px");
          cleanupElements(this.DOMelements.lines);
          cleanupElements(this.DOMelements.labels);
          this.redraw();
          resized = true;
        } else {
          cleanupElements(this.DOMelements.lines);
          cleanupElements(this.DOMelements.labels);
          resized = false;
        }

      return resized;
    }
    /**
     * converts value
     * @param {number} value
     * @returns {number} converted number
     */

  }, {
    key: "convertValue",
    value: function convertValue(value) {
      return this.scale.convertValue(value);
    }
    /**
     * converts value
     * @param {number} x
     * @returns {number} screen value
     */

  }, {
    key: "screenToValue",
    value: function screenToValue(x) {
      return this.scale.screenToValue(x);
    }
    /**
     * Create a label for the axis at position x
     *
     * @param {number} y
     * @param {string} text
     * @param {'top'|'right'|'bottom'|'left'} orientation
     * @param {string} className
     * @param {number} characterHeight
     * @private
     */

  }, {
    key: "_redrawLabel",
    value: function _redrawLabel(y, text, orientation, className, characterHeight) {
      // reuse redundant label
      var label = getDOMElement('div', this.DOMelements.labels, this.dom.frame); //this.dom.redundant.labels.shift();

      label.className = className;
      label.innerHTML = text;

      if (orientation === 'left') {
        label.style.left = "-".concat(this.options.labelOffsetX, "px");
        label.style.textAlign = "right";
      } else {
        label.style.right = "-".concat(this.options.labelOffsetX, "px");
        label.style.textAlign = "left";
      }

      label.style.top = "".concat(y - 0.5 * characterHeight + this.options.labelOffsetY, "px");
      text += '';
      var largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);

      if (this.maxLabelSize < text.length * largestWidth) {
        this.maxLabelSize = text.length * largestWidth;
      }
    }
    /**
     * Create a minor line for the axis at position y
     * @param {number} y
     * @param {'top'|'right'|'bottom'|'left'} orientation
     * @param {string} className
     * @param {number} offset
     * @param {number} width
     */

  }, {
    key: "_redrawLine",
    value: function _redrawLine(y, orientation, className, offset, width) {
      if (this.master === true) {
        var line = getDOMElement('div', this.DOMelements.lines, this.dom.lineContainer); //this.dom.redundant.lines.shift();

        line.className = className;
        line.innerHTML = '';

        if (orientation === 'left') {
          line.style.left = "".concat(this.width - offset, "px");
        } else {
          line.style.right = "".concat(this.width - offset, "px");
        }

        line.style.width = "".concat(width, "px");
        line.style.top = "".concat(y, "px");
      }
    }
    /**
     * Create a title for the axis
     * @private
     * @param {'top'|'right'|'bottom'|'left'} orientation
     */

  }, {
    key: "_redrawTitle",
    value: function _redrawTitle(orientation) {
      prepareElements(this.DOMelements.title); // Check if the title is defined for this axes

      if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
        var title = getDOMElement('div', this.DOMelements.title, this.dom.frame);
        title.className = "vis-y-axis vis-title vis-".concat(orientation);
        title.innerHTML = this.options[orientation].title.text; // Add style - if provided

        if (this.options[orientation].title.style !== undefined) {
          util$2.addCssText(title, this.options[orientation].title.style);
        }

        if (orientation === 'left') {
          title.style.left = "".concat(this.props.titleCharHeight, "px");
        } else {
          title.style.right = "".concat(this.props.titleCharHeight, "px");
        }

        title.style.width = "".concat(this.height, "px");
      } // we need to clean up in case we did not use all elements.


      cleanupElements(this.DOMelements.title);
    }
    /**
     * Determine the size of text on the axis (both major and minor axis).
     * The size is calculated only once and then cached in this.props.
     * @private
     */

  }, {
    key: "_calculateCharSize",
    value: function _calculateCharSize() {
      // determine the char width and height on the minor axis
      if (!('minorCharHeight' in this.props)) {
        var textMinor = document.createTextNode('0');
        var measureCharMinor = document.createElement('div');
        measureCharMinor.className = 'vis-y-axis vis-minor vis-measure';
        measureCharMinor.appendChild(textMinor);
        this.dom.frame.appendChild(measureCharMinor);
        this.props.minorCharHeight = measureCharMinor.clientHeight;
        this.props.minorCharWidth = measureCharMinor.clientWidth;
        this.dom.frame.removeChild(measureCharMinor);
      }

      if (!('majorCharHeight' in this.props)) {
        var textMajor = document.createTextNode('0');
        var measureCharMajor = document.createElement('div');
        measureCharMajor.className = 'vis-y-axis vis-major vis-measure';
        measureCharMajor.appendChild(textMajor);
        this.dom.frame.appendChild(measureCharMajor);
        this.props.majorCharHeight = measureCharMajor.clientHeight;
        this.props.majorCharWidth = measureCharMajor.clientWidth;
        this.dom.frame.removeChild(measureCharMajor);
      }

      if (!('titleCharHeight' in this.props)) {
        var textTitle = document.createTextNode('0');
        var measureCharTitle = document.createElement('div');
        measureCharTitle.className = 'vis-y-axis vis-title vis-measure';
        measureCharTitle.appendChild(textTitle);
        this.dom.frame.appendChild(measureCharTitle);
        this.props.titleCharHeight = measureCharTitle.clientHeight;
        this.props.titleCharWidth = measureCharTitle.clientWidth;
        this.dom.frame.removeChild(measureCharTitle);
      }
    }
  }]);

  return DataAxis;
}(Component);
/**
 *
 * @param {number | string} groupId
 * @param {Object} options   // TODO: Describe options
 *
 * @constructor Points
 */


function Points(groupId, options) {} // eslint-disable-line no-unused-vars

/**
 * draw the data points
 *
 * @param {Array} dataset
 * @param {GraphGroup} group
 * @param {Object} framework            | SVG DOM element
 * @param {number} [offset]
 */


Points.draw = function (dataset, group, framework, offset) {
  offset = offset || 0;
  var callback = getCallback(framework, group);

  for (var i = 0; i < dataset.length; i++) {
    if (!callback) {
      // draw the point the simple way.
      drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
    } else {
      var callbackResult = callback(dataset[i], group); // result might be true, false or an object

      if (callbackResult === true || _typeof(callbackResult) === 'object') {
        drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
      }
    }
  }
};

Points.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline"); //Don't call callback on icon

  drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
};
/**
 *
 * @param {vis.Group} group
 * @param {any} callbackResult
 * @returns {{style: *, styles: (*|string), size: *, className: *}}
 */


function getGroupTemplate(group, callbackResult) {
  callbackResult = typeof callbackResult === 'undefined' ? {} : callbackResult;
  return {
    style: callbackResult.style || group.options.drawPoints.style,
    styles: callbackResult.styles || group.options.drawPoints.styles,
    size: callbackResult.size || group.options.drawPoints.size,
    className: callbackResult.className || group.className
  };
}
/**
 *
 * @param {Object} framework            | SVG DOM element
 * @param {vis.Group} group
 * @returns {function}
 */


function getCallback(framework, group) {
  var callback = undefined; // check for the graph2d onRender

  if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == 'function') {
    callback = framework.options.drawPoints.onRender;
  } // override it with the group onRender if defined


  if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == 'function') {
    callback = group.group.options.drawPoints.onRender;
  }

  return callback;
}
/**
 *
 * @param {vis.GraphGroup.id} groupId
 * @param {Object} options   // TODO: Describe options
 * @constructor Bargraph
 */


function Bargraph(groupId, options) {// eslint-disable-line no-unused-vars
}

Bargraph.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline");
  var barWidth = Math.round(0.3 * iconWidth);
  var originalWidth = group.options.barChart.width;
  var scale = originalWidth / barWidth;
  var bar1Height = Math.round(0.4 * iconHeight);
  var bar2Height = Math.round(0.75 * iconHeight);
  var offset = Math.round((iconWidth - 2 * barWidth) / 3);
  drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
  drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);

  if (group.options.drawPoints.enabled == true) {
    var groupTemplate = {
      style: group.options.drawPoints.style,
      styles: group.options.drawPoints.styles,
      size: group.options.drawPoints.size / scale,
      className: group.className
    };
    drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
    drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
  }
};
/**
 * draw a bar graph
 *
 * @param {Array.<vis.GraphGroup.id>} groupIds
 * @param {Object} processedGroupData
 * @param {{svg: Object, svgElements: Array.<Object>, options: Object, groups: Array.<vis.Group>}} framework
 */


Bargraph.draw = function (groupIds, processedGroupData, framework) {
  var combinedData = [];
  var intersections = {};
  var coreDistance;
  var key, drawData;
  var group;
  var i, j;
  var barPoints = 0; // combine all barchart data

  for (i = 0; i < groupIds.length; i++) {
    group = framework.groups[groupIds[i]];

    if (group.options.style === 'bar') {
      if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === undefined || framework.options.groups.visibility[groupIds[i]] === true)) {
        for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
          combinedData.push({
            screen_x: processedGroupData[groupIds[i]][j].screen_x,
            screen_end: processedGroupData[groupIds[i]][j].screen_end,
            screen_y: processedGroupData[groupIds[i]][j].screen_y,
            x: processedGroupData[groupIds[i]][j].x,
            end: processedGroupData[groupIds[i]][j].end,
            y: processedGroupData[groupIds[i]][j].y,
            groupId: groupIds[i],
            label: processedGroupData[groupIds[i]][j].label
          });
          barPoints += 1;
        }
      }
    }
  }

  if (barPoints === 0) {
    return;
  } // sort by time and by group


  combinedData.sort(function (a, b) {
    if (a.screen_x === b.screen_x) {
      return a.groupId < b.groupId ? -1 : 1;
    } else {
      return a.screen_x - b.screen_x;
    }
  }); // get intersections

  Bargraph._getDataIntersections(intersections, combinedData); // plot barchart


  for (i = 0; i < combinedData.length; i++) {
    group = framework.groups[combinedData[i].groupId];
    var minWidth = group.options.barChart.minWidth != undefined ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;
    key = combinedData[i].screen_x;
    var heightOffset = 0;

    if (intersections[key] === undefined) {
      if (i + 1 < combinedData.length) {
        coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
      }

      drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
    } else {
      var nextKey = i + (intersections[key].amount - intersections[key].resolved);

      if (nextKey < combinedData.length) {
        coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
      }

      drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
      intersections[key].resolved += 1;

      if (group.options.stack === true && group.options.excludeFromStacking !== true) {
        if (combinedData[i].screen_y < group.zeroPosition) {
          heightOffset = intersections[key].accumulatedNegative;
          intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
        } else {
          heightOffset = intersections[key].accumulatedPositive;
          intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
        }
      } else if (group.options.barChart.sideBySide === true) {
        drawData.width = drawData.width / intersections[key].amount;
        drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
      }
    }

    var dataWidth = drawData.width;
    var start = combinedData[i].screen_x; // are we drawing explicit boxes? (we supplied an end value)

    if (combinedData[i].screen_end != undefined) {
      dataWidth = combinedData[i].screen_end - combinedData[i].screen_x;
      start += dataWidth * 0.5;
    } else {
      start += drawData.offset;
    }

    drawBar(start, combinedData[i].screen_y - heightOffset, dataWidth, group.zeroPosition - combinedData[i].screen_y, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style); // draw points

    if (group.options.drawPoints.enabled === true) {
      var pointData = {
        screen_x: combinedData[i].screen_x,
        screen_y: combinedData[i].screen_y - heightOffset,
        x: combinedData[i].x,
        y: combinedData[i].y,
        groupId: combinedData[i].groupId,
        label: combinedData[i].label
      };
      Points.draw([pointData], group, framework, drawData.offset); //DOMutil.drawPoint(combinedData[i].x + drawData.offset, combinedData[i].y, group, framework.svgElements, framework.svg);
    }
  }
};
/**
 * Fill the intersections object with counters of how many datapoints share the same x coordinates
 * @param {Object} intersections
 * @param {Array.<Object>} combinedData
 * @private
 */


Bargraph._getDataIntersections = function (intersections, combinedData) {
  // get intersections
  var coreDistance;

  for (var i = 0; i < combinedData.length; i++) {
    if (i + 1 < combinedData.length) {
      coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
    }

    if (i > 0) {
      coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
    }

    if (coreDistance === 0) {
      if (intersections[combinedData[i].screen_x] === undefined) {
        intersections[combinedData[i].screen_x] = {
          amount: 0,
          resolved: 0,
          accumulatedPositive: 0,
          accumulatedNegative: 0
        };
      }

      intersections[combinedData[i].screen_x].amount += 1;
    }
  }
};
/**
 * Get the width and offset for bargraphs based on the coredistance between datapoints
 *
 * @param {number} coreDistance
 * @param {vis.Group} group
 * @param {number} minWidth
 * @returns {{width: number, offset: number}}
 * @private
 */


Bargraph._getSafeDrawData = function (coreDistance, group, minWidth) {
  var width, offset;

  if (coreDistance < group.options.barChart.width && coreDistance > 0) {
    width = coreDistance < minWidth ? minWidth : coreDistance;
    offset = 0; // recalculate offset with the new width;

    if (group.options.barChart.align === 'left') {
      offset -= 0.5 * coreDistance;
    } else if (group.options.barChart.align === 'right') {
      offset += 0.5 * coreDistance;
    }
  } else {
    // default settings
    width = group.options.barChart.width;
    offset = 0;

    if (group.options.barChart.align === 'left') {
      offset -= 0.5 * group.options.barChart.width;
    } else if (group.options.barChart.align === 'right') {
      offset += 0.5 * group.options.barChart.width;
    }
  }

  return {
    width: width,
    offset: offset
  };
};

Bargraph.getStackedYRange = function (combinedData, groupRanges, groupIds, groupLabel, orientation) {
  if (combinedData.length > 0) {
    // sort by time and by group
    combinedData.sort(function (a, b) {
      if (a.screen_x === b.screen_x) {
        return a.groupId < b.groupId ? -1 : 1;
      } else {
        return a.screen_x - b.screen_x;
      }
    });
    var intersections = {};

    Bargraph._getDataIntersections(intersections, combinedData);

    groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
    groupRanges[groupLabel].yAxisOrientation = orientation;
    groupIds.push(groupLabel);
  }
};

Bargraph._getStackedYRange = function (intersections, combinedData) {
  var key;
  var yMin = combinedData[0].screen_y;
  var yMax = combinedData[0].screen_y;

  for (var i = 0; i < combinedData.length; i++) {
    key = combinedData[i].screen_x;

    if (intersections[key] === undefined) {
      yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
      yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
    } else {
      if (combinedData[i].screen_y < 0) {
        intersections[key].accumulatedNegative += combinedData[i].screen_y;
      } else {
        intersections[key].accumulatedPositive += combinedData[i].screen_y;
      }
    }
  }

  for (var xpos in intersections) {
    if (intersections.hasOwnProperty(xpos)) {
      yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
      yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
      yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
      yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
    }
  }

  return {
    min: yMin,
    max: yMax
  };
};
/**
 *
 * @param {vis.GraphGroup.id} groupId
 * @param {Object} options   // TODO: Describe options
 * @constructor Line
 */


function Line(groupId, options) {// eslint-disable-line no-unused-vars
}

Line.calcPath = function (dataset, group) {
  if (dataset != null) {
    if (dataset.length > 0) {
      var d = []; // construct path from dataset

      if (group.options.interpolation.enabled == true) {
        d = Line._catmullRom(dataset, group);
      } else {
        d = Line._linear(dataset);
      }

      return d;
    }
  }
};

Line.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
  var fillHeight = iconHeight * 0.5;
  var path, fillPath;
  var outline = getSVGElement("rect", framework.svgElements, framework.svg);
  outline.setAttributeNS(null, "x", x);
  outline.setAttributeNS(null, "y", y - fillHeight);
  outline.setAttributeNS(null, "width", iconWidth);
  outline.setAttributeNS(null, "height", 2 * fillHeight);
  outline.setAttributeNS(null, "class", "vis-outline");
  path = getSVGElement("path", framework.svgElements, framework.svg);
  path.setAttributeNS(null, "class", group.className);

  if (group.style !== undefined) {
    path.setAttributeNS(null, "style", group.style);
  }

  path.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y + "");

  if (group.options.shaded.enabled == true) {
    fillPath = getSVGElement("path", framework.svgElements, framework.svg);

    if (group.options.shaded.orientation == 'top') {
      fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
    } else {
      fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " " + "L" + x + "," + (y + fillHeight) + " " + "L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
    }

    fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");

    if (group.options.shaded.style !== undefined && group.options.shaded.style !== "") {
      fillPath.setAttributeNS(null, "style", group.options.shaded.style);
    }
  }

  if (group.options.drawPoints.enabled == true) {
    var groupTemplate = {
      style: group.options.drawPoints.style,
      styles: group.options.drawPoints.styles,
      size: group.options.drawPoints.size,
      className: group.className
    };
    drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
  }
};

Line.drawShading = function (pathArray, group, subPathArray, framework) {
  // append shading to the path
  if (group.options.shaded.enabled == true) {
    var svgHeight = Number(framework.svg.style.height.replace('px', ''));
    var fillPath = getSVGElement('path', framework.svgElements, framework.svg);
    var type = "L";

    if (group.options.interpolation.enabled == true) {
      type = "C";
    }

    var dFill;
    var zero = 0;

    if (group.options.shaded.orientation == 'top') {
      zero = 0;
    } else if (group.options.shaded.orientation == 'bottom') {
      zero = svgHeight;
    } else {
      zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
    }

    if (group.options.shaded.orientation == 'group' && subPathArray != null && subPathArray != undefined) {
      dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' L' + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
    } else {
      dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' V' + zero + ' H' + pathArray[0][0] + " Z";
    }

    fillPath.setAttributeNS(null, 'class', group.className + ' vis-fill');

    if (group.options.shaded.style !== undefined) {
      fillPath.setAttributeNS(null, 'style', group.options.shaded.style);
    }

    fillPath.setAttributeNS(null, 'd', dFill);
  }
};
/**
 * draw a line graph
 *
 * @param {Array.<Object>} pathArray
 * @param {vis.Group} group
 * @param {{svg: Object, svgElements: Array.<Object>, options: Object, groups: Array.<vis.Group>}} framework
 */


Line.draw = function (pathArray, group, framework) {
  if (pathArray != null && pathArray != undefined) {
    var path = getSVGElement('path', framework.svgElements, framework.svg);
    path.setAttributeNS(null, "class", group.className);

    if (group.style !== undefined) {
      path.setAttributeNS(null, "style", group.style);
    }

    var type = "L";

    if (group.options.interpolation.enabled == true) {
      type = "C";
    } // copy properties to path for drawing.


    path.setAttributeNS(null, 'd', 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
  }
};

Line.serializePath = function (pathArray, type, inverse) {
  if (pathArray.length < 2) {
    //Too little data to create a path.
    return "";
  }

  var d = type;
  var i;

  if (inverse) {
    for (i = pathArray.length - 2; i > 0; i--) {
      d += pathArray[i][0] + "," + pathArray[i][1] + " ";
    }
  } else {
    for (i = 1; i < pathArray.length; i++) {
      d += pathArray[i][0] + "," + pathArray[i][1] + " ";
    }
  }

  return d;
};
/**
 * This uses an uniform parametrization of the interpolation algorithm:
 * 'On the Parameterization of Catmull-Rom Curves' by Cem Yuksel et al.
 * @param {Array.<Object>} data
 * @returns {string}
 * @private
 */


Line._catmullRomUniform = function (data) {
  // catmull rom
  var p0, p1, p2, p3, bp1, bp2;
  var d = [];
  d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
  var normalization = 1 / 6;
  var length = data.length;

  for (var i = 0; i < length - 1; i++) {
    p0 = i == 0 ? data[0] : data[i - 1];
    p1 = data[i];
    p2 = data[i + 1];
    p3 = i + 2 < length ? data[i + 2] : p2; // Catmull-Rom to Cubic Bezier conversion matrix
    //    0       1       0       0
    //  -1/6      1      1/6      0
    //    0      1/6      1     -1/6
    //    0       0       1       0
    //    bp0 = { x: p1.x,                               y: p1.y };

    bp1 = {
      screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
      screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
    };
    bp2 = {
      screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
      screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
    }; //    bp0 = { x: p2.x,                               y: p2.y };

    d.push([bp1.screen_x, bp1.screen_y]);
    d.push([bp2.screen_x, bp2.screen_y]);
    d.push([p2.screen_x, p2.screen_y]);
  }

  return d;
};
/**
 * This uses either the chordal or centripetal parameterization of the catmull-rom algorithm.
 * By default, the centripetal parameterization is used because this gives the nicest results.
 * These parameterizations are relatively heavy because the distance between 4 points have to be calculated.
 *
 * One optimization can be used to reuse distances since this is a sliding window approach.
 * @param {Array.<Object>} data
 * @param {vis.GraphGroup} group
 * @returns {string}
 * @private
 */


Line._catmullRom = function (data, group) {
  var alpha = group.options.interpolation.alpha;

  if (alpha == 0 || alpha === undefined) {
    return this._catmullRomUniform(data);
  } else {
    var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
    var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
    var d = [];
    d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
    var length = data.length;

    for (var i = 0; i < length - 1; i++) {
      p0 = i == 0 ? data[0] : data[i - 1];
      p1 = data[i];
      p2 = data[i + 1];
      p3 = i + 2 < length ? data[i + 2] : p2;
      d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
      d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
      d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2)); // Catmull-Rom to Cubic Bezier conversion matrix
      // A = 2d1^2a + 3d1^a * d2^a + d3^2a
      // B = 2d3^2a + 3d3^a * d2^a + d2^2a
      // [   0             1            0          0          ]
      // [   -d2^2a /N     A/N          d1^2a /N   0          ]
      // [   0             d3^2a /M     B/M        -d2^2a /M  ]
      // [   0             0            1          0          ]

      d3powA = Math.pow(d3, alpha);
      d3pow2A = Math.pow(d3, 2 * alpha);
      d2powA = Math.pow(d2, alpha);
      d2pow2A = Math.pow(d2, 2 * alpha);
      d1powA = Math.pow(d1, alpha);
      d1pow2A = Math.pow(d1, 2 * alpha);
      A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
      B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
      N = 3 * d1powA * (d1powA + d2powA);

      if (N > 0) {
        N = 1 / N;
      }

      M = 3 * d3powA * (d3powA + d2powA);

      if (M > 0) {
        M = 1 / M;
      }

      bp1 = {
        screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
        screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
      };
      bp2 = {
        screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
        screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
      };

      if (bp1.screen_x == 0 && bp1.screen_y == 0) {
        bp1 = p1;
      }

      if (bp2.screen_x == 0 && bp2.screen_y == 0) {
        bp2 = p2;
      }

      d.push([bp1.screen_x, bp1.screen_y]);
      d.push([bp2.screen_x, bp2.screen_y]);
      d.push([p2.screen_x, p2.screen_y]);
    }

    return d;
  }
};
/**
 * this generates the SVG path for a linear drawing between datapoints.
 * @param {Array.<Object>} data
 * @returns {string}
 * @private
 */


Line._linear = function (data) {
  // linear
  var d = [];

  for (var i = 0; i < data.length; i++) {
    d.push([data[i].screen_x, data[i].screen_y]);
  }

  return d;
};
/**
 * /**
 * @param {object} group            | the object of the group from the dataset
 * @param {string} groupId          | ID of the group
 * @param {object} options          | the default options
 * @param {array} groupsUsingDefaultStyles  | this array has one entree.
 *                                            It is passed as an array so it is passed by reference.
 *                                            It enumerates through the default styles
 * @constructor GraphGroup
 */


function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
  this.id = groupId;
  var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'drawPoints', 'shaded', 'interpolation', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
  this.options = util$2.selectiveBridgeObject(fields, options);
  this.usingDefaultStyle = group.className === undefined;
  this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
  this.zeroPosition = 0;
  this.update(group);

  if (this.usingDefaultStyle == true) {
    this.groupsUsingDefaultStyles[0] += 1;
  }

  this.itemsData = [];
  this.visible = group.visible === undefined ? true : group.visible;
}
/**
 * this loads a reference to all items in this group into this group.
 * @param {array} items
 */


GraphGroup.prototype.setItems = function (items) {
  if (items != null) {
    this.itemsData = items;

    if (this.options.sort == true) {
      util$2.insertSort(this.itemsData, function (a, b) {
        return a.x > b.x ? 1 : -1;
      });
    }
  } else {
    this.itemsData = [];
  }
};

GraphGroup.prototype.getItems = function () {
  return this.itemsData;
};
/**
 * this is used for barcharts and shading, this way, we only have to calculate it once.
 * @param {number} pos
 */


GraphGroup.prototype.setZeroPosition = function (pos) {
  this.zeroPosition = pos;
};
/**
 * set the options of the graph group over the default options.
 * @param {Object} options
 */


GraphGroup.prototype.setOptions = function (options) {
  if (options !== undefined) {
    var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
    util$2.selectiveDeepExtend(fields, this.options, options); // if the group's drawPoints is a function delegate the callback to the onRender property

    if (typeof options.drawPoints == 'function') {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }

    util$2.mergeOptions(this.options, options, 'interpolation');
    util$2.mergeOptions(this.options, options, 'drawPoints');
    util$2.mergeOptions(this.options, options, 'shaded');

    if (options.interpolation) {
      if (_typeof(options.interpolation) == 'object') {
        if (options.interpolation.parametrization) {
          if (options.interpolation.parametrization == 'uniform') {
            this.options.interpolation.alpha = 0;
          } else if (options.interpolation.parametrization == 'chordal') {
            this.options.interpolation.alpha = 1.0;
          } else {
            this.options.interpolation.parametrization = 'centripetal';
            this.options.interpolation.alpha = 0.5;
          }
        }
      }
    }
  }
};
/**
 * this updates the current group class with the latest group dataset entree, used in _updateGroup in linegraph
 * @param {vis.Group} group
 */


GraphGroup.prototype.update = function (group) {
  this.group = group;
  this.content = group.content || 'graph';
  this.className = group.className || this.className || 'vis-graph-group' + this.groupsUsingDefaultStyles[0] % 10;
  this.visible = group.visible === undefined ? true : group.visible;
  this.style = group.style;
  this.setOptions(group.options);
};
/**
 * return the legend entree for this group.
 *
 * @param {number} iconWidth
 * @param {number} iconHeight
 * @param {{svg: (*|Element), svgElements: Object, options: Object, groups: Array.<Object>}} framework
 * @param {number} x
 * @param {number} y
 * @returns {{icon: (*|Element), label: (*|string), orientation: *}}
 */


GraphGroup.prototype.getLegend = function (iconWidth, iconHeight, framework, x, y) {
  if (framework == undefined || framework == null) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    framework = {
      svg: svg,
      svgElements: {},
      options: this.options,
      groups: [this]
    };
  }

  if (x == undefined || x == null) {
    x = 0;
  }

  if (y == undefined || y == null) {
    y = 0.5 * iconHeight;
  }

  switch (this.options.style) {
    case "line":
      Line.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;

    case "points": //explicit no break

    case "point":
      Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;

    case "bar":
      Bargraph.drawIcon(this, x, y, iconWidth, iconHeight, framework);
      break;
  }

  return {
    icon: framework.svg,
    label: this.content,
    orientation: this.options.yAxisOrientation
  };
};

GraphGroup.prototype.getYRange = function (groupData) {
  var yMin = groupData[0].y;
  var yMax = groupData[0].y;

  for (var j = 0; j < groupData.length; j++) {
    yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
    yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
  }

  return {
    min: yMin,
    max: yMax,
    yAxisOrientation: this.options.yAxisOrientation
  };
};
/**
 * Legend for Graph2d
 *
 * @param {vis.Graph2d.body} body
 * @param {vis.Graph2d.options} options
 * @param {number} side
 * @param {vis.LineGraph.options} linegraphOptions
 * @constructor Legend
 * @extends Component
 */


function Legend(body, options, side, linegraphOptions) {
  this.body = body;
  this.defaultOptions = {
    enabled: false,
    icons: true,
    iconSize: 20,
    iconSpacing: 6,
    left: {
      visible: true,
      position: 'top-left' // top/bottom - left,center,right

    },
    right: {
      visible: true,
      position: 'top-right' // top/bottom - left,center,right

    }
  };
  this.side = side;
  this.options = util$2.extend({}, this.defaultOptions);
  this.linegraphOptions = linegraphOptions;
  this.svgElements = {};
  this.dom = {};
  this.groups = {};
  this.amountOfGroups = 0;

  this._create();

  this.framework = {
    svg: this.svg,
    svgElements: this.svgElements,
    options: this.options,
    groups: this.groups
  };
  this.setOptions(options);
}

Legend.prototype = new Component();

Legend.prototype.clear = function () {
  this.groups = {};
  this.amountOfGroups = 0;
};

Legend.prototype.addGroup = function (label, graphOptions) {
  // Include a group only if the group option 'excludeFromLegend: false' is not set.
  if (graphOptions.options.excludeFromLegend != true) {
    if (!this.groups.hasOwnProperty(label)) {
      this.groups[label] = graphOptions;
    }

    this.amountOfGroups += 1;
  }
};

Legend.prototype.updateGroup = function (label, graphOptions) {
  this.groups[label] = graphOptions;
};

Legend.prototype.removeGroup = function (label) {
  if (this.groups.hasOwnProperty(label)) {
    delete this.groups[label];
    this.amountOfGroups -= 1;
  }
};

Legend.prototype._create = function () {
  this.dom.frame = document.createElement('div');
  this.dom.frame.className = 'vis-legend';
  this.dom.frame.style.position = "absolute";
  this.dom.frame.style.top = "10px";
  this.dom.frame.style.display = "block";
  this.dom.textArea = document.createElement('div');
  this.dom.textArea.className = 'vis-legend-text';
  this.dom.textArea.style.position = "relative";
  this.dom.textArea.style.top = "0px";
  this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
  this.svg.style.position = 'absolute';
  this.svg.style.top = 0 + 'px';
  this.svg.style.width = this.options.iconSize + 5 + 'px';
  this.svg.style.height = '100%';
  this.dom.frame.appendChild(this.svg);
  this.dom.frame.appendChild(this.dom.textArea);
};
/**
 * Hide the component from the DOM
 */


Legend.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }
};
/**
 * Show the component in the DOM (when not already visible).
 */


Legend.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }
};

Legend.prototype.setOptions = function (options) {
  var fields = ['enabled', 'orientation', 'icons', 'left', 'right'];
  util$2.selectiveDeepExtend(fields, this.options, options);
};

Legend.prototype.redraw = function () {
  var activeGroups = 0;
  var groupArray = Object.keys(this.groups);
  groupArray.sort(function (a, b) {
    return a < b ? -1 : 1;
  });

  for (var i = 0; i < groupArray.length; i++) {
    var groupId = groupArray[i];

    if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
      activeGroups++;
    }
  }

  if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
    this.hide();
  } else {
    this.show();

    if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'bottom-left') {
      this.dom.frame.style.left = '4px';
      this.dom.frame.style.textAlign = "left";
      this.dom.textArea.style.textAlign = "left";
      this.dom.textArea.style.left = this.options.iconSize + 15 + 'px';
      this.dom.textArea.style.right = '';
      this.svg.style.left = 0 + 'px';
      this.svg.style.right = '';
    } else {
      this.dom.frame.style.right = '4px';
      this.dom.frame.style.textAlign = "right";
      this.dom.textArea.style.textAlign = "right";
      this.dom.textArea.style.right = this.options.iconSize + 15 + 'px';
      this.dom.textArea.style.left = '';
      this.svg.style.right = 0 + 'px';
      this.svg.style.left = '';
    }

    if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'top-right') {
      this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
      this.dom.frame.style.bottom = '';
    } else {
      var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
      this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
      this.dom.frame.style.top = '';
    }

    if (this.options.icons == false) {
      this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + 'px';
      this.dom.textArea.style.right = '';
      this.dom.textArea.style.left = '';
      this.svg.style.width = '0px';
    } else {
      this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + 'px';
      this.drawLegendIcons();
    }

    var content = '';

    for (i = 0; i < groupArray.length; i++) {
      groupId = groupArray[i];

      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
        content += this.groups[groupId].content + '<br />';
      }
    }

    this.dom.textArea.innerHTML = content;
    this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + 'px';
  }
};

Legend.prototype.drawLegendIcons = function () {
  if (this.dom.frame.parentNode) {
    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    }); // this resets the elements so the order is maintained

    resetElements(this.svgElements);
    var padding = window.getComputedStyle(this.dom.frame).paddingTop;
    var iconOffset = Number(padding.replace('px', ''));
    var x = iconOffset;
    var iconWidth = this.options.iconSize;
    var iconHeight = 0.75 * this.options.iconSize;
    var y = iconOffset + 0.5 * iconHeight + 3;
    this.svg.style.width = iconWidth + 5 + iconOffset + 'px';

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];

      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + this.options.iconSpacing;
      }
    }
  }
};

var UNGROUPED$3 = '__ungrouped__'; // reserved group id for ungrouped items

/**
 * This is the constructor of the LineGraph. It requires a Timeline body and options.
 *
 * @param {vis.Timeline.body} body
 * @param {Object} options
 * @constructor LineGraph
 * @extends Component
 */

function LineGraph(body, options) {
  this.id = util$2.randomUUID();
  this.body = body;
  this.defaultOptions = {
    yAxisOrientation: 'left',
    defaultGroup: 'default',
    sort: true,
    sampling: true,
    stack: false,
    graphHeight: '400px',
    shaded: {
      enabled: false,
      orientation: 'bottom' // top, bottom, zero

    },
    style: 'line',
    // line, bar
    barChart: {
      width: 50,
      sideBySide: false,
      align: 'center' // left, center, right

    },
    interpolation: {
      enabled: true,
      parametrization: 'centripetal',
      // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      alpha: 0.5
    },
    drawPoints: {
      enabled: true,
      size: 6,
      style: 'square' // square, circle

    },
    dataAxis: {},
    //Defaults are done on DataAxis level
    legend: {},
    //Defaults are done on Legend level
    groups: {
      visibility: {}
    }
  }; // options is shared by this lineGraph and all its items

  this.options = util$2.extend({}, this.defaultOptions);
  this.dom = {};
  this.props = {};
  this.hammer = null;
  this.groups = {};
  this.abortedGraphUpdate = false;
  this.updateSVGheight = false;
  this.updateSVGheightOnResize = false;
  this.forceGraphUpdate = true;
  var me = this;
  this.itemsData = null; // DataSet

  this.groupsData = null; // DataSet
  // listeners for the DataSet of the items

  this.itemListeners = {
    'add': function add(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onAdd(params.items);
    },
    'update': function update(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onUpdate(params.items);
    },
    'remove': function remove(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onRemove(params.items);
    }
  }; // listeners for the DataSet of the groups

  this.groupListeners = {
    'add': function add(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onAddGroups(params.items);
    },
    'update': function update(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onUpdateGroups(params.items);
    },
    'remove': function remove(event, params, senderId) {
      // eslint-disable-line no-unused-vars
      me._onRemoveGroups(params.items);
    }
  };
  this.items = {}; // object with an Item for every data item

  this.selection = []; // list with the ids of all selected nodes

  this.lastStart = this.body.range.start;
  this.touchParams = {}; // stores properties while dragging

  this.svgElements = {};
  this.setOptions(options);
  this.groupsUsingDefaultStyles = [0];
  this.body.emitter.on('rangechanged', function () {
    me.lastStart = me.body.range.start;
    me.svg.style.left = util$2.option.asSize(-me.props.width);
    me.forceGraphUpdate = true; //Is this local redraw necessary? (Core also does a change event!)

    me.redraw.call(me);
  }); // create the HTML DOM

  this._create();

  this.framework = {
    svg: this.svg,
    svgElements: this.svgElements,
    options: this.options,
    groups: this.groups
  };
}

LineGraph.prototype = new Component();
/**
 * Create the HTML DOM for the ItemSet
 */

LineGraph.prototype._create = function () {
  var frame = document.createElement('div');
  frame.className = 'vis-line-graph';
  this.dom.frame = frame; // create svg element for graph drawing.

  this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  this.svg.style.position = 'relative';
  this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
  this.svg.style.display = 'block';
  frame.appendChild(this.svg); // data axis

  this.options.dataAxis.orientation = 'left';
  this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
  this.options.dataAxis.orientation = 'right';
  this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
  delete this.options.dataAxis.orientation; // legends

  this.legendLeft = new Legend(this.body, this.options.legend, 'left', this.options.groups);
  this.legendRight = new Legend(this.body, this.options.legend, 'right', this.options.groups);
  this.show();
};
/**
 * set the options of the LineGraph. the mergeOptions is used for subObjects that have an enabled element.
 * @param {object} options
 */


LineGraph.prototype.setOptions = function (options) {
  if (options) {
    var fields = ['sampling', 'defaultGroup', 'stack', 'height', 'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', 'sort', 'groups'];

    if (options.graphHeight === undefined && options.height !== undefined) {
      this.updateSVGheight = true;
      this.updateSVGheightOnResize = true;
    } else if (this.body.domProps.centerContainer.height !== undefined && options.graphHeight !== undefined) {
      if (parseInt((options.graphHeight + '').replace("px", '')) < this.body.domProps.centerContainer.height) {
        this.updateSVGheight = true;
      }
    }

    util$2.selectiveDeepExtend(fields, this.options, options);
    util$2.mergeOptions(this.options, options, 'interpolation');
    util$2.mergeOptions(this.options, options, 'drawPoints');
    util$2.mergeOptions(this.options, options, 'shaded');
    util$2.mergeOptions(this.options, options, 'legend');

    if (options.interpolation) {
      if (_typeof(options.interpolation) == 'object') {
        if (options.interpolation.parametrization) {
          if (options.interpolation.parametrization == 'uniform') {
            this.options.interpolation.alpha = 0;
          } else if (options.interpolation.parametrization == 'chordal') {
            this.options.interpolation.alpha = 1.0;
          } else {
            this.options.interpolation.parametrization = 'centripetal';
            this.options.interpolation.alpha = 0.5;
          }
        }
      }
    }

    if (this.yAxisLeft) {
      if (options.dataAxis !== undefined) {
        this.yAxisLeft.setOptions(this.options.dataAxis);
        this.yAxisRight.setOptions(this.options.dataAxis);
      }
    }

    if (this.legendLeft) {
      if (options.legend !== undefined) {
        this.legendLeft.setOptions(this.options.legend);
        this.legendRight.setOptions(this.options.legend);
      }
    }

    if (this.groups.hasOwnProperty(UNGROUPED$3)) {
      this.groups[UNGROUPED$3].setOptions(options);
    }
  } // this is used to redraw the graph if the visibility of the groups is changed.


  if (this.dom.frame) {
    //not on initial run?
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
};
/**
 * Hide the component from the DOM
 */


LineGraph.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }
};
/**
 * Show the component in the DOM (when not already visible).
 */


LineGraph.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }
};
/**
 * Set items
 * @param {vis.DataSet | null} items
 */


LineGraph.prototype.setItems = function (items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData; // replace the dataset

  if (!items) {
    this.itemsData = null;
  } else if (items instanceof DataSet || items instanceof DataView$2) {
    this.itemsData = items;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util$2.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    }); // remove all drawn items

    ids = oldItemsData.getIds();

    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util$2.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    }); // add all new items

    ids = this.itemsData.getIds();

    this._onAdd(ids);
  }
};
/**
 * Set groups
 * @param {vis.DataSet} groups
 */


LineGraph.prototype.setGroups = function (groups) {
  var me = this;
  var ids; // unsubscribe from current dataset

  if (this.groupsData) {
    util$2.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.off(event, callback);
    }); // remove all drawn groups

    ids = this.groupsData.getIds();
    this.groupsData = null;

    for (var i = 0; i < ids.length; i++) {
      this._removeGroup(ids[i]);
    }
  } // replace the dataset


  if (!groups) {
    this.groupsData = null;
  } else if (groups instanceof DataSet || groups instanceof DataView$2) {
    this.groupsData = groups;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util$2.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    }); // draw all ms

    ids = this.groupsData.getIds();

    this._onAddGroups(ids);
  }
};

LineGraph.prototype._onUpdate = function (ids) {
  this._updateAllGroupData(ids);
};

LineGraph.prototype._onAdd = function (ids) {
  this._onUpdate(ids);
};

LineGraph.prototype._onRemove = function (ids) {
  this._onUpdate(ids);
};

LineGraph.prototype._onUpdateGroups = function (groupIds) {
  this._updateAllGroupData(null, groupIds);
};

LineGraph.prototype._onAddGroups = function (groupIds) {
  this._onUpdateGroups(groupIds);
};
/**
 * this cleans the group out off the legends and the dataaxis, updates the ungrouped and updates the graph
 * @param {Array} groupIds
 * @private
 */


LineGraph.prototype._onRemoveGroups = function (groupIds) {
  for (var i = 0; i < groupIds.length; i++) {
    this._removeGroup(groupIds[i]);
  }

  this.forceGraphUpdate = true;
  this.body.emitter.emit("_change", {
    queue: true
  });
};
/**
 * this cleans the group out off the legends and the dataaxis
 * @param {vis.GraphGroup.id} groupId
 * @private
 */


LineGraph.prototype._removeGroup = function (groupId) {
  if (this.groups.hasOwnProperty(groupId)) {
    if (this.groups[groupId].options.yAxisOrientation == 'right') {
      this.yAxisRight.removeGroup(groupId);
      this.legendRight.removeGroup(groupId);
      this.legendRight.redraw();
    } else {
      this.yAxisLeft.removeGroup(groupId);
      this.legendLeft.removeGroup(groupId);
      this.legendLeft.redraw();
    }

    delete this.groups[groupId];
  }
};
/**
 * update a group object with the group dataset entree
 *
 * @param {vis.GraphGroup} group
 * @param {vis.GraphGroup.id} groupId
 * @private
 */


LineGraph.prototype._updateGroup = function (group, groupId) {
  if (!this.groups.hasOwnProperty(groupId)) {
    this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);

    if (this.groups[groupId].options.yAxisOrientation == 'right') {
      this.yAxisRight.addGroup(groupId, this.groups[groupId]);
      this.legendRight.addGroup(groupId, this.groups[groupId]);
    } else {
      this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
      this.legendLeft.addGroup(groupId, this.groups[groupId]);
    }
  } else {
    this.groups[groupId].update(group);

    if (this.groups[groupId].options.yAxisOrientation == 'right') {
      this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
      this.legendRight.updateGroup(groupId, this.groups[groupId]); //If yAxisOrientation changed, clean out the group from the other axis.

      this.yAxisLeft.removeGroup(groupId);
      this.legendLeft.removeGroup(groupId);
    } else {
      this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
      this.legendLeft.updateGroup(groupId, this.groups[groupId]); //If yAxisOrientation changed, clean out the group from the other axis.

      this.yAxisRight.removeGroup(groupId);
      this.legendRight.removeGroup(groupId);
    }
  }

  this.legendLeft.redraw();
  this.legendRight.redraw();
};
/**
 * this updates all groups, it is used when there is an update the the itemset.
 *
 * @param  {Array} ids
 * @param  {Array} groupIds
 * @private
 */


LineGraph.prototype._updateAllGroupData = function (ids, groupIds) {
  if (this.itemsData != null) {
    var groupsContent = {};
    var items = this.itemsData.get();
    var fieldId = this.itemsData._idProp;
    var idMap = {};

    if (ids) {
      ids.map(function (id) {
        idMap[id] = id;
      });
    } //pre-Determine array sizes, for more efficient memory claim


    var groupCounts = {};

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var groupId = item.group;

      if (groupId === null || groupId === undefined) {
        groupId = UNGROUPED$3;
      }

      groupCounts.hasOwnProperty(groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
    } //Pre-load arrays from existing groups if items are not changed (not in ids)


    var existingItemsMap = {};

    if (!groupIds && ids) {
      for (groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          group = this.groups[groupId];
          var existing_items = group.getItems();
          groupsContent[groupId] = existing_items.filter(function (item) {
            existingItemsMap[item[fieldId]] = item[fieldId];
            return item[fieldId] !== idMap[item[fieldId]];
          });
          var newLength = groupCounts[groupId];
          groupCounts[groupId] -= groupsContent[groupId].length;

          if (groupsContent[groupId].length < newLength) {
            groupsContent[groupId][newLength - 1] = {};
          }
        }
      }
    } //Now insert data into the arrays.


    for (i = 0; i < items.length; i++) {
      item = items[i];
      groupId = item.group;

      if (groupId === null || groupId === undefined) {
        groupId = UNGROUPED$3;
      }

      if (!groupIds && ids && item[fieldId] !== idMap[item[fieldId]] && existingItemsMap.hasOwnProperty(item[fieldId])) {
        continue;
      }

      if (!groupsContent.hasOwnProperty(groupId)) {
        groupsContent[groupId] = new Array(groupCounts[groupId]);
      } //Copy data (because of unmodifiable DataView input.


      var extended = util$2.bridgeObject(item);
      extended.x = util$2.convert(item.x, 'Date');
      extended.end = util$2.convert(item.end, 'Date');
      extended.orginalY = item.y; //real Y

      extended.y = Number(item.y);
      extended[fieldId] = item[fieldId];
      var index = groupsContent[groupId].length - groupCounts[groupId]--;
      groupsContent[groupId][index] = extended;
    } //Make sure all groups are present, to allow removal of old groups


    for (groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        if (!groupsContent.hasOwnProperty(groupId)) {
          groupsContent[groupId] = new Array(0);
        }
      }
    } //Update legendas, style and axis


    for (groupId in groupsContent) {
      if (groupsContent.hasOwnProperty(groupId)) {
        if (groupsContent[groupId].length == 0) {
          if (this.groups.hasOwnProperty(groupId)) {
            this._removeGroup(groupId);
          }
        } else {
          var group = undefined;

          if (this.groupsData != undefined) {
            group = this.groupsData.get(groupId);
          }

          if (group == undefined) {
            group = {
              id: groupId,
              content: this.options.defaultGroup + groupId
            };
          }

          this._updateGroup(group, groupId);

          this.groups[groupId].setItems(groupsContent[groupId]);
        }
      }
    }

    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", {
      queue: true
    });
  }
};
/**
 * Redraw the component, mandatory function
 * @return {boolean} Returns true if the component is resized
 */


LineGraph.prototype.redraw = function () {
  var resized = false; // calculate actual size and position

  this.props.width = this.dom.frame.offsetWidth;
  this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom; // check if this component is resized

  resized = this._isResized() || resized; // check whether zoomed (in that case we need to re-stack everything)

  var visibleInterval = this.body.range.end - this.body.range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval;
  this.lastVisibleInterval = visibleInterval; // the svg element is three times as big as the width, this allows for fully dragging left and right
  // without reloading the graph. the controls for this are bound to events in the constructor

  if (resized == true) {
    this.svg.style.width = util$2.option.asSize(3 * this.props.width);
    this.svg.style.left = util$2.option.asSize(-this.props.width); // if the height of the graph is set as proportional, change the height of the svg

    if ((this.options.height + '').indexOf("%") != -1 || this.updateSVGheightOnResize == true) {
      this.updateSVGheight = true;
    }
  } // update the height of the graph on each redraw of the graph.


  if (this.updateSVGheight == true) {
    if (this.options.graphHeight != this.props.height + 'px') {
      this.options.graphHeight = this.props.height + 'px';
      this.svg.style.height = this.props.height + 'px';
    }

    this.updateSVGheight = false;
  } else {
    this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
  } // zoomed is here to ensure that animations are shown correctly.


  if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
    resized = this._updateGraph() || resized;
    this.forceGraphUpdate = false;
  } else {
    // move the whole svg while dragging
    if (this.lastStart != 0) {
      var offset = this.body.range.start - this.lastStart;
      var range = this.body.range.end - this.body.range.start;

      if (this.props.width != 0) {
        var rangePerPixelInv = this.props.width / range;
        var xOffset = offset * rangePerPixelInv;
        this.svg.style.left = -this.props.width - xOffset + 'px';
      }
    }
  }

  this.legendLeft.redraw();
  this.legendRight.redraw();
  return resized;
};

LineGraph.prototype._getSortedGroupIds = function () {
  // getting group Ids
  var grouplist = [];

  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];

      if (group.visible == true && (this.options.groups.visibility[groupId] === undefined || this.options.groups.visibility[groupId] == true)) {
        grouplist.push({
          id: groupId,
          zIndex: group.options.zIndex
        });
      }
    }
  }

  util$2.insertSort(grouplist, function (a, b) {
    var az = a.zIndex;
    var bz = b.zIndex;
    if (az === undefined) az = 0;
    if (bz === undefined) bz = 0;
    return az == bz ? 0 : az < bz ? -1 : 1;
  });
  var groupIds = new Array(grouplist.length);

  for (var i = 0; i < grouplist.length; i++) {
    groupIds[i] = grouplist[i].id;
  }

  return groupIds;
};
/**
 * Update and redraw the graph.
 *
 * @returns {boolean}
 * @private
 */


LineGraph.prototype._updateGraph = function () {
  // reset the svg elements
  prepareElements(this.svgElements);

  if (this.props.width != 0 && this.itemsData != null) {
    var group, i;
    var groupRanges = {};
    var changeCalled = false; // this is the range of the SVG canvas

    var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
    var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width); // getting group Ids

    var groupIds = this._getSortedGroupIds();

    if (groupIds.length > 0) {
      var groupsData = {}; // fill groups data, this only loads the data we require based on the timewindow

      this._getRelevantData(groupIds, groupsData, minDate, maxDate); // apply sampling, if disabled, it will pass through this function.


      this._applySampling(groupIds, groupsData); // we transform the X coordinates to detect collisions


      for (i = 0; i < groupIds.length; i++) {
        this._convertXcoordinates(groupsData[groupIds[i]]);
      } // now all needed data has been collected we start the processing.


      this._getYRanges(groupIds, groupsData, groupRanges); // update the Y axis first, we use this data to draw at the correct Y points


      changeCalled = this._updateYAxis(groupIds, groupRanges); //  at changeCalled, abort this update cycle as the graph needs another update with new Width input from the Redraw container.
      //  Cleanup SVG elements on abort.

      if (changeCalled == true) {
        cleanupElements(this.svgElements);
        this.abortedGraphUpdate = true;
        return true;
      }

      this.abortedGraphUpdate = false; // With the yAxis scaled correctly, use this to get the Y values of the points.

      var below = undefined;

      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];

        if (this.options.stack === true && this.options.style === 'line') {
          if (group.options.excludeFromStacking == undefined || !group.options.excludeFromStacking) {
            if (below != undefined) {
              this._stack(groupsData[group.id], groupsData[below.id]);

              if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                  below.options.shaded.orientation = "group";
                  below.options.shaded.groupId = group.id;
                } else {
                  group.options.shaded.orientation = "group";
                  group.options.shaded.groupId = below.id;
                }
              }
            }

            below = group;
          }
        }

        this._convertYcoordinates(groupsData[groupIds[i]], group);
      } //Precalculate paths and draw shading if appropriate. This will make sure the shading is always behind any lines.


      var paths = {};

      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];

        if (group.options.style === 'line' && group.options.shaded.enabled == true) {
          var dataset = groupsData[groupIds[i]];

          if (dataset == null || dataset.length == 0) {
            continue;
          }

          if (!paths.hasOwnProperty(groupIds[i])) {
            paths[groupIds[i]] = Line.calcPath(dataset, group);
          }

          if (group.options.shaded.orientation === "group") {
            var subGroupId = group.options.shaded.groupId;

            if (groupIds.indexOf(subGroupId) === -1) {
              console.log(group.id + ": Unknown shading group target given:" + subGroupId);
              continue;
            }

            if (!paths.hasOwnProperty(subGroupId)) {
              paths[subGroupId] = Line.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
            }

            Line.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
          } else {
            Line.drawShading(paths[groupIds[i]], group, undefined, this.framework);
          }
        }
      } // draw the groups, calculating paths if still necessary.


      Bargraph.draw(groupIds, groupsData, this.framework);

      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];

        if (groupsData[groupIds[i]].length > 0) {
          switch (group.options.style) {
            case "line":
              if (!paths.hasOwnProperty(groupIds[i])) {
                paths[groupIds[i]] = Line.calcPath(groupsData[groupIds[i]], group);
              }

              Line.draw(paths[groupIds[i]], group, this.framework);
            // eslint-disable-line no-fallthrough

            case "point": // eslint-disable-line no-fallthrough

            case "points":
              if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                Points.draw(groupsData[groupIds[i]], group, this.framework);
              }

              break;

            case "bar": // bar needs to be drawn enmasse
            // eslint-disable-line no-fallthrough

            default: //do nothing...

          }
        }
      }
    }
  } // cleanup unused svg elements


  cleanupElements(this.svgElements);
  return false;
};

LineGraph.prototype._stack = function (data, subData) {
  var index, dx, dy, subPrevPoint, subNextPoint;
  index = 0; // for each data point we look for a matching on in the set below

  for (var j = 0; j < data.length; j++) {
    subPrevPoint = undefined;
    subNextPoint = undefined; // we look for time matches or a before-after point

    for (var k = index; k < subData.length; k++) {
      // if times match exactly
      if (subData[k].x === data[j].x) {
        subPrevPoint = subData[k];
        subNextPoint = subData[k];
        index = k;
        break;
      } else if (subData[k].x > data[j].x) {
        // overshoot
        subNextPoint = subData[k];

        if (k == 0) {
          subPrevPoint = subNextPoint;
        } else {
          subPrevPoint = subData[k - 1];
        }

        index = k;
        break;
      }
    } // in case the last data point has been used, we assume it stays like this.


    if (subNextPoint === undefined) {
      subPrevPoint = subData[subData.length - 1];
      subNextPoint = subData[subData.length - 1];
    } // linear interpolation


    dx = subNextPoint.x - subPrevPoint.x;
    dy = subNextPoint.y - subPrevPoint.y;

    if (dx == 0) {
      data[j].y = data[j].orginalY + subNextPoint.y;
    } else {
      data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y; // ax + b where b is data[j].y
    }
  }
};
/**
 * first select and preprocess the data from the datasets.
 * the groups have their preselection of data, we now loop over this data to see
 * what data we need to draw. Sorted data is much faster.
 * more optimization is possible by doing the sampling before and using the binary search
 * to find the end date to determine the increment.
 *
 * @param {array}  groupIds
 * @param {object} groupsData
 * @param {date}   minDate
 * @param {date}   maxDate
 * @private
 */


LineGraph.prototype._getRelevantData = function (groupIds, groupsData, minDate, maxDate) {
  var group, i, j, item;

  if (groupIds.length > 0) {
    for (i = 0; i < groupIds.length; i++) {
      group = this.groups[groupIds[i]];
      var itemsData = group.getItems(); // optimization for sorted data

      if (group.options.sort == true) {
        var dateComparator = function dateComparator(a, b) {
          return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
        };

        var first = Math.max(0, util$2.binarySearchValue(itemsData, minDate, 'x', 'before', dateComparator));
        var last = Math.min(itemsData.length, util$2.binarySearchValue(itemsData, maxDate, 'x', 'after', dateComparator) + 1);

        if (last <= 0) {
          last = itemsData.length;
        }

        var dataContainer = new Array(last - first);

        for (j = first; j < last; j++) {
          item = group.itemsData[j];
          dataContainer[j - first] = item;
        }

        groupsData[groupIds[i]] = dataContainer;
      } else {
        // If unsorted data, all data is relevant, just returning entire structure
        groupsData[groupIds[i]] = group.itemsData;
      }
    }
  }
};
/**
 *
 * @param {Array.<vis.GraphGroup.id>} groupIds
 * @param {vis.DataSet} groupsData
 * @private
 */


LineGraph.prototype._applySampling = function (groupIds, groupsData) {
  var group;

  if (groupIds.length > 0) {
    for (var i = 0; i < groupIds.length; i++) {
      group = this.groups[groupIds[i]];

      if (group.options.sampling == true) {
        var dataContainer = groupsData[groupIds[i]];

        if (dataContainer.length > 0) {
          var increment = 1;
          var amountOfPoints = dataContainer.length; // the global screen is used because changing the width of the yAxis may affect the increment, resulting in an endless loop
          // of width changing of the yAxis.
          //TODO: This assumes sorted data, but that's not guaranteed!

          var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
          var pointsPerPixel = amountOfPoints / xDistance;
          increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));
          var sampledData = new Array(amountOfPoints);

          for (var j = 0; j < amountOfPoints; j += increment) {
            var idx = Math.round(j / increment);
            sampledData[idx] = dataContainer[j];
          }

          groupsData[groupIds[i]] = sampledData.splice(0, Math.round(amountOfPoints / increment));
        }
      }
    }
  }
};
/**
 *
 * @param {Array.<vis.GraphGroup.id>} groupIds
 * @param {vis.DataSet} groupsData
 * @param {object} groupRanges  | this is being filled here
 * @private
 */


LineGraph.prototype._getYRanges = function (groupIds, groupsData, groupRanges) {
  var groupData, group, i;
  var combinedDataLeft = [];
  var combinedDataRight = [];
  var options;

  if (groupIds.length > 0) {
    for (i = 0; i < groupIds.length; i++) {
      groupData = groupsData[groupIds[i]];
      options = this.groups[groupIds[i]].options;

      if (groupData.length > 0) {
        group = this.groups[groupIds[i]]; // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.

        if (options.stack === true && options.style === 'bar') {
          if (options.yAxisOrientation === 'left') {
            combinedDataLeft = combinedDataLeft.concat(groupData);
          } else {
            combinedDataRight = combinedDataRight.concat(groupData);
          }
        } else {
          groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
        }
      }
    } // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.


    Bargraph.getStackedYRange(combinedDataLeft, groupRanges, groupIds, '__barStackLeft', 'left');
    Bargraph.getStackedYRange(combinedDataRight, groupRanges, groupIds, '__barStackRight', 'right');
  }
};
/**
 * this sets the Y ranges for the Y axis. It also determines which of the axis should be shown or hidden.
 * @param {Array.<vis.GraphGroup.id>} groupIds
 * @param {Object} groupRanges
 * @returns {boolean} resized
 * @private
 */


LineGraph.prototype._updateYAxis = function (groupIds, groupRanges) {
  var resized = false;
  var yAxisLeftUsed = false;
  var yAxisRightUsed = false;
  var minLeft = 1e9,
      minRight = 1e9,
      maxLeft = -1e9,
      maxRight = -1e9,
      minVal,
      maxVal; // if groups are present

  if (groupIds.length > 0) {
    // this is here to make sure that if there are no items in the axis but there are groups, that there is no infinite draw/redraw loop.
    for (var i = 0; i < groupIds.length; i++) {
      var group = this.groups[groupIds[i]];

      if (group && group.options.yAxisOrientation != 'right') {
        yAxisLeftUsed = true;
        minLeft = 1e9;
        maxLeft = -1e9;
      } else if (group && group.options.yAxisOrientation) {
        yAxisRightUsed = true;
        minRight = 1e9;
        maxRight = -1e9;
      }
    } // if there are items:


    for (i = 0; i < groupIds.length; i++) {
      if (groupRanges.hasOwnProperty(groupIds[i])) {
        if (groupRanges[groupIds[i]].ignore !== true) {
          minVal = groupRanges[groupIds[i]].min;
          maxVal = groupRanges[groupIds[i]].max;

          if (groupRanges[groupIds[i]].yAxisOrientation != 'right') {
            yAxisLeftUsed = true;
            minLeft = minLeft > minVal ? minVal : minLeft;
            maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
          } else {
            yAxisRightUsed = true;
            minRight = minRight > minVal ? minVal : minRight;
            maxRight = maxRight < maxVal ? maxVal : maxRight;
          }
        }
      }
    }

    if (yAxisLeftUsed == true) {
      this.yAxisLeft.setRange(minLeft, maxLeft);
    }

    if (yAxisRightUsed == true) {
      this.yAxisRight.setRange(minRight, maxRight);
    }
  }

  resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
  resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;

  if (yAxisRightUsed == true && yAxisLeftUsed == true) {
    this.yAxisLeft.drawIcons = true;
    this.yAxisRight.drawIcons = true;
  } else {
    this.yAxisLeft.drawIcons = false;
    this.yAxisRight.drawIcons = false;
  }

  this.yAxisRight.master = !yAxisLeftUsed;
  this.yAxisRight.masterAxis = this.yAxisLeft;

  if (this.yAxisRight.master == false) {
    if (yAxisRightUsed == true) {
      this.yAxisLeft.lineOffset = this.yAxisRight.width;
    } else {
      this.yAxisLeft.lineOffset = 0;
    }

    resized = this.yAxisLeft.redraw() || resized;
    resized = this.yAxisRight.redraw() || resized;
  } else {
    resized = this.yAxisRight.redraw() || resized;
  } // clean the accumulated lists


  var tempGroups = ['__barStackLeft', '__barStackRight', '__lineStackLeft', '__lineStackRight'];

  for (i = 0; i < tempGroups.length; i++) {
    if (groupIds.indexOf(tempGroups[i]) != -1) {
      groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);
    }
  }

  return resized;
};
/**
 * This shows or hides the Y axis if needed. If there is a change, the changed event is emitted by the updateYAxis function
 *
 * @param {boolean} axisUsed
 * @param {vis.DataAxis}  axis
 * @returns {boolean}
 * @private
 */


LineGraph.prototype._toggleAxisVisiblity = function (axisUsed, axis) {
  var changed = false;

  if (axisUsed == false) {
    if (axis.dom.frame.parentNode && axis.hidden == false) {
      axis.hide();
      changed = true;
    }
  } else {
    if (!axis.dom.frame.parentNode && axis.hidden == true) {
      axis.show();
      changed = true;
    }
  }

  return changed;
};
/**
 * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
 * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
 * the yAxis.
 *
 * @param {Array.<Object>} datapoints
 * @private
 */


LineGraph.prototype._convertXcoordinates = function (datapoints) {
  var toScreen = this.body.util.toScreen;

  for (var i = 0; i < datapoints.length; i++) {
    datapoints[i].screen_x = toScreen(datapoints[i].x) + this.props.width;
    datapoints[i].screen_y = datapoints[i].y; //starting point for range calculations

    if (datapoints[i].end != undefined) {
      datapoints[i].screen_end = toScreen(datapoints[i].end) + this.props.width;
    } else {
      datapoints[i].screen_end = undefined;
    }
  }
};
/**
 * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
 * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
 * the yAxis.
 *
 * @param {Array.<Object>} datapoints
 * @param {vis.GraphGroup} group
 * @private
 */


LineGraph.prototype._convertYcoordinates = function (datapoints, group) {
  var axis = this.yAxisLeft;
  var svgHeight = Number(this.svg.style.height.replace('px', ''));

  if (group.options.yAxisOrientation == 'right') {
    axis = this.yAxisRight;
  }

  for (var i = 0; i < datapoints.length; i++) {
    datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
  }

  group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
};
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */


var string$1 = 'string';
var bool$1 = 'boolean';
var number$1 = 'number';
var array$1 = 'array';
var date$1 = 'date';
var object$1 = 'object'; // should only be in a __type__ property

var dom$1 = 'dom';
var moment$5 = 'moment';
var any$1 = 'any';
var allOptions$2 = {
  configure: {
    enabled: {
      'boolean': bool$1
    },
    filter: {
      'boolean': bool$1,
      'function': 'function'
    },
    container: {
      dom: dom$1
    },
    __type__: {
      object: object$1,
      'boolean': bool$1,
      'function': 'function'
    }
  },
  //globals :
  alignCurrentTime: {
    string: string$1,
    'undefined': 'undefined'
  },
  yAxisOrientation: {
    string: ['left', 'right']
  },
  defaultGroup: {
    string: string$1
  },
  sort: {
    'boolean': bool$1
  },
  sampling: {
    'boolean': bool$1
  },
  stack: {
    'boolean': bool$1
  },
  graphHeight: {
    string: string$1,
    number: number$1
  },
  shaded: {
    enabled: {
      'boolean': bool$1
    },
    orientation: {
      string: ['bottom', 'top', 'zero', 'group']
    },
    // top, bottom, zero, group
    groupId: {
      object: object$1
    },
    __type__: {
      'boolean': bool$1,
      object: object$1
    }
  },
  style: {
    string: ['line', 'bar', 'points']
  },
  // line, bar
  barChart: {
    width: {
      number: number$1
    },
    minWidth: {
      number: number$1
    },
    sideBySide: {
      'boolean': bool$1
    },
    align: {
      string: ['left', 'center', 'right']
    },
    __type__: {
      object: object$1
    }
  },
  interpolation: {
    enabled: {
      'boolean': bool$1
    },
    parametrization: {
      string: ['centripetal', 'chordal', 'uniform']
    },
    // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
    alpha: {
      number: number$1
    },
    __type__: {
      object: object$1,
      'boolean': bool$1
    }
  },
  drawPoints: {
    enabled: {
      'boolean': bool$1
    },
    onRender: {
      'function': 'function'
    },
    size: {
      number: number$1
    },
    style: {
      string: ['square', 'circle']
    },
    // square, circle
    __type__: {
      object: object$1,
      'boolean': bool$1,
      'function': 'function'
    }
  },
  dataAxis: {
    showMinorLabels: {
      'boolean': bool$1
    },
    showMajorLabels: {
      'boolean': bool$1
    },
    icons: {
      'boolean': bool$1
    },
    width: {
      string: string$1,
      number: number$1
    },
    visible: {
      'boolean': bool$1
    },
    alignZeros: {
      'boolean': bool$1
    },
    left: {
      range: {
        min: {
          number: number$1,
          'undefined': 'undefined'
        },
        max: {
          number: number$1,
          'undefined': 'undefined'
        },
        __type__: {
          object: object$1
        }
      },
      format: {
        'function': 'function'
      },
      title: {
        text: {
          string: string$1,
          number: number$1,
          'undefined': 'undefined'
        },
        style: {
          string: string$1,
          'undefined': 'undefined'
        },
        __type__: {
          object: object$1
        }
      },
      __type__: {
        object: object$1
      }
    },
    right: {
      range: {
        min: {
          number: number$1,
          'undefined': 'undefined'
        },
        max: {
          number: number$1,
          'undefined': 'undefined'
        },
        __type__: {
          object: object$1
        }
      },
      format: {
        'function': 'function'
      },
      title: {
        text: {
          string: string$1,
          number: number$1,
          'undefined': 'undefined'
        },
        style: {
          string: string$1,
          'undefined': 'undefined'
        },
        __type__: {
          object: object$1
        }
      },
      __type__: {
        object: object$1
      }
    },
    __type__: {
      object: object$1
    }
  },
  legend: {
    enabled: {
      'boolean': bool$1
    },
    icons: {
      'boolean': bool$1
    },
    left: {
      visible: {
        'boolean': bool$1
      },
      position: {
        string: ['top-right', 'bottom-right', 'top-left', 'bottom-left']
      },
      __type__: {
        object: object$1
      }
    },
    right: {
      visible: {
        'boolean': bool$1
      },
      position: {
        string: ['top-right', 'bottom-right', 'top-left', 'bottom-left']
      },
      __type__: {
        object: object$1
      }
    },
    __type__: {
      object: object$1,
      'boolean': bool$1
    }
  },
  groups: {
    visibility: {
      any: any$1
    },
    __type__: {
      object: object$1
    }
  },
  autoResize: {
    'boolean': bool$1
  },
  throttleRedraw: {
    number: number$1
  },
  // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
  clickToUse: {
    'boolean': bool$1
  },
  end: {
    number: number$1,
    date: date$1,
    string: string$1,
    moment: moment$5
  },
  format: {
    minorLabels: {
      millisecond: {
        string: string$1,
        'undefined': 'undefined'
      },
      second: {
        string: string$1,
        'undefined': 'undefined'
      },
      minute: {
        string: string$1,
        'undefined': 'undefined'
      },
      hour: {
        string: string$1,
        'undefined': 'undefined'
      },
      weekday: {
        string: string$1,
        'undefined': 'undefined'
      },
      day: {
        string: string$1,
        'undefined': 'undefined'
      },
      month: {
        string: string$1,
        'undefined': 'undefined'
      },
      quarter: {
        string: string$1,
        'undefined': 'undefined'
      },
      year: {
        string: string$1,
        'undefined': 'undefined'
      },
      __type__: {
        object: object$1
      }
    },
    majorLabels: {
      millisecond: {
        string: string$1,
        'undefined': 'undefined'
      },
      second: {
        string: string$1,
        'undefined': 'undefined'
      },
      minute: {
        string: string$1,
        'undefined': 'undefined'
      },
      hour: {
        string: string$1,
        'undefined': 'undefined'
      },
      weekday: {
        string: string$1,
        'undefined': 'undefined'
      },
      day: {
        string: string$1,
        'undefined': 'undefined'
      },
      month: {
        string: string$1,
        'undefined': 'undefined'
      },
      quarter: {
        string: string$1,
        'undefined': 'undefined'
      },
      year: {
        string: string$1,
        'undefined': 'undefined'
      },
      __type__: {
        object: object$1
      }
    },
    __type__: {
      object: object$1
    }
  },
  moment: {
    'function': 'function'
  },
  height: {
    string: string$1,
    number: number$1
  },
  hiddenDates: {
    start: {
      date: date$1,
      number: number$1,
      string: string$1,
      moment: moment$5
    },
    end: {
      date: date$1,
      number: number$1,
      string: string$1,
      moment: moment$5
    },
    repeat: {
      string: string$1
    },
    __type__: {
      object: object$1,
      array: array$1
    }
  },
  locale: {
    string: string$1
  },
  locales: {
    __any__: {
      any: any$1
    },
    __type__: {
      object: object$1
    }
  },
  max: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$5
  },
  maxHeight: {
    number: number$1,
    string: string$1
  },
  maxMinorChars: {
    number: number$1
  },
  min: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$5
  },
  minHeight: {
    number: number$1,
    string: string$1
  },
  moveable: {
    'boolean': bool$1
  },
  multiselect: {
    'boolean': bool$1
  },
  orientation: {
    string: string$1
  },
  showCurrentTime: {
    'boolean': bool$1
  },
  showMajorLabels: {
    'boolean': bool$1
  },
  showMinorLabels: {
    'boolean': bool$1
  },
  start: {
    date: date$1,
    number: number$1,
    string: string$1,
    moment: moment$5
  },
  timeAxis: {
    scale: {
      string: string$1,
      'undefined': 'undefined'
    },
    step: {
      number: number$1,
      'undefined': 'undefined'
    },
    __type__: {
      object: object$1
    }
  },
  width: {
    string: string$1,
    number: number$1
  },
  zoomable: {
    'boolean': bool$1
  },
  zoomKey: {
    string: ['ctrlKey', 'altKey', 'metaKey', '']
  },
  zoomMax: {
    number: number$1
  },
  zoomMin: {
    number: number$1
  },
  zIndex: {
    number: number$1
  },
  __type__: {
    object: object$1
  }
};
var configureOptions$1 = {
  global: {
    alignCurrentTime: ['none', 'year', 'month', 'quarter', 'week', 'isoWeek', 'day', 'date', 'hour', 'minute', 'second'],
    //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
    sort: true,
    sampling: true,
    stack: false,
    shaded: {
      enabled: false,
      orientation: ['zero', 'top', 'bottom', 'group'] // zero, top, bottom

    },
    style: ['line', 'bar', 'points'],
    // line, bar
    barChart: {
      width: [50, 5, 100, 5],
      minWidth: [50, 5, 100, 5],
      sideBySide: false,
      align: ['left', 'center', 'right'] // left, center, right

    },
    interpolation: {
      enabled: true,
      parametrization: ['centripetal', 'chordal', 'uniform'] // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)

    },
    drawPoints: {
      enabled: true,
      size: [6, 2, 30, 1],
      style: ['square', 'circle'] // square, circle

    },
    dataAxis: {
      showMinorLabels: true,
      showMajorLabels: true,
      icons: false,
      width: [40, 0, 200, 1],
      visible: true,
      alignZeros: true,
      left: {
        //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
        //format: function (value) {return value;},
        title: {
          text: '',
          style: ''
        }
      },
      right: {
        //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
        //format: function (value) {return value;},
        title: {
          text: '',
          style: ''
        }
      }
    },
    legend: {
      enabled: false,
      icons: true,
      left: {
        visible: true,
        position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right

      },
      right: {
        visible: true,
        position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right

      }
    },
    autoResize: true,
    clickToUse: false,
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        month: 'MMM',
        quarter: '[Q]Q',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        month: 'YYYY',
        quarter: 'YYYY',
        year: ''
      }
    },
    height: '',
    locale: '',
    max: '',
    maxHeight: '',
    maxMinorChars: [7, 0, 20, 1],
    min: '',
    minHeight: '',
    moveable: true,
    orientation: ['both', 'bottom', 'top'],
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    start: '',
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1],
    zIndex: 0
  }
};
/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | Array} [items]
 * @param {vis.DataSet | Array | vis.DataView | Object} [groups]
 * @param {Object} [options]  See Graph2d.setOptions for the available options.
 * @constructor Graph2d
 * @extends Core
 */

function Graph2d(container, items, groups, options) {
  // if the third element is options, the forth is groups (optionally);
  if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView$2) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  } // TODO: REMOVE THIS in the next MAJOR release
  // see https://github.com/almende/vis/issues/2511


  if (options && options.throttleRedraw) {
    console.warn("Graph2d option \"throttleRedraw\" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.");
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,
    autoResize: true,
    orientation: {
      axis: 'bottom',
      // axis orientation: 'bottom', 'top', or 'both'
      item: 'bottom' // not relevant for Graph2d

    },
    moment: moment$3,
    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util$2.deepExtend({}, this.defaultOptions); // Create the DOM, props, and emitter

  this._create(container); // all components listed here will be repainted automatically


  this.components = [];
  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    hiddenDates: [],
    util: {
      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me),
      // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime: me._toGlobalTime.bind(me)
    }
  }; // range

  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range; // time axis

  this.timeAxis = new TimeAxis(this.body);
  this.components.push(this.timeAxis); //this.body.util.snap = this.timeAxis.snap.bind(this.timeAxis);
  // current time bar

  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime); // item set

  this.linegraph = new LineGraph(this.body);
  this.components.push(this.linegraph);
  this.itemsData = null; // DataSet

  this.groupsData = null; // DataSet

  this.on('tap', function (event) {
    me.emit('click', me.getEventProperties(event));
  });
  this.on('doubletap', function (event) {
    me.emit('doubleClick', me.getEventProperties(event));
  });

  this.dom.root.oncontextmenu = function (event) {
    me.emit('contextmenu', me.getEventProperties(event));
  }; //Single time autoscale/fit


  this.initialFitDone = false;
  this.on('changed', function () {
    if (me.itemsData == null) return;

    if (!me.initialFitDone && !me.options.rollingMode) {
      me.initialFitDone = true;

      if (me.options.start != undefined || me.options.end != undefined) {
        if (me.options.start == undefined || me.options.end == undefined) {
          var range = me.getItemRange();
        }

        var start = me.options.start != undefined ? me.options.start : range.min;
        var end = me.options.end != undefined ? me.options.end : range.max;
        me.setWindow(start, end, {
          animation: false
        });
      } else {
        me.fit({
          animation: false
        });
      }
    }

    if (!me.initialDrawDone && (me.initialRangeChangeDone || !me.options.start && !me.options.end || me.options.rollingMode)) {
      me.initialDrawDone = true;
      me.dom.root.style.visibility = 'visible';
      me.dom.loadingScreen.parentNode.removeChild(me.dom.loadingScreen);

      if (me.options.onInitialDrawComplete) {
        setTimeout(function () {
          return me.options.onInitialDrawComplete();
        }, 0);
      }
    }
  }); // apply options

  if (options) {
    this.setOptions(options);
  } // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!


  if (groups) {
    this.setGroups(groups);
  } // create itemset


  if (items) {
    this.setItems(items);
  } // draw for the first time


  this._redraw();
} // Extend the functionality from Core


Graph2d.prototype = new Core();

Graph2d.prototype.setOptions = function (options) {
  // validate options
  var errorFound = Validator.validate(options, allOptions$2);

  if (errorFound === true) {
    console.log('%cErrors have been found in the supplied options object.', printStyle);
  }

  Core.prototype.setOptions.call(this, options);
};
/**
 * Set items
 * @param {vis.DataSet | Array | null} items
 */


Graph2d.prototype.setItems = function (items) {
  var initialLoad = this.itemsData == null; // convert to type DataSet when needed

  var newDataSet;

  if (!items) {
    newDataSet = null;
  } else if (items instanceof DataSet || items instanceof DataView$2) {
    newDataSet = items;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  } // set items


  this.itemsData = newDataSet;
  this.linegraph && this.linegraph.setItems(newDataSet);

  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      var start = this.options.start != undefined ? this.options.start : null;
      var end = this.options.end != undefined ? this.options.end : null;
      this.setWindow(start, end, {
        animation: false
      });
    } else {
      this.fit({
        animation: false
      });
    }
  }
};
/**
 * Set groups
 * @param {vis.DataSet | Array} groups
 */


Graph2d.prototype.setGroups = function (groups) {
  // convert to type DataSet when needed
  var newDataSet;

  if (!groups) {
    newDataSet = null;
  } else if (groups instanceof DataSet || groups instanceof DataView$2) {
    newDataSet = groups;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.linegraph.setGroups(newDataSet);
};
/**
 * Returns an object containing an SVG element with the icon of the group (size determined by iconWidth and iconHeight), the label of the group (content) and the yAxisOrientation of the group (left or right).
 * @param {vis.GraphGroup.id} groupId
 * @param {number} width
 * @param {number} height
 * @returns {{icon: SVGElement, label: string, orientation: string}|string}
 */


Graph2d.prototype.getLegend = function (groupId, width, height) {
  if (width === undefined) {
    width = 15;
  }

  if (height === undefined) {
    height = 15;
  }

  if (this.linegraph.groups[groupId] !== undefined) {
    return this.linegraph.groups[groupId].getLegend(width, height);
  } else {
    return "cannot find group:'" + groupId + "'";
  }
};
/**
 * This checks if the visible option of the supplied group (by ID) is true or false.
 * @param {vis.GraphGroup.id} groupId
 * @returns {boolean}
 */


Graph2d.prototype.isGroupVisible = function (groupId) {
  if (this.linegraph.groups[groupId] !== undefined) {
    return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === undefined || this.linegraph.options.groups.visibility[groupId] == true);
  } else {
    return false;
  }
};
/**
 * Get the data range of the item set.
 * @returns {{min: Date, max: Date}} range  A range with a start and end Date.
 *                                          When no minimum is found, min==null
 *                                          When no maximum is found, max==null
 */


Graph2d.prototype.getDataRange = function () {
  var min = null;
  var max = null; // calculate min from start filed

  for (var groupId in this.linegraph.groups) {
    if (this.linegraph.groups.hasOwnProperty(groupId)) {
      if (this.linegraph.groups[groupId].visible == true) {
        for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
          var item = this.linegraph.groups[groupId].itemsData[i];
          var value = util$2.convert(item.x, 'Date').valueOf();
          min = min == null ? value : min > value ? value : min;
          max = max == null ? value : max < value ? value : max;
        }
      }
    }
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};
/**
 * Generate Timeline related information from an event
 * @param {Event} event
 * @return {Object} An object with related information, like on which area
 *                  The event happened, whether clicked on an item, etc.
 */


Graph2d.prototype.getEventProperties = function (event) {
  var clientX = event.center ? event.center.x : event.clientX;
  var clientY = event.center ? event.center.y : event.clientY;
  var x = clientX - util$2.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - util$2.getAbsoluteTop(this.dom.centerContainer);

  var time = this._toTime(x);

  var customTime = CustomTime.customTimeFromTarget(event);
  var element = util$2.getTarget(event);
  var what = null;

  if (util$2.hasParent(element, this.timeAxis.dom.foreground)) {
    what = 'axis';
  } else if (this.timeAxis2 && util$2.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = 'axis';
  } else if (util$2.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
    what = 'data-axis';
  } else if (util$2.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
    what = 'data-axis';
  } else if (util$2.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
    what = 'legend';
  } else if (util$2.hasParent(element, this.linegraph.legendRight.dom.frame)) {
    what = 'legend';
  } else if (customTime != null) {
    what = 'custom-time';
  } else if (util$2.hasParent(element, this.currentTime.bar)) {
    what = 'current-time';
  } else if (util$2.hasParent(element, this.dom.center)) {
    what = 'background';
  }

  var value = [];
  var yAxisLeft = this.linegraph.yAxisLeft;
  var yAxisRight = this.linegraph.yAxisRight;

  if (!yAxisLeft.hidden && this.itemsData.length > 0) {
    value.push(yAxisLeft.screenToValue(y));
  }

  if (!yAxisRight.hidden && this.itemsData.length > 0) {
    value.push(yAxisRight.screenToValue(y));
  }

  return {
    event: event,
    customTime: customTime ? customTime.options.id : null,
    what: what,
    pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
    pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
    x: x,
    y: y,
    time: time,
    value: value
  };
};
/**
 * Load a configurator
 * @return {Object}
 * @private
 */


Graph2d.prototype._createConfigurator = function () {
  return new Configurator(this, this.dom.container, configureOptions$1);
}; // utils


var defaultLanguage = getNavigatorLanguage();
moment$3.locale(defaultLanguage);
var timeline = {
  Core: Core,
  DateUtil: DateUtil,
  Range: Range,
  stack: stack$1,
  TimeStep: TimeStep,
  components: {
    items: {
      Item: Item,
      BackgroundItem: BackgroundItem,
      BoxItem: BoxItem,
      PointItem: PointItem,
      RangeItem: RangeItem
    },
    BackgroundGroup: BackgroundGroup,
    Component: Component,
    CurrentTime: CurrentTime,
    CustomTime: CustomTime,
    DataAxis: DataAxis,
    DataScale: DataScale,
    GraphGroup: GraphGroup,
    Group: Group,
    ItemSet: ItemSet,
    Legend: Legend,
    LineGraph: LineGraph,
    TimeAxis: TimeAxis
  }
};
exports.timeline = timeline;
var index$1 = {
  util: util,
  DOMutil: DOMutil,
  DataSet: DataSet,
  DataView: DataView$2,
  Queue: Queue,
  Timeline: Timeline,
  Graph2d: Graph2d,
  timeline: timeline,
  moment: moment$3,
  Hammer: Hammer$1,
  keycharm: keycharm
};
var _default = index$1;
exports.default = _default;
},{}],"CvJj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __exportStar(m, exports) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
},{}],"urBN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = isFunction;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
  return typeof x === 'function';
}
},{}],"Jhcl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: undefined,

  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error =
      /*@__PURE__*/
      new Error();
      /*@__PURE__*/

      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      /*@__PURE__*/
      console.log('RxJS: Back to a better error behavior. Thank you. <3');
    }

    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },

  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }

};
exports.config = config;
},{}],"KN9L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hostReportError = hostReportError;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
  setTimeout(function () {
    throw err;
  }, 0);
}
},{}],"NxTO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = void 0;

var _config = require("./config");

var _hostReportError = require("./util/hostReportError");

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
  closed: true,
  next: function (value) {},
  error: function (err) {
    if (_config.config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      (0, _hostReportError.hostReportError)(err);
    }
  },
  complete: function () {}
};
exports.empty = empty;
},{"./config":"Jhcl","./util/hostReportError":"KN9L"}],"hGKc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArray = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray =
/*@__PURE__*/
function () {
  return Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };
}();

exports.isArray = isArray;
},{}],"g8CQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObject = isObject;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
  return x !== null && typeof x === 'object';
}
},{}],"J94B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnsubscriptionError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl =
/*@__PURE__*/
function () {
  function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
  }

  UnsubscriptionErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return UnsubscriptionErrorImpl;
}();

var UnsubscriptionError = UnsubscriptionErrorImpl;
exports.UnsubscriptionError = UnsubscriptionError;
},{}],"kylD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subscription = void 0;

var _isArray = require("./util/isArray");

var _isObject = require("./util/isObject");

var _isFunction = require("./util/isFunction");

var _UnsubscriptionError = require("./util/UnsubscriptionError");

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription =
/*@__PURE__*/
function () {
  function Subscription(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (unsubscribe) {
      this._unsubscribe = unsubscribe;
    }
  }

  Subscription.prototype.unsubscribe = function () {
    var errors;

    if (this.closed) {
      return;
    }

    var _a = this,
        _parentOrParents = _a._parentOrParents,
        _unsubscribe = _a._unsubscribe,
        _subscriptions = _a._subscriptions;

    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (_parentOrParents instanceof Subscription) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }

    if ((0, _isFunction.isFunction)(_unsubscribe)) {
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof _UnsubscriptionError.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }

    if ((0, _isArray.isArray)(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;

      while (++index < len) {
        var sub = _subscriptions[index];

        if ((0, _isObject.isObject)(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];

            if (e instanceof _UnsubscriptionError.UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }

    if (errors) {
      throw new _UnsubscriptionError.UnsubscriptionError(errors);
    }
  };

  Subscription.prototype.add = function (teardown) {
    var subscription = teardown;

    if (!teardown) {
      return Subscription.EMPTY;
    }

    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);

      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription)) {
          var tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }

        break;

      default:
        {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
    }

    var _parentOrParents = subscription._parentOrParents;

    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription) {
      if (_parentOrParents === this) {
        return subscription;
      }

      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }

    var subscriptions = this._subscriptions;

    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }

    return subscription;
  };

  Subscription.prototype.remove = function (subscription) {
    var subscriptions = this._subscriptions;

    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);

      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };

  Subscription.EMPTY = function (empty) {
    empty.closed = true;
    return empty;
  }(new Subscription());

  return Subscription;
}();

exports.Subscription = Subscription;

function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function (errs, err) {
    return errs.concat(err instanceof _UnsubscriptionError.UnsubscriptionError ? err.errors : err);
  }, []);
}
},{"./util/isArray":"hGKc","./util/isObject":"g8CQ","./util/isFunction":"urBN","./util/UnsubscriptionError":"J94B"}],"p0lr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.$$rxSubscriber = exports.rxSubscriber = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber =
/*@__PURE__*/
function () {
  return typeof Symbol === 'function' ?
  /*@__PURE__*/
  Symbol('rxSubscriber') : '@@rxSubscriber_' +
  /*@__PURE__*/
  Math.random();
}();

exports.rxSubscriber = rxSubscriber;
var $$rxSubscriber = rxSubscriber;
exports.$$rxSubscriber = $$rxSubscriber;
},{}],"Cb5c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SafeSubscriber = exports.Subscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isFunction = require("./util/isFunction");

var _Observer = require("./Observer");

var _Subscription = require("./Subscription");

var _rxSubscriber = require("../internal/symbol/rxSubscriber");

var _config = require("./config");

var _hostReportError = require("./util/hostReportError");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Subscriber, _super);

  function Subscriber(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;

    switch (arguments.length) {
      case 0:
        _this.destination = _Observer.empty;
        break;

      case 1:
        if (!destinationOrNext) {
          _this.destination = _Observer.empty;
          break;
        }

        if (typeof destinationOrNext === 'object') {
          if (destinationOrNext instanceof Subscriber) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }

          break;
        }

      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }

    return _this;
  }

  Subscriber.prototype[_rxSubscriber.rxSubscriber] = function () {
    return this;
  };

  Subscriber.create = function (next, error, complete) {
    var subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };

  Subscriber.prototype.next = function (value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };

  Subscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      this.isStopped = true;

      this._error(err);
    }
  };

  Subscriber.prototype.complete = function () {
    if (!this.isStopped) {
      this.isStopped = true;

      this._complete();
    }
  };

  Subscriber.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.isStopped = true;

    _super.prototype.unsubscribe.call(this);
  };

  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };

  Subscriber.prototype._error = function (err) {
    this.destination.error(err);
    this.unsubscribe();
  };

  Subscriber.prototype._complete = function () {
    this.destination.complete();
    this.unsubscribe();
  };

  Subscriber.prototype._unsubscribeAndRecycle = function () {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };

  return Subscriber;
}(_Subscription.Subscription);

exports.Subscriber = Subscriber;

var SafeSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SafeSubscriber, _super);

  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;

    if ((0, _isFunction.isFunction)(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;

      if (observerOrNext !== _Observer.empty) {
        context = Object.create(observerOrNext);

        if ((0, _isFunction.isFunction)(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }

        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }

    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }

  SafeSubscriber.prototype.next = function (value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;

      if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = _config.config.useDeprecatedSynchronousErrorHandling;

      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);

          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();

        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }

        (0, _hostReportError.hostReportError)(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          (0, _hostReportError.hostReportError)(err);
        }

        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.complete = function () {
    var _this = this;

    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;

      if (this._complete) {
        var wrappedComplete = function () {
          return _this._complete.call(_this._context);
        };

        if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);

          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();

      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        (0, _hostReportError.hostReportError)(err);
      }
    }
  };

  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
    if (!_config.config.useDeprecatedSynchronousErrorHandling) {
      throw new Error('bad call');
    }

    try {
      fn.call(this._context, value);
    } catch (err) {
      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        (0, _hostReportError.hostReportError)(err);
        return true;
      }
    }

    return false;
  };

  SafeSubscriber.prototype._unsubscribe = function () {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;

    _parentSubscriber.unsubscribe();
  };

  return SafeSubscriber;
}(Subscriber);

exports.SafeSubscriber = SafeSubscriber;
},{"tslib":"CvJj","./util/isFunction":"urBN","./Observer":"NxTO","./Subscription":"kylD","../internal/symbol/rxSubscriber":"p0lr","./config":"Jhcl","./util/hostReportError":"KN9L"}],"yrZ0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canReportError = canReportError;

var _Subscriber = require("../Subscriber");

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
  while (observer) {
    var _a = observer,
        closed_1 = _a.closed,
        destination = _a.destination,
        isStopped = _a.isStopped;

    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof _Subscriber.Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }

  return true;
}
},{"../Subscriber":"Cb5c"}],"McCe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSubscriber = toSubscriber;

var _Subscriber = require("../Subscriber");

var _rxSubscriber = require("../symbol/rxSubscriber");

var _Observer = require("../Observer");

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof _Subscriber.Subscriber) {
      return nextOrObserver;
    }

    if (nextOrObserver[_rxSubscriber.rxSubscriber]) {
      return nextOrObserver[_rxSubscriber.rxSubscriber]();
    }
  }

  if (!nextOrObserver && !error && !complete) {
    return new _Subscriber.Subscriber(_Observer.empty);
  }

  return new _Subscriber.Subscriber(nextOrObserver, error, complete);
}
},{"../Subscriber":"Cb5c","../symbol/rxSubscriber":"p0lr","../Observer":"NxTO"}],"ufLg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observable = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable =
/*@__PURE__*/
function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();

exports.observable = observable;
},{}],"Kkj8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noop = noop;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() {}
},{}],"RKca":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pipe = pipe;
exports.pipeFromArray = pipeFromArray;

var _noop = require("./noop");

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipe() {
  var fns = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }

  return pipeFromArray(fns);
}

function pipeFromArray(fns) {
  if (!fns) {
    return _noop.noop;
  }

  if (fns.length === 1) {
    return fns[0];
  }

  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
},{"./noop":"Kkj8"}],"eNLs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

var _canReportError = require("./util/canReportError");

var _toSubscriber = require("./util/toSubscriber");

var _observable = require("./symbol/observable");

var _pipe = require("./util/pipe");

var _config = require("./config");

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable =
/*@__PURE__*/
function () {
  function Observable(subscribe) {
    this._isScalar = false;

    if (subscribe) {
      this._subscribe = subscribe;
    }
  }

  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };

  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = (0, _toSubscriber.toSubscriber)(observerOrNext, error, complete);

    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || _config.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }

    if (_config.config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;

        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }

    return sink;
  };

  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (_config.config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }

      if ((0, _canReportError.canReportError)(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };

  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function (value) {
        try {
          next(value);
        } catch (err) {
          reject(err);

          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };

  Observable.prototype._subscribe = function (subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };

  Observable.prototype[_observable.observable] = function () {
    return this;
  };

  Observable.prototype.pipe = function () {
    var operations = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }

    if (operations.length === 0) {
      return this;
    }

    return (0, _pipe.pipeFromArray)(operations)(this);
  };

  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;

      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };

  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };

  return Observable;
}();

exports.Observable = Observable;

function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = _config.config.Promise || Promise;
  }

  if (!promiseCtor) {
    throw new Error('no Promise impl found');
  }

  return promiseCtor;
}
},{"./util/canReportError":"yrZ0","./util/toSubscriber":"McCe","./symbol/observable":"ufLg","./util/pipe":"RKca","./config":"Jhcl"}],"aESt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectUnsubscribedError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl =
/*@__PURE__*/
function () {
  function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
  }

  ObjectUnsubscribedErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl;
}();

var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
},{}],"D3Ra":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubjectSubscription = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("./Subscription");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubjectSubscription, _super);

  function SubjectSubscription(subject, subscriber) {
    var _this = _super.call(this) || this;

    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }

  SubjectSubscription.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;

    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }

    var subscriberIndex = observers.indexOf(this.subscriber);

    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };

  return SubjectSubscription;
}(_Subscription.Subscription);

exports.SubjectSubscription = SubjectSubscription;
},{"tslib":"CvJj","./Subscription":"kylD"}],"ChYR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnonymousSubject = exports.Subject = exports.SubjectSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Observable = require("./Observable");

var _Subscriber = require("./Subscriber");

var _Subscription = require("./Subscription");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

var _SubjectSubscription = require("./SubjectSubscription");

var _rxSubscriber = require("../internal/symbol/rxSubscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(SubjectSubscriber, _super);

  function SubjectSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    return _this;
  }

  return SubjectSubscriber;
}(_Subscriber.Subscriber);

exports.SubjectSubscriber = SubjectSubscriber;

var Subject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Subject, _super);

  function Subject() {
    var _this = _super.call(this) || this;

    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }

  Subject.prototype[_rxSubscriber.rxSubscriber] = function () {
    return new SubjectSubscriber(this);
  };

  Subject.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };

  Subject.prototype.next = function (value) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();

      for (var i = 0; i < len; i++) {
        copy[i].next(value);
      }
    }
  };

  Subject.prototype.error = function (err) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].error(err);
    }

    this.observers.length = 0;
  };

  Subject.prototype.complete = function () {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    }

    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].complete();
    }

    this.observers.length = 0;
  };

  Subject.prototype.unsubscribe = function () {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };

  Subject.prototype._trySubscribe = function (subscriber) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };

  Subject.prototype._subscribe = function (subscriber) {
    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription.Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return _Subscription.Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new _SubjectSubscription.SubjectSubscription(this, subscriber);
    }
  };

  Subject.prototype.asObservable = function () {
    var observable = new _Observable.Observable();
    observable.source = this;
    return observable;
  };

  Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };

  return Subject;
}(_Observable.Observable);

exports.Subject = Subject;

var AnonymousSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnonymousSubject, _super);

  function AnonymousSubject(destination, source) {
    var _this = _super.call(this) || this;

    _this.destination = destination;
    _this.source = source;
    return _this;
  }

  AnonymousSubject.prototype.next = function (value) {
    var destination = this.destination;

    if (destination && destination.next) {
      destination.next(value);
    }
  };

  AnonymousSubject.prototype.error = function (err) {
    var destination = this.destination;

    if (destination && destination.error) {
      this.destination.error(err);
    }
  };

  AnonymousSubject.prototype.complete = function () {
    var destination = this.destination;

    if (destination && destination.complete) {
      this.destination.complete();
    }
  };

  AnonymousSubject.prototype._subscribe = function (subscriber) {
    var source = this.source;

    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return _Subscription.Subscription.EMPTY;
    }
  };

  return AnonymousSubject;
}(Subject);

exports.AnonymousSubject = AnonymousSubject;
},{"tslib":"CvJj","./Observable":"eNLs","./Subscriber":"Cb5c","./Subscription":"kylD","./util/ObjectUnsubscribedError":"aESt","./SubjectSubscription":"D3Ra","../internal/symbol/rxSubscriber":"p0lr"}],"npbM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refCount = refCount;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}

var RefCountOperator =
/*@__PURE__*/
function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}();

var RefCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"CvJj","../Subscriber":"Cb5c"}],"CWP9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectableObservableDescriptor = exports.ConnectableObservable = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("../Subject");

var _Observable = require("../Observable");

var _Subscriber = require("../Subscriber");

var _Subscription = require("../Subscription");

var _refCount = require("../operators/refCount");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ConnectableObservable, _super);

  function ConnectableObservable(source, subjectFactory) {
    var _this = _super.call(this) || this;

    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }

  ConnectableObservable.prototype._subscribe = function (subscriber) {
    return this.getSubject().subscribe(subscriber);
  };

  ConnectableObservable.prototype.getSubject = function () {
    var subject = this._subject;

    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }

    return this._subject;
  };

  ConnectableObservable.prototype.connect = function () {
    var connection = this._connection;

    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new _Subscription.Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

      if (connection.closed) {
        this._connection = null;
        connection = _Subscription.Subscription.EMPTY;
      }
    }

    return connection;
  };

  ConnectableObservable.prototype.refCount = function () {
    return (0, _refCount.refCount)()(this);
  };

  return ConnectableObservable;
}(_Observable.Observable);

exports.ConnectableObservable = ConnectableObservable;

var connectableObservableDescriptor =
/*@__PURE__*/
function () {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: {
      value: null
    },
    _refCount: {
      value: 0,
      writable: true
    },
    _subject: {
      value: null,
      writable: true
    },
    _connection: {
      value: null,
      writable: true
    },
    _subscribe: {
      value: connectableProto._subscribe
    },
    _isComplete: {
      value: connectableProto._isComplete,
      writable: true
    },
    getSubject: {
      value: connectableProto.getSubject
    },
    connect: {
      value: connectableProto.connect
    },
    refCount: {
      value: connectableProto.refCount
    }
  };
}();

exports.connectableObservableDescriptor = connectableObservableDescriptor;

var ConnectableSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ConnectableSubscriber, _super);

  function ConnectableSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  ConnectableSubscriber.prototype._error = function (err) {
    this._unsubscribe();

    _super.prototype._error.call(this, err);
  };

  ConnectableSubscriber.prototype._complete = function () {
    this.connectable._isComplete = true;

    this._unsubscribe();

    _super.prototype._complete.call(this);
  };

  ConnectableSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;

      if (connection) {
        connection.unsubscribe();
      }
    }
  };

  return ConnectableSubscriber;
}(_Subject.SubjectSubscriber);

var RefCountOperator =
/*@__PURE__*/
function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}();

var RefCountSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"CvJj","../Subject":"ChYR","../Observable":"eNLs","../Subscriber":"Cb5c","../Subscription":"kylD","../operators/refCount":"npbM"}],"NOba":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.groupBy = groupBy;
exports.GroupedObservable = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Subscription = require("../Subscription");

var _Observable = require("../Observable");

var _Subject = require("../Subject");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function (source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}

var GroupByOperator =
/*@__PURE__*/
function () {
  function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }

  GroupByOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };

  return GroupByOperator;
}();

var GroupBySubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupBySubscriber, _super);

  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;

    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }

  GroupBySubscriber.prototype._next = function (value) {
    var key;

    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }

    this._group(value, key);
  };

  GroupBySubscriber.prototype._group = function (value, key) {
    var groups = this.groups;

    if (!groups) {
      groups = this.groups = new Map();
    }

    var group = groups.get(key);
    var element;

    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }

    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new _Subject.Subject();
      groups.set(key, group);
      var groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);

      if (this.durationSelector) {
        var duration = void 0;

        try {
          duration = this.durationSelector(new GroupedObservable(key, group));
        } catch (err) {
          this.error(err);
          return;
        }

        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      }
    }

    if (!group.closed) {
      group.next(element);
    }
  };

  GroupBySubscriber.prototype._error = function (err) {
    var groups = this.groups;

    if (groups) {
      groups.forEach(function (group, key) {
        group.error(err);
      });
      groups.clear();
    }

    this.destination.error(err);
  };

  GroupBySubscriber.prototype._complete = function () {
    var groups = this.groups;

    if (groups) {
      groups.forEach(function (group, key) {
        group.complete();
      });
      groups.clear();
    }

    this.destination.complete();
  };

  GroupBySubscriber.prototype.removeGroup = function (key) {
    this.groups.delete(key);
  };

  GroupBySubscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;

      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };

  return GroupBySubscriber;
}(_Subscriber.Subscriber);

var GroupDurationSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupDurationSubscriber, _super);

  function GroupDurationSubscriber(key, group, parent) {
    var _this = _super.call(this, group) || this;

    _this.key = key;
    _this.group = group;
    _this.parent = parent;
    return _this;
  }

  GroupDurationSubscriber.prototype._next = function (value) {
    this.complete();
  };

  GroupDurationSubscriber.prototype._unsubscribe = function () {
    var _a = this,
        parent = _a.parent,
        key = _a.key;

    this.key = this.parent = null;

    if (parent) {
      parent.removeGroup(key);
    }
  };

  return GroupDurationSubscriber;
}(_Subscriber.Subscriber);

var GroupedObservable =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(GroupedObservable, _super);

  function GroupedObservable(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;

    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }

  GroupedObservable.prototype._subscribe = function (subscriber) {
    var subscription = new _Subscription.Subscription();

    var _a = this,
        refCountSubscription = _a.refCountSubscription,
        groupSubject = _a.groupSubject;

    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }

    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };

  return GroupedObservable;
}(_Observable.Observable);

exports.GroupedObservable = GroupedObservable;

var InnerRefCountSubscription =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(InnerRefCountSubscription, _super);

  function InnerRefCountSubscription(parent) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    parent.count++;
    return _this;
  }

  InnerRefCountSubscription.prototype.unsubscribe = function () {
    var parent = this.parent;

    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);

      parent.count -= 1;

      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };

  return InnerRefCountSubscription;
}(_Subscription.Subscription);
},{"tslib":"CvJj","../Subscriber":"Cb5c","../Subscription":"kylD","../Observable":"eNLs","../Subject":"ChYR"}],"vz6i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BehaviorSubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(BehaviorSubject, _super);

  function BehaviorSubject(_value) {
    var _this = _super.call(this) || this;

    _this._value = _value;
    return _this;
  }

  Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function () {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });

  BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);

    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }

    return subscription;
  };

  BehaviorSubject.prototype.getValue = function () {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };

  BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
  };

  return BehaviorSubject;
}(_Subject.Subject);

exports.BehaviorSubject = BehaviorSubject;
},{"tslib":"CvJj","./Subject":"ChYR","./util/ObjectUnsubscribedError":"aESt"}],"lXyf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Action = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscription = require("../Subscription");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(Action, _super);

  function Action(scheduler, work) {
    return _super.call(this) || this;
  }

  Action.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return this;
  };

  return Action;
}(_Subscription.Subscription);

exports.Action = Action;
},{"tslib":"CvJj","../Subscription":"kylD"}],"EYeg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Action = require("./Action");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncAction, _super);

  function AsyncAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }

  AsyncAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (this.closed) {
      return this;
    }

    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }

    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };

  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };

  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }

    clearInterval(id);
    return undefined;
  };

  AsyncAction.prototype.execute = function (state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }

    this.pending = false;

    var error = this._execute(state, delay);

    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };

  AsyncAction.prototype._execute = function (state, delay) {
    var errored = false;
    var errorValue = undefined;

    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }

    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };

  AsyncAction.prototype._unsubscribe = function () {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;

    if (index !== -1) {
      actions.splice(index, 1);
    }

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }

    this.delay = null;
  };

  return AsyncAction;
}(_Action.Action);

exports.AsyncAction = AsyncAction;
},{"tslib":"CvJj","./Action":"lXyf"}],"IzYe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueueAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(QueueAction, _super);

  function QueueAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  QueueAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay > 0) {
      return _super.prototype.schedule.call(this, state, delay);
    }

    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };

  QueueAction.prototype.execute = function (state, delay) {
    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
  };

  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    return scheduler.flush(this);
  };

  return QueueAction;
}(_AsyncAction.AsyncAction);

exports.QueueAction = QueueAction;
},{"tslib":"CvJj","./AsyncAction":"EYeg"}],"PEqa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;

var Scheduler =
/*@__PURE__*/
function () {
  function Scheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }

    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }

  Scheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    return new this.SchedulerAction(this, work).schedule(state, delay);
  };

  Scheduler.now = function () {
    return Date.now();
  };

  return Scheduler;
}();

exports.Scheduler = Scheduler;
},{}],"oQUP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Scheduler = require("../Scheduler");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncScheduler, _super);

  function AsyncScheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = _Scheduler.Scheduler.now;
    }

    var _this = _super.call(this, SchedulerAction, function () {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    }) || this;

    _this.actions = [];
    _this.active = false;
    _this.scheduled = undefined;
    return _this;
  }

  AsyncScheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state);
    }
  };

  AsyncScheduler.prototype.flush = function (action) {
    var actions = this.actions;

    if (this.active) {
      actions.push(action);
      return;
    }

    var error;
    this.active = true;

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());

    this.active = false;

    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsyncScheduler;
}(_Scheduler.Scheduler);

exports.AsyncScheduler = AsyncScheduler;
},{"tslib":"CvJj","../Scheduler":"PEqa"}],"veRg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueueScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(QueueScheduler, _super);

  function QueueScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return QueueScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.QueueScheduler = QueueScheduler;
},{"tslib":"CvJj","./AsyncScheduler":"oQUP"}],"LwhG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queue = void 0;

var _QueueAction = require("./QueueAction");

var _QueueScheduler = require("./QueueScheduler");

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue =
/*@__PURE__*/
new _QueueScheduler.QueueScheduler(_QueueAction.QueueAction);
exports.queue = queue;
},{"./QueueAction":"IzYe","./QueueScheduler":"veRg"}],"yJHz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = empty;
exports.EMPTY = void 0;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY =
/*@__PURE__*/
new _Observable.Observable(function (subscriber) {
  return subscriber.complete();
});
exports.EMPTY = EMPTY;

function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}

function emptyScheduled(scheduler) {
  return new _Observable.Observable(function (subscriber) {
    return scheduler.schedule(function () {
      return subscriber.complete();
    });
  });
}
},{"../Observable":"eNLs"}],"kChJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isScheduler = isScheduler;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
  return value && typeof value.schedule === 'function';
}
},{}],"w1m3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToArray = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
  return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }

    subscriber.complete();
  };
};

exports.subscribeToArray = subscribeToArray;
},{}],"LzTI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleArray = scheduleArray;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function scheduleArray(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    var i = 0;
    sub.add(scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
        return;
      }

      subscriber.next(input[i++]);

      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
},{"../Observable":"eNLs","../Subscription":"kylD"}],"H2SB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromArray = fromArray;

var _Observable = require("../Observable");

var _subscribeToArray = require("../util/subscribeToArray");

var _scheduleArray = require("../scheduled/scheduleArray");

/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable((0, _subscribeToArray.subscribeToArray)(input));
  } else {
    return (0, _scheduleArray.scheduleArray)(input, scheduler);
  }
}
},{"../Observable":"eNLs","../util/subscribeToArray":"w1m3","../scheduled/scheduleArray":"LzTI"}],"ejbS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.of = of;

var _isScheduler = require("../util/isScheduler");

var _fromArray = require("./fromArray");

var _scheduleArray = require("../scheduled/scheduleArray");

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function of() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var scheduler = args[args.length - 1];

  if ((0, _isScheduler.isScheduler)(scheduler)) {
    args.pop();
    return (0, _scheduleArray.scheduleArray)(args, scheduler);
  } else {
    return (0, _fromArray.fromArray)(args);
  }
}
},{"../util/isScheduler":"kChJ","./fromArray":"H2SB","../scheduled/scheduleArray":"LzTI"}],"PeYS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throwError = throwError;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable(function (subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new _Observable.Observable(function (subscriber) {
      return scheduler.schedule(dispatch, 0, {
        error: error,
        subscriber: subscriber
      });
    });
  }
}

function dispatch(_a) {
  var error = _a.error,
      subscriber = _a.subscriber;
  subscriber.error(error);
}
},{"../Observable":"eNLs"}],"Yyds":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Notification = exports.NotificationKind = void 0;

var _empty = require("./observable/empty");

var _of = require("./observable/of");

var _throwError = require("./observable/throwError");

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var NotificationKind;
/*@__PURE__*/

exports.NotificationKind = NotificationKind;

(function (NotificationKind) {
  NotificationKind["NEXT"] = "N";
  NotificationKind["ERROR"] = "E";
  NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (exports.NotificationKind = NotificationKind = {}));

var Notification =
/*@__PURE__*/
function () {
  function Notification(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }

  Notification.prototype.observe = function (observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);

      case 'E':
        return observer.error && observer.error(this.error);

      case 'C':
        return observer.complete && observer.complete();
    }
  };

  Notification.prototype.do = function (next, error, complete) {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return next && next(this.value);

      case 'E':
        return error && error(this.error);

      case 'C':
        return complete && complete();
    }
  };

  Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };

  Notification.prototype.toObservable = function () {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return (0, _of.of)(this.value);

      case 'E':
        return (0, _throwError.throwError)(this.error);

      case 'C':
        return (0, _empty.empty)();
    }

    throw new Error('unexpected notification kind value');
  };

  Notification.createNext = function (value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }

    return Notification.undefinedValueNotification;
  };

  Notification.createError = function (err) {
    return new Notification('E', undefined, err);
  };

  Notification.createComplete = function () {
    return Notification.completeNotification;
  };

  Notification.completeNotification = new Notification('C');
  Notification.undefinedValueNotification = new Notification('N', undefined);
  return Notification;
}();

exports.Notification = Notification;
},{"./observable/empty":"yJHz","./observable/of":"ejbS","./observable/throwError":"PeYS"}],"f5HV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeOn = observeOn;
exports.ObserveOnMessage = exports.ObserveOnSubscriber = exports.ObserveOnOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

var _Notification = require("../Notification");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}

var ObserveOnOperator =
/*@__PURE__*/
function () {
  function ObserveOnOperator(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.scheduler = scheduler;
    this.delay = delay;
  }

  ObserveOnOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };

  return ObserveOnOperator;
}();

exports.ObserveOnOperator = ObserveOnOperator;

var ObserveOnSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ObserveOnSubscriber, _super);

  function ObserveOnSubscriber(destination, scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    var _this = _super.call(this, destination) || this;

    _this.scheduler = scheduler;
    _this.delay = delay;
    return _this;
  }

  ObserveOnSubscriber.dispatch = function (arg) {
    var notification = arg.notification,
        destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };

  ObserveOnSubscriber.prototype._next = function (value) {
    this.scheduleMessage(_Notification.Notification.createNext(value));
  };

  ObserveOnSubscriber.prototype._error = function (err) {
    this.scheduleMessage(_Notification.Notification.createError(err));
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype._complete = function () {
    this.scheduleMessage(_Notification.Notification.createComplete());
    this.unsubscribe();
  };

  return ObserveOnSubscriber;
}(_Subscriber.Subscriber);

exports.ObserveOnSubscriber = ObserveOnSubscriber;

var ObserveOnMessage =
/*@__PURE__*/
function () {
  function ObserveOnMessage(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }

  return ObserveOnMessage;
}();

exports.ObserveOnMessage = ObserveOnMessage;
},{"tslib":"CvJj","../Subscriber":"Cb5c","../Notification":"Yyds"}],"fnPk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplaySubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _queue = require("./scheduler/queue");

var _Subscription = require("./Subscription");

var _observeOn = require("./operators/observeOn");

var _ObjectUnsubscribedError = require("./util/ObjectUnsubscribedError");

var _SubjectSubscription = require("./SubjectSubscription");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ReplaySubject, _super);

  function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }

    if (windowTime === void 0) {
      windowTime = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this) || this;

    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime < 1 ? 1 : windowTime;

    if (windowTime === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }

    return _this;
  }

  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
    var _events = this._events;

    _events.push(value);

    if (_events.length > this._bufferSize) {
      _events.shift();
    }

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype.nextTimeWindow = function (value) {
    this._events.push(new ReplayEvent(this._getNow(), value));

    this._trimBufferThenGetEvents();

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype._subscribe = function (subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;

    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;

    if (this.closed) {
      throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = _Subscription.Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new _SubjectSubscription.SubjectSubscription(this, subscriber);
    }

    if (scheduler) {
      subscriber.add(subscriber = new _observeOn.ObserveOnSubscriber(subscriber, scheduler));
    }

    if (_infiniteTimeWindow) {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }

    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }

    return subscription;
  };

  ReplaySubject.prototype._getNow = function () {
    return (this.scheduler || _queue.queue).now();
  };

  ReplaySubject.prototype._trimBufferThenGetEvents = function () {
    var now = this._getNow();

    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;

    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }

      spliceCount++;
    }

    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }

    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }

    return _events;
  };

  return ReplaySubject;
}(_Subject.Subject);

exports.ReplaySubject = ReplaySubject;

var ReplayEvent =
/*@__PURE__*/
function () {
  function ReplayEvent(time, value) {
    this.time = time;
    this.value = value;
  }

  return ReplayEvent;
}();
},{"tslib":"CvJj","./Subject":"ChYR","./scheduler/queue":"LwhG","./Subscription":"kylD","./operators/observeOn":"f5HV","./util/ObjectUnsubscribedError":"aESt","./SubjectSubscription":"D3Ra"}],"eFQJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncSubject = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subject = require("./Subject");

var _Subscription = require("./Subscription");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsyncSubject, _super);

  function AsyncSubject() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }

  AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription.Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return _Subscription.Subscription.EMPTY;
    }

    return _super.prototype._subscribe.call(this, subscriber);
  };

  AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };

  AsyncSubject.prototype.error = function (error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };

  AsyncSubject.prototype.complete = function () {
    this.hasCompleted = true;

    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }

    _super.prototype.complete.call(this);
  };

  return AsyncSubject;
}(_Subject.Subject);

exports.AsyncSubject = AsyncSubject;
},{"tslib":"CvJj","./Subject":"ChYR","./Subscription":"kylD"}],"BXBT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Immediate = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};

function runIfPresent(handle) {
  var cb = tasksByHandle[handle];

  if (cb) {
    cb();
  }
}

var Immediate = {
  setImmediate: function (cb) {
    var handle = nextHandle++;
    tasksByHandle[handle] = cb;
    Promise.resolve().then(function () {
      return runIfPresent(handle);
    });
    return handle;
  },
  clearImmediate: function (handle) {
    delete tasksByHandle[handle];
  }
};
exports.Immediate = Immediate;
},{}],"CvMk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsapAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Immediate = require("../util/Immediate");

var _AsyncAction = require("./AsyncAction");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsapAction, _super);

  function AsapAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = _Immediate.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };

  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
    }

    if (scheduler.actions.length === 0) {
      _Immediate.Immediate.clearImmediate(id);

      scheduler.scheduled = undefined;
    }

    return undefined;
  };

  return AsapAction;
}(_AsyncAction.AsyncAction);

exports.AsapAction = AsapAction;
},{"tslib":"CvJj","../util/Immediate":"BXBT","./AsyncAction":"EYeg"}],"JFO8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsapScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AsapScheduler, _super);

  function AsapScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AsapScheduler.prototype.flush = function (action) {
    this.active = true;
    this.scheduled = undefined;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));

    this.active = false;

    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsapScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.AsapScheduler = AsapScheduler;
},{"tslib":"CvJj","./AsyncScheduler":"oQUP"}],"hGLO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asap = void 0;

var _AsapAction = require("./AsapAction");

var _AsapScheduler = require("./AsapScheduler");

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap =
/*@__PURE__*/
new _AsapScheduler.AsapScheduler(_AsapAction.AsapAction);
exports.asap = asap;
},{"./AsapAction":"CvMk","./AsapScheduler":"JFO8"}],"hPfc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.async = void 0;

var _AsyncAction = require("./AsyncAction");

var _AsyncScheduler = require("./AsyncScheduler");

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async =
/*@__PURE__*/
new _AsyncScheduler.AsyncScheduler(_AsyncAction.AsyncAction);
exports.async = async;
},{"./AsyncAction":"EYeg","./AsyncScheduler":"oQUP"}],"MGFW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationFrameAction = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnimationFrameAction, _super);

  function AnimationFrameAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
      return scheduler.flush(null);
    }));
  };

  AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
    }

    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = undefined;
    }

    return undefined;
  };

  return AnimationFrameAction;
}(_AsyncAction.AsyncAction);

exports.AnimationFrameAction = AnimationFrameAction;
},{"tslib":"CvJj","./AsyncAction":"EYeg"}],"ds5Z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationFrameScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncScheduler = require("./AsyncScheduler");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(AnimationFrameScheduler, _super);

  function AnimationFrameScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AnimationFrameScheduler.prototype.flush = function (action) {
    this.active = true;
    this.scheduled = undefined;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));

    this.active = false;

    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AnimationFrameScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.AnimationFrameScheduler = AnimationFrameScheduler;
},{"tslib":"CvJj","./AsyncScheduler":"oQUP"}],"XSA2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animationFrame = void 0;

var _AnimationFrameAction = require("./AnimationFrameAction");

var _AnimationFrameScheduler = require("./AnimationFrameScheduler");

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame =
/*@__PURE__*/
new _AnimationFrameScheduler.AnimationFrameScheduler(_AnimationFrameAction.AnimationFrameAction);
exports.animationFrame = animationFrame;
},{"./AnimationFrameAction":"MGFW","./AnimationFrameScheduler":"ds5Z"}],"tPIC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VirtualAction = exports.VirtualTimeScheduler = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _AsyncAction = require("./AsyncAction");

var _AsyncScheduler = require("./AsyncScheduler");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(VirtualTimeScheduler, _super);

  function VirtualTimeScheduler(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }

    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this, SchedulerAction, function () {
      return _this.frame;
    }) || this;

    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }

  VirtualTimeScheduler.prototype.flush = function () {
    var _a = this,
        actions = _a.actions,
        maxFrames = _a.maxFrames;

    var error, action;

    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;

      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }

    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  VirtualTimeScheduler.frameTimeFactor = 10;
  return VirtualTimeScheduler;
}(_AsyncScheduler.AsyncScheduler);

exports.VirtualTimeScheduler = VirtualTimeScheduler;

var VirtualAction =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(VirtualAction, _super);

  function VirtualAction(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }

    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }

  VirtualAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (!this.id) {
      return _super.prototype.schedule.call(this, state, delay);
    }

    this.active = false;
    var action = new VirtualAction(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay);
  };

  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.delay = scheduler.frame + delay;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction.sortActions);
    return true;
  };

  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return undefined;
  };

  VirtualAction.prototype._execute = function (state, delay) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay);
    }
  };

  VirtualAction.sortActions = function (a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };

  return VirtualAction;
}(_AsyncAction.AsyncAction);

exports.VirtualAction = VirtualAction;
},{"tslib":"CvJj","./AsyncAction":"EYeg","./AsyncScheduler":"oQUP"}],"u6is":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.identity = identity;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
  return x;
}
},{}],"has7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObservable = isObservable;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function isObservable(obj) {
  return !!obj && (obj instanceof _Observable.Observable || typeof obj.lift === 'function' && typeof obj.subscribe === 'function');
}
},{"../Observable":"eNLs"}],"zbvn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArgumentOutOfRangeError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl =
/*@__PURE__*/
function () {
  function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
  }

  ArgumentOutOfRangeErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl;
}();

var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
},{}],"aprA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmptyError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl =
/*@__PURE__*/
function () {
  function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
  }

  EmptyErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return EmptyErrorImpl;
}();

var EmptyError = EmptyErrorImpl;
exports.EmptyError = EmptyError;
},{}],"AHhI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeoutError = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl =
/*@__PURE__*/
function () {
  function TimeoutErrorImpl() {
    Error.call(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    return this;
  }

  TimeoutErrorImpl.prototype =
  /*@__PURE__*/
  Object.create(Error.prototype);
  return TimeoutErrorImpl;
}();

var TimeoutError = TimeoutErrorImpl;
exports.TimeoutError = TimeoutError;
},{}],"qXrK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = map;
exports.MapOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }

    return source.lift(new MapOperator(project, thisArg));
  };
}

var MapOperator =
/*@__PURE__*/
function () {
  function MapOperator(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }

  MapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };

  return MapOperator;
}();

exports.MapOperator = MapOperator;

var MapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MapSubscriber, _super);

  function MapSubscriber(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }

  MapSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return MapSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"CvJj","../Subscriber":"Cb5c"}],"amVY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindCallback = bindCallback;

var _Observable = require("../Observable");

var _AsyncSubject = require("../AsyncSubject");

var _map = require("../operators/map");

var _canReportError = require("../util/canReportError");

var _isArray = require("../util/isArray");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if ((0, _isScheduler.isScheduler)(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0, _map.map)(function (args) {
          return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
        }));
      };
    }
  }

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var context = this;
    var subject;
    var params = {
      context: context,
      subject: subject,
      callbackFunc: callbackFunc,
      scheduler: scheduler
    };
    return new _Observable.Observable(function (subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new _AsyncSubject.AsyncSubject();

          var handler = function () {
            var innerArgs = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
            }

            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };

          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if ((0, _canReportError.canReportError)(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }

        return subject.subscribe(subscriber);
      } else {
        var state = {
          args: args,
          subscriber: subscriber,
          params: params
        };
        return scheduler.schedule(dispatch, 0, state);
      }
    });
  };
}

function dispatch(state) {
  var _this = this;

  var self = this;
  var args = state.args,
      subscriber = state.subscriber,
      params = state.params;
  var callbackFunc = params.callbackFunc,
      context = params.context,
      scheduler = params.scheduler;
  var subject = params.subject;

  if (!subject) {
    subject = params.subject = new _AsyncSubject.AsyncSubject();

    var handler = function () {
      var innerArgs = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }

      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

      _this.add(scheduler.schedule(dispatchNext, 0, {
        value: value,
        subject: subject
      }));
    };

    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }

  this.add(subject.subscribe(subscriber));
}

function dispatchNext(state) {
  var value = state.value,
      subject = state.subject;
  subject.next(value);
  subject.complete();
}

function dispatchError(state) {
  var err = state.err,
      subject = state.subject;
  subject.error(err);
}
},{"../Observable":"eNLs","../AsyncSubject":"eFQJ","../operators/map":"qXrK","../util/canReportError":"yrZ0","../util/isArray":"hGKc","../util/isScheduler":"kChJ"}],"n9wG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindNodeCallback = bindNodeCallback;

var _Observable = require("../Observable");

var _AsyncSubject = require("../AsyncSubject");

var _map = require("../operators/map");

var _canReportError = require("../util/canReportError");

var _isScheduler = require("../util/isScheduler");

var _isArray = require("../util/isArray");

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if ((0, _isScheduler.isScheduler)(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0, _map.map)(function (args) {
          return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
        }));
      };
    }
  }

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var params = {
      subject: undefined,
      args: args,
      callbackFunc: callbackFunc,
      scheduler: scheduler,
      context: this
    };
    return new _Observable.Observable(function (subscriber) {
      var context = params.context;
      var subject = params.subject;

      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new _AsyncSubject.AsyncSubject();

          var handler = function () {
            var innerArgs = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
            }

            var err = innerArgs.shift();

            if (err) {
              subject.error(err);
              return;
            }

            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };

          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if ((0, _canReportError.canReportError)(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }

        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch, 0, {
          params: params,
          subscriber: subscriber,
          context: context
        });
      }
    });
  };
}

function dispatch(state) {
  var _this = this;

  var params = state.params,
      subscriber = state.subscriber,
      context = state.context;
  var callbackFunc = params.callbackFunc,
      args = params.args,
      scheduler = params.scheduler;
  var subject = params.subject;

  if (!subject) {
    subject = params.subject = new _AsyncSubject.AsyncSubject();

    var handler = function () {
      var innerArgs = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }

      var err = innerArgs.shift();

      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, {
          err: err,
          subject: subject
        }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

        _this.add(scheduler.schedule(dispatchNext, 0, {
          value: value,
          subject: subject
        }));
      }
    };

    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, {
        err: err,
        subject: subject
      }));
    }
  }

  this.add(subject.subscribe(subscriber));
}

function dispatchNext(arg) {
  var value = arg.value,
      subject = arg.subject;
  subject.next(value);
  subject.complete();
}

function dispatchError(arg) {
  var err = arg.err,
      subject = arg.subject;
  subject.error(err);
}
},{"../Observable":"eNLs","../AsyncSubject":"eFQJ","../operators/map":"qXrK","../util/canReportError":"yrZ0","../util/isScheduler":"kChJ","../util/isArray":"hGKc"}],"gqLc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OuterSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("./Subscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(OuterSubscriber, _super);

  function OuterSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  OuterSubscriber.prototype.notifyError = function (error, innerSub) {
    this.destination.error(error);
  };

  OuterSubscriber.prototype.notifyComplete = function (innerSub) {
    this.destination.complete();
  };

  return OuterSubscriber;
}(_Subscriber.Subscriber);

exports.OuterSubscriber = OuterSubscriber;
},{"tslib":"CvJj","./Subscriber":"Cb5c"}],"OA4X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InnerSubscriber = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("./Subscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(InnerSubscriber, _super);

  function InnerSubscriber(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }

  InnerSubscriber.prototype._next = function (value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };

  InnerSubscriber.prototype._error = function (error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };

  InnerSubscriber.prototype._complete = function () {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };

  return InnerSubscriber;
}(_Subscriber.Subscriber);

exports.InnerSubscriber = InnerSubscriber;
},{"tslib":"CvJj","./Subscriber":"Cb5c"}],"Fuat":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToPromise = void 0;

var _hostReportError = require("./hostReportError");

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
  return function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, _hostReportError.hostReportError);
    return subscriber;
  };
};

exports.subscribeToPromise = subscribeToPromise;
},{"./hostReportError":"KN9L"}],"gkUl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSymbolIterator = getSymbolIterator;
exports.$$iterator = exports.iterator = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }

  return Symbol.iterator;
}

var iterator =
/*@__PURE__*/
getSymbolIterator();
exports.iterator = iterator;
var $$iterator = iterator;
exports.$$iterator = $$iterator;
},{}],"Zjgu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToIterable = void 0;

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
  return function (subscriber) {
    var iterator = iterable[_iterator.iterator]();

    do {
      var item = iterator.next();

      if (item.done) {
        subscriber.complete();
        break;
      }

      subscriber.next(item.value);

      if (subscriber.closed) {
        break;
      }
    } while (true);

    if (typeof iterator.return === 'function') {
      subscriber.add(function () {
        if (iterator.return) {
          iterator.return();
        }
      });
    }

    return subscriber;
  };
};

exports.subscribeToIterable = subscribeToIterable;
},{"../symbol/iterator":"gkUl"}],"vCox":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToObservable = void 0;

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
  return function (subscriber) {
    var obs = obj[_observable.observable]();

    if (typeof obs.subscribe !== 'function') {
      throw new TypeError('Provided object does not correctly implement Symbol.observable');
    } else {
      return obs.subscribe(subscriber);
    }
  };
};

exports.subscribeToObservable = subscribeToObservable;
},{"../symbol/observable":"ufLg"}],"fMjD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayLike = void 0;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = function (x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};

exports.isArrayLike = isArrayLike;
},{}],"tLeD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPromise = isPromise;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
},{}],"K5ym":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeTo = void 0;

var _subscribeToArray = require("./subscribeToArray");

var _subscribeToPromise = require("./subscribeToPromise");

var _subscribeToIterable = require("./subscribeToIterable");

var _subscribeToObservable = require("./subscribeToObservable");

var _isArrayLike = require("./isArrayLike");

var _isPromise = require("./isPromise");

var _isObject = require("./isObject");

var _iterator = require("../symbol/iterator");

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
  if (!!result && typeof result[_observable.observable] === 'function') {
    return (0, _subscribeToObservable.subscribeToObservable)(result);
  } else if ((0, _isArrayLike.isArrayLike)(result)) {
    return (0, _subscribeToArray.subscribeToArray)(result);
  } else if ((0, _isPromise.isPromise)(result)) {
    return (0, _subscribeToPromise.subscribeToPromise)(result);
  } else if (!!result && typeof result[_iterator.iterator] === 'function') {
    return (0, _subscribeToIterable.subscribeToIterable)(result);
  } else {
    var value = (0, _isObject.isObject)(result) ? 'an invalid object' : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(msg);
  }
};

exports.subscribeTo = subscribeTo;
},{"./subscribeToArray":"w1m3","./subscribeToPromise":"Fuat","./subscribeToIterable":"Zjgu","./subscribeToObservable":"vCox","./isArrayLike":"fMjD","./isPromise":"tLeD","./isObject":"g8CQ","../symbol/iterator":"gkUl","../symbol/observable":"ufLg"}],"P9HJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToResult = subscribeToResult;

var _InnerSubscriber = require("../InnerSubscriber");

var _subscribeTo = require("./subscribeTo");

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
  if (destination === void 0) {
    destination = new _InnerSubscriber.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }

  if (destination.closed) {
    return undefined;
  }

  if (result instanceof _Observable.Observable) {
    return result.subscribe(destination);
  }

  return (0, _subscribeTo.subscribeTo)(result)(destination);
}
},{"../InnerSubscriber":"OA4X","./subscribeTo":"K5ym","../Observable":"eNLs"}],"hTSZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineLatest = combineLatest;
exports.CombineLatestSubscriber = exports.CombineLatestOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isScheduler = require("../util/isScheduler");

var _isArray = require("../util/isArray");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _fromArray = require("./fromArray");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};

function combineLatest() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var resultSelector = null;
  var scheduler = null;

  if ((0, _isScheduler.isScheduler)(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }

  if (typeof observables[observables.length - 1] === 'function') {
    resultSelector = observables.pop();
  }

  if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
    observables = observables[0];
  }

  return (0, _fromArray.fromArray)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}

var CombineLatestOperator =
/*@__PURE__*/
function () {
  function CombineLatestOperator(resultSelector) {
    this.resultSelector = resultSelector;
  }

  CombineLatestOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };

  return CombineLatestOperator;
}();

exports.CombineLatestOperator = CombineLatestOperator;

var CombineLatestSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(CombineLatestSubscriber, _super);

  function CombineLatestSubscriber(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;

    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }

  CombineLatestSubscriber.prototype._next = function (observable) {
    this.values.push(NONE);
    this.observables.push(observable);
  };

  CombineLatestSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;

      for (var i = 0; i < len; i++) {
        var observable = observables[i];
        this.add((0, _subscribeToResult.subscribeToResult)(this, observable, observable, i));
      }
    }
  };

  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };

  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;

    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };

  CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
    var result;

    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return CombineLatestSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.CombineLatestSubscriber = CombineLatestSubscriber;
},{"tslib":"CvJj","../util/isScheduler":"kChJ","../util/isArray":"hGKc","../OuterSubscriber":"gqLc","../util/subscribeToResult":"P9HJ","./fromArray":"H2SB"}],"q5Qm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleObservable = scheduleObservable;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
function scheduleObservable(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    sub.add(scheduler.schedule(function () {
      var observable = input[_observable.observable]();

      sub.add(observable.subscribe({
        next: function (value) {
          sub.add(scheduler.schedule(function () {
            return subscriber.next(value);
          }));
        },
        error: function (err) {
          sub.add(scheduler.schedule(function () {
            return subscriber.error(err);
          }));
        },
        complete: function () {
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
},{"../Observable":"eNLs","../Subscription":"kylD","../symbol/observable":"ufLg"}],"OdUd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.schedulePromise = schedulePromise;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function schedulePromise(input, scheduler) {
  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    sub.add(scheduler.schedule(function () {
      return input.then(function (value) {
        sub.add(scheduler.schedule(function () {
          subscriber.next(value);
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }));
      }, function (err) {
        sub.add(scheduler.schedule(function () {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
},{"../Observable":"eNLs","../Subscription":"kylD"}],"sp2m":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduleIterable = scheduleIterable;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }

  return new _Observable.Observable(function (subscriber) {
    var sub = new _Subscription.Subscription();
    var iterator;
    sub.add(function () {
      if (iterator && typeof iterator.return === 'function') {
        iterator.return();
      }
    });
    sub.add(scheduler.schedule(function () {
      iterator = input[_iterator.iterator]();
      sub.add(scheduler.schedule(function () {
        if (subscriber.closed) {
          return;
        }

        var value;
        var done;

        try {
          var result = iterator.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }

        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
},{"../Observable":"eNLs","../Subscription":"kylD","../symbol/iterator":"gkUl"}],"oRwm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInteropObservable = isInteropObservable;

var _observable = require("../symbol/observable");

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
  return input && typeof input[_observable.observable] === 'function';
}
},{"../symbol/observable":"ufLg"}],"uVmC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIterable = isIterable;

var _iterator = require("../symbol/iterator");

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
  return input && typeof input[_iterator.iterator] === 'function';
}
},{"../symbol/iterator":"gkUl"}],"P1uA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scheduled = scheduled;

var _scheduleObservable = require("./scheduleObservable");

var _schedulePromise = require("./schedulePromise");

var _scheduleArray = require("./scheduleArray");

var _scheduleIterable = require("./scheduleIterable");

var _isInteropObservable = require("../util/isInteropObservable");

var _isPromise = require("../util/isPromise");

var _isArrayLike = require("../util/isArrayLike");

var _isIterable = require("../util/isIterable");

/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
function scheduled(input, scheduler) {
  if (input != null) {
    if ((0, _isInteropObservable.isInteropObservable)(input)) {
      return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
    } else if ((0, _isPromise.isPromise)(input)) {
      return (0, _schedulePromise.schedulePromise)(input, scheduler);
    } else if ((0, _isArrayLike.isArrayLike)(input)) {
      return (0, _scheduleArray.scheduleArray)(input, scheduler);
    } else if ((0, _isIterable.isIterable)(input) || typeof input === 'string') {
      return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
    }
  }

  throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
},{"./scheduleObservable":"q5Qm","./schedulePromise":"OdUd","./scheduleArray":"LzTI","./scheduleIterable":"sp2m","../util/isInteropObservable":"oRwm","../util/isPromise":"tLeD","../util/isArrayLike":"fMjD","../util/isIterable":"uVmC"}],"mcUj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.from = from;

var _Observable = require("../Observable");

var _subscribeTo = require("../util/subscribeTo");

var _scheduled = require("../scheduled/scheduled");

/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof _Observable.Observable) {
      return input;
    }

    return new _Observable.Observable((0, _subscribeTo.subscribeTo)(input));
  } else {
    return (0, _scheduled.scheduled)(input, scheduler);
  }
}
},{"../Observable":"eNLs","../util/subscribeTo":"K5ym","../scheduled/scheduled":"P1uA"}],"FPwf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeMap = mergeMap;
exports.MergeMapSubscriber = exports.MergeMapOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _subscribeToResult = require("../util/subscribeToResult");

var _OuterSubscriber = require("../OuterSubscriber");

var _InnerSubscriber = require("../InnerSubscriber");

var _map = require("./map");

var _from = require("../observable/from");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (typeof resultSelector === 'function') {
    return function (source) {
      return source.pipe(mergeMap(function (a, i) {
        return (0, _from.from)(project(a, i)).pipe((0, _map.map)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }

  return function (source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}

var MergeMapOperator =
/*@__PURE__*/
function () {
  function MergeMapOperator(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    this.project = project;
    this.concurrent = concurrent;
  }

  MergeMapOperator.prototype.call = function (observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };

  return MergeMapOperator;
}();

exports.MergeMapOperator = MergeMapOperator;

var MergeMapSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(MergeMapSubscriber, _super);

  function MergeMapSubscriber(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }

  MergeMapSubscriber.prototype._next = function (value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };

  MergeMapSubscriber.prototype._tryNext = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.active++;

    this._innerSub(result, value, index);
  };

  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
    var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
    var destination = this.destination;
    destination.add(innerSubscriber);
    (0, _subscribeToResult.subscribeToResult)(this, ish, value, index, innerSubscriber);
  };

  MergeMapSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
    var buffer = this.buffer;
    this.remove(innerSub);
    this.active--;

    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };

  return MergeMapSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.MergeMapSubscriber = MergeMapSubscriber;
},{"tslib":"CvJj","../util/subscribeToResult":"P9HJ","../OuterSubscriber":"gqLc","../InnerSubscriber":"OA4X","./map":"qXrK","../observable/from":"mcUj"}],"H3gn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeAll = mergeAll;

var _mergeMap = require("./mergeMap");

var _identity = require("../util/identity");

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  return (0, _mergeMap.mergeMap)(_identity.identity, concurrent);
}
},{"./mergeMap":"FPwf","../util/identity":"u6is"}],"tKsx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatAll = concatAll;

var _mergeAll = require("./mergeAll");

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
  return (0, _mergeAll.mergeAll)(1);
}
},{"./mergeAll":"H3gn"}],"ZFK1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

var _of = require("./of");

var _concatAll = require("../operators/concatAll");

/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return (0, _concatAll.concatAll)()(_of.of.apply(void 0, observables));
}
},{"./of":"ejbS","../operators/concatAll":"tKsx"}],"qA6d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defer = defer;

var _Observable = require("../Observable");

var _from = require("./from");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function defer(observableFactory) {
  return new _Observable.Observable(function (subscriber) {
    var input;

    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var source = input ? (0, _from.from)(input) : (0, _empty.empty)();
    return source.subscribe(subscriber);
  });
}
},{"../Observable":"eNLs","./from":"mcUj","./empty":"yJHz"}],"kgMP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forkJoin = forkJoin;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _map = require("../operators/map");

var _isObject = require("../util/isObject");

var _from = require("./from");

/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */
function forkJoin() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  if (sources.length === 1) {
    var first_1 = sources[0];

    if ((0, _isArray.isArray)(first_1)) {
      return forkJoinInternal(first_1, null);
    }

    if ((0, _isObject.isObject)(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function (key) {
        return first_1[key];
      }), keys);
    }
  }

  if (typeof sources[sources.length - 1] === 'function') {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && (0, _isArray.isArray)(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe((0, _map.map)(function (args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }

  return forkJoinInternal(sources, null);
}

function forkJoinInternal(sources, keys) {
  return new _Observable.Observable(function (subscriber) {
    var len = sources.length;

    if (len === 0) {
      subscriber.complete();
      return;
    }

    var values = new Array(len);
    var completed = 0;
    var emitted = 0;

    var _loop_1 = function (i) {
      var source = (0, _from.from)(sources[i]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function (value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }

          values[i] = value;
        },
        error: function (err) {
          return subscriber.error(err);
        },
        complete: function () {
          completed++;

          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function (result, key, i) {
                return result[key] = values[i], result;
              }, {}) : values);
            }

            subscriber.complete();
          }
        }
      }));
    };

    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
  });
}
},{"../Observable":"eNLs","../util/isArray":"hGKc","../operators/map":"qXrK","../util/isObject":"g8CQ","./from":"mcUj"}],"iv30":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEvent = fromEvent;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _isFunction = require("../util/isFunction");

var _map = require("../operators/map");

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
var toString =
/*@__PURE__*/
function () {
  return Object.prototype.toString;
}();

function fromEvent(target, eventName, options, resultSelector) {
  if ((0, _isFunction.isFunction)(options)) {
    resultSelector = options;
    options = undefined;
  }

  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe((0, _map.map)(function (args) {
      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }

  return new _Observable.Observable(function (subscriber) {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }

    setupSubscription(target, eventName, handler, subscriber, options);
  });
}

function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;

  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);

    unsubscribe = function () {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);

    unsubscribe = function () {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);

    unsubscribe = function () {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError('Invalid event target');
  }

  subscriber.add(unsubscribe);
}

function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}

function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}

function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
},{"../Observable":"eNLs","../util/isArray":"hGKc","../util/isFunction":"urBN","../operators/map":"qXrK"}],"tRvz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEventPattern = fromEventPattern;

var _Observable = require("../Observable");

var _isArray = require("../util/isArray");

var _isFunction = require("../util/isFunction");

var _map = require("../operators/map");

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe((0, _map.map)(function (args) {
      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }

  return new _Observable.Observable(function (subscriber) {
    var handler = function () {
      var e = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }

      return subscriber.next(e.length === 1 ? e[0] : e);
    };

    var retValue;

    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    if (!(0, _isFunction.isFunction)(removeHandler)) {
      return undefined;
    }

    return function () {
      return removeHandler(handler, retValue);
    };
  });
}
},{"../Observable":"eNLs","../util/isArray":"hGKc","../util/isFunction":"urBN","../operators/map":"qXrK"}],"taDX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;

var _Observable = require("../Observable");

var _identity = require("../util/identity");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;

  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || _identity.identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === undefined || (0, _isScheduler.isScheduler)(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = _identity.identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }

  return new _Observable.Observable(function (subscriber) {
    var state = initialState;

    if (scheduler) {
      return scheduler.schedule(dispatch, 0, {
        subscriber: subscriber,
        iterate: iterate,
        condition: condition,
        resultSelector: resultSelector,
        state: state
      });
    }

    do {
      if (condition) {
        var conditionResult = void 0;

        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }

      var value = void 0;

      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }

      subscriber.next(value);

      if (subscriber.closed) {
        break;
      }

      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }
    } while (true);

    return undefined;
  });
}

function dispatch(state) {
  var subscriber = state.subscriber,
      condition = state.condition;

  if (subscriber.closed) {
    return undefined;
  }

  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }
  } else {
    state.needIterate = true;
  }

  if (condition) {
    var conditionResult = void 0;

    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    if (!conditionResult) {
      subscriber.complete();
      return undefined;
    }

    if (subscriber.closed) {
      return undefined;
    }
  }

  var value;

  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return undefined;
  }

  if (subscriber.closed) {
    return undefined;
  }

  subscriber.next(value);

  if (subscriber.closed) {
    return undefined;
  }

  return this.schedule(state);
}
},{"../Observable":"eNLs","../util/identity":"u6is","../util/isScheduler":"kChJ"}],"MkQo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iif = iif;

var _defer = require("./defer");

var _empty = require("./empty");

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = _empty.EMPTY;
  }

  if (falseResult === void 0) {
    falseResult = _empty.EMPTY;
  }

  return (0, _defer.defer)(function () {
    return condition() ? trueResult : falseResult;
  });
}
},{"./defer":"qA6d","./empty":"yJHz"}],"yazh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumeric = isNumeric;

var _isArray = require("./isArray");

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
  return !(0, _isArray.isArray)(val) && val - parseFloat(val) + 1 >= 0;
}
},{"./isArray":"hGKc"}],"EZOX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = interval;

var _Observable = require("../Observable");

var _async = require("../scheduler/async");

var _isNumeric = require("../util/isNumeric");

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }

  if (scheduler === void 0) {
    scheduler = _async.async;
  }

  if (!(0, _isNumeric.isNumeric)(period) || period < 0) {
    period = 0;
  }

  if (!scheduler || typeof scheduler.schedule !== 'function') {
    scheduler = _async.async;
  }

  return new _Observable.Observable(function (subscriber) {
    subscriber.add(scheduler.schedule(dispatch, period, {
      subscriber: subscriber,
      counter: 0,
      period: period
    }));
    return subscriber;
  });
}

function dispatch(state) {
  var subscriber = state.subscriber,
      counter = state.counter,
      period = state.period;
  subscriber.next(counter);
  this.schedule({
    subscriber: subscriber,
    counter: counter + 1,
    period: period
  }, period);
}
},{"../Observable":"eNLs","../scheduler/async":"hPfc","../util/isNumeric":"yazh"}],"FCPu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = merge;

var _Observable = require("../Observable");

var _isScheduler = require("../util/isScheduler");

var _mergeAll = require("../operators/mergeAll");

var _fromArray = require("./fromArray");

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last = observables[observables.length - 1];

  if ((0, _isScheduler.isScheduler)(last)) {
    scheduler = observables.pop();

    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
      concurrent = observables.pop();
    }
  } else if (typeof last === 'number') {
    concurrent = observables.pop();
  }

  if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable.Observable) {
    return observables[0];
  }

  return (0, _mergeAll.mergeAll)(concurrent)((0, _fromArray.fromArray)(observables, scheduler));
}
},{"../Observable":"eNLs","../util/isScheduler":"kChJ","../operators/mergeAll":"H3gn","./fromArray":"H2SB"}],"S6Z7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.never = never;
exports.NEVER = void 0;

var _Observable = require("../Observable");

var _noop = require("../util/noop");

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER =
/*@__PURE__*/
new _Observable.Observable(_noop.noop);
exports.NEVER = NEVER;

function never() {
  return NEVER;
}
},{"../Observable":"eNLs","../util/noop":"Kkj8"}],"lCXO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onErrorResumeNext = onErrorResumeNext;

var _Observable = require("../Observable");

var _from = require("./from");

var _isArray = require("../util/isArray");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
function onErrorResumeNext() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  if (sources.length === 0) {
    return _empty.EMPTY;
  }

  var first = sources[0],
      remainder = sources.slice(1);

  if (sources.length === 1 && (0, _isArray.isArray)(first)) {
    return onErrorResumeNext.apply(void 0, first);
  }

  return new _Observable.Observable(function (subscriber) {
    var subNext = function () {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };

    return (0, _from.from)(first).subscribe({
      next: function (value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
},{"../Observable":"eNLs","./from":"mcUj","../util/isArray":"hGKc","./empty":"yJHz"}],"VFVu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pairs = pairs;
exports.dispatch = dispatch;

var _Observable = require("../Observable");

var _Subscription = require("../Subscription");

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new _Observable.Observable(function (subscriber) {
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length && !subscriber.closed; i++) {
        var key = keys[i];

        if (obj.hasOwnProperty(key)) {
          subscriber.next([key, obj[key]]);
        }
      }

      subscriber.complete();
    });
  } else {
    return new _Observable.Observable(function (subscriber) {
      var keys = Object.keys(obj);
      var subscription = new _Subscription.Subscription();
      subscription.add(scheduler.schedule(dispatch, 0, {
        keys: keys,
        index: 0,
        subscriber: subscriber,
        subscription: subscription,
        obj: obj
      }));
      return subscription;
    });
  }
}

function dispatch(state) {
  var keys = state.keys,
      index = state.index,
      subscriber = state.subscriber,
      subscription = state.subscription,
      obj = state.obj;

  if (!subscriber.closed) {
    if (index < keys.length) {
      var key = keys[index];
      subscriber.next([key, obj[key]]);
      subscription.add(this.schedule({
        keys: keys,
        index: index + 1,
        subscriber: subscriber,
        subscription: subscription,
        obj: obj
      }));
    } else {
      subscriber.complete();
    }
  }
}
},{"../Observable":"eNLs","../Subscription":"kylD"}],"ptR6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.not = not;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }

  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
},{}],"nUBk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filter = filter;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _Subscriber = require("../Subscriber");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}

var FilterOperator =
/*@__PURE__*/
function () {
  function FilterOperator(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }

  FilterOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };

  return FilterOperator;
}();

var FilterSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(FilterSubscriber, _super);

  function FilterSubscriber(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }

  FilterSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    if (result) {
      this.destination.next(value);
    }
  };

  return FilterSubscriber;
}(_Subscriber.Subscriber);
},{"tslib":"CvJj","../Subscriber":"Cb5c"}],"X4vB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.partition = partition;

var _not = require("../util/not");

var _subscribeTo = require("../util/subscribeTo");

var _filter = require("../operators/filter");

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */
function partition(source, predicate, thisArg) {
  return [(0, _filter.filter)(predicate, thisArg)(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))), (0, _filter.filter)((0, _not.not)(predicate, thisArg))(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source)))];
}
},{"../util/not":"ptR6","../util/subscribeTo":"K5ym","../operators/filter":"nUBk","../Observable":"eNLs"}],"BQup":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.race = race;
exports.RaceSubscriber = exports.RaceOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _isArray = require("../util/isArray");

var _fromArray = require("./fromArray");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function race() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  if (observables.length === 1) {
    if ((0, _isArray.isArray)(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }

  return (0, _fromArray.fromArray)(observables, undefined).lift(new RaceOperator());
}

var RaceOperator =
/*@__PURE__*/
function () {
  function RaceOperator() {}

  RaceOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };

  return RaceOperator;
}();

exports.RaceOperator = RaceOperator;

var RaceSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(RaceSubscriber, _super);

  function RaceSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }

  RaceSubscriber.prototype._next = function (observable) {
    this.observables.push(observable);
  };

  RaceSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable = observables[i];
        var subscription = (0, _subscribeToResult.subscribeToResult)(this, observable, observable, i);

        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }

        this.add(subscription);
      }

      this.observables = null;
    }
  };

  RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (!this.hasFirst) {
      this.hasFirst = true;

      for (var i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }

      this.subscriptions = null;
    }

    this.destination.next(innerValue);
  };

  return RaceSubscriber;
}(_OuterSubscriber.OuterSubscriber);

exports.RaceSubscriber = RaceSubscriber;
},{"tslib":"CvJj","../util/isArray":"hGKc","./fromArray":"H2SB","../OuterSubscriber":"gqLc","../util/subscribeToResult":"P9HJ"}],"TL3y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.range = range;
exports.dispatch = dispatch;

var _Observable = require("../Observable");

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function range(start, count, scheduler) {
  if (start === void 0) {
    start = 0;
  }

  return new _Observable.Observable(function (subscriber) {
    if (count === undefined) {
      count = start;
      start = 0;
    }

    var index = 0;
    var current = start;

    if (scheduler) {
      return scheduler.schedule(dispatch, 0, {
        index: index,
        count: count,
        start: start,
        subscriber: subscriber
      });
    } else {
      do {
        if (index++ >= count) {
          subscriber.complete();
          break;
        }

        subscriber.next(current++);

        if (subscriber.closed) {
          break;
        }
      } while (true);
    }

    return undefined;
  });
}

function dispatch(state) {
  var start = state.start,
      index = state.index,
      count = state.count,
      subscriber = state.subscriber;

  if (index >= count) {
    subscriber.complete();
    return;
  }

  subscriber.next(start);

  if (subscriber.closed) {
    return;
  }

  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
},{"../Observable":"eNLs"}],"Mt5U":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timer = timer;

var _Observable = require("../Observable");

var _async = require("../scheduler/async");

var _isNumeric = require("../util/isNumeric");

var _isScheduler = require("../util/isScheduler");

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }

  var period = -1;

  if ((0, _isNumeric.isNumeric)(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if ((0, _isScheduler.isScheduler)(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }

  if (!(0, _isScheduler.isScheduler)(scheduler)) {
    scheduler = _async.async;
  }

  return new _Observable.Observable(function (subscriber) {
    var due = (0, _isNumeric.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period: period,
      subscriber: subscriber
    });
  });
}

function dispatch(state) {
  var index = state.index,
      period = state.period,
      subscriber = state.subscriber;
  subscriber.next(index);

  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }

  state.index = index + 1;
  this.schedule(state, period);
}
},{"../Observable":"eNLs","../scheduler/async":"hPfc","../util/isNumeric":"yazh","../util/isScheduler":"kChJ"}],"gqLh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.using = using;

var _Observable = require("../Observable");

var _from = require("./from");

var _empty = require("./empty");

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function using(resourceFactory, observableFactory) {
  return new _Observable.Observable(function (subscriber) {
    var resource;

    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var result;

    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var source = result ? (0, _from.from)(result) : _empty.EMPTY;
    var subscription = source.subscribe(subscriber);
    return function () {
      subscription.unsubscribe();

      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
},{"../Observable":"eNLs","./from":"mcUj","./empty":"yJHz"}],"Xq91":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zip = zip;
exports.ZipSubscriber = exports.ZipOperator = void 0;

var tslib_1 = _interopRequireWildcard(require("tslib"));

var _fromArray = require("./fromArray");

var _isArray = require("../util/isArray");

var _Subscriber = require("../Subscriber");

var _OuterSubscriber = require("../OuterSubscriber");

var _subscribeToResult = require("../util/subscribeToResult");

var _iterator = require("../../internal/symbol/iterator");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
function zip() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var resultSelector = observables[observables.length - 1];

  if (typeof resultSelector === 'function') {
    observables.pop();
  }

  return (0, _fromArray.fromArray)(observables, undefined).lift(new ZipOperator(resultSelector));
}

var ZipOperator =
/*@__PURE__*/
function () {
  function ZipOperator(resultSelector) {
    this.resultSelector = resultSelector;
  }

  ZipOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };

  return ZipOperator;
}();

exports.ZipOperator = ZipOperator;

var ZipSubscriber =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ZipSubscriber, _super);

  function ZipSubscriber(destination, resultSelector, values) {
    if (values === void 0) {
      values = Object.create(null);
    }

    var _this = _super.call(this, destination) || this;

    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
    _this.values = values;
    return _this;
  }

  ZipSubscriber.prototype._next = function (value) {
    var iterators = this.iterators;

    if ((0, _isArray.isArray)(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[_iterator.iterator] === 'function') {
      iterators.push(new StaticIterator(value[_iterator.iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };

  ZipSubscriber.prototype._complete = function () {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();

    if (len === 0) {
      this.destination.complete();
      return;
    }

    this.active = len;

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];

      if (iterator.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator.subscribe(iterator, i));
      } else {
        this.active--;
      }
    }
  };

  ZipSubscriber.prototype.notifyInactive = function () {
    this.active--;

    if (this.active === 0) {
      this.destination.complete();
    }
  };

  ZipSubscriber.prototype.checkIterators = function () {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];

      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
        return;
      }
    }

    var shouldComplete = false;
    var args = [];

    for (var i = 0; i < len; i++) {
      var iterator = iterators[i];
      var result = iterator.next();

      if (iterator.hasCompleted()) {
        shouldComplete = true;
      }

      if (result.done) {
        destination.complete();
        return;
      }

      args.push(result.value);
    }

    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }

    if (shouldComplete) {
      destination.complete();
    }
  };

  ZipSubscriber.prototype._tryresultSelector = function (args) {
    var result;

    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return ZipSubscriber;
}(_Subscriber.Subscriber);

exports.ZipSubscriber = ZipSubscriber;

var StaticIterator =
/*@__PURE__*/
function () {
  function StaticIterator(iterator) {
    this.iterator = iterator;
    this.nextResult = iterator.next();
  }

  StaticIterator.prototype.hasValue = function () {
    return true;
  };

  StaticIterator.prototype.next = function () {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };

  StaticIterator.prototype.hasCompleted = function () {
    var nextResult = this.nextResult;
    return nextResult && nextResult.done;
  };

  return StaticIterator;
}();

var StaticArrayIterator =
/*@__PURE__*/
function () {
  function StaticArrayIterator(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }

  StaticArrayIterator.prototype[_iterator.iterator] = function () {
    return this;
  };

  StaticArrayIterator.prototype.next = function (value) {
    var i = this.index++;
    var array = this.array;
    return i < this.length ? {
      value: array[i],
      done: false
    } : {
      value: null,
      done: true
    };
  };

  StaticArrayIterator.prototype.hasValue = function () {
    return this.array.length > this.index;
  };

  StaticArrayIterator.prototype.hasCompleted = function () {
    return this.array.length === this.index;
  };

  return StaticArrayIterator;
}();

var ZipBufferIterator =
/*@__PURE__*/
function (_super) {
  tslib_1.__extends(ZipBufferIterator, _super);

  function ZipBufferIterator(destination, parent, observable) {
    var _this = _super.call(this, destination) || this;

    _this.parent = parent;
    _this.observable = observable;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }

  ZipBufferIterator.prototype[_iterator.iterator] = function () {
    return this;
  };

  ZipBufferIterator.prototype.next = function () {
    var buffer = this.buffer;

    if (buffer.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer.shift(),
        done: false
      };
    }
  };

  ZipBufferIterator.prototype.hasValue = function () {
    return this.buffer.length > 0;
  };

  ZipBufferIterator.prototype.hasCompleted = function () {
    return this.buffer.length === 0 && this.isComplete;
  };

  ZipBufferIterator.prototype.notifyComplete = function () {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };

  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };

  ZipBufferIterator.prototype.subscribe = function (value, index) {
    return (0, _subscribeToResult.subscribeToResult)(this, this.observable, this, index);
  };

  return ZipBufferIterator;
}(_OuterSubscriber.OuterSubscriber);
},{"tslib":"CvJj","./fromArray":"H2SB","../util/isArray":"hGKc","../Subscriber":"Cb5c","../OuterSubscriber":"gqLc","../util/subscribeToResult":"P9HJ","../../internal/symbol/iterator":"gkUl"}],"qwSA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Observable", {
  enumerable: true,
  get: function () {
    return _Observable.Observable;
  }
});
Object.defineProperty(exports, "ConnectableObservable", {
  enumerable: true,
  get: function () {
    return _ConnectableObservable.ConnectableObservable;
  }
});
Object.defineProperty(exports, "GroupedObservable", {
  enumerable: true,
  get: function () {
    return _groupBy.GroupedObservable;
  }
});
Object.defineProperty(exports, "observable", {
  enumerable: true,
  get: function () {
    return _observable.observable;
  }
});
Object.defineProperty(exports, "Subject", {
  enumerable: true,
  get: function () {
    return _Subject.Subject;
  }
});
Object.defineProperty(exports, "BehaviorSubject", {
  enumerable: true,
  get: function () {
    return _BehaviorSubject.BehaviorSubject;
  }
});
Object.defineProperty(exports, "ReplaySubject", {
  enumerable: true,
  get: function () {
    return _ReplaySubject.ReplaySubject;
  }
});
Object.defineProperty(exports, "AsyncSubject", {
  enumerable: true,
  get: function () {
    return _AsyncSubject.AsyncSubject;
  }
});
Object.defineProperty(exports, "asapScheduler", {
  enumerable: true,
  get: function () {
    return _asap.asap;
  }
});
Object.defineProperty(exports, "asyncScheduler", {
  enumerable: true,
  get: function () {
    return _async.async;
  }
});
Object.defineProperty(exports, "queueScheduler", {
  enumerable: true,
  get: function () {
    return _queue.queue;
  }
});
Object.defineProperty(exports, "animationFrameScheduler", {
  enumerable: true,
  get: function () {
    return _animationFrame.animationFrame;
  }
});
Object.defineProperty(exports, "VirtualTimeScheduler", {
  enumerable: true,
  get: function () {
    return _VirtualTimeScheduler.VirtualTimeScheduler;
  }
});
Object.defineProperty(exports, "VirtualAction", {
  enumerable: true,
  get: function () {
    return _VirtualTimeScheduler.VirtualAction;
  }
});
Object.defineProperty(exports, "Scheduler", {
  enumerable: true,
  get: function () {
    return _Scheduler.Scheduler;
  }
});
Object.defineProperty(exports, "Subscription", {
  enumerable: true,
  get: function () {
    return _Subscription.Subscription;
  }
});
Object.defineProperty(exports, "Subscriber", {
  enumerable: true,
  get: function () {
    return _Subscriber.Subscriber;
  }
});
Object.defineProperty(exports, "Notification", {
  enumerable: true,
  get: function () {
    return _Notification.Notification;
  }
});
Object.defineProperty(exports, "NotificationKind", {
  enumerable: true,
  get: function () {
    return _Notification.NotificationKind;
  }
});
Object.defineProperty(exports, "pipe", {
  enumerable: true,
  get: function () {
    return _pipe.pipe;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function () {
    return _noop.noop;
  }
});
Object.defineProperty(exports, "identity", {
  enumerable: true,
  get: function () {
    return _identity.identity;
  }
});
Object.defineProperty(exports, "isObservable", {
  enumerable: true,
  get: function () {
    return _isObservable.isObservable;
  }
});
Object.defineProperty(exports, "ArgumentOutOfRangeError", {
  enumerable: true,
  get: function () {
    return _ArgumentOutOfRangeError.ArgumentOutOfRangeError;
  }
});
Object.defineProperty(exports, "EmptyError", {
  enumerable: true,
  get: function () {
    return _EmptyError.EmptyError;
  }
});
Object.defineProperty(exports, "ObjectUnsubscribedError", {
  enumerable: true,
  get: function () {
    return _ObjectUnsubscribedError.ObjectUnsubscribedError;
  }
});
Object.defineProperty(exports, "UnsubscriptionError", {
  enumerable: true,
  get: function () {
    return _UnsubscriptionError.UnsubscriptionError;
  }
});
Object.defineProperty(exports, "TimeoutError", {
  enumerable: true,
  get: function () {
    return _TimeoutError.TimeoutError;
  }
});
Object.defineProperty(exports, "bindCallback", {
  enumerable: true,
  get: function () {
    return _bindCallback.bindCallback;
  }
});
Object.defineProperty(exports, "bindNodeCallback", {
  enumerable: true,
  get: function () {
    return _bindNodeCallback.bindNodeCallback;
  }
});
Object.defineProperty(exports, "combineLatest", {
  enumerable: true,
  get: function () {
    return _combineLatest.combineLatest;
  }
});
Object.defineProperty(exports, "concat", {
  enumerable: true,
  get: function () {
    return _concat.concat;
  }
});
Object.defineProperty(exports, "defer", {
  enumerable: true,
  get: function () {
    return _defer.defer;
  }
});
Object.defineProperty(exports, "empty", {
  enumerable: true,
  get: function () {
    return _empty.empty;
  }
});
Object.defineProperty(exports, "EMPTY", {
  enumerable: true,
  get: function () {
    return _empty.EMPTY;
  }
});
Object.defineProperty(exports, "forkJoin", {
  enumerable: true,
  get: function () {
    return _forkJoin.forkJoin;
  }
});
Object.defineProperty(exports, "from", {
  enumerable: true,
  get: function () {
    return _from.from;
  }
});
Object.defineProperty(exports, "fromEvent", {
  enumerable: true,
  get: function () {
    return _fromEvent.fromEvent;
  }
});
Object.defineProperty(exports, "fromEventPattern", {
  enumerable: true,
  get: function () {
    return _fromEventPattern.fromEventPattern;
  }
});
Object.defineProperty(exports, "generate", {
  enumerable: true,
  get: function () {
    return _generate.generate;
  }
});
Object.defineProperty(exports, "iif", {
  enumerable: true,
  get: function () {
    return _iif.iif;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function () {
    return _interval.interval;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.merge;
  }
});
Object.defineProperty(exports, "never", {
  enumerable: true,
  get: function () {
    return _never.never;
  }
});
Object.defineProperty(exports, "NEVER", {
  enumerable: true,
  get: function () {
    return _never.NEVER;
  }
});
Object.defineProperty(exports, "of", {
  enumerable: true,
  get: function () {
    return _of.of;
  }
});
Object.defineProperty(exports, "onErrorResumeNext", {
  enumerable: true,
  get: function () {
    return _onErrorResumeNext.onErrorResumeNext;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function () {
    return _pairs.pairs;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function () {
    return _partition.partition;
  }
});
Object.defineProperty(exports, "race", {
  enumerable: true,
  get: function () {
    return _race.race;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function () {
    return _range.range;
  }
});
Object.defineProperty(exports, "throwError", {
  enumerable: true,
  get: function () {
    return _throwError.throwError;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function () {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "using", {
  enumerable: true,
  get: function () {
    return _using.using;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.zip;
  }
});
Object.defineProperty(exports, "scheduled", {
  enumerable: true,
  get: function () {
    return _scheduled.scheduled;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _config.config;
  }
});

var _Observable = require("./internal/Observable");

var _ConnectableObservable = require("./internal/observable/ConnectableObservable");

var _groupBy = require("./internal/operators/groupBy");

var _observable = require("./internal/symbol/observable");

var _Subject = require("./internal/Subject");

var _BehaviorSubject = require("./internal/BehaviorSubject");

var _ReplaySubject = require("./internal/ReplaySubject");

var _AsyncSubject = require("./internal/AsyncSubject");

var _asap = require("./internal/scheduler/asap");

var _async = require("./internal/scheduler/async");

var _queue = require("./internal/scheduler/queue");

var _animationFrame = require("./internal/scheduler/animationFrame");

var _VirtualTimeScheduler = require("./internal/scheduler/VirtualTimeScheduler");

var _Scheduler = require("./internal/Scheduler");

var _Subscription = require("./internal/Subscription");

var _Subscriber = require("./internal/Subscriber");

var _Notification = require("./internal/Notification");

var _pipe = require("./internal/util/pipe");

var _noop = require("./internal/util/noop");

var _identity = require("./internal/util/identity");

var _isObservable = require("./internal/util/isObservable");

var _ArgumentOutOfRangeError = require("./internal/util/ArgumentOutOfRangeError");

var _EmptyError = require("./internal/util/EmptyError");

var _ObjectUnsubscribedError = require("./internal/util/ObjectUnsubscribedError");

var _UnsubscriptionError = require("./internal/util/UnsubscriptionError");

var _TimeoutError = require("./internal/util/TimeoutError");

var _bindCallback = require("./internal/observable/bindCallback");

var _bindNodeCallback = require("./internal/observable/bindNodeCallback");

var _combineLatest = require("./internal/observable/combineLatest");

var _concat = require("./internal/observable/concat");

var _defer = require("./internal/observable/defer");

var _empty = require("./internal/observable/empty");

var _forkJoin = require("./internal/observable/forkJoin");

var _from = require("./internal/observable/from");

var _fromEvent = require("./internal/observable/fromEvent");

var _fromEventPattern = require("./internal/observable/fromEventPattern");

var _generate = require("./internal/observable/generate");

var _iif = require("./internal/observable/iif");

var _interval = require("./internal/observable/interval");

var _merge = require("./internal/observable/merge");

var _never = require("./internal/observable/never");

var _of = require("./internal/observable/of");

var _onErrorResumeNext = require("./internal/observable/onErrorResumeNext");

var _pairs = require("./internal/observable/pairs");

var _partition = require("./internal/observable/partition");

var _race = require("./internal/observable/race");

var _range = require("./internal/observable/range");

var _throwError = require("./internal/observable/throwError");

var _timer = require("./internal/observable/timer");

var _using = require("./internal/observable/using");

var _zip = require("./internal/observable/zip");

var _scheduled = require("./internal/scheduled/scheduled");

var _config = require("./internal/config");
},{"./internal/Observable":"eNLs","./internal/observable/ConnectableObservable":"CWP9","./internal/operators/groupBy":"NOba","./internal/symbol/observable":"ufLg","./internal/Subject":"ChYR","./internal/BehaviorSubject":"vz6i","./internal/ReplaySubject":"fnPk","./internal/AsyncSubject":"eFQJ","./internal/scheduler/asap":"hGLO","./internal/scheduler/async":"hPfc","./internal/scheduler/queue":"LwhG","./internal/scheduler/animationFrame":"XSA2","./internal/scheduler/VirtualTimeScheduler":"tPIC","./internal/Scheduler":"PEqa","./internal/Subscription":"kylD","./internal/Subscriber":"Cb5c","./internal/Notification":"Yyds","./internal/util/pipe":"RKca","./internal/util/noop":"Kkj8","./internal/util/identity":"u6is","./internal/util/isObservable":"has7","./internal/util/ArgumentOutOfRangeError":"zbvn","./internal/util/EmptyError":"aprA","./internal/util/ObjectUnsubscribedError":"aESt","./internal/util/UnsubscriptionError":"J94B","./internal/util/TimeoutError":"AHhI","./internal/observable/bindCallback":"amVY","./internal/observable/bindNodeCallback":"n9wG","./internal/observable/combineLatest":"hTSZ","./internal/observable/concat":"ZFK1","./internal/observable/defer":"qA6d","./internal/observable/empty":"yJHz","./internal/observable/forkJoin":"kgMP","./internal/observable/from":"mcUj","./internal/observable/fromEvent":"iv30","./internal/observable/fromEventPattern":"tRvz","./internal/observable/generate":"taDX","./internal/observable/iif":"MkQo","./internal/observable/interval":"EZOX","./internal/observable/merge":"FCPu","./internal/observable/never":"S6Z7","./internal/observable/of":"ejbS","./internal/observable/onErrorResumeNext":"lCXO","./internal/observable/pairs":"VFVu","./internal/observable/partition":"X4vB","./internal/observable/race":"BQup","./internal/observable/range":"TL3y","./internal/observable/throwError":"PeYS","./internal/observable/timer":"Mt5U","./internal/observable/using":"gqLh","./internal/observable/zip":"Xq91","./internal/scheduled/scheduled":"P1uA","./internal/config":"Jhcl"}],"FRly":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"Quj6":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"aqZJ":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"aMB2":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"FRly","ieee754":"Quj6","isarray":"aqZJ","buffer":"aMB2"}],"HJaA":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
var define;
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

},{"buffer":"aMB2"}],"O2jE":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vis_network_1 = __importDefault(require("vis-network"));

var vis_timeline_1 = require("vis-timeline");

var rxjs_1 = require("rxjs");

var lodash_1 = require("lodash");

vis_timeline_1.moment.updateLocale("en", {
  relativeTime: {
    s: "%d seconds"
  }
});
console.log("Evalutated data.ts");
var data = {
  nodes: new vis_network_1.default.DataSet(),
  edges: new vis_network_1.default.DataSet()
};
var expirationTime = undefined;
rxjs_1.interval(1000).subscribe(updateExpirationTimer);
rxjs_1.interval(1000).subscribe(updateGraphFeatures);

function addNode(id, group) {
  if (group === void 0) {
    group = 0;
  }

  if (expirationTime && vis_timeline_1.moment().isAfter(expirationTime)) {
    console.error("Can not add node, file expired");
    console.log({
      now: vis_timeline_1.moment(),
      extendedTo: expirationTime
    });
    return;
  }

  if (!expirationTime) {
    expirationTime = vis_timeline_1.moment();
  }

  data.nodes.add({
    id: id,
    group: group
  });
  expirationTime = expirationTime.add(4000, "ms");
}

exports.addNode = addNode;

function updateNode(id, group) {
  data.nodes.update({
    id: id,
    group: group
  });
}

exports.updateNode = updateNode;

function removeNode(id) {
  data.nodes.remove({
    id: id
  });
}

exports.removeNode = removeNode;

function addEdge(from, to, hidden) {
  if (hidden === void 0) {
    hidden = false;
  }

  data.edges.add({
    from: from,
    to: to,
    hidden: hidden
  });
}

exports.addEdge = addEdge;

function clearNodes() {
  data.nodes.clear();
  data.edges.clear();
}

exports.clearNodes = clearNodes;

function isExtinct() {
  return vis_timeline_1.moment().isAfter(expirationTime);
}

exports.isExtinct = isExtinct;

function restore(nodes, edges) {
  if (nodes) {
    nodes.forEach(function (node) {
      addNode(node.id, 0);
    });
  }

  if (edges) {
    edges.forEach(function (edge) {
      addEdge(edge.from, edge.to, false);
    });
  }
}

exports.restore = restore;

function dump() {
  console.log(JSON.stringify(data.nodes.get()));
  console.log(JSON.stringify(data.edges.get()));
}

exports.dump = dump;

function updateExpirationTimer() {
  if (expirationTime) {
    document.getElementById("expiration-timer").textContent = "File expire " + expirationTime.fromNow();
  }
}

function updateGraphFeatures() {
  (function updateTopInDegree() {
    var tos = lodash_1.countBy(data.edges.get(), "to");
    var sorted = lodash_1.chain(tos).map(function (cnt, to) {
      return {
        to: to,
        count: cnt
      };
    }).sortBy("count").takeRight(10).value();
    document.getElementById("max-in-degree").textContent = "Top10 In-Degree: " + sorted.reverse().map(function (_a) {
      var to = _a.to,
          count = _a.count;
      return "\uD835\uDF93(" + to + ") = " + count;
    }).join(" | ");
  })();

  (function updateTopOutDegree() {
    var froms = lodash_1.countBy(data.edges.get(), "from");
    var sorted = lodash_1.chain(froms).map(function (cnt, from) {
      return {
        from: from,
        count: cnt
      };
    }).sortBy("count").takeRight(10).value();
    document.getElementById("max-out-degree").textContent = "Top10 Out-Degree: " + sorted.reverse().map(function (_a) {
      var from = _a.from,
          count = _a.count;
      return "\uD835\uDF93(" + from + ") = " + count;
    }).join(" | ");
  })();
}

exports.default = data;
},{"vis-network":"isAo","vis-timeline":"w89l","rxjs":"qwSA","lodash":"HJaA"}],"gvrn":[function(require,module,exports) {
module.exports = [{
  "from": 1,
  "to": 0
}, {
  "from": 2,
  "to": 1
}, {
  "from": 2,
  "to": 0
}, {
  "from": 3,
  "to": 0
}, {
  "from": 3,
  "to": 1
}, {
  "from": 4,
  "to": 2
}, {
  "from": 5,
  "to": 4
}, {
  "from": 6,
  "to": 5
}, {
  "from": 6,
  "to": 4
}, {
  "from": 6,
  "to": 0
}, {
  "from": 7,
  "to": 1
}, {
  "from": 7,
  "to": 3
}, {
  "from": 7,
  "to": 2
}, {
  "from": 7,
  "to": 5
}, {
  "from": 8,
  "to": 1
}, {
  "from": 8,
  "to": 4
}, {
  "from": 8,
  "to": 5
}, {
  "from": 9,
  "to": 1
}, {
  "from": 9,
  "to": 3
}, {
  "from": 10,
  "to": 7
}, {
  "from": 11,
  "to": 4
}, {
  "from": 11,
  "to": 5
}, {
  "from": 12,
  "to": 0
}, {
  "from": 12,
  "to": 2
}, {
  "from": 13,
  "to": 2
}, {
  "from": 13,
  "to": 5
}, {
  "from": 13,
  "to": 7
}, {
  "from": 14,
  "to": 0
}, {
  "from": 14,
  "to": 2
}, {
  "from": 14,
  "to": 12
}, {
  "from": 15,
  "to": 5
}, {
  "from": 15,
  "to": 7
}, {
  "from": 15,
  "to": 13
}, {
  "from": 16,
  "to": 1
}, {
  "from": 16,
  "to": 3
}, {
  "from": 17,
  "to": 4
}, {
  "from": 17,
  "to": 8
}, {
  "from": 18,
  "to": 0
}, {
  "from": 18,
  "to": 1
}, {
  "from": 19,
  "to": 2
}, {
  "from": 19,
  "to": 12
}, {
  "from": 20,
  "to": 1
}, {
  "from": 20,
  "to": 18
}, {
  "from": 21,
  "to": 2
}, {
  "from": 21,
  "to": 7
}, {
  "from": 21,
  "to": 13
}, {
  "from": 22,
  "to": 5
}, {
  "from": 22,
  "to": 11
}, {
  "from": 23,
  "to": 1
}, {
  "from": 23,
  "to": 2
}, {
  "from": 23,
  "to": 5
}, {
  "from": 23,
  "to": 7
}, {
  "from": 24,
  "to": 0
}, {
  "from": 24,
  "to": 6
}, {
  "from": 25,
  "to": 0
}, {
  "from": 25,
  "to": 1
}, {
  "from": 26,
  "to": 17
}, {
  "from": 27,
  "to": 4
}, {
  "from": 27,
  "to": 0
}, {
  "from": 27,
  "to": 6
}, {
  "from": 28,
  "to": 0
}, {
  "from": 28,
  "to": 1
}, {
  "from": 28,
  "to": 3
}, {
  "from": 29,
  "to": 1
}, {
  "from": 29,
  "to": 3
}, {
  "from": 29,
  "to": 16
}, {
  "from": 30,
  "to": 0
}, {
  "from": 30,
  "to": 1
}, {
  "from": 30,
  "to": 18
}, {
  "from": 31,
  "to": 30
}, {
  "from": 32,
  "to": 7
}, {
  "from": 32,
  "to": 13
}, {
  "from": 33,
  "to": 1
}, {
  "from": 33,
  "to": 29
}, {
  "from": 34,
  "to": 1
}, {
  "from": 34,
  "to": 9
}, {
  "from": 35,
  "to": 4
}, {
  "from": 35,
  "to": 17
}, {
  "from": 36,
  "to": 0
}, {
  "from": 36,
  "to": 6
}, {
  "from": 37,
  "to": 36
}, {
  "from": 38,
  "to": 0
}, {
  "from": 38,
  "to": 27
}, {
  "from": 39,
  "to": 1
}, {
  "from": 39,
  "to": 5
}, {
  "from": 39,
  "to": 8
}, {
  "from": 40,
  "to": 5
}, {
  "from": 41,
  "to": 1
}, {
  "from": 42,
  "to": 2
}, {
  "from": 42,
  "to": 4
}, {
  "from": 43,
  "to": 11
}, {
  "from": 44,
  "to": 12
}, {
  "from": 44,
  "to": 19
}, {
  "from": 45,
  "to": 1
}, {
  "from": 45,
  "to": 2
}, {
  "from": 45,
  "to": 7
}, {
  "from": 45,
  "to": 23
}, {
  "from": 46,
  "to": 1
}, {
  "from": 46,
  "to": 4
}, {
  "from": 46,
  "to": 8
}, {
  "from": 47,
  "to": 3
}, {
  "from": 47,
  "to": 5
}, {
  "from": 47,
  "to": 7
}, {
  "from": 48,
  "to": 1
}, {
  "from": 48,
  "to": 18
}, {
  "from": 48,
  "to": 30
}, {
  "from": 49,
  "to": 4
}, {
  "from": 49,
  "to": 17
}, {
  "from": 49,
  "to": 35
}, {
  "from": 50,
  "to": 43
}, {
  "from": 51,
  "to": 49
}, {
  "from": 52,
  "to": 0
}, {
  "from": 52,
  "to": 1
}, {
  "from": 52,
  "to": 30
}, {
  "from": 53,
  "to": 1
}, {
  "from": 53,
  "to": 5
}, {
  "from": 53,
  "to": 8
}, {
  "from": 53,
  "to": 39
}, {
  "from": 54,
  "to": 0
}, {
  "from": 54,
  "to": 1
}, {
  "from": 54,
  "to": 3
}, {
  "from": 54,
  "to": 28
}, {
  "from": 55,
  "to": 5
}, {
  "from": 56,
  "to": 2
}, {
  "from": 56,
  "to": 14
}, {
  "from": 57,
  "to": 37
}, {
  "from": 58,
  "to": 13
}, {
  "from": 59,
  "to": 1
}, {
  "from": 59,
  "to": 29
}, {
  "from": 59,
  "to": 33
}, {
  "from": 60,
  "to": 5
}, {
  "from": 60,
  "to": 6
}, {
  "from": 61,
  "to": 5
}, {
  "from": 61,
  "to": 8
}, {
  "from": 61,
  "to": 39
}, {
  "from": 62,
  "to": 5
}, {
  "from": 62,
  "to": 6
}, {
  "from": 62,
  "to": 60
}, {
  "from": 63,
  "to": 0
}, {
  "from": 63,
  "to": 1
}, {
  "from": 63,
  "to": 18
}, {
  "from": 64,
  "to": 1
}, {
  "from": 64,
  "to": 53
}, {
  "from": 65,
  "to": 10
}, {
  "from": 66,
  "to": 0
}, {
  "from": 66,
  "to": 36
}, {
  "from": 67,
  "to": 36
}, {
  "from": 68,
  "to": 1
}, {
  "from": 68,
  "to": 4
}, {
  "from": 68,
  "to": 46
}, {
  "from": 69,
  "to": 36
}, {
  "from": 69,
  "to": 66
}, {
  "from": 70,
  "to": 27
}, {
  "from": 70,
  "to": 38
}, {
  "from": 71,
  "to": 29
}, {
  "from": 72,
  "to": 0
}, {
  "from": 72,
  "to": 24
}, {
  "from": 73,
  "to": 13
}, {
  "from": 73,
  "to": 21
}, {
  "from": 74,
  "to": 10
}, {
  "from": 75,
  "to": 1
}, {
  "from": 75,
  "to": 16
}, {
  "from": 76,
  "to": 1
}, {
  "from": 76,
  "to": 33
}, {
  "from": 76,
  "to": 59
}, {
  "from": 77,
  "to": 1
}, {
  "from": 78,
  "to": 10
}, {
  "from": 79,
  "to": 18
}, {
  "from": 79,
  "to": 20
}, {
  "from": 80,
  "to": 69
}, {
  "from": 81,
  "to": 36
}, {
  "from": 81,
  "to": 37
}, {
  "from": 82,
  "to": 27
}, {
  "from": 82,
  "to": 70
}, {
  "from": 83,
  "to": 0
}, {
  "from": 83,
  "to": 3
}, {
  "from": 83,
  "to": 54
}, {
  "from": 84,
  "to": 36
}, {
  "from": 84,
  "to": 67
}, {
  "from": 85,
  "to": 67
}, {
  "from": 86,
  "to": 4
}, {
  "from": 87,
  "to": 5
}, {
  "from": 87,
  "to": 15
}, {
  "from": 88,
  "to": 1
}, {
  "from": 88,
  "to": 25
}, {
  "from": 89,
  "to": 11
}, {
  "from": 89,
  "to": 43
}, {
  "from": 90,
  "to": 36
}, {
  "from": 90,
  "to": 69
}, {
  "from": 91,
  "to": 4
}, {
  "from": 91,
  "to": 17
}, {
  "from": 91,
  "to": 35
}, {
  "from": 92,
  "to": 24
}, {
  "from": 93,
  "to": 36
}, {
  "from": 93,
  "to": 84
}, {
  "from": 94,
  "to": 52
}, {
  "from": 95,
  "to": 1
}, {
  "from": 95,
  "to": 20
}, {
  "from": 96,
  "to": 18
}, {
  "from": 96,
  "to": 79
}, {
  "from": 97,
  "to": 39
}, {
  "from": 97,
  "to": 61
}, {
  "from": 98,
  "to": 4
}, {
  "from": 98,
  "to": 8
}, {
  "from": 98,
  "to": 17
}, {
  "from": 99,
  "to": 8
}, {
  "from": 99,
  "to": 39
}, {
  "from": 100,
  "to": 0
}, {
  "from": 100,
  "to": 30
}, {
  "from": 101,
  "to": 10
}, {
  "from": 101,
  "to": 78
}, {
  "from": 102,
  "to": 4
}, {
  "from": 102,
  "to": 0
}, {
  "from": 102,
  "to": 6
}, {
  "from": 102,
  "to": 27
}, {
  "from": 103,
  "to": 11
}, {
  "from": 103,
  "to": 43
}, {
  "from": 103,
  "to": 89
}, {
  "from": 104,
  "to": 65
}, {
  "from": 105,
  "to": 52
}, {
  "from": 105,
  "to": 94
}, {
  "from": 106,
  "to": 0
}, {
  "from": 106,
  "to": 100
}, {
  "from": 107,
  "to": 5
}, {
  "from": 107,
  "to": 22
}, {
  "from": 108,
  "to": 89
}, {
  "from": 109,
  "to": 17
}, {
  "from": 109,
  "to": 26
}, {
  "from": 110,
  "to": 8
}, {
  "from": 110,
  "to": 39
}, {
  "from": 111,
  "to": 37
}, {
  "from": 111,
  "to": 57
}, {
  "from": 112,
  "to": 52
}, {
  "from": 112,
  "to": 94
}, {
  "from": 113,
  "to": 85
}, {
  "from": 114,
  "to": 81
}, {
  "from": 115,
  "to": 4
}, {
  "from": 115,
  "to": 8
}, {
  "from": 115,
  "to": 46
}, {
  "from": 116,
  "to": 94
}, {
  "from": 117,
  "to": 101
}, {
  "from": 118,
  "to": 13
}, {
  "from": 118,
  "to": 58
}, {
  "from": 119,
  "to": 19
}, {
  "from": 119,
  "to": 44
}, {
  "from": 120,
  "to": 1
}, {
  "from": 120,
  "to": 9
}, {
  "from": 120,
  "to": 34
}, {
  "from": 121,
  "to": 77
}, {
  "from": 122,
  "to": 0
}, {
  "from": 122,
  "to": 24
}, {
  "from": 123,
  "to": 116
}, {
  "from": 124,
  "to": 61
}, {
  "from": 125,
  "to": 14
}, {
  "from": 125,
  "to": 56
}, {
  "from": 126,
  "to": 2
}, {
  "from": 126,
  "to": 56
}, {
  "from": 127,
  "to": 4
}, {
  "from": 127,
  "to": 5
}, {
  "from": 128,
  "to": 10
}, {
  "from": 128,
  "to": 74
}, {
  "from": 129,
  "to": 14
}, {
  "from": 130,
  "to": 1
}, {
  "from": 130,
  "to": 23
}, {
  "from": 131,
  "to": 113
}, {
  "from": 132,
  "to": 27
}, {
  "from": 133,
  "to": 5
}, {
  "from": 133,
  "to": 8
}, {
  "from": 133,
  "to": 39
}, {
  "from": 134,
  "to": 128
}, {
  "from": 135,
  "to": 60
}, {
  "from": 135,
  "to": 62
}, {
  "from": 136,
  "to": 27
}, {
  "from": 136,
  "to": 102
}, {
  "from": 137,
  "to": 17
}, {
  "from": 137,
  "to": 35
}, {
  "from": 138,
  "to": 1
}, {
  "from": 138,
  "to": 3
}, {
  "from": 139,
  "to": 60
}, {
  "from": 139,
  "to": 135
}, {
  "from": 140,
  "to": 0
}, {
  "from": 140,
  "to": 106
}, {
  "from": 141,
  "to": 36
}, {
  "from": 141,
  "to": 69
}, {
  "from": 141,
  "to": 90
}, {
  "from": 142,
  "to": 1
}, {
  "from": 142,
  "to": 20
}, {
  "from": 143,
  "to": 0
}, {
  "from": 143,
  "to": 36
}, {
  "from": 143,
  "to": 66
}, {
  "from": 144,
  "to": 12
}, {
  "from": 144,
  "to": 19
}, {
  "from": 145,
  "to": 28
}, {
  "from": 145,
  "to": 54
}, {
  "from": 146,
  "to": 14
}, {
  "from": 147,
  "to": 1
}, {
  "from": 147,
  "to": 88
}, {
  "from": 148,
  "to": 94
}, {
  "from": 148,
  "to": 112
}, {
  "from": 149,
  "to": 1
}, {
  "from": 149,
  "to": 41
}, {
  "from": 150,
  "to": 4
}, {
  "from": 151,
  "to": 0
}, {
  "from": 151,
  "to": 24
}, {
  "from": 152,
  "to": 4
}, {
  "from": 152,
  "to": 91
}, {
  "from": 153,
  "to": 0
}, {
  "from": 153,
  "to": 36
}, {
  "from": 154,
  "to": 118
}, {
  "from": 155,
  "to": 60
}, {
  "from": 155,
  "to": 62
}, {
  "from": 156,
  "to": 4
}, {
  "from": 156,
  "to": 152
}, {
  "from": 157,
  "to": 64
}, {
  "from": 158,
  "to": 1
}, {
  "from": 158,
  "to": 16
}, {
  "from": 158,
  "to": 75
}, {
  "from": 159,
  "to": 1
}, {
  "from": 159,
  "to": 29
}, {
  "from": 159,
  "to": 33
}, {
  "from": 160,
  "to": 119
}, {
  "from": 161,
  "to": 41
}, {
  "from": 162,
  "to": 5
}, {
  "from": 162,
  "to": 127
}, {
  "from": 163,
  "to": 17
}, {
  "from": 163,
  "to": 35
}, {
  "from": 163,
  "to": 137
}, {
  "from": 164,
  "to": 4
}, {
  "from": 164,
  "to": 152
}, {
  "from": 164,
  "to": 156
}, {
  "from": 165,
  "to": 0
}, {
  "from": 165,
  "to": 6
}, {
  "from": 165,
  "to": 36
}, {
  "from": 166,
  "to": 10
}, {
  "from": 166,
  "to": 65
}, {
  "from": 167,
  "to": 94
}, {
  "from": 167,
  "to": 148
}, {
  "from": 168,
  "to": 0
}, {
  "from": 168,
  "to": 100
}, {
  "from": 169,
  "to": 52
}, {
  "from": 169,
  "to": 94
}, {
  "from": 169,
  "to": 105
}, {
  "from": 170,
  "to": 0
}, {
  "from": 170,
  "to": 168
}, {
  "from": 171,
  "to": 75
}, {
  "from": 172,
  "to": 79
}, {
  "from": 172,
  "to": 96
}, {
  "from": 173,
  "to": 4
}, {
  "from": 173,
  "to": 17
}, {
  "from": 173,
  "to": 35
}, {
  "from": 174,
  "to": 5
}, {
  "from": 174,
  "to": 7
}, {
  "from": 174,
  "to": 23
}, {
  "from": 175,
  "to": 7
}, {
  "from": 175,
  "to": 10
}, {
  "from": 176,
  "to": 50
}, {
  "from": 177,
  "to": 1
}, {
  "from": 177,
  "to": 46
}, {
  "from": 178,
  "to": 113
}, {
  "from": 178,
  "to": 131
}, {
  "from": 179,
  "to": 65
}, {
  "from": 180,
  "to": 2
}, {
  "from": 180,
  "to": 4
}, {
  "from": 181,
  "to": 44
}, {
  "from": 181,
  "to": 119
}, {
  "from": 182,
  "to": 67
}, {
  "from": 183,
  "to": 17
}, {
  "from": 183,
  "to": 35
}, {
  "from": 184,
  "to": 7
}, {
  "from": 184,
  "to": 13
}, {
  "from": 184,
  "to": 32
}, {
  "from": 185,
  "to": 26
}, {
  "from": 186,
  "to": 113
}, {
  "from": 187,
  "to": 124
}, {
  "from": 188,
  "to": 36
}, {
  "from": 188,
  "to": 90
}, {
  "from": 189,
  "to": 1
}, {
  "from": 189,
  "to": 147
}, {
  "from": 190,
  "to": 3
}, {
  "from": 190,
  "to": 16
}, {
  "from": 190,
  "to": 29
}, {
  "from": 191,
  "to": 5
}, {
  "from": 191,
  "to": 8
}, {
  "from": 191,
  "to": 53
}, {
  "from": 192,
  "to": 156
}, {
  "from": 193,
  "to": 94
}, {
  "from": 193,
  "to": 116
}, {
  "from": 194,
  "to": 1
}, {
  "from": 194,
  "to": 23
}, {
  "from": 194,
  "to": 45
}, {
  "from": 195,
  "to": 1
}, {
  "from": 195,
  "to": 142
}, {
  "from": 196,
  "to": 5
}, {
  "from": 196,
  "to": 191
}, {
  "from": 197,
  "to": 1
}, {
  "from": 197,
  "to": 34
}, {
  "from": 197,
  "to": 120
}, {
  "from": 198,
  "to": 56
}, {
  "from": 198,
  "to": 125
}, {
  "from": 199,
  "to": 55
}, {
  "from": 200,
  "to": 82
}, {
  "from": 201,
  "to": 13
}, {
  "from": 201,
  "to": 118
}, {
  "from": 202,
  "to": 199
}, {
  "from": 203,
  "to": 25
}, {
  "from": 203,
  "to": 88
}, {
  "from": 204,
  "to": 1
}, {
  "from": 204,
  "to": 189
}, {
  "from": 205,
  "to": 1
}, {
  "from": 205,
  "to": 18
}, {
  "from": 206,
  "to": 64
}, {
  "from": 207,
  "to": 13
}, {
  "from": 207,
  "to": 21
}, {
  "from": 207,
  "to": 73
}, {
  "from": 208,
  "to": 26
}, {
  "from": 209,
  "to": 33
}, {
  "from": 209,
  "to": 59
}, {
  "from": 210,
  "to": 94
}, {
  "from": 210,
  "to": 148
}, {
  "from": 210,
  "to": 167
}, {
  "from": 211,
  "to": 7
}, {
  "from": 211,
  "to": 23
}, {
  "from": 211,
  "to": 174
}, {
  "from": 212,
  "to": 147
}, {
  "from": 213,
  "to": 29
}, {
  "from": 213,
  "to": 71
}, {
  "from": 214,
  "to": 94
}, {
  "from": 214,
  "to": 116
}, {
  "from": 215,
  "to": 1
}, {
  "from": 215,
  "to": 3
}, {
  "from": 215,
  "to": 138
}, {
  "from": 216,
  "to": 2
}, {
  "from": 216,
  "to": 13
}, {
  "from": 217,
  "to": 116
}, {
  "from": 218,
  "to": 53
}, {
  "from": 218,
  "to": 191
}, {
  "from": 219,
  "to": 1
}, {
  "from": 219,
  "to": 3
}, {
  "from": 219,
  "to": 16
}, {
  "from": 220,
  "to": 4
}, {
  "from": 220,
  "to": 156
}, {
  "from": 221,
  "to": 89
}, {
  "from": 221,
  "to": 108
}, {
  "from": 222,
  "to": 60
}, {
  "from": 222,
  "to": 139
}, {
  "from": 223,
  "to": 5
}, {
  "from": 223,
  "to": 8
}, {
  "from": 223,
  "to": 191
}, {
  "from": 224,
  "to": 0
}, {
  "from": 224,
  "to": 36
}, {
  "from": 225,
  "to": 0
}, {
  "from": 225,
  "to": 1
}, {
  "from": 226,
  "to": 1
}, {
  "from": 226,
  "to": 20
}, {
  "from": 226,
  "to": 95
}, {
  "from": 227,
  "to": 112
}, {
  "from": 227,
  "to": 148
}, {
  "from": 228,
  "to": 7
}, {
  "from": 228,
  "to": 23
}, {
  "from": 228,
  "to": 174
}, {
  "from": 229,
  "to": 25
}, {
  "from": 229,
  "to": 88
}, {
  "from": 229,
  "to": 203
}, {
  "from": 230,
  "to": 121
}, {
  "from": 231,
  "to": 118
}, {
  "from": 231,
  "to": 154
}, {
  "from": 232,
  "to": 0
}, {
  "from": 232,
  "to": 30
}, {
  "from": 232,
  "to": 52
}, {
  "from": 233,
  "to": 64
}, {
  "from": 233,
  "to": 206
}, {
  "from": 234,
  "to": 12
}, {
  "from": 234,
  "to": 19
}, {
  "from": 234,
  "to": 144
}, {
  "from": 235,
  "to": 213
}, {
  "from": 236,
  "to": 186
}, {
  "from": 237,
  "to": 1
}, {
  "from": 237,
  "to": 5
}, {
  "from": 237,
  "to": 8
}, {
  "from": 237,
  "to": 39
}, {
  "from": 238,
  "to": 181
}, {
  "from": 239,
  "to": 1
}, {
  "from": 239,
  "to": 88
}, {
  "from": 239,
  "to": 147
}, {
  "from": 240,
  "to": 31
}, {
  "from": 241,
  "to": 36
}, {
  "from": 241,
  "to": 143
}, {
  "from": 242,
  "to": 230
}, {
  "from": 243,
  "to": 36
}, {
  "from": 243,
  "to": 69
}, {
  "from": 243,
  "to": 90
}, {
  "from": 243,
  "to": 141
}, {
  "from": 244,
  "to": 46
}, {
  "from": 244,
  "to": 115
}, {
  "from": 245,
  "to": 1
}, {
  "from": 245,
  "to": 204
}, {
  "from": 246,
  "to": 35
}, {
  "from": 247,
  "to": 4
}, {
  "from": 247,
  "to": 86
}, {
  "from": 248,
  "to": 11
}, {
  "from": 248,
  "to": 89
}, {
  "from": 249,
  "to": 99
}, {
  "from": 250,
  "to": 1
}, {
  "from": 250,
  "to": 5
}, {
  "from": 250,
  "to": 8
}, {
  "from": 250,
  "to": 39
}, {
  "from": 251,
  "to": 4
}, {
  "from": 251,
  "to": 8
}, {
  "from": 251,
  "to": 115
}, {
  "from": 252,
  "to": 213
}, {
  "from": 252,
  "to": 235
}, {
  "from": 253,
  "to": 17
}, {
  "from": 253,
  "to": 35
}, {
  "from": 253,
  "to": 173
}, {
  "from": 254,
  "to": 18
}, {
  "from": 255,
  "to": 0
}, {
  "from": 255,
  "to": 52
}, {
  "from": 255,
  "to": 232
}, {
  "from": 256,
  "to": 217
}, {
  "from": 257,
  "to": 1
}, {
  "from": 257,
  "to": 18
}, {
  "from": 257,
  "to": 48
}, {
  "from": 258,
  "to": 2
}, {
  "from": 258,
  "to": 4
}, {
  "from": 258,
  "to": 180
}, {
  "from": 259,
  "to": 77
}, {
  "from": 259,
  "to": 121
}, {
  "from": 260,
  "to": 0
}, {
  "from": 260,
  "to": 6
}, {
  "from": 260,
  "to": 36
}, {
  "from": 260,
  "to": 165
}, {
  "from": 261,
  "to": 5
}, {
  "from": 261,
  "to": 7
}, {
  "from": 261,
  "to": 47
}, {
  "from": 262,
  "to": 60
}, {
  "from": 262,
  "to": 62
}, {
  "from": 262,
  "to": 135
}, {
  "from": 263,
  "to": 33
}, {
  "from": 263,
  "to": 209
}, {
  "from": 264,
  "to": 41
}, {
  "from": 265,
  "to": 8
}, {
  "from": 265,
  "to": 46
}, {
  "from": 266,
  "to": 77
}, {
  "from": 266,
  "to": 121
}, {
  "from": 267,
  "to": 8
}, {
  "from": 267,
  "to": 39
}, {
  "from": 267,
  "to": 110
}, {
  "from": 268,
  "to": 156
}, {
  "from": 268,
  "to": 192
}, {
  "from": 269,
  "to": 1
}, {
  "from": 269,
  "to": 3
}, {
  "from": 269,
  "to": 16
}, {
  "from": 269,
  "to": 29
}, {
  "from": 270,
  "to": 171
}, {
  "from": 271,
  "to": 18
}, {
  "from": 271,
  "to": 48
}, {
  "from": 272,
  "to": 94
}, {
  "from": 272,
  "to": 148
}, {
  "from": 272,
  "to": 167
}, {
  "from": 273,
  "to": 137
}, {
  "from": 274,
  "to": 77
}, {
  "from": 274,
  "to": 121
}, {
  "from": 275,
  "to": 1
}, {
  "from": 275,
  "to": 3
}, {
  "from": 275,
  "to": 269
}, {
  "from": 276,
  "to": 8
}, {
  "from": 276,
  "to": 39
}, {
  "from": 276,
  "to": 110
}, {
  "from": 277,
  "to": 17
}, {
  "from": 277,
  "to": 35
}, {
  "from": 277,
  "to": 173
}, {
  "from": 277,
  "to": 253
}, {
  "from": 278,
  "to": 233
}, {
  "from": 279,
  "to": 69
}, {
  "from": 279,
  "to": 90
}, {
  "from": 279,
  "to": 141
}, {
  "from": 280,
  "to": 13
}, {
  "from": 280,
  "to": 58
}, {
  "from": 281,
  "to": 1
}, {
  "from": 281,
  "to": 142
}, {
  "from": 281,
  "to": 195
}, {
  "from": 282,
  "to": 2
}, {
  "from": 282,
  "to": 216
}, {
  "from": 283,
  "to": 172
}, {
  "from": 284,
  "to": 74
}, {
  "from": 285,
  "to": 1
}, {
  "from": 285,
  "to": 34
}, {
  "from": 286,
  "to": 38
}, {
  "from": 287,
  "to": 1
}, {
  "from": 287,
  "to": 195
}, {
  "from": 287,
  "to": 281
}, {
  "from": 288,
  "to": 34
}, {
  "from": 289,
  "to": 0
}, {
  "from": 289,
  "to": 2
}, {
  "from": 289,
  "to": 12
}, {
  "from": 289,
  "to": 14
}, {
  "from": 290,
  "to": 4
}, {
  "from": 290,
  "to": 5
}, {
  "from": 290,
  "to": 8
}, {
  "from": 291,
  "to": 25
}, {
  "from": 291,
  "to": 88
}, {
  "from": 291,
  "to": 203
}, {
  "from": 291,
  "to": 229
}, {
  "from": 292,
  "to": 125
}, {
  "from": 293,
  "to": 5
}, {
  "from": 293,
  "to": 107
}, {
  "from": 294,
  "to": 154
}, {
  "from": 295,
  "to": 16
}, {
  "from": 295,
  "to": 75
}, {
  "from": 296,
  "to": 121
}, {
  "from": 296,
  "to": 274
}, {
  "from": 297,
  "to": 2
}, {
  "from": 297,
  "to": 7
}, {
  "from": 297,
  "to": 21
}, {
  "from": 298,
  "to": 292
}, {
  "from": 299,
  "to": 102
}, {
  "from": 299,
  "to": 136
}, {
  "from": 300,
  "to": 53
}, {
  "from": 300,
  "to": 218
}, {
  "from": 301,
  "to": 11
}, {
  "from": 301,
  "to": 43
}, {
  "from": 301,
  "to": 89
}, {
  "from": 301,
  "to": 103
}, {
  "from": 302,
  "to": 2
}, {
  "from": 302,
  "to": 216
}, {
  "from": 303,
  "to": 11
}, {
  "from": 303,
  "to": 43
}, {
  "from": 303,
  "to": 89
}, {
  "from": 303,
  "to": 103
}, {
  "from": 304,
  "to": 43
}, {
  "from": 304,
  "to": 303
}, {
  "from": 305,
  "to": 1
}, {
  "from": 305,
  "to": 204
}, {
  "from": 305,
  "to": 245
}, {
  "from": 306,
  "to": 0
}, {
  "from": 306,
  "to": 36
}, {
  "from": 306,
  "to": 66
}, {
  "from": 306,
  "to": 143
}, {
  "from": 307,
  "to": 94
}, {
  "from": 307,
  "to": 148
}, {
  "from": 307,
  "to": 210
}, {
  "from": 308,
  "to": 183
}, {
  "from": 309,
  "to": 91
}, {
  "from": 310,
  "to": 167
}, {
  "from": 311,
  "to": 233
}, {
  "from": 312,
  "to": 1
}, {
  "from": 312,
  "to": 245
}, {
  "from": 312,
  "to": 305
}, {
  "from": 313,
  "to": 0
}, {
  "from": 313,
  "to": 2
}, {
  "from": 314,
  "to": 4
}, {
  "from": 314,
  "to": 5
}, {
  "from": 315,
  "to": 307
}, {
  "from": 316,
  "to": 288
}, {
  "from": 317,
  "to": 16
}, {
  "from": 317,
  "to": 295
}, {
  "from": 318,
  "to": 113
}, {
  "from": 318,
  "to": 131
}, {
  "from": 319,
  "to": 145
}, {
  "from": 320,
  "to": 36
}, {
  "from": 320,
  "to": 66
}, {
  "from": 321,
  "to": 2
}, {
  "from": 321,
  "to": 14
}, {
  "from": 321,
  "to": 56
}, {
  "from": 322,
  "to": 153
}, {
  "from": 323,
  "to": 41
}, {
  "from": 323,
  "to": 264
}, {
  "from": 324,
  "to": 315
}, {
  "from": 325,
  "to": 29
}, {
  "from": 325,
  "to": 33
}, {
  "from": 325,
  "to": 159
}, {
  "from": 326,
  "to": 16
}, {
  "from": 326,
  "to": 29
}, {
  "from": 326,
  "to": 190
}, {
  "from": 327,
  "to": 173
}, {
  "from": 327,
  "to": 277
}, {
  "from": 328,
  "to": 27
}, {
  "from": 328,
  "to": 132
}, {
  "from": 329,
  "to": 36
}, {
  "from": 329,
  "to": 188
}, {
  "from": 330,
  "to": 130
}, {
  "from": 331,
  "to": 1
}, {
  "from": 331,
  "to": 39
}, {
  "from": 332,
  "to": 213
}, {
  "from": 332,
  "to": 235
}, {
  "from": 333,
  "to": 2
}, {
  "from": 333,
  "to": 13
}, {
  "from": 334,
  "to": 60
}, {
  "from": 334,
  "to": 62
}, {
  "from": 334,
  "to": 135
}, {
  "from": 335,
  "to": 171
}, {
  "from": 335,
  "to": 270
}, {
  "from": 336,
  "to": 44
}, {
  "from": 336,
  "to": 119
}, {
  "from": 336,
  "to": 181
}, {
  "from": 337,
  "to": 206
}, {
  "from": 338,
  "to": 286
}, {
  "from": 339,
  "to": 1
}, {
  "from": 339,
  "to": 149
}, {
  "from": 340,
  "to": 4
}, {
  "from": 340,
  "to": 17
}, {
  "from": 340,
  "to": 98
}, {
  "from": 341,
  "to": 1
}, {
  "from": 341,
  "to": 3
}, {
  "from": 341,
  "to": 7
}, {
  "from": 342,
  "to": 30
}, {
  "from": 342,
  "to": 52
}, {
  "from": 342,
  "to": 232
}, {
  "from": 343,
  "to": 248
}, {
  "from": 344,
  "to": 24
}, {
  "from": 344,
  "to": 92
}, {
  "from": 345,
  "to": 1
}, {
  "from": 345,
  "to": 8
}, {
  "from": 345,
  "to": 46
}, {
  "from": 346,
  "to": 1
}, {
  "from": 346,
  "to": 64
}, {
  "from": 347,
  "to": 11
}, {
  "from": 347,
  "to": 89
}, {
  "from": 347,
  "to": 103
}, {
  "from": 347,
  "to": 301
}, {
  "from": 348,
  "to": 248
}, {
  "from": 348,
  "to": 343
}, {
  "from": 349,
  "to": 60
}, {
  "from": 349,
  "to": 62
}, {
  "from": 349,
  "to": 135
}, {
  "from": 350,
  "to": 79
}, {
  "from": 351,
  "to": 39
}, {
  "from": 351,
  "to": 276
}, {
  "from": 352,
  "to": 268
}, {
  "from": 353,
  "to": 16
}, {
  "from": 353,
  "to": 29
}, {
  "from": 353,
  "to": 190
}, {
  "from": 354,
  "to": 12
}, {
  "from": 354,
  "to": 144
}, {
  "from": 354,
  "to": 234
}, {
  "from": 355,
  "to": 3
}, {
  "from": 355,
  "to": 275
}, {
  "from": 356,
  "to": 1
}, {
  "from": 356,
  "to": 5
}, {
  "from": 356,
  "to": 23
}, {
  "from": 357,
  "to": 260
}, {
  "from": 358,
  "to": 24
}, {
  "from": 358,
  "to": 151
}, {
  "from": 359,
  "to": 33
}, {
  "from": 360,
  "to": 10
}, {
  "from": 360,
  "to": 78
}, {
  "from": 361,
  "to": 150
}, {
  "from": 362,
  "to": 3
}, {
  "from": 362,
  "to": 28
}, {
  "from": 363,
  "to": 85
}, {
  "from": 363,
  "to": 113
}, {
  "from": 364,
  "to": 1
}, {
  "from": 364,
  "to": 59
}, {
  "from": 364,
  "to": 76
}, {
  "from": 365,
  "to": 36
}, {
  "from": 365,
  "to": 67
}, {
  "from": 366,
  "to": 27
}, {
  "from": 366,
  "to": 136
}, {
  "from": 367,
  "to": 200
}, {
  "from": 368,
  "to": 251
}, {
  "from": 369,
  "to": 182
}, {
  "from": 370,
  "to": 245
}, {
  "from": 371,
  "to": 112
}, {
  "from": 371,
  "to": 227
}, {
  "from": 372,
  "to": 1
}, {
  "from": 372,
  "to": 9
}, {
  "from": 373,
  "to": 57
}, {
  "from": 374,
  "to": 7
}, {
  "from": 374,
  "to": 341
}, {
  "from": 375,
  "to": 60
}, {
  "from": 375,
  "to": 62
}, {
  "from": 375,
  "to": 135
}, {
  "from": 375,
  "to": 334
}, {
  "from": 376,
  "to": 4
}, {
  "from": 376,
  "to": 5
}, {
  "from": 376,
  "to": 127
}, {
  "from": 377,
  "to": 274
}, {
  "from": 377,
  "to": 296
}, {
  "from": 378,
  "to": 16
}, {
  "from": 378,
  "to": 29
}, {
  "from": 378,
  "to": 190
}, {
  "from": 379,
  "to": 0
}, {
  "from": 379,
  "to": 1
}, {
  "from": 379,
  "to": 18
}, {
  "from": 380,
  "to": 30
}, {
  "from": 380,
  "to": 31
}, {
  "from": 381,
  "to": 7
}, {
  "from": 381,
  "to": 13
}, {
  "from": 381,
  "to": 32
}, {
  "from": 382,
  "to": 204
}, {
  "from": 383,
  "to": 11
}, {
  "from": 383,
  "to": 43
}, {
  "from": 383,
  "to": 89
}, {
  "from": 383,
  "to": 103
}, {
  "from": 383,
  "to": 303
}, {
  "from": 384,
  "to": 246
}, {
  "from": 385,
  "to": 30
}, {
  "from": 385,
  "to": 31
}, {
  "from": 386,
  "to": 62
}, {
  "from": 386,
  "to": 135
}, {
  "from": 386,
  "to": 334
}, {
  "from": 387,
  "to": 343
}, {
  "from": 388,
  "to": 13
}, {
  "from": 388,
  "to": 73
}, {
  "from": 389,
  "to": 88
}, {
  "from": 389,
  "to": 203
}, {
  "from": 389,
  "to": 229
}, {
  "from": 390,
  "to": 162
}, {
  "from": 391,
  "to": 0
}, {
  "from": 391,
  "to": 3
}, {
  "from": 391,
  "to": 83
}, {
  "from": 392,
  "to": 55
}, {
  "from": 393,
  "to": 29
}, {
  "from": 393,
  "to": 353
}, {
  "from": 394,
  "to": 4
}, {
  "from": 394,
  "to": 115
}, {
  "from": 395,
  "to": 7
}, {
  "from": 395,
  "to": 374
}, {
  "from": 396,
  "to": 119
}, {
  "from": 396,
  "to": 336
}, {
  "from": 397,
  "to": 50
}, {
  "from": 397,
  "to": 176
}, {
  "from": 398,
  "to": 217
}, {
  "from": 398,
  "to": 256
}, {
  "from": 399,
  "to": 88
}, {
  "from": 400,
  "to": 0
}, {
  "from": 400,
  "to": 36
}, {
  "from": 400,
  "to": 165
}, {
  "from": 401,
  "to": 50
}, {
  "from": 402,
  "to": 199
}, {
  "from": 402,
  "to": 202
}, {
  "from": 403,
  "to": 294
}, {
  "from": 404,
  "to": 0
}, {
  "from": 404,
  "to": 1
}, {
  "from": 404,
  "to": 28
}, {
  "from": 405,
  "to": 208
}, {
  "from": 406,
  "to": 17
}, {
  "from": 406,
  "to": 35
}, {
  "from": 406,
  "to": 91
}, {
  "from": 407,
  "to": 227
}, {
  "from": 408,
  "to": 2
}, {
  "from": 408,
  "to": 5
}, {
  "from": 408,
  "to": 23
}, {
  "from": 409,
  "to": 36
}, {
  "from": 409,
  "to": 37
}, {
  "from": 410,
  "to": 324
}, {
  "from": 411,
  "to": 79
}, {
  "from": 411,
  "to": 350
}, {
  "from": 412,
  "to": 29
}, {
  "from": 412,
  "to": 71
}, {
  "from": 413,
  "to": 185
}, {
  "from": 414,
  "to": 18
}, {
  "from": 414,
  "to": 254
}, {
  "from": 415,
  "to": 79
}, {
  "from": 416,
  "to": 17
}, {
  "from": 416,
  "to": 35
}, {
  "from": 416,
  "to": 173
}, {
  "from": 416,
  "to": 277
}, {
  "from": 417,
  "to": 264
}, {
  "from": 417,
  "to": 323
}, {
  "from": 418,
  "to": 88
}, {
  "from": 418,
  "to": 203
}, {
  "from": 418,
  "to": 229
}, {
  "from": 419,
  "to": 73
}, {
  "from": 419,
  "to": 388
}, {
  "from": 420,
  "to": 105
}, {
  "from": 420,
  "to": 169
}, {
  "from": 421,
  "to": 1
}, {
  "from": 421,
  "to": 5
}, {
  "from": 421,
  "to": 7
}, {
  "from": 422,
  "to": 156
}, {
  "from": 422,
  "to": 268
}, {
  "from": 423,
  "to": 69
}, {
  "from": 423,
  "to": 141
}, {
  "from": 423,
  "to": 279
}, {
  "from": 424,
  "to": 78
}, {
  "from": 425,
  "to": 355
}, {
  "from": 426,
  "to": 4
}, {
  "from": 426,
  "to": 180
}, {
  "from": 427,
  "to": 95
}, {
  "from": 428,
  "to": 0
}, {
  "from": 428,
  "to": 106
}, {
  "from": 429,
  "to": 135
}, {
  "from": 430,
  "to": 50
}, {
  "from": 431,
  "to": 161
}, {
  "from": 432,
  "to": 0
}, {
  "from": 432,
  "to": 1
}, {
  "from": 432,
  "to": 54
}, {
  "from": 433,
  "to": 8
}, {
  "from": 434,
  "to": 2
}, {
  "from": 434,
  "to": 12
}, {
  "from": 434,
  "to": 19
}, {
  "from": 435,
  "to": 188
}, {
  "from": 436,
  "to": 178
}, {
  "from": 437,
  "to": 10
}, {
  "from": 437,
  "to": 175
}, {
  "from": 438,
  "to": 273
}, {
  "from": 439,
  "to": 12
}, {
  "from": 439,
  "to": 19
}, {
  "from": 439,
  "to": 234
}, {
  "from": 440,
  "to": 100
}, {
  "from": 441,
  "to": 1
}, {
  "from": 441,
  "to": 305
}, {
  "from": 441,
  "to": 312
}, {
  "from": 442,
  "to": 14
}, {
  "from": 442,
  "to": 129
}, {
  "from": 443,
  "to": 30
}, {
  "from": 443,
  "to": 52
}, {
  "from": 443,
  "to": 232
}, {
  "from": 443,
  "to": 342
}, {
  "from": 444,
  "to": 150
}, {
  "from": 444,
  "to": 361
}, {
  "from": 445,
  "to": 11
}, {
  "from": 445,
  "to": 89
}, {
  "from": 445,
  "to": 103
}, {
  "from": 445,
  "to": 303
}, {
  "from": 446,
  "to": 64
}, {
  "from": 447,
  "to": 5
}, {
  "from": 447,
  "to": 408
}, {
  "from": 448,
  "to": 82
}, {
  "from": 448,
  "to": 200
}, {
  "from": 449,
  "to": 17
}, {
  "from": 449,
  "to": 35
}, {
  "from": 449,
  "to": 277
}, {
  "from": 449,
  "to": 416
}, {
  "from": 450,
  "to": 191
}, {
  "from": 450,
  "to": 223
}, {
  "from": 451,
  "to": 43
}, {
  "from": 451,
  "to": 103
}, {
  "from": 452,
  "to": 62
}, {
  "from": 452,
  "to": 135
}, {
  "from": 453,
  "to": 0
}, {
  "from": 453,
  "to": 52
}, {
  "from": 453,
  "to": 232
}, {
  "from": 453,
  "to": 255
}, {
  "from": 454,
  "to": 1
}, {
  "from": 454,
  "to": 4
}, {
  "from": 454,
  "to": 46
}, {
  "from": 455,
  "to": 58
}, {
  "from": 456,
  "to": 176
}, {
  "from": 456,
  "to": 397
}, {
  "from": 457,
  "to": 10
}, {
  "from": 457,
  "to": 175
}, {
  "from": 457,
  "to": 437
}, {
  "from": 458,
  "to": 36
}, {
  "from": 458,
  "to": 37
}, {
  "from": 459,
  "to": 148
}, {
  "from": 459,
  "to": 167
}, {
  "from": 460,
  "to": 213
}, {
  "from": 460,
  "to": 252
}, {
  "from": 461,
  "to": 36
}, {
  "from": 461,
  "to": 90
}, {
  "from": 461,
  "to": 141
}, {
  "from": 461,
  "to": 243
}, {
  "from": 462,
  "to": 1
}, {
  "from": 462,
  "to": 305
}, {
  "from": 462,
  "to": 441
}, {
  "from": 463,
  "to": 66
}, {
  "from": 464,
  "to": 288
}, {
  "from": 465,
  "to": 62
}, {
  "from": 465,
  "to": 334
}, {
  "from": 466,
  "to": 43
}, {
  "from": 466,
  "to": 304
}, {
  "from": 467,
  "to": 7
}, {
  "from": 467,
  "to": 10
}, {
  "from": 467,
  "to": 175
}, {
  "from": 468,
  "to": 14
}, {
  "from": 468,
  "to": 146
}, {
  "from": 469,
  "to": 171
}, {
  "from": 469,
  "to": 270
}, {
  "from": 469,
  "to": 335
}, {
  "from": 470,
  "to": 36
}, {
  "from": 470,
  "to": 81
}, {
  "from": 471,
  "to": 66
}, {
  "from": 472,
  "to": 269
}, {
  "from": 473,
  "to": 11
}, {
  "from": 473,
  "to": 89
}, {
  "from": 473,
  "to": 303
}, {
  "from": 473,
  "to": 383
}, {
  "from": 474,
  "to": 0
}, {
  "from": 474,
  "to": 3
}, {
  "from": 475,
  "to": 0
}, {
  "from": 475,
  "to": 30
}, {
  "from": 475,
  "to": 100
}, {
  "from": 476,
  "to": 3
}, {
  "from": 476,
  "to": 29
}, {
  "from": 477,
  "to": 13
}, {
  "from": 477,
  "to": 118
}, {
  "from": 478,
  "to": 203
}, {
  "from": 478,
  "to": 229
}, {
  "from": 478,
  "to": 418
}, {
  "from": 479,
  "to": 69
}, {
  "from": 479,
  "to": 90
}, {
  "from": 479,
  "to": 141
}, {
  "from": 479,
  "to": 279
}, {
  "from": 480,
  "to": 2
}, {
  "from": 480,
  "to": 302
}, {
  "from": 481,
  "to": 4
}, {
  "from": 481,
  "to": 5
}, {
  "from": 481,
  "to": 127
}, {
  "from": 481,
  "to": 376
}, {
  "from": 482,
  "to": 4
}, {
  "from": 482,
  "to": 8
}, {
  "from": 482,
  "to": 46
}, {
  "from": 483,
  "to": 16
}, {
  "from": 483,
  "to": 29
}, {
  "from": 483,
  "to": 378
}, {
  "from": 484,
  "to": 350
}, {
  "from": 484,
  "to": 411
}, {
  "from": 485,
  "to": 469
}, {
  "from": 486,
  "to": 17
}, {
  "from": 486,
  "to": 35
}, {
  "from": 486,
  "to": 173
}, {
  "from": 486,
  "to": 253
}, {
  "from": 486,
  "to": 277
}, {
  "from": 487,
  "to": 16
}, {
  "from": 488,
  "to": 55
}, {
  "from": 488,
  "to": 392
}, {
  "from": 489,
  "to": 38
}, {
  "from": 490,
  "to": 145
}, {
  "from": 491,
  "to": 37
}, {
  "from": 491,
  "to": 409
}, {
  "from": 492,
  "to": 286
}, {
  "from": 493,
  "to": 411
}, {
  "from": 494,
  "to": 35
}, {
  "from": 495,
  "to": 35
}, {
  "from": 496,
  "to": 268
}, {
  "from": 496,
  "to": 422
}, {
  "from": 497,
  "to": 242
}, {
  "from": 498,
  "to": 2
}, {
  "from": 498,
  "to": 4
}, {
  "from": 498,
  "to": 180
}, {
  "from": 498,
  "to": 258
}, {
  "from": 499,
  "to": 382
}, {
  "from": 500,
  "to": 0
}, {
  "from": 500,
  "to": 30
}, {
  "from": 500,
  "to": 100
}, {
  "from": 501,
  "to": 85
}, {
  "from": 501,
  "to": 113
}, {
  "from": 501,
  "to": 363
}, {
  "from": 502,
  "to": 1
}, {
  "from": 502,
  "to": 226
}, {
  "from": 503,
  "to": 123
}, {
  "from": 504,
  "to": 66
}, {
  "from": 504,
  "to": 69
}, {
  "from": 505,
  "to": 36
}, {
  "from": 505,
  "to": 243
}, {
  "from": 505,
  "to": 461
}, {
  "from": 506,
  "to": 17
}, {
  "from": 506,
  "to": 406
}, {
  "from": 507,
  "to": 447
}, {
  "from": 508,
  "to": 477
}, {
  "from": 509,
  "to": 162
}, {
  "from": 509,
  "to": 390
}, {
  "from": 510,
  "to": 82
}, {
  "from": 510,
  "to": 200
}, {
  "from": 511,
  "to": 171
}, {
  "from": 511,
  "to": 270
}, {
  "from": 511,
  "to": 469
}, {
  "from": 512,
  "to": 13
}, {
  "from": 512,
  "to": 58
}, {
  "from": 513,
  "to": 1
}, {
  "from": 513,
  "to": 3
}, {
  "from": 513,
  "to": 269
}, {
  "from": 513,
  "to": 275
}, {
  "from": 514,
  "to": 240
}, {
  "from": 515,
  "to": 92
}, {
  "from": 515,
  "to": 344
}, {
  "from": 516,
  "to": 106
}, {
  "from": 517,
  "to": 37
}, {
  "from": 517,
  "to": 57
}, {
  "from": 517,
  "to": 111
}, {
  "from": 518,
  "to": 0
}, {
  "from": 518,
  "to": 36
}, {
  "from": 518,
  "to": 224
}, {
  "from": 519,
  "to": 1
}, {
  "from": 519,
  "to": 18
}, {
  "from": 519,
  "to": 30
}, {
  "from": 519,
  "to": 48
}, {
  "from": 520,
  "to": 3
}, {
  "from": 520,
  "to": 7
}, {
  "from": 521,
  "to": 38
}, {
  "from": 521,
  "to": 70
}, {
  "from": 522,
  "to": 154
}, {
  "from": 522,
  "to": 294
}, {
  "from": 523,
  "to": 134
}, {
  "from": 524,
  "to": 2
}, {
  "from": 524,
  "to": 7
}, {
  "from": 524,
  "to": 21
}, {
  "from": 524,
  "to": 297
}, {
  "from": 525,
  "to": 69
}, {
  "from": 525,
  "to": 90
}, {
  "from": 525,
  "to": 279
}, {
  "from": 525,
  "to": 479
}, {
  "from": 526,
  "to": 119
}, {
  "from": 527,
  "to": 62
}, {
  "from": 527,
  "to": 135
}, {
  "from": 527,
  "to": 262
}, {
  "from": 528,
  "to": 90
}, {
  "from": 528,
  "to": 141
}, {
  "from": 528,
  "to": 243
}, {
  "from": 528,
  "to": 461
}, {
  "from": 529,
  "to": 11
}, {
  "from": 529,
  "to": 89
}, {
  "from": 529,
  "to": 103
}, {
  "from": 529,
  "to": 303
}, {
  "from": 529,
  "to": 383
}, {
  "from": 530,
  "to": 1
}, {
  "from": 530,
  "to": 64
}, {
  "from": 530,
  "to": 346
}, {
  "from": 531,
  "to": 52
}, {
  "from": 531,
  "to": 232
}, {
  "from": 531,
  "to": 342
}, {
  "from": 532,
  "to": 36
}, {
  "from": 532,
  "to": 90
}, {
  "from": 532,
  "to": 141
}, {
  "from": 532,
  "to": 461
}, {
  "from": 533,
  "to": 226
}, {
  "from": 534,
  "to": 34
}, {
  "from": 534,
  "to": 288
}, {
  "from": 535,
  "to": 286
}, {
  "from": 536,
  "to": 182
}, {
  "from": 536,
  "to": 369
}, {
  "from": 537,
  "to": 117
}, {
  "from": 538,
  "to": 0
}, {
  "from": 538,
  "to": 52
}, {
  "from": 539,
  "to": 18
}, {
  "from": 539,
  "to": 48
}, {
  "from": 539,
  "to": 271
}, {
  "from": 540,
  "to": 411
}, {
  "from": 540,
  "to": 493
}, {
  "from": 541,
  "to": 437
}, {
  "from": 542,
  "to": 537
}, {
  "from": 543,
  "to": 64
}, {
  "from": 543,
  "to": 206
}, {
  "from": 544,
  "to": 203
}, {
  "from": 545,
  "to": 121
}, {
  "from": 545,
  "to": 230
}, {
  "from": 546,
  "to": 307
}, {
  "from": 547,
  "to": 4
}, {
  "from": 547,
  "to": 8
}, {
  "from": 547,
  "to": 251
}, {
  "from": 548,
  "to": 37
}, {
  "from": 548,
  "to": 57
}, {
  "from": 548,
  "to": 517
}, {
  "from": 549,
  "to": 209
}, {
  "from": 550,
  "to": 377
}, {
  "from": 551,
  "to": 36
}, {
  "from": 551,
  "to": 188
}, {
  "from": 551,
  "to": 329
}, {
  "from": 552,
  "to": 67
}, {
  "from": 553,
  "to": 64
}, {
  "from": 553,
  "to": 346
}, {
  "from": 554,
  "to": 447
}, {
  "from": 554,
  "to": 507
}, {
  "from": 555,
  "to": 203
}, {
  "from": 555,
  "to": 229
}, {
  "from": 555,
  "to": 478
}, {
  "from": 556,
  "to": 1
}, {
  "from": 556,
  "to": 204
}, {
  "from": 556,
  "to": 305
}, {
  "from": 557,
  "to": 370
}, {
  "from": 558,
  "to": 305
}, {
  "from": 558,
  "to": 462
}, {
  "from": 559,
  "to": 249
}, {
  "from": 560,
  "to": 0
}, {
  "from": 560,
  "to": 24
}, {
  "from": 560,
  "to": 72
}, {
  "from": 561,
  "to": 37
}, {
  "from": 561,
  "to": 491
}, {
  "from": 562,
  "to": 2
}, {
  "from": 562,
  "to": 56
}, {
  "from": 563,
  "to": 342
}, {
  "from": 564,
  "to": 2
}, {
  "from": 564,
  "to": 7
}, {
  "from": 564,
  "to": 21
}, {
  "from": 564,
  "to": 297
}, {
  "from": 565,
  "to": 1
}, {
  "from": 565,
  "to": 305
}, {
  "from": 565,
  "to": 312
}, {
  "from": 565,
  "to": 441
}, {
  "from": 566,
  "to": 0
}, {
  "from": 566,
  "to": 100
}, {
  "from": 566,
  "to": 168
}, {
  "from": 567,
  "to": 7
}, {
  "from": 567,
  "to": 13
}, {
  "from": 567,
  "to": 381
}, {
  "from": 568,
  "to": 25
}, {
  "from": 568,
  "to": 88
}, {
  "from": 569,
  "to": 94
}, {
  "from": 569,
  "to": 148
}, {
  "from": 570,
  "to": 247
}, {
  "from": 571,
  "to": 11
}, {
  "from": 571,
  "to": 89
}, {
  "from": 571,
  "to": 301
}, {
  "from": 571,
  "to": 347
}, {
  "from": 572,
  "to": 17
}, {
  "from": 572,
  "to": 253
}, {
  "from": 573,
  "to": 16
}, {
  "from": 573,
  "to": 29
}, {
  "from": 573,
  "to": 190
}, {
  "from": 573,
  "to": 326
}, {
  "from": 574,
  "to": 320
}, {
  "from": 575,
  "to": 2
}, {
  "from": 575,
  "to": 42
}, {
  "from": 576,
  "to": 17
}, {
  "from": 576,
  "to": 109
}, {
  "from": 577,
  "to": 541
}, {
  "from": 578,
  "to": 91
}, {
  "from": 578,
  "to": 152
}, {
  "from": 579,
  "to": 1
}, {
  "from": 579,
  "to": 63
}, {
  "from": 580,
  "to": 4
}, {
  "from": 580,
  "to": 17
}, {
  "from": 580,
  "to": 98
}, {
  "from": 581,
  "to": 251
}, {
  "from": 581,
  "to": 368
}, {
  "from": 582,
  "to": 0
}, {
  "from": 582,
  "to": 6
}, {
  "from": 582,
  "to": 36
}, {
  "from": 582,
  "to": 165
}, {
  "from": 583,
  "to": 5
}, {
  "from": 583,
  "to": 8
}, {
  "from": 583,
  "to": 53
}, {
  "from": 583,
  "to": 191
}, {
  "from": 584,
  "to": 487
}, {
  "from": 585,
  "to": 286
}, {
  "from": 586,
  "to": 11
}, {
  "from": 586,
  "to": 43
}, {
  "from": 586,
  "to": 89
}, {
  "from": 586,
  "to": 103
}, {
  "from": 586,
  "to": 301
}, {
  "from": 587,
  "to": 3
}, {
  "from": 587,
  "to": 9
}, {
  "from": 588,
  "to": 579
}, {
  "from": 589,
  "to": 173
}, {
  "from": 589,
  "to": 253
}, {
  "from": 590,
  "to": 69
}, {
  "from": 590,
  "to": 141
}, {
  "from": 591,
  "to": 408
}, {
  "from": 591,
  "to": 447
}, {
  "from": 592,
  "to": 0
}, {
  "from": 592,
  "to": 30
}, {
  "from": 592,
  "to": 100
}, {
  "from": 593,
  "to": 5
}, {
  "from": 593,
  "to": 47
}, {
  "from": 593,
  "to": 261
}, {
  "from": 594,
  "to": 286
}, {
  "from": 595,
  "to": 5
}, {
  "from": 595,
  "to": 408
}, {
  "from": 595,
  "to": 447
}, {
  "from": 596,
  "to": 30
}, {
  "from": 596,
  "to": 385
}, {
  "from": 597,
  "to": 99
}, {
  "from": 597,
  "to": 249
}, {
  "from": 598,
  "to": 70
}, {
  "from": 598,
  "to": 521
}, {
  "from": 599,
  "to": 62
}, {
  "from": 599,
  "to": 135
}, {
  "from": 600,
  "to": 579
}, {
  "from": 600,
  "to": 588
}, {
  "from": 601,
  "to": 114
}, {
  "from": 602,
  "to": 245
}, {
  "from": 602,
  "to": 370
}, {
  "from": 603,
  "to": 1
}, {
  "from": 603,
  "to": 3
}, {
  "from": 604,
  "to": 29
}, {
  "from": 604,
  "to": 393
}, {
  "from": 605,
  "to": 238
}, {
  "from": 606,
  "to": 134
}, {
  "from": 606,
  "to": 523
}, {
  "from": 607,
  "to": 405
}, {
  "from": 608,
  "to": 485
}, {
  "from": 609,
  "to": 0
}, {
  "from": 609,
  "to": 100
}, {
  "from": 610,
  "to": 82
}, {
  "from": 611,
  "to": 427
}, {
  "from": 612,
  "to": 38
}, {
  "from": 612,
  "to": 286
}, {
  "from": 613,
  "to": 37
}, {
  "from": 613,
  "to": 561
}, {
  "from": 614,
  "to": 268
}, {
  "from": 615,
  "to": 204
}, {
  "from": 615,
  "to": 382
}, {
  "from": 616,
  "to": 610
}, {
  "from": 617,
  "to": 18
}, {
  "from": 617,
  "to": 48
}, {
  "from": 617,
  "to": 539
}, {
  "from": 618,
  "to": 47
}, {
  "from": 618,
  "to": 593
}, {
  "from": 619,
  "to": 579
}, {
  "from": 619,
  "to": 600
}, {
  "from": 620,
  "to": 3
}, {
  "from": 620,
  "to": 29
}, {
  "from": 620,
  "to": 269
}, {
  "from": 621,
  "to": 2
}, {
  "from": 621,
  "to": 21
}, {
  "from": 621,
  "to": 297
}, {
  "from": 621,
  "to": 524
}, {
  "from": 622,
  "to": 36
}, {
  "from": 622,
  "to": 518
}, {
  "from": 623,
  "to": 29
}, {
  "from": 623,
  "to": 71
}, {
  "from": 624,
  "to": 53
}, {
  "from": 624,
  "to": 191
}, {
  "from": 624,
  "to": 218
}, {
  "from": 625,
  "to": 78
}, {
  "from": 625,
  "to": 101
}, {
  "from": 626,
  "to": 0
}, {
  "from": 626,
  "to": 36
}, {
  "from": 626,
  "to": 165
}, {
  "from": 626,
  "to": 400
}, {
  "from": 627,
  "to": 27
}, {
  "from": 627,
  "to": 38
}, {
  "from": 627,
  "to": 70
}, {
  "from": 628,
  "to": 148
}, {
  "from": 628,
  "to": 167
}, {
  "from": 628,
  "to": 459
}, {
  "from": 629,
  "to": 1
}, {
  "from": 629,
  "to": 64
}, {
  "from": 629,
  "to": 346
}, {
  "from": 630,
  "to": 78
}, {
  "from": 630,
  "to": 424
}, {
  "from": 631,
  "to": 462
}, {
  "from": 632,
  "to": 60
}, {
  "from": 632,
  "to": 62
}, {
  "from": 632,
  "to": 135
}, {
  "from": 633,
  "to": 5
}, {
  "from": 633,
  "to": 191
}, {
  "from": 633,
  "to": 583
}, {
  "from": 634,
  "to": 29
}, {
  "from": 634,
  "to": 71
}, {
  "from": 634,
  "to": 623
}, {
  "from": 635,
  "to": 264
}, {
  "from": 635,
  "to": 323
}, {
  "from": 635,
  "to": 417
}, {
  "from": 636,
  "to": 5
}, {
  "from": 636,
  "to": 7
}, {
  "from": 636,
  "to": 47
}, {
  "from": 637,
  "to": 5
}, {
  "from": 637,
  "to": 6
}, {
  "from": 637,
  "to": 62
}, {
  "from": 638,
  "to": 8
}, {
  "from": 638,
  "to": 61
}, {
  "from": 639,
  "to": 61
}, {
  "from": 639,
  "to": 97
}, {
  "from": 640,
  "to": 367
}, {
  "from": 641,
  "to": 16
}, {
  "from": 641,
  "to": 29
}, {
  "from": 641,
  "to": 190
}, {
  "from": 641,
  "to": 378
}, {
  "from": 642,
  "to": 191
}, {
  "from": 642,
  "to": 450
}, {
  "from": 643,
  "to": 28
}, {
  "from": 643,
  "to": 404
}, {
  "from": 644,
  "to": 1
}, {
  "from": 644,
  "to": 25
}, {
  "from": 645,
  "to": 11
}, {
  "from": 645,
  "to": 103
}, {
  "from": 645,
  "to": 445
}, {
  "from": 646,
  "to": 1
}, {
  "from": 646,
  "to": 245
}, {
  "from": 646,
  "to": 305
}, {
  "from": 647,
  "to": 147
}, {
  "from": 647,
  "to": 212
}, {
  "from": 648,
  "to": 4
}, {
  "from": 648,
  "to": 5
}, {
  "from": 648,
  "to": 127
}, {
  "from": 649,
  "to": 1
}, {
  "from": 649,
  "to": 197
}, {
  "from": 650,
  "to": 24
}, {
  "from": 650,
  "to": 151
}, {
  "from": 650,
  "to": 358
}, {
  "from": 651,
  "to": 206
}, {
  "from": 652,
  "to": 2
}, {
  "from": 652,
  "to": 4
}, {
  "from": 653,
  "to": 170
}, {
  "from": 654,
  "to": 11
}, {
  "from": 654,
  "to": 89
}, {
  "from": 654,
  "to": 383
}, {
  "from": 654,
  "to": 473
}, {
  "from": 655,
  "to": 180
}, {
  "from": 655,
  "to": 498
}, {
  "from": 656,
  "to": 168
}, {
  "from": 656,
  "to": 170
}, {
  "from": 657,
  "to": 334
}, {
  "from": 657,
  "to": 465
}, {
  "from": 658,
  "to": 104
}, {
  "from": 659,
  "to": 520
}, {
  "from": 660,
  "to": 14
}, {
  "from": 660,
  "to": 146
}, {
  "from": 660,
  "to": 468
}, {
  "from": 661,
  "to": 36
}, {
  "from": 661,
  "to": 84
}, {
  "from": 662,
  "to": 253
}, {
  "from": 663,
  "to": 342
}, {
  "from": 663,
  "to": 563
}, {
  "from": 664,
  "to": 248
}, {
  "from": 664,
  "to": 343
}, {
  "from": 664,
  "to": 348
}, {
  "from": 665,
  "to": 141
}, {
  "from": 665,
  "to": 461
}, {
  "from": 665,
  "to": 532
}, {
  "from": 666,
  "to": 472
}, {
  "from": 667,
  "to": 588
}, {
  "from": 667,
  "to": 600
}, {
  "from": 668,
  "to": 427
}, {
  "from": 668,
  "to": 611
}, {
  "from": 669,
  "to": 112
}, {
  "from": 669,
  "to": 148
}, {
  "from": 669,
  "to": 227
}, {
  "from": 670,
  "to": 49
}, {
  "from": 670,
  "to": 51
}, {
  "from": 671,
  "to": 17
}, {
  "from": 671,
  "to": 253
}, {
  "from": 672,
  "to": 197
}, {
  "from": 672,
  "to": 649
}, {
  "from": 673,
  "to": 23
}, {
  "from": 674,
  "to": 4
}, {
  "from": 674,
  "to": 115
}, {
  "from": 674,
  "to": 251
}, {
  "from": 675,
  "to": 0
}, {
  "from": 675,
  "to": 6
}, {
  "from": 675,
  "to": 582
}, {
  "from": 676,
  "to": 1
}, {
  "from": 676,
  "to": 130
}, {
  "from": 677,
  "to": 524
}, {
  "from": 678,
  "to": 50
}, {
  "from": 679,
  "to": 1
}, {
  "from": 679,
  "to": 30
}, {
  "from": 679,
  "to": 48
}, {
  "from": 680,
  "to": 370
}, {
  "from": 681,
  "to": 88
}, {
  "from": 681,
  "to": 203
}, {
  "from": 681,
  "to": 418
}, {
  "from": 682,
  "to": 186
}, {
  "from": 683,
  "to": 1
}, {
  "from": 683,
  "to": 16
}, {
  "from": 683,
  "to": 75
}, {
  "from": 683,
  "to": 158
}, {
  "from": 684,
  "to": 55
}, {
  "from": 685,
  "to": 341
}, {
  "from": 685,
  "to": 374
}, {
  "from": 686,
  "to": 2
}, {
  "from": 686,
  "to": 333
}, {
  "from": 687,
  "to": 407
}, {
  "from": 688,
  "to": 171
}, {
  "from": 689,
  "to": 52
}, {
  "from": 689,
  "to": 105
}, {
  "from": 690,
  "to": 94
}, {
  "from": 690,
  "to": 148
}, {
  "from": 691,
  "to": 370
}, {
  "from": 691,
  "to": 602
}, {
  "from": 692,
  "to": 16
}, {
  "from": 692,
  "to": 487
}, {
  "from": 693,
  "to": 147
}, {
  "from": 693,
  "to": 647
}, {
  "from": 694,
  "to": 427
}, {
  "from": 694,
  "to": 611
}, {
  "from": 695,
  "to": 89
}, {
  "from": 695,
  "to": 221
}, {
  "from": 696,
  "to": 35
}, {
  "from": 696,
  "to": 246
}, {
  "from": 697,
  "to": 50
}, {
  "from": 697,
  "to": 401
}, {
  "from": 698,
  "to": 307
}, {
  "from": 698,
  "to": 315
}, {
  "from": 699,
  "to": 429
}, {
  "from": 700,
  "to": 135
}, {
  "from": 700,
  "to": 452
}, {
  "from": 701,
  "to": 112
}, {
  "from": 701,
  "to": 227
}, {
  "from": 702,
  "to": 472
}, {
  "from": 702,
  "to": 666
}, {
  "from": 703,
  "to": 412
}, {
  "from": 704,
  "to": 421
}, {
  "from": 705,
  "to": 1
}, {
  "from": 705,
  "to": 3
}, {
  "from": 705,
  "to": 9
}, {
  "from": 706,
  "to": 591
}, {
  "from": 707,
  "to": 1
}, {
  "from": 707,
  "to": 147
}, {
  "from": 707,
  "to": 239
}, {
  "from": 708,
  "to": 134
}, {
  "from": 709,
  "to": 216
}, {
  "from": 709,
  "to": 302
}, {
  "from": 710,
  "to": 222
}, {
  "from": 711,
  "to": 333
}, {
  "from": 712,
  "to": 18
}, {
  "from": 712,
  "to": 48
}, {
  "from": 712,
  "to": 271
}, {
  "from": 712,
  "to": 539
}, {
  "from": 713,
  "to": 605
}, {
  "from": 714,
  "to": 85
}, {
  "from": 714,
  "to": 113
}, {
  "from": 715,
  "to": 36
}, {
  "from": 715,
  "to": 67
}, {
  "from": 715,
  "to": 84
}, {
  "from": 716,
  "to": 686
}, {
  "from": 717,
  "to": 412
}, {
  "from": 717,
  "to": 703
}, {
  "from": 718,
  "to": 240
}, {
  "from": 719,
  "to": 171
}, {
  "from": 719,
  "to": 335
}, {
  "from": 719,
  "to": 469
}, {
  "from": 720,
  "to": 469
}, {
  "from": 720,
  "to": 511
}, {
  "from": 721,
  "to": 95
}, {
  "from": 721,
  "to": 427
}, {
  "from": 722,
  "to": 297
}, {
  "from": 722,
  "to": 564
}, {
  "from": 723,
  "to": 1
}, {
  "from": 723,
  "to": 18
}, {
  "from": 723,
  "to": 205
}, {
  "from": 724,
  "to": 11
}, {
  "from": 724,
  "to": 301
}, {
  "from": 725,
  "to": 663
}, {
  "from": 726,
  "to": 82
}, {
  "from": 726,
  "to": 448
}, {
  "from": 727,
  "to": 148
}, {
  "from": 728,
  "to": 13
}, {
  "from": 728,
  "to": 216
}, {
  "from": 729,
  "to": 296
}, {
  "from": 729,
  "to": 377
}, {
  "from": 730,
  "to": 168
}, {
  "from": 731,
  "to": 520
}, {
  "from": 732,
  "to": 1
}, {
  "from": 732,
  "to": 48
}, {
  "from": 732,
  "to": 679
}, {
  "from": 733,
  "to": 308
}, {
  "from": 734,
  "to": 12
}, {
  "from": 734,
  "to": 19
}, {
  "from": 734,
  "to": 44
}, {
  "from": 735,
  "to": 364
}, {
  "from": 736,
  "to": 7
}, {
  "from": 736,
  "to": 297
}, {
  "from": 737,
  "to": 684
}, {
  "from": 738,
  "to": 618
}, {
  "from": 739,
  "to": 682
}, {
  "from": 740,
  "to": 90
}, {
  "from": 741,
  "to": 275
}, {
  "from": 741,
  "to": 355
}, {
  "from": 742,
  "to": 69
}, {
  "from": 742,
  "to": 90
}, {
  "from": 742,
  "to": 279
}, {
  "from": 743,
  "to": 119
}, {
  "from": 743,
  "to": 181
}, {
  "from": 744,
  "to": 89
}, {
  "from": 744,
  "to": 248
}, {
  "from": 745,
  "to": 30
}, {
  "from": 745,
  "to": 385
}, {
  "from": 745,
  "to": 596
}, {
  "from": 746,
  "to": 67
}, {
  "from": 747,
  "to": 662
}, {
  "from": 748,
  "to": 318
}, {
  "from": 749,
  "to": 226
}, {
  "from": 749,
  "to": 502
}, {
  "from": 750,
  "to": 1
}, {
  "from": 750,
  "to": 29
}, {
  "from": 750,
  "to": 33
}, {
  "from": 750,
  "to": 59
}, {
  "from": 751,
  "to": 148
}, {
  "from": 751,
  "to": 227
}, {
  "from": 752,
  "to": 245
}, {
  "from": 752,
  "to": 370
}, {
  "from": 752,
  "to": 602
}, {
  "from": 753,
  "to": 1
}, {
  "from": 753,
  "to": 138
}, {
  "from": 754,
  "to": 129
}, {
  "from": 754,
  "to": 442
}, {
  "from": 755,
  "to": 35
}, {
  "from": 755,
  "to": 173
}, {
  "from": 755,
  "to": 253
}, {
  "from": 755,
  "to": 277
}, {
  "from": 756,
  "to": 264
}, {
  "from": 756,
  "to": 323
}, {
  "from": 756,
  "to": 417
}, {
  "from": 756,
  "to": 635
}, {
  "from": 757,
  "to": 147
}, {
  "from": 757,
  "to": 647
}, {
  "from": 758,
  "to": 1
}, {
  "from": 758,
  "to": 7
}, {
  "from": 758,
  "to": 341
}, {
  "from": 759,
  "to": 307
}, {
  "from": 760,
  "to": 69
}, {
  "from": 760,
  "to": 279
}, {
  "from": 760,
  "to": 479
}, {
  "from": 761,
  "to": 1
}, {
  "from": 761,
  "to": 189
}, {
  "from": 761,
  "to": 204
}, {
  "from": 762,
  "to": 113
}, {
  "from": 762,
  "to": 186
}, {
  "from": 763,
  "to": 36
}, {
  "from": 763,
  "to": 90
}, {
  "from": 763,
  "to": 532
}, {
  "from": 764,
  "to": 209
}, {
  "from": 764,
  "to": 549
}, {
  "from": 765,
  "to": 412
}, {
  "from": 765,
  "to": 703
}, {
  "from": 765,
  "to": 717
}, {
  "from": 766,
  "to": 735
}, {
  "from": 767,
  "to": 249
}, {
  "from": 767,
  "to": 597
}, {
  "from": 768,
  "to": 227
}, {
  "from": 768,
  "to": 371
}, {
  "from": 769,
  "to": 523
}, {
  "from": 770,
  "to": 18
}, {
  "from": 770,
  "to": 254
}, {
  "from": 770,
  "to": 414
}, {
  "from": 771,
  "to": 405
}, {
  "from": 772,
  "to": 33
}, {
  "from": 772,
  "to": 325
}, {
  "from": 773,
  "to": 91
}, {
  "from": 773,
  "to": 578
}, {
  "from": 774,
  "to": 203
}, {
  "from": 774,
  "to": 229
}, {
  "from": 774,
  "to": 478
}, {
  "from": 774,
  "to": 555
}, {
  "from": 775,
  "to": 11
}, {
  "from": 775,
  "to": 89
}, {
  "from": 775,
  "to": 248
}, {
  "from": 776,
  "to": 363
}, {
  "from": 777,
  "to": 305
}, {
  "from": 777,
  "to": 312
}, {
  "from": 777,
  "to": 441
}, {
  "from": 777,
  "to": 565
}, {
  "from": 778,
  "to": 0
}, {
  "from": 778,
  "to": 30
}, {
  "from": 778,
  "to": 100
}, {
  "from": 779,
  "to": 2
}, {
  "from": 779,
  "to": 4
}, {
  "from": 780,
  "to": 706
}, {
  "from": 781,
  "to": 49
}, {
  "from": 781,
  "to": 670
}, {
  "from": 782,
  "to": 135
}, {
  "from": 782,
  "to": 452
}, {
  "from": 783,
  "to": 557
}, {
  "from": 784,
  "to": 1
}, {
  "from": 784,
  "to": 64
}, {
  "from": 785,
  "to": 274
}, {
  "from": 786,
  "to": 474
}, {
  "from": 787,
  "to": 60
}, {
  "from": 787,
  "to": 62
}, {
  "from": 787,
  "to": 262
}, {
  "from": 788,
  "to": 82
}, {
  "from": 788,
  "to": 448
}, {
  "from": 789,
  "to": 62
}, {
  "from": 789,
  "to": 135
}, {
  "from": 789,
  "to": 334
}, {
  "from": 789,
  "to": 375
}, {
  "from": 790,
  "to": 59
}, {
  "from": 790,
  "to": 209
}, {
  "from": 791,
  "to": 625
}, {
  "from": 792,
  "to": 60
}, {
  "from": 792,
  "to": 62
}, {
  "from": 792,
  "to": 135
}, {
  "from": 792,
  "to": 334
}, {
  "from": 792,
  "to": 375
}, {
  "from": 793,
  "to": 28
}, {
  "from": 793,
  "to": 54
}, {
  "from": 793,
  "to": 145
}, {
  "from": 794,
  "to": 134
}, {
  "from": 795,
  "to": 1
}, {
  "from": 795,
  "to": 158
}, {
  "from": 796,
  "to": 35
}, {
  "from": 796,
  "to": 49
}, {
  "from": 797,
  "to": 191
}, {
  "from": 797,
  "to": 450
}, {
  "from": 798,
  "to": 515
}, {
  "from": 799,
  "to": 104
}, {
  "from": 800,
  "to": 38
}, {
  "from": 800,
  "to": 286
}, {
  "from": 800,
  "to": 612
}, {
  "from": 801,
  "to": 711
}, {
  "from": 802,
  "to": 1
}, {
  "from": 802,
  "to": 53
}, {
  "from": 803,
  "to": 469
}, {
  "from": 803,
  "to": 720
}, {
  "from": 804,
  "to": 1
}, {
  "from": 804,
  "to": 5
}, {
  "from": 804,
  "to": 39
}, {
  "from": 805,
  "to": 29
}, {
  "from": 805,
  "to": 33
}, {
  "from": 806,
  "to": 171
}, {
  "from": 806,
  "to": 469
}, {
  "from": 806,
  "to": 719
}, {
  "from": 807,
  "to": 2
}, {
  "from": 807,
  "to": 21
}, {
  "from": 807,
  "to": 297
}, {
  "from": 807,
  "to": 564
}, {
  "from": 808,
  "to": 216
}, {
  "from": 808,
  "to": 302
}, {
  "from": 808,
  "to": 709
}, {
  "from": 809,
  "to": 11
}, {
  "from": 809,
  "to": 89
}, {
  "from": 809,
  "to": 303
}, {
  "from": 809,
  "to": 473
}, {
  "from": 810,
  "to": 56
}, {
  "from": 810,
  "to": 198
}, {
  "from": 811,
  "to": 407
}, {
  "from": 812,
  "to": 730
}, {
  "from": 813,
  "to": 17
}, {
  "from": 813,
  "to": 26
}, {
  "from": 813,
  "to": 109
}, {
  "from": 814,
  "to": 5
}, {
  "from": 814,
  "to": 4
}, {
  "from": 814,
  "to": 0
}, {
  "from": 814,
  "to": 6
}, {
  "from": 815,
  "to": 16
}, {
  "from": 815,
  "to": 295
}, {
  "from": 815,
  "to": 317
}, {
  "from": 816,
  "to": 4
}, {
  "from": 816,
  "to": 27
}, {
  "from": 816,
  "to": 102
}, {
  "from": 817,
  "to": 228
}, {
  "from": 818,
  "to": 287
}, {
  "from": 819,
  "to": 188
}, {
  "from": 819,
  "to": 435
}, {
  "from": 820,
  "to": 32
}, {
  "from": 821,
  "to": 245
}, {
  "from": 821,
  "to": 370
}, {
  "from": 822,
  "to": 18
}, {
  "from": 822,
  "to": 48
}, {
  "from": 822,
  "to": 271
}, {
  "from": 822,
  "to": 539
}, {
  "from": 822,
  "to": 712
}, {
  "from": 823,
  "to": 203
}, {
  "from": 823,
  "to": 229
}, {
  "from": 823,
  "to": 478
}, {
  "from": 823,
  "to": 555
}, {
  "from": 824,
  "to": 35
}, {
  "from": 824,
  "to": 137
}, {
  "from": 825,
  "to": 212
}, {
  "from": 826,
  "to": 819
}, {
  "from": 827,
  "to": 0
}, {
  "from": 827,
  "to": 609
}, {
  "from": 828,
  "to": 242
}, {
  "from": 828,
  "to": 497
}, {
  "from": 829,
  "to": 5
}, {
  "from": 829,
  "to": 0
}, {
  "from": 829,
  "to": 6
}, {
  "from": 830,
  "to": 727
}, {
  "from": 831,
  "to": 25
}, {
  "from": 831,
  "to": 88
}, {
  "from": 831,
  "to": 229
}, {
  "from": 832,
  "to": 188
}, {
  "from": 832,
  "to": 551
}, {
  "from": 833,
  "to": 23
}, {
  "from": 833,
  "to": 45
}, {
  "from": 834,
  "to": 148
}, {
  "from": 834,
  "to": 727
}, {
  "from": 835,
  "to": 23
}, {
  "from": 835,
  "to": 174
}, {
  "from": 835,
  "to": 228
}, {
  "from": 836,
  "to": 186
}, {
  "from": 837,
  "to": 113
}, {
  "from": 837,
  "to": 186
}, {
  "from": 838,
  "to": 24
}, {
  "from": 838,
  "to": 92
}, {
  "from": 839,
  "to": 382
}, {
  "from": 839,
  "to": 499
}, {
  "from": 840,
  "to": 135
}, {
  "from": 840,
  "to": 599
}, {
  "from": 841,
  "to": 10
}, {
  "from": 842,
  "to": 193
}, {
  "from": 843,
  "to": 55
}, {
  "from": 843,
  "to": 392
}, {
  "from": 843,
  "to": 488
}, {
  "from": 844,
  "to": 0
}, {
  "from": 844,
  "to": 404
}, {
  "from": 845,
  "to": 1
}, {
  "from": 845,
  "to": 7
}, {
  "from": 845,
  "to": 341
}, {
  "from": 846,
  "to": 161
}, {
  "from": 847,
  "to": 251
}, {
  "from": 847,
  "to": 581
}, {
  "from": 848,
  "to": 54
}, {
  "from": 848,
  "to": 145
}, {
  "from": 848,
  "to": 793
}, {
  "from": 849,
  "to": 56
}, {
  "from": 849,
  "to": 562
}, {
  "from": 850,
  "to": 405
}, {
  "from": 851,
  "to": 680
}, {
  "from": 852,
  "to": 412
}, {
  "from": 852,
  "to": 703
}, {
  "from": 852,
  "to": 717
}, {
  "from": 852,
  "to": 765
}, {
  "from": 853,
  "to": 110
}, {
  "from": 854,
  "to": 33
}, {
  "from": 854,
  "to": 59
}, {
  "from": 854,
  "to": 750
}, {
  "from": 855,
  "to": 644
}, {
  "from": 856,
  "to": 803
}, {
  "from": 857,
  "to": 66
}, {
  "from": 858,
  "to": 762
}, {
  "from": 859,
  "to": 0
}, {
  "from": 859,
  "to": 100
}, {
  "from": 859,
  "to": 609
}, {
  "from": 860,
  "to": 1
}, {
  "from": 860,
  "to": 379
}, {
  "from": 861,
  "to": 50
}, {
  "from": 861,
  "to": 401
}, {
  "from": 861,
  "to": 697
}, {
  "from": 862,
  "to": 2
}, {
  "from": 862,
  "to": 14
}, {
  "from": 862,
  "to": 321
}, {
  "from": 863,
  "to": 254
}, {
  "from": 863,
  "to": 414
}, {
  "from": 864,
  "to": 29
}, {
  "from": 864,
  "to": 353
}, {
  "from": 864,
  "to": 393
}, {
  "from": 865,
  "to": 711
}, {
  "from": 865,
  "to": 801
}, {
  "from": 866,
  "to": 135
}, {
  "from": 866,
  "to": 599
}, {
  "from": 867,
  "to": 35
}, {
  "from": 867,
  "to": 173
}, {
  "from": 867,
  "to": 416
}, {
  "from": 868,
  "to": 284
}, {
  "from": 869,
  "to": 387
}, {
  "from": 870,
  "to": 89
}, {
  "from": 870,
  "to": 108
}, {
  "from": 871,
  "to": 750
}, {
  "from": 872,
  "to": 273
}, {
  "from": 872,
  "to": 438
}, {
  "from": 873,
  "to": 3
}, {
  "from": 873,
  "to": 29
}, {
  "from": 873,
  "to": 620
}, {
  "from": 874,
  "to": 50
}, {
  "from": 874,
  "to": 401
}, {
  "from": 875,
  "to": 1
}, {
  "from": 875,
  "to": 20
}, {
  "from": 875,
  "to": 226
}, {
  "from": 876,
  "to": 487
}, {
  "from": 876,
  "to": 692
}, {
  "from": 877,
  "to": 24
}, {
  "from": 877,
  "to": 838
}, {
  "from": 878,
  "to": 49
}, {
  "from": 878,
  "to": 670
}, {
  "from": 879,
  "to": 551
}, {
  "from": 879,
  "to": 832
}, {
  "from": 880,
  "to": 803
}, {
  "from": 881,
  "to": 18
}, {
  "from": 881,
  "to": 254
}, {
  "from": 881,
  "to": 414
}, {
  "from": 882,
  "to": 249
}, {
  "from": 883,
  "to": 36
}, {
  "from": 883,
  "to": 37
}, {
  "from": 884,
  "to": 0
}, {
  "from": 884,
  "to": 12
}, {
  "from": 885,
  "to": 335
}, {
  "from": 885,
  "to": 469
}, {
  "from": 886,
  "to": 82
}, {
  "from": 886,
  "to": 200
}, {
  "from": 887,
  "to": 135
}, {
  "from": 887,
  "to": 452
}, {
  "from": 887,
  "to": 700
}, {
  "from": 888,
  "to": 568
}, {
  "from": 889,
  "to": 1
}, {
  "from": 889,
  "to": 33
}, {
  "from": 889,
  "to": 59
}, {
  "from": 890,
  "to": 85
}, {
  "from": 890,
  "to": 363
}, {
  "from": 891,
  "to": 32
}, {
  "from": 891,
  "to": 820
}, {
  "from": 892,
  "to": 519
}, {
  "from": 893,
  "to": 762
}, {
  "from": 894,
  "to": 10
}, {
  "from": 894,
  "to": 437
}, {
  "from": 894,
  "to": 457
}, {
  "from": 895,
  "to": 439
}, {
  "from": 896,
  "to": 579
}, {
  "from": 896,
  "to": 600
}, {
  "from": 896,
  "to": 619
}, {
  "from": 897,
  "to": 191
}, {
  "from": 897,
  "to": 642
}, {
  "from": 898,
  "to": 18
}, {
  "from": 898,
  "to": 519
}, {
  "from": 899,
  "to": 871
}, {
  "from": 900,
  "to": 29
}, {
  "from": 900,
  "to": 378
}, {
  "from": 901,
  "to": 105
}, {
  "from": 901,
  "to": 689
}, {
  "from": 902,
  "to": 295
}, {
  "from": 902,
  "to": 317
}, {
  "from": 902,
  "to": 815
}, {
  "from": 903,
  "to": 605
}, {
  "from": 904,
  "to": 16
}, {
  "from": 905,
  "to": 13
}, {
  "from": 905,
  "to": 184
}, {
  "from": 906,
  "to": 534
}, {
  "from": 907,
  "to": 131
}, {
  "from": 908,
  "to": 682
}, {
  "from": 909,
  "to": 305
}, {
  "from": 909,
  "to": 558
}, {
  "from": 910,
  "to": 147
}, {
  "from": 910,
  "to": 707
}, {
  "from": 911,
  "to": 60
}, {
  "from": 911,
  "to": 62
}, {
  "from": 911,
  "to": 334
}, {
  "from": 912,
  "to": 18
}, {
  "from": 912,
  "to": 519
}, {
  "from": 912,
  "to": 898
}, {
  "from": 913,
  "to": 223
}, {
  "from": 913,
  "to": 450
}, {
  "from": 914,
  "to": 495
}, {
  "from": 915,
  "to": 702
}, {
  "from": 916,
  "to": 135
}, {
  "from": 916,
  "to": 599
}, {
  "from": 916,
  "to": 840
}, {
  "from": 917,
  "to": 305
}, {
  "from": 917,
  "to": 909
}, {
  "from": 918,
  "to": 493
}, {
  "from": 919,
  "to": 17
}, {
  "from": 919,
  "to": 163
}, {
  "from": 920,
  "to": 711
}, {
  "from": 921,
  "to": 19
}, {
  "from": 921,
  "to": 234
}, {
  "from": 922,
  "to": 37
}, {
  "from": 922,
  "to": 57
}, {
  "from": 922,
  "to": 548
}, {
  "from": 923,
  "to": 29
}, {
  "from": 923,
  "to": 378
}, {
  "from": 923,
  "to": 641
}, {
  "from": 924,
  "to": 341
}, {
  "from": 924,
  "to": 845
}, {
  "from": 925,
  "to": 204
}, {
  "from": 925,
  "to": 305
}, {
  "from": 926,
  "to": 0
}, {
  "from": 926,
  "to": 609
}, {
  "from": 926,
  "to": 827
}, {
  "from": 927,
  "to": 4
}, {
  "from": 927,
  "to": 5
}, {
  "from": 927,
  "to": 376
}, {
  "from": 928,
  "to": 50
}, {
  "from": 928,
  "to": 697
}, {
  "from": 928,
  "to": 861
}, {
  "from": 929,
  "to": 5
}, {
  "from": 929,
  "to": 408
}, {
  "from": 930,
  "to": 95
}, {
  "from": 930,
  "to": 721
}, {
  "from": 931,
  "to": 388
}, {
  "from": 931,
  "to": 419
}, {
  "from": 932,
  "to": 0
}, {
  "from": 932,
  "to": 1
}, {
  "from": 933,
  "to": 0
}, {
  "from": 933,
  "to": 609
}, {
  "from": 933,
  "to": 926
}, {
  "from": 934,
  "to": 200
}, {
  "from": 934,
  "to": 367
}, {
  "from": 935,
  "to": 1
}, {
  "from": 935,
  "to": 204
}, {
  "from": 935,
  "to": 305
}, {
  "from": 935,
  "to": 556
}, {
  "from": 936,
  "to": 134
}, {
  "from": 936,
  "to": 708
}, {
  "from": 937,
  "to": 221
}, {
  "from": 938,
  "to": 4
}, {
  "from": 938,
  "to": 173
}, {
  "from": 939,
  "to": 294
}, {
  "from": 940,
  "to": 44
}, {
  "from": 940,
  "to": 119
}, {
  "from": 941,
  "to": 19
}, {
  "from": 941,
  "to": 44
}, {
  "from": 942,
  "to": 666
}, {
  "from": 943,
  "to": 3
}, {
  "from": 943,
  "to": 28
}, {
  "from": 944,
  "to": 114
}, {
  "from": 944,
  "to": 601
}, {
  "from": 945,
  "to": 69
}, {
  "from": 945,
  "to": 141
}, {
  "from": 945,
  "to": 590
}, {
  "from": 946,
  "to": 1
}, {
  "from": 946,
  "to": 39
}, {
  "from": 946,
  "to": 331
}, {
  "from": 947,
  "to": 213
}, {
  "from": 947,
  "to": 235
}, {
  "from": 948,
  "to": 688
}, {
  "from": 949,
  "to": 120
}, {
  "from": 949,
  "to": 197
}, {
  "from": 950,
  "to": 0
}, {
  "from": 950,
  "to": 1
}, {
  "from": 950,
  "to": 18
}, {
  "from": 951,
  "to": 542
}, {
  "from": 952,
  "to": 589
}, {
  "from": 953,
  "to": 212
}, {
  "from": 953,
  "to": 647
}, {
  "from": 954,
  "to": 0
}, {
  "from": 954,
  "to": 24
}, {
  "from": 954,
  "to": 122
}, {
  "from": 955,
  "to": 268
}, {
  "from": 955,
  "to": 614
}, {
  "from": 956,
  "to": 209
}, {
  "from": 957,
  "to": 27
}, {
  "from": 957,
  "to": 70
}, {
  "from": 958,
  "to": 7
}, {
  "from": 958,
  "to": 520
}, {
  "from": 959,
  "to": 27
}, {
  "from": 959,
  "to": 102
}, {
  "from": 959,
  "to": 816
}, {
  "from": 960,
  "to": 114
}, {
  "from": 961,
  "to": 1
}, {
  "from": 961,
  "to": 23
}, {
  "from": 961,
  "to": 130
}, {
  "from": 962,
  "to": 412
}, {
  "from": 962,
  "to": 703
}, {
  "from": 963,
  "to": 563
}, {
  "from": 964,
  "to": 409
}, {
  "from": 965,
  "to": 450
}, {
  "from": 966,
  "to": 502
}, {
  "from": 967,
  "to": 29
}, {
  "from": 967,
  "to": 71
}, {
  "from": 967,
  "to": 213
}, {
  "from": 968,
  "to": 13
}, {
  "from": 968,
  "to": 58
}, {
  "from": 969,
  "to": 891
}, {
  "from": 970,
  "to": 171
}, {
  "from": 970,
  "to": 469
}, {
  "from": 971,
  "to": 82
}, {
  "from": 971,
  "to": 200
}, {
  "from": 971,
  "to": 510
}, {
  "from": 972,
  "to": 130
}, {
  "from": 972,
  "to": 676
}, {
  "from": 973,
  "to": 54
}, {
  "from": 973,
  "to": 145
}, {
  "from": 973,
  "to": 793
}, {
  "from": 974,
  "to": 144
}, {
  "from": 974,
  "to": 354
}, {
  "from": 975,
  "to": 1
}, {
  "from": 975,
  "to": 33
}, {
  "from": 976,
  "to": 180
}, {
  "from": 976,
  "to": 655
}, {
  "from": 977,
  "to": 91
}, {
  "from": 977,
  "to": 773
}, {
  "from": 978,
  "to": 551
}, {
  "from": 978,
  "to": 879
}, {
  "from": 979,
  "to": 16
}, {
  "from": 979,
  "to": 487
}, {
  "from": 979,
  "to": 692
}, {
  "from": 980,
  "to": 16
}, {
  "from": 980,
  "to": 378
}, {
  "from": 980,
  "to": 483
}, {
  "from": 981,
  "to": 30
}, {
  "from": 981,
  "to": 385
}, {
  "from": 981,
  "to": 596
}, {
  "from": 982,
  "to": 589
}, {
  "from": 982,
  "to": 952
}, {
  "from": 983,
  "to": 152
}, {
  "from": 983,
  "to": 156
}, {
  "from": 983,
  "to": 164
}, {
  "from": 984,
  "to": 50
}, {
  "from": 984,
  "to": 401
}, {
  "from": 984,
  "to": 697
}, {
  "from": 985,
  "to": 1
}, {
  "from": 985,
  "to": 147
}, {
  "from": 986,
  "to": 892
}, {
  "from": 987,
  "to": 1
}, {
  "from": 987,
  "to": 985
}, {
  "from": 988,
  "to": 33
}, {
  "from": 988,
  "to": 59
}, {
  "from": 988,
  "to": 76
}, {
  "from": 989,
  "to": 159
}, {
  "from": 990,
  "to": 711
}, {
  "from": 990,
  "to": 801
}, {
  "from": 991,
  "to": 461
}, {
  "from": 991,
  "to": 665
}, {
  "from": 992,
  "to": 408
}, {
  "from": 992,
  "to": 929
}, {
  "from": 993,
  "to": 432
}, {
  "from": 994,
  "to": 11
}, {
  "from": 994,
  "to": 383
}, {
  "from": 995,
  "to": 36
}, {
  "from": 995,
  "to": 67
}, {
  "from": 995,
  "to": 715
}, {
  "from": 996,
  "to": 107
}, {
  "from": 997,
  "to": 841
}, {
  "from": 998,
  "to": 412
}, {
  "from": 998,
  "to": 962
}, {
  "from": 999,
  "to": 58
}];
},{}],"vUQY":[function(require,module,exports) {
module.exports = [{
  "id": 0
}, {
  "id": 1
}, {
  "id": 2
}, {
  "id": 3
}, {
  "id": 4
}, {
  "id": 5
}, {
  "id": 6
}, {
  "id": 7
}, {
  "id": 8
}, {
  "id": 9
}, {
  "id": 10
}, {
  "id": 11
}, {
  "id": 12
}, {
  "id": 13
}, {
  "id": 14
}, {
  "id": 15
}, {
  "id": 16
}, {
  "id": 17
}, {
  "id": 18
}, {
  "id": 19
}, {
  "id": 20
}, {
  "id": 21
}, {
  "id": 22
}, {
  "id": 23
}, {
  "id": 24
}, {
  "id": 25
}, {
  "id": 26
}, {
  "id": 27
}, {
  "id": 28
}, {
  "id": 29
}, {
  "id": 30
}, {
  "id": 31
}, {
  "id": 32
}, {
  "id": 33
}, {
  "id": 34
}, {
  "id": 35
}, {
  "id": 36
}, {
  "id": 37
}, {
  "id": 38
}, {
  "id": 39
}, {
  "id": 40
}, {
  "id": 41
}, {
  "id": 42
}, {
  "id": 43
}, {
  "id": 44
}, {
  "id": 45
}, {
  "id": 46
}, {
  "id": 47
}, {
  "id": 48
}, {
  "id": 49
}, {
  "id": 50
}, {
  "id": 51
}, {
  "id": 52
}, {
  "id": 53
}, {
  "id": 54
}, {
  "id": 55
}, {
  "id": 56
}, {
  "id": 57
}, {
  "id": 58
}, {
  "id": 59
}, {
  "id": 60
}, {
  "id": 61
}, {
  "id": 62
}, {
  "id": 63
}, {
  "id": 64
}, {
  "id": 65
}, {
  "id": 66
}, {
  "id": 67
}, {
  "id": 68
}, {
  "id": 69
}, {
  "id": 70
}, {
  "id": 71
}, {
  "id": 72
}, {
  "id": 73
}, {
  "id": 74
}, {
  "id": 75
}, {
  "id": 76
}, {
  "id": 77
}, {
  "id": 78
}, {
  "id": 79
}, {
  "id": 80
}, {
  "id": 81
}, {
  "id": 82
}, {
  "id": 83
}, {
  "id": 84
}, {
  "id": 85
}, {
  "id": 86
}, {
  "id": 87
}, {
  "id": 88
}, {
  "id": 89
}, {
  "id": 90
}, {
  "id": 91
}, {
  "id": 92
}, {
  "id": 93
}, {
  "id": 94
}, {
  "id": 95
}, {
  "id": 96
}, {
  "id": 97
}, {
  "id": 98
}, {
  "id": 99
}, {
  "id": 100
}, {
  "id": 101
}, {
  "id": 102
}, {
  "id": 103
}, {
  "id": 104
}, {
  "id": 105
}, {
  "id": 106
}, {
  "id": 107
}, {
  "id": 108
}, {
  "id": 109
}, {
  "id": 110
}, {
  "id": 111
}, {
  "id": 112
}, {
  "id": 113
}, {
  "id": 114
}, {
  "id": 115
}, {
  "id": 116
}, {
  "id": 117
}, {
  "id": 118
}, {
  "id": 119
}, {
  "id": 120
}, {
  "id": 121
}, {
  "id": 122
}, {
  "id": 123
}, {
  "id": 124
}, {
  "id": 125
}, {
  "id": 126
}, {
  "id": 127
}, {
  "id": 128
}, {
  "id": 129
}, {
  "id": 130
}, {
  "id": 131
}, {
  "id": 132
}, {
  "id": 133
}, {
  "id": 134
}, {
  "id": 135
}, {
  "id": 136
}, {
  "id": 137
}, {
  "id": 138
}, {
  "id": 139
}, {
  "id": 140
}, {
  "id": 141
}, {
  "id": 142
}, {
  "id": 143
}, {
  "id": 144
}, {
  "id": 145
}, {
  "id": 146
}, {
  "id": 147
}, {
  "id": 148
}, {
  "id": 149
}, {
  "id": 150
}, {
  "id": 151
}, {
  "id": 152
}, {
  "id": 153
}, {
  "id": 154
}, {
  "id": 155
}, {
  "id": 156
}, {
  "id": 157
}, {
  "id": 158
}, {
  "id": 159
}, {
  "id": 160
}, {
  "id": 161
}, {
  "id": 162
}, {
  "id": 163
}, {
  "id": 164
}, {
  "id": 165
}, {
  "id": 166
}, {
  "id": 167
}, {
  "id": 168
}, {
  "id": 169
}, {
  "id": 170
}, {
  "id": 171
}, {
  "id": 172
}, {
  "id": 173
}, {
  "id": 174
}, {
  "id": 175
}, {
  "id": 176
}, {
  "id": 177
}, {
  "id": 178
}, {
  "id": 179
}, {
  "id": 180
}, {
  "id": 181
}, {
  "id": 182
}, {
  "id": 183
}, {
  "id": 184
}, {
  "id": 185
}, {
  "id": 186
}, {
  "id": 187
}, {
  "id": 188
}, {
  "id": 189
}, {
  "id": 190
}, {
  "id": 191
}, {
  "id": 192
}, {
  "id": 193
}, {
  "id": 194
}, {
  "id": 195
}, {
  "id": 196
}, {
  "id": 197
}, {
  "id": 198
}, {
  "id": 199
}, {
  "id": 200
}, {
  "id": 201
}, {
  "id": 202
}, {
  "id": 203
}, {
  "id": 204
}, {
  "id": 205
}, {
  "id": 206
}, {
  "id": 207
}, {
  "id": 208
}, {
  "id": 209
}, {
  "id": 210
}, {
  "id": 211
}, {
  "id": 212
}, {
  "id": 213
}, {
  "id": 214
}, {
  "id": 215
}, {
  "id": 216
}, {
  "id": 217
}, {
  "id": 218
}, {
  "id": 219
}, {
  "id": 220
}, {
  "id": 221
}, {
  "id": 222
}, {
  "id": 223
}, {
  "id": 224
}, {
  "id": 225
}, {
  "id": 226
}, {
  "id": 227
}, {
  "id": 228
}, {
  "id": 229
}, {
  "id": 230
}, {
  "id": 231
}, {
  "id": 232
}, {
  "id": 233
}, {
  "id": 234
}, {
  "id": 235
}, {
  "id": 236
}, {
  "id": 237
}, {
  "id": 238
}, {
  "id": 239
}, {
  "id": 240
}, {
  "id": 241
}, {
  "id": 242
}, {
  "id": 243
}, {
  "id": 244
}, {
  "id": 245
}, {
  "id": 246
}, {
  "id": 247
}, {
  "id": 248
}, {
  "id": 249
}, {
  "id": 250
}, {
  "id": 251
}, {
  "id": 252
}, {
  "id": 253
}, {
  "id": 254
}, {
  "id": 255
}, {
  "id": 256
}, {
  "id": 257
}, {
  "id": 258
}, {
  "id": 259
}, {
  "id": 260
}, {
  "id": 261
}, {
  "id": 262
}, {
  "id": 263
}, {
  "id": 264
}, {
  "id": 265
}, {
  "id": 266
}, {
  "id": 267
}, {
  "id": 268
}, {
  "id": 269
}, {
  "id": 270
}, {
  "id": 271
}, {
  "id": 272
}, {
  "id": 273
}, {
  "id": 274
}, {
  "id": 275
}, {
  "id": 276
}, {
  "id": 277
}, {
  "id": 278
}, {
  "id": 279
}, {
  "id": 280
}, {
  "id": 281
}, {
  "id": 282
}, {
  "id": 283
}, {
  "id": 284
}, {
  "id": 285
}, {
  "id": 286
}, {
  "id": 287
}, {
  "id": 288
}, {
  "id": 289
}, {
  "id": 290
}, {
  "id": 291
}, {
  "id": 292
}, {
  "id": 293
}, {
  "id": 294
}, {
  "id": 295
}, {
  "id": 296
}, {
  "id": 297
}, {
  "id": 298
}, {
  "id": 299
}, {
  "id": 300
}, {
  "id": 301
}, {
  "id": 302
}, {
  "id": 303
}, {
  "id": 304
}, {
  "id": 305
}, {
  "id": 306
}, {
  "id": 307
}, {
  "id": 308
}, {
  "id": 309
}, {
  "id": 310
}, {
  "id": 311
}, {
  "id": 312
}, {
  "id": 313
}, {
  "id": 314
}, {
  "id": 315
}, {
  "id": 316
}, {
  "id": 317
}, {
  "id": 318
}, {
  "id": 319
}, {
  "id": 320
}, {
  "id": 321
}, {
  "id": 322
}, {
  "id": 323
}, {
  "id": 324
}, {
  "id": 325
}, {
  "id": 326
}, {
  "id": 327
}, {
  "id": 328
}, {
  "id": 329
}, {
  "id": 330
}, {
  "id": 331
}, {
  "id": 332
}, {
  "id": 333
}, {
  "id": 334
}, {
  "id": 335
}, {
  "id": 336
}, {
  "id": 337
}, {
  "id": 338
}, {
  "id": 339
}, {
  "id": 340
}, {
  "id": 341
}, {
  "id": 342
}, {
  "id": 343
}, {
  "id": 344
}, {
  "id": 345
}, {
  "id": 346
}, {
  "id": 347
}, {
  "id": 348
}, {
  "id": 349
}, {
  "id": 350
}, {
  "id": 351
}, {
  "id": 352
}, {
  "id": 353
}, {
  "id": 354
}, {
  "id": 355
}, {
  "id": 356
}, {
  "id": 357
}, {
  "id": 358
}, {
  "id": 359
}, {
  "id": 360
}, {
  "id": 361
}, {
  "id": 362
}, {
  "id": 363
}, {
  "id": 364
}, {
  "id": 365
}, {
  "id": 366
}, {
  "id": 367
}, {
  "id": 368
}, {
  "id": 369
}, {
  "id": 370
}, {
  "id": 371
}, {
  "id": 372
}, {
  "id": 373
}, {
  "id": 374
}, {
  "id": 375
}, {
  "id": 376
}, {
  "id": 377
}, {
  "id": 378
}, {
  "id": 379
}, {
  "id": 380
}, {
  "id": 381
}, {
  "id": 382
}, {
  "id": 383
}, {
  "id": 384
}, {
  "id": 385
}, {
  "id": 386
}, {
  "id": 387
}, {
  "id": 388
}, {
  "id": 389
}, {
  "id": 390
}, {
  "id": 391
}, {
  "id": 392
}, {
  "id": 393
}, {
  "id": 394
}, {
  "id": 395
}, {
  "id": 396
}, {
  "id": 397
}, {
  "id": 398
}, {
  "id": 399
}, {
  "id": 400
}, {
  "id": 401
}, {
  "id": 402
}, {
  "id": 403
}, {
  "id": 404
}, {
  "id": 405
}, {
  "id": 406
}, {
  "id": 407
}, {
  "id": 408
}, {
  "id": 409
}, {
  "id": 410
}, {
  "id": 411
}, {
  "id": 412
}, {
  "id": 413
}, {
  "id": 414
}, {
  "id": 415
}, {
  "id": 416
}, {
  "id": 417
}, {
  "id": 418
}, {
  "id": 419
}, {
  "id": 420
}, {
  "id": 421
}, {
  "id": 422
}, {
  "id": 423
}, {
  "id": 424
}, {
  "id": 425
}, {
  "id": 426
}, {
  "id": 427
}, {
  "id": 428
}, {
  "id": 429
}, {
  "id": 430
}, {
  "id": 431
}, {
  "id": 432
}, {
  "id": 433
}, {
  "id": 434
}, {
  "id": 435
}, {
  "id": 436
}, {
  "id": 437
}, {
  "id": 438
}, {
  "id": 439
}, {
  "id": 440
}, {
  "id": 441
}, {
  "id": 442
}, {
  "id": 443
}, {
  "id": 444
}, {
  "id": 445
}, {
  "id": 446
}, {
  "id": 447
}, {
  "id": 448
}, {
  "id": 449
}, {
  "id": 450
}, {
  "id": 451
}, {
  "id": 452
}, {
  "id": 453
}, {
  "id": 454
}, {
  "id": 455
}, {
  "id": 456
}, {
  "id": 457
}, {
  "id": 458
}, {
  "id": 459
}, {
  "id": 460
}, {
  "id": 461
}, {
  "id": 462
}, {
  "id": 463
}, {
  "id": 464
}, {
  "id": 465
}, {
  "id": 466
}, {
  "id": 467
}, {
  "id": 468
}, {
  "id": 469
}, {
  "id": 470
}, {
  "id": 471
}, {
  "id": 472
}, {
  "id": 473
}, {
  "id": 474
}, {
  "id": 475
}, {
  "id": 476
}, {
  "id": 477
}, {
  "id": 478
}, {
  "id": 479
}, {
  "id": 480
}, {
  "id": 481
}, {
  "id": 482
}, {
  "id": 483
}, {
  "id": 484
}, {
  "id": 485
}, {
  "id": 486
}, {
  "id": 487
}, {
  "id": 488
}, {
  "id": 489
}, {
  "id": 490
}, {
  "id": 491
}, {
  "id": 492
}, {
  "id": 493
}, {
  "id": 494
}, {
  "id": 495
}, {
  "id": 496
}, {
  "id": 497
}, {
  "id": 498
}, {
  "id": 499
}, {
  "id": 500
}, {
  "id": 501
}, {
  "id": 502
}, {
  "id": 503
}, {
  "id": 504
}, {
  "id": 505
}, {
  "id": 506
}, {
  "id": 507
}, {
  "id": 508
}, {
  "id": 509
}, {
  "id": 510
}, {
  "id": 511
}, {
  "id": 512
}, {
  "id": 513
}, {
  "id": 514
}, {
  "id": 515
}, {
  "id": 516
}, {
  "id": 517
}, {
  "id": 518
}, {
  "id": 519
}, {
  "id": 520
}, {
  "id": 521
}, {
  "id": 522
}, {
  "id": 523
}, {
  "id": 524
}, {
  "id": 525
}, {
  "id": 526
}, {
  "id": 527
}, {
  "id": 528
}, {
  "id": 529
}, {
  "id": 530
}, {
  "id": 531
}, {
  "id": 532
}, {
  "id": 533
}, {
  "id": 534
}, {
  "id": 535
}, {
  "id": 536
}, {
  "id": 537
}, {
  "id": 538
}, {
  "id": 539
}, {
  "id": 540
}, {
  "id": 541
}, {
  "id": 542
}, {
  "id": 543
}, {
  "id": 544
}, {
  "id": 545
}, {
  "id": 546
}, {
  "id": 547
}, {
  "id": 548
}, {
  "id": 549
}, {
  "id": 550
}, {
  "id": 551
}, {
  "id": 552
}, {
  "id": 553
}, {
  "id": 554
}, {
  "id": 555
}, {
  "id": 556
}, {
  "id": 557
}, {
  "id": 558
}, {
  "id": 559
}, {
  "id": 560
}, {
  "id": 561
}, {
  "id": 562
}, {
  "id": 563
}, {
  "id": 564
}, {
  "id": 565
}, {
  "id": 566
}, {
  "id": 567
}, {
  "id": 568
}, {
  "id": 569
}, {
  "id": 570
}, {
  "id": 571
}, {
  "id": 572
}, {
  "id": 573
}, {
  "id": 574
}, {
  "id": 575
}, {
  "id": 576
}, {
  "id": 577
}, {
  "id": 578
}, {
  "id": 579
}, {
  "id": 580
}, {
  "id": 581
}, {
  "id": 582
}, {
  "id": 583
}, {
  "id": 584
}, {
  "id": 585
}, {
  "id": 586
}, {
  "id": 587
}, {
  "id": 588
}, {
  "id": 589
}, {
  "id": 590
}, {
  "id": 591
}, {
  "id": 592
}, {
  "id": 593
}, {
  "id": 594
}, {
  "id": 595
}, {
  "id": 596
}, {
  "id": 597
}, {
  "id": 598
}, {
  "id": 599
}, {
  "id": 600
}, {
  "id": 601
}, {
  "id": 602
}, {
  "id": 603
}, {
  "id": 604
}, {
  "id": 605
}, {
  "id": 606
}, {
  "id": 607
}, {
  "id": 608
}, {
  "id": 609
}, {
  "id": 610
}, {
  "id": 611
}, {
  "id": 612
}, {
  "id": 613
}, {
  "id": 614
}, {
  "id": 615
}, {
  "id": 616
}, {
  "id": 617
}, {
  "id": 618
}, {
  "id": 619
}, {
  "id": 620
}, {
  "id": 621
}, {
  "id": 622
}, {
  "id": 623
}, {
  "id": 624
}, {
  "id": 625
}, {
  "id": 626
}, {
  "id": 627
}, {
  "id": 628
}, {
  "id": 629
}, {
  "id": 630
}, {
  "id": 631
}, {
  "id": 632
}, {
  "id": 633
}, {
  "id": 634
}, {
  "id": 635
}, {
  "id": 636
}, {
  "id": 637
}, {
  "id": 638
}, {
  "id": 639
}, {
  "id": 640
}, {
  "id": 641
}, {
  "id": 642
}, {
  "id": 643
}, {
  "id": 644
}, {
  "id": 645
}, {
  "id": 646
}, {
  "id": 647
}, {
  "id": 648
}, {
  "id": 649
}, {
  "id": 650
}, {
  "id": 651
}, {
  "id": 652
}, {
  "id": 653
}, {
  "id": 654
}, {
  "id": 655
}, {
  "id": 656
}, {
  "id": 657
}, {
  "id": 658
}, {
  "id": 659
}, {
  "id": 660
}, {
  "id": 661
}, {
  "id": 662
}, {
  "id": 663
}, {
  "id": 664
}, {
  "id": 665
}, {
  "id": 666
}, {
  "id": 667
}, {
  "id": 668
}, {
  "id": 669
}, {
  "id": 670
}, {
  "id": 671
}, {
  "id": 672
}, {
  "id": 673
}, {
  "id": 674
}, {
  "id": 675
}, {
  "id": 676
}, {
  "id": 677
}, {
  "id": 678
}, {
  "id": 679
}, {
  "id": 680
}, {
  "id": 681
}, {
  "id": 682
}, {
  "id": 683
}, {
  "id": 684
}, {
  "id": 685
}, {
  "id": 686
}, {
  "id": 687
}, {
  "id": 688
}, {
  "id": 689
}, {
  "id": 690
}, {
  "id": 691
}, {
  "id": 692
}, {
  "id": 693
}, {
  "id": 694
}, {
  "id": 695
}, {
  "id": 696
}, {
  "id": 697
}, {
  "id": 698
}, {
  "id": 699
}, {
  "id": 700
}, {
  "id": 701
}, {
  "id": 702
}, {
  "id": 703
}, {
  "id": 704
}, {
  "id": 705
}, {
  "id": 706
}, {
  "id": 707
}, {
  "id": 708
}, {
  "id": 709
}, {
  "id": 710
}, {
  "id": 711
}, {
  "id": 712
}, {
  "id": 713
}, {
  "id": 714
}, {
  "id": 715
}, {
  "id": 716
}, {
  "id": 717
}, {
  "id": 718
}, {
  "id": 719
}, {
  "id": 720
}, {
  "id": 721
}, {
  "id": 722
}, {
  "id": 723
}, {
  "id": 724
}, {
  "id": 725
}, {
  "id": 726
}, {
  "id": 727
}, {
  "id": 728
}, {
  "id": 729
}, {
  "id": 730
}, {
  "id": 731
}, {
  "id": 732
}, {
  "id": 733
}, {
  "id": 734
}, {
  "id": 735
}, {
  "id": 736
}, {
  "id": 737
}, {
  "id": 738
}, {
  "id": 739
}, {
  "id": 740
}, {
  "id": 741
}, {
  "id": 742
}, {
  "id": 743
}, {
  "id": 744
}, {
  "id": 745
}, {
  "id": 746
}, {
  "id": 747
}, {
  "id": 748
}, {
  "id": 749
}, {
  "id": 750
}, {
  "id": 751
}, {
  "id": 752
}, {
  "id": 753
}, {
  "id": 754
}, {
  "id": 755
}, {
  "id": 756
}, {
  "id": 757
}, {
  "id": 758
}, {
  "id": 759
}, {
  "id": 760
}, {
  "id": 761
}, {
  "id": 762
}, {
  "id": 763
}, {
  "id": 764
}, {
  "id": 765
}, {
  "id": 766
}, {
  "id": 767
}, {
  "id": 768
}, {
  "id": 769
}, {
  "id": 770
}, {
  "id": 771
}, {
  "id": 772
}, {
  "id": 773
}, {
  "id": 774
}, {
  "id": 775
}, {
  "id": 776
}, {
  "id": 777
}, {
  "id": 778
}, {
  "id": 779
}, {
  "id": 780
}, {
  "id": 781
}, {
  "id": 782
}, {
  "id": 783
}, {
  "id": 784
}, {
  "id": 785
}, {
  "id": 786
}, {
  "id": 787
}, {
  "id": 788
}, {
  "id": 789
}, {
  "id": 790
}, {
  "id": 791
}, {
  "id": 792
}, {
  "id": 793
}, {
  "id": 794
}, {
  "id": 795
}, {
  "id": 796
}, {
  "id": 797
}, {
  "id": 798
}, {
  "id": 799
}, {
  "id": 800
}, {
  "id": 801
}, {
  "id": 802
}, {
  "id": 803
}, {
  "id": 804
}, {
  "id": 805
}, {
  "id": 806
}, {
  "id": 807
}, {
  "id": 808
}, {
  "id": 809
}, {
  "id": 810
}, {
  "id": 811
}, {
  "id": 812
}, {
  "id": 813
}, {
  "id": 814
}, {
  "id": 815
}, {
  "id": 816
}, {
  "id": 817
}, {
  "id": 818
}, {
  "id": 819
}, {
  "id": 820
}, {
  "id": 821
}, {
  "id": 822
}, {
  "id": 823
}, {
  "id": 824
}, {
  "id": 825
}, {
  "id": 826
}, {
  "id": 827
}, {
  "id": 828
}, {
  "id": 829
}, {
  "id": 830
}, {
  "id": 831
}, {
  "id": 832
}, {
  "id": 833
}, {
  "id": 834
}, {
  "id": 835
}, {
  "id": 836
}, {
  "id": 837
}, {
  "id": 838
}, {
  "id": 839
}, {
  "id": 840
}, {
  "id": 841
}, {
  "id": 842
}, {
  "id": 843
}, {
  "id": 844
}, {
  "id": 845
}, {
  "id": 846
}, {
  "id": 847
}, {
  "id": 848
}, {
  "id": 849
}, {
  "id": 850
}, {
  "id": 851
}, {
  "id": 852
}, {
  "id": 853
}, {
  "id": 854
}, {
  "id": 855
}, {
  "id": 856
}, {
  "id": 857
}, {
  "id": 858
}, {
  "id": 859
}, {
  "id": 860
}, {
  "id": 861
}, {
  "id": 862
}, {
  "id": 863
}, {
  "id": 864
}, {
  "id": 865
}, {
  "id": 866
}, {
  "id": 867
}, {
  "id": 868
}, {
  "id": 869
}, {
  "id": 870
}, {
  "id": 871
}, {
  "id": 872
}, {
  "id": 873
}, {
  "id": 874
}, {
  "id": 875
}, {
  "id": 876
}, {
  "id": 877
}, {
  "id": 878
}, {
  "id": 879
}, {
  "id": 880
}, {
  "id": 881
}, {
  "id": 882
}, {
  "id": 883
}, {
  "id": 884
}, {
  "id": 885
}, {
  "id": 886
}, {
  "id": 887
}, {
  "id": 888
}, {
  "id": 889
}, {
  "id": 890
}, {
  "id": 891
}, {
  "id": 892
}, {
  "id": 893
}, {
  "id": 894
}, {
  "id": 895
}, {
  "id": 896
}, {
  "id": 897
}, {
  "id": 898
}, {
  "id": 899
}, {
  "id": 900
}, {
  "id": 901
}, {
  "id": 902
}, {
  "id": 903
}, {
  "id": 904
}, {
  "id": 905
}, {
  "id": 906
}, {
  "id": 907
}, {
  "id": 908
}, {
  "id": 909
}, {
  "id": 910
}, {
  "id": 911
}, {
  "id": 912
}, {
  "id": 913
}, {
  "id": 914
}, {
  "id": 915
}, {
  "id": 916
}, {
  "id": 917
}, {
  "id": 918
}, {
  "id": 919
}, {
  "id": 920
}, {
  "id": 921
}, {
  "id": 922
}, {
  "id": 923
}, {
  "id": 924
}, {
  "id": 925
}, {
  "id": 926
}, {
  "id": 927
}, {
  "id": 928
}, {
  "id": 929
}, {
  "id": 930
}, {
  "id": 931
}, {
  "id": 932
}, {
  "id": 933
}, {
  "id": 934
}, {
  "id": 935
}, {
  "id": 936
}, {
  "id": 937
}, {
  "id": 938
}, {
  "id": 939
}, {
  "id": 940
}, {
  "id": 941
}, {
  "id": 942
}, {
  "id": 943
}, {
  "id": 944
}, {
  "id": 945
}, {
  "id": 946
}, {
  "id": 947
}, {
  "id": 948
}, {
  "id": 949
}, {
  "id": 950
}, {
  "id": 951
}, {
  "id": 952
}, {
  "id": 953
}, {
  "id": 954
}, {
  "id": 955
}, {
  "id": 956
}, {
  "id": 957
}, {
  "id": 958
}, {
  "id": 959
}, {
  "id": 960
}, {
  "id": 961
}, {
  "id": 962
}, {
  "id": 963
}, {
  "id": 964
}, {
  "id": 965
}, {
  "id": 966
}, {
  "id": 967
}, {
  "id": 968
}, {
  "id": 969
}, {
  "id": 970
}, {
  "id": 971
}, {
  "id": 972
}, {
  "id": 973
}, {
  "id": 974
}, {
  "id": 975
}, {
  "id": 976
}, {
  "id": 977
}, {
  "id": 978
}, {
  "id": 979
}, {
  "id": 980
}, {
  "id": 981
}, {
  "id": 982
}, {
  "id": 983
}, {
  "id": 984
}, {
  "id": 985
}, {
  "id": 986
}, {
  "id": 987
}, {
  "id": 988
}, {
  "id": 989
}, {
  "id": 990
}, {
  "id": 991
}, {
  "id": 992
}, {
  "id": 993
}, {
  "id": 994
}, {
  "id": 995
}, {
  "id": 996
}, {
  "id": 997
}, {
  "id": 998
}, {
  "id": 999
}];
},{}],"qeUI":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vis_timeline_1 = __importDefault(require("vis-timeline"));

var data_1 = __importDefault(require("./data"));

var DELAY = 500; // delay in ms to add new data points
// create a graph2d with an (currently empty) dataset

var container = document.getElementById("visualization");
var dataset = new vis_timeline_1.default.DataSet();
var groups = new vis_timeline_1.default.DataSet();
groups.add({
  id: 0,
  content: "Nodes",
  options: {
    drawPoints: {
      style: "square" // square, circle

    },
    shaded: {
      orientation: "bottom" // top, bottom

    }
  }
});
groups.add({
  id: 1,
  content: "Edges",
  options: {
    drawPoints: {
      style: "circle" // square, circle

    }
  }
});
groups.add({
  id: 2,
  content: "Infected",
  options: {
    drawPoints: {
      style: "square" // square, circle

    }
  }
});
var options = {
  start: vis_timeline_1.default.moment().add(-30, "seconds"),
  end: vis_timeline_1.default.moment(),
  legend: true,
  dataAxis: {
    left: {
      range: {
        min: -1
      }
    }
  }
};
var graph2d = new vis_timeline_1.default.Graph2d(container, dataset, groups, options); // a function to generate data points

function y(x) {
  return (Math.sin(x / 2) + Math.cos(x / 4)) * 5;
}

function renderStep() {
  // move the window (you can think of different strategies).
  var now = vis_timeline_1.default.moment();
  var range = graph2d.getWindow();
  var interval = range.end - range.start;
  var strategy = "static";

  switch (strategy) {
    case "continuous":
      // continuously move the window
      graph2d.setWindow(now - interval, now, {
        animation: false
      });
      requestAnimationFrame(renderStep);
      break;

    case "discrete":
      graph2d.setWindow(now - interval, now, {
        animation: false
      });
      setTimeout(renderStep, DELAY);
      break;

    default:
      // 'static'
      // move the window 90% to the left when now is larger than the end of the window
      if (now > range.end) {
        graph2d.setWindow(now - 0.1 * interval, now + 0.9 * interval);
      }

      setTimeout(renderStep, DELAY);
      break;
  }
}

renderStep();
/**
 * Add a new datapoint to the graph
 */

function addDataPoint() {
  // add a new data point to the dataset
  var now = vis_timeline_1.default.moment();
  dataset.add({
    x: now,
    y: data_1.default.nodes.getIds().length,
    group: 0
  });
  dataset.add({
    x: now,
    y: data_1.default.edges.getIds().length,
    group: 1
  });
  dataset.add({
    x: now,
    y: data_1.default.nodes.get().filter(function (node) {
      return node.group === 1;
    }).length,
    group: 2
  }); // remove all data points which are no longer visible

  var range = graph2d.getWindow();
  var interval = range.end - range.start;
  var oldIds = dataset.getIds({
    filter: function filter(item) {
      return item.x < range.start - interval;
    }
  });
  dataset.remove(oldIds);
  setTimeout(addDataPoint, DELAY);
}

addDataPoint();
},{"vis-timeline":"w89l","./data":"O2jE"}],"UbxC":[function(require,module,exports) {
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vis_network_1 = __importDefault(require("vis-network"));

var data_1 = __importStar(require("./data"));

var edges_json_1 = __importDefault(require("./probdup/edges.json"));

var nodes_json_1 = __importDefault(require("./probdup/nodes.json"));

require("./plot"); // create a network


var options = {
  edges: {
    arrows: "to",
    color: {
      inherit: "to"
    },
    smooth: {
      type: "continuous" // continuous

    }
  },
  physics: {
    stabilization: false
  }
};
var networkContainer = document.getElementById("network");
new vis_network_1.default.Network(networkContainer, data_1.default, options);
var minSuspicion = 1;
var maxSuspicion = 4;

function randomSuspicion() {
  return Math.round(Math.random() * (maxSuspicion - minSuspicion) + minSuspicion);
}

function delay(msec) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_a) {
      return [2
      /*return*/
      , new Promise(function (resolve) {
        return setTimeout(resolve, msec * 1000);
      })];
    });
  });
}

function generate() {
  return __awaiter(this, void 0, void 0, function () {
    var initNodes, _loop_1, i, _loop_2, i;

    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          initNodes = 10;

          _loop_1 = function _loop_1(i) {
            var suspicion, availableNodes, edges_1;
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  return [4
                  /*yield*/
                  , delay(0.5)];

                case 1:
                  _a.sent();

                  suspicion = randomSuspicion();
                  availableNodes = data_1.default.nodes.get();
                  edges_1 = Array.from({
                    length: suspicion
                  }, function () {
                    return availableNodes.length > 0 ? {
                      from: i,
                      to: Number(availableNodes.splice(Math.round(Math.random() * (availableNodes.length - 1)), 1)[0].id)
                    } : undefined;
                  });
                  data_1.addNode(i, 0);
                  edges_1.filter(function (edge) {
                    return edge !== undefined;
                  }).forEach(function (edge) {
                    return data_1.addEdge(edge.from, edge.to);
                  });
                  return [2
                  /*return*/
                  ];
              }
            });
          };

          i = 0;
          _a.label = 1;

        case 1:
          if (!(i < initNodes)) return [3
          /*break*/
          , 4];
          return [5
          /*yield**/
          , _loop_1(i)];

        case 2:
          _a.sent();

          _a.label = 3;

        case 3:
          i++;
          return [3
          /*break*/
          , 1];

        case 4:
          _loop_2 = function _loop_2(i) {
            var availableNodes, pickedHost;
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  return [4
                  /*yield*/
                  , delay(0.01)];

                case 1:
                  _a.sent();

                  availableNodes = data_1.default.nodes.get();
                  pickedHost = Math.round(Math.random() * (availableNodes.length - 1));
                  data_1.default.edges.get().filter(function (edge) {
                    return edge.from === pickedHost;
                  }).filter(function () {
                    return Math.random() > 0.5;
                  }).forEach(function (edge) {
                    return data_1.addEdge(i, Number(edge.to));
                  });
                  data_1.addNode(i, 0);
                  data_1.addEdge(i, pickedHost);
                  return [2
                  /*return*/
                  ];
              }
            });
          };

          i = initNodes;
          _a.label = 5;

        case 5:
          if (!(i < initNodes + 990)) return [3
          /*break*/
          , 8];
          return [5
          /*yield**/
          , _loop_2(i)];

        case 6:
          _a.sent();

          _a.label = 7;

        case 7:
          i++;
          return [3
          /*break*/
          , 5];

        case 8:
          return [2
          /*return*/
          ];
      }
    });
  });
}

function publishOn(initNodes) {
  var availableNodes = data_1.default.nodes.getIds();

  for (var index = 0; index < initNodes; index++) {
    var pickedHost = Math.round(Math.random() * (availableNodes.length - 1));
    data_1.default.nodes.update({
      id: pickedHost,
      group: 1
    });
  }
}

function buildAdjacentList(nodes, edges) {
  var adjacentList = new Map();
  edges.forEach(function (edge) {
    var fromAdjances = adjacentList.get(edge.from) || new Array();
    fromAdjances.push(nodes[edge.to]);
    adjacentList.set(edge.from, fromAdjances);
    var toAdjances = adjacentList.get(edge.to) || new Array();
    toAdjances.push(nodes[edge.from]);
    adjacentList.set(edge.to, toAdjances);
  });
  console.log("adjacentList size: " + adjacentList.size);
  return adjacentList;
}

function buildNeighboursRatio(adjacentList) {
  var neighboursRatio = new Array(adjacentList.size);
  console.log("adjacentList length " + adjacentList.size);
  adjacentList.forEach(function (neighbours, nodeId) {
    console.log("calculating neighboursRatio for " + nodeId + " with neighbours count: " + neighbours.length);
    neighboursRatio[nodeId] = neighbours.filter(function (neighbour) {
      return neighbour.group === 1 || neighbour.group === 2;
    }).length / neighbours.length;
    console.log("neighbours ratio " + neighboursRatio[nodeId]);
  });
  console.log({
    neighboursRatio: neighboursRatio
  });
  return neighboursRatio;
} // 0 - Health Susceptible initial state
// 1 - Infected Acute when infected by EIP
// 2 - Infected Recoverable - when all neighbours are infected
// 3 - Healthly Quarantine - healed, can stay here forever if stayed long enough


var epsilon = 0.1;
var Zia = 20;
var Zhq = 2;
var tao = 20;
var currentCycle = 0;

function spread() {
  console.log("spread");
  var nodes = data_1.default.nodes.get();
  var edges = data_1.default.edges.get();
  var adjacentList = buildAdjacentList(nodes, edges);
  console.log("builded adjacentList: " + adjacentList.size);
  var neighboursRatio = buildNeighboursRatio(adjacentList);
  nodes.forEach(function (node) {
    if (node.group === 0) {
      if (neighboursRatio[node.id] >= epsilon) {
        // More than epsilon of my neighbours are infected so do I
        data_1.updateNode(node.id, 1);
      }
    } else if (node.group === 1) {
      if (Math.random() <= 1 / Zia) {
        if (neighboursRatio[node.id] === 1) {
          // All of my neighbours are infected so do I
          data_1.updateNode(node.id, 2);
        } else {
          data_1.updateNode(node.id, 3);
        }
      }
    } else if (node.group === 2) {
      if (neighboursRatio[node.id] < 1) {
        // Not all of my neighbours are infected, so I suspect that something is
        // going on there.
        data_1.updateNode(node.id, 3);
      }
    } else if (node.group === 3) {
      if (Math.random() <= 1 / Zhq && currentCycle < tao) {
        if (neighboursRatio[node.id] >= epsilon) {
          data_1.updateNode(node.id, 1);
        } else {
          data_1.updateNode(node.id, 0);
        }
      }
    }
  });
  currentCycle++;
}

$("#restore").click(function () {
  return data_1.restore(nodes_json_1.default, edges_json_1.default);
});
$("#publish").click(function () {
  return publishOn(1);
});
$("#spread").click(spread);
},{"vis-network":"isAo","./data":"O2jE","./probdup/edges.json":"gvrn","./probdup/nodes.json":"vUQY","./plot":"qeUI"}],"jP6t":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jquery_1 = __importDefault(require("jquery"));

window.$ = jquery_1.default;

require("popper.js");

require("bootstrap");

require("bootstrap/dist/css/bootstrap.css"); // Import precompiled Bootstrap css


require("@fortawesome/fontawesome-free/css/all.css");

require("vis-timeline/dist/vis-timeline-graph2d.css");

var data_1 = require("./data");

$("#dump").click(function () {
  return data_1.dump();
});
/* import "./index"; */

require("./probdup");
/* import "./randdup"; */
},{"jquery":"HlZQ","popper.js":"v5IM","bootstrap":"pe4o","bootstrap/dist/css/bootstrap.css":"gsgA","@fortawesome/fontawesome-free/css/all.css":"Eofe","vis-timeline/dist/vis-timeline-graph2d.css":"gsgA","./data":"O2jE","./probdup":"UbxC"}]},{},["jP6t"], null)
//# sourceMappingURL=/main.ac7549cf.js.map